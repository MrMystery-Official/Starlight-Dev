; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01LBDDMOBJ@?$FN@				; `string'
PUBLIC	??_C@_08ENAFOMOP@?$CDSCROLLX@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL@				; `string'
PUBLIC	??_C@_06EBHDMMP@?$CDimage@			; `string'
PUBLIC	??_C@_08FEBONNKO@?$CDSCROLLY@			; `string'
PUBLIC	??_C@_03JHEALCLB@?$FLx?$FN@			; `string'
PUBLIC	??_C@_03JDMNMOAD@?$FL?$HO?$FN@			; `string'
PUBLIC	??_C@_03KFJJABDB@?$CIx?$CJ@			; `string'
PUBLIC	??_C@_03PFOPMNLJ@?$FL?5?$FN@			; `string'
PUBLIC	??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@		; `string'
PUBLIC	??_C@_03MHDGHODJ@?$CI?5?$CJ@			; `string'
PUBLIC	??_C@_0CC@IODDEFBI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_02LLHJFGPH@?5?$HM@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_0N@LNBMNBNO@?$CD?$CDComboPopup@		; `string'
PUBLIC	??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@	; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_02HJNLAKPP@S8@				; `string'
PUBLIC	??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@	; `string'
PUBLIC	??_C@_03KLLGJOHN@S16@				; `string'
PUBLIC	??_C@_02HNFGHGEN@U8@				; `string'
PUBLIC	??_C@_03MMFOIPBH@S32@				; `string'
PUBLIC	??_C@_03IONNMBKB@U16@				; `string'
PUBLIC	??_C@_03JMMPOKHK@S64@				; `string'
PUBLIC	??_C@_03OJDFNAML@U32@				; `string'
PUBLIC	??_C@_03LJKELFKG@U64@				; `string'
PUBLIC	??_C@_05LLAMLEHD@?$CFI64d@			; `string'
PUBLIC	??_C@_06BNJCAIGJ@double@			; `string'
PUBLIC	??_C@_05OINFJHGD@?$CFI64u@			; `string'
PUBLIC	??_C@_05DMFAOFEI@?$CD?$CDmin@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf@			; `string'
PUBLIC	??_C@_0BN@BGBNDAJ@ID?3?50x?$CF08X?0?5ActiveID?3?50x?$CF08X@ ; `string'
PUBLIC	??_C@_05CONLABCH@?$CD?$CDmax@			; `string'
PUBLIC	??_C@_0BL@FCPBEJDK@has_preferred_x?3?5?$CFd?5?$CI?$CF?42f?$CJ@ ; `string'
PUBLIC	??_C@_0DI@KFHJPBJM@CurLenW?3?5?$CFd?0?5CurLenA?3?5?$CFd?0?5Curso@ ; `string'
PUBLIC	??_C@_0L@NBJMPEMP@undopoints@			; `string'
PUBLIC	??_C@_0EJ@KOMDKONB@undo_point?3?5?$CFd?0?5redo_point?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_03CEFFAPNG@?$CD?$CDX@			; `string'
PUBLIC	??_C@_0EH@KMDCELMD@?$CFc?5?$FL?$CF02d?$FN?5where?5?$CF03d?0?5insert?5?$CF0@ ; `string'
PUBLIC	??_C@_03BGGDGNFE@?$CD?$CDZ@			; `string'
PUBLIC	??_C@_03DNEODOJH@?$CD?$CDY@			; `string'
PUBLIC	??_C@_03GOOLIKIF@?$CF3d@			; `string'
PUBLIC	??_C@_03KDMNBDBJ@?$CD?$CDW@			; `string'
PUBLIC	??_C@_05HKBGOMJ@G?3?$CF3d@			; `string'
PUBLIC	??_C@_05FELKPNOB@R?3?$CF3d@			; `string'
PUBLIC	??_C@_05NBPIINNE@A?3?$CF3d@			; `string'
PUBLIC	??_C@_05FHGMPPHK@B?3?$CF3d@			; `string'
PUBLIC	??_C@_05JPOGCOEE@S?3?$CF3d@			; `string'
PUBLIC	??_C@_05PGPHNMBM@H?3?$CF3d@			; `string'
PUBLIC	??_C@_05ONBKDNLK@?$CF0?43f@			; `string'
PUBLIC	??_C@_05MPCLLPPH@V?3?$CF3d@			; `string'
PUBLIC	??_C@_07BGLBHCJI@G?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07CCOKENNH@R?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07NANOHLBP@A?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07FOFBHMPM@B?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07OOEAENEJ@S?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07MPJBGADE@H?3?$CF0?43f@			; `string'
PUBLIC	??_C@_07FFNLLALM@M?30?4000@			; `string'
PUBLIC	??_C@_07KGKAEDCN@V?3?$CF0?43f@			; `string'
PUBLIC	??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_05BNGMMMAL@M?3000@			; `string'
PUBLIC	??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ ; `string'
PUBLIC	??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@		; `string'
PUBLIC	??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@	; `string'
PUBLIC	??_C@_03PPLPHHG@hsv@				; `string'
PUBLIC	??_C@_06MAKAMBBI@picker@			; `string'
PUBLIC	??_C@_03GKJJMKFG@hue@				; `string'
PUBLIC	??_C@_02CPGMCOJE@sv@				; `string'
PUBLIC	??_C@_08DCPBJHAO@Original@			; `string'
PUBLIC	??_C@_05IAEKHIAN@alpha@				; `string'
PUBLIC	??_C@_05JCABMAIH@?$CD?$CDrgb@			; `string'
PUBLIC	??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@		; `string'
PUBLIC	??_C@_05BOAMFJMJ@?$CD?$CDhex@			; `string'
PUBLIC	??_C@_05JICEKLIF@?$CD?$CDhsv@			; `string'
PUBLIC	??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ ; `string'
PUBLIC	??_C@_09JCCDBEFL@?$CD?$CDpreview@		; `string'
PUBLIC	??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@ ; `string'
PUBLIC	??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ ; `string'
PUBLIC	??_C@_03ICFFBAI@RGB@				; `string'
PUBLIC	??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@ ; `string'
PUBLIC	??_C@_03CJOBKKAE@Hex@				; `string'
PUBLIC	??_C@_03CAADKAK@HSV@				; `string'
PUBLIC	??_C@_0L@MDNPBJBM@0?400?4?41?400@		; `string'
PUBLIC	??_C@_06FDBEKFBH@0?4?4255@			; `string'
PUBLIC	??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ ; `string'
PUBLIC	??_C@_09NMCCFHEI@Copy?5as?4?4@			; `string'
PUBLIC	??_C@_0N@KFBFGFJL@?$CD?$CDselectable@		; `string'
PUBLIC	??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_09KEDLMDJL@Alpha?5Bar@			; `string'
PUBLIC	??_C@_0BE@ENPGBMIC@?$CD?$CDpreviewing_picker@	; `string'
PUBLIC	??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@		; `string'
PUBLIC	??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ ; `string'
PUBLIC	??_C@_06GBEGMGE@?$CFs?3?5?$CFd@			; `string'
PUBLIC	??_C@_06DJHOIPC@?$CFs?3?5?$CFs@			; `string'
PUBLIC	??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@		; `string'
PUBLIC	??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@		; `string'
PUBLIC	??_C@_03CFMEKBHF@?$CD?$CD?$DM@			; `string'
PUBLIC	??_C@_09FHPMMDGK@?$CD?$CDmenubar@		; `string'
PUBLIC	??_C@_03BHPCMDPH@?$CD?$CD?$DO@			; `string'
EXTRN	__imp_atof:PROC
;	COMDAT ?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
CONST	SEGMENT
?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB DD 03f800000r ; 1 ; `GetMinimumStepAtDecimalPrecision'::`2'::min_steps
	DD	03dcccccdr			; 0.1
	DD	03c23d70ar			; 0.01
	DD	03a83126fr			; 0.001
	DD	038d1b717r			; 0.0001
	DD	03727c5acr			; 1e-05
	DD	0358637bdr			; 1e-06
	DD	033d6bf95r			; 1e-07
	DD	0322bcc77r			; 1e-08
	DD	03089705fr			; 1e-09
CONST	ENDS
;	COMDAT ?fmt_table_float@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA
CONST	SEGMENT
?fmt_table_float@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA DQ FLAT:??_C@_05ONBKDNLK@?$CF0?43f@ ; `ImGui::ColorEdit4'::`27'::fmt_table_float
	DQ	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DQ	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DQ	FLAT:??_C@_05ONBKDNLK@?$CF0?43f@
	DQ	FLAT:??_C@_07CCOKENNH@R?3?$CF0?43f@
	DQ	FLAT:??_C@_07BGLBHCJI@G?3?$CF0?43f@
	DQ	FLAT:??_C@_07FOFBHMPM@B?3?$CF0?43f@
	DQ	FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
	DQ	FLAT:??_C@_07MPJBGADE@H?3?$CF0?43f@
	DQ	FLAT:??_C@_07OOEAENEJ@S?3?$CF0?43f@
	DQ	FLAT:??_C@_07KGKAEDCN@V?3?$CF0?43f@
	DQ	FLAT:??_C@_07NANOHLBP@A?3?$CF0?43f@
CONST	ENDS
;	COMDAT ?fmt_table_int@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA
CONST	SEGMENT
?fmt_table_int@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA DQ FLAT:??_C@_03GOOLIKIF@?$CF3d@ ; `ImGui::ColorEdit4'::`27'::fmt_table_int
	DQ	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DQ	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DQ	FLAT:??_C@_03GOOLIKIF@?$CF3d@
	DQ	FLAT:??_C@_05FELKPNOB@R?3?$CF3d@
	DQ	FLAT:??_C@_05HKBGOMJ@G?3?$CF3d@
	DQ	FLAT:??_C@_05FHGMPPHK@B?3?$CF3d@
	DQ	FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
	DQ	FLAT:??_C@_05PGPHNMBM@H?3?$CF3d@
	DQ	FLAT:??_C@_05JPOGCOEE@S?3?$CF3d@
	DQ	FLAT:??_C@_05MPCLLPPH@V?3?$CF3d@
	DQ	FLAT:??_C@_05NBPIINNE@A?3?$CF3d@
CONST	ENDS
;	COMDAT ?ids@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAPEBDA
CONST	SEGMENT
?ids@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAPEBDA DQ FLAT:??_C@_03CEFFAPNG@?$CD?$CDX@ ; `ImGui::ColorEdit4'::`27'::ids
	DQ	FLAT:??_C@_03DNEODOJH@?$CD?$CDY@
	DQ	FLAT:??_C@_03BGGDGNFE@?$CD?$CDZ@
	DQ	FLAT:??_C@_03KDMNBDBJ@?$CD?$CDW@
CONST	ENDS
;	COMDAT ??_C@_03BHPCMDPH@?$CD?$CD?$DO@
CONST	SEGMENT
??_C@_03BHPCMDPH@?$CD?$CD?$DO@ DB '##>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FHPMMDGK@?$CD?$CDmenubar@
CONST	SEGMENT
??_C@_09FHPMMDGK@?$CD?$CDmenubar@ DB '##menubar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFMEKBHF@?$CD?$CD?$DM@
CONST	SEGMENT
??_C@_03CFMEKBHF@?$CD?$CD?$DM@ DB '##<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_07EKEPIENH@?$CF?$CFs?3?5?$CFs@ DB '%%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@
CONST	SEGMENT
??_C@_08KELGKKHF@?$CFs?3?5?$CF?43f@ DB '%s: %.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJHOIPC@?$CFs?3?5?$CFs@
CONST	SEGMENT
??_C@_06DJHOIPC@?$CFs?3?5?$CFs@ DB '%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GBEGMGE@?$CFs?3?5?$CFd@
CONST	SEGMENT
??_C@_06GBEGMGE@?$CFs?3?5?$CFd@ DB '%s: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_0BE@OBCBLNMM@?$CFd?3?5?$CF8?44g?6?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 0aH
	DB	'%d: %8.4g', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@
CONST	SEGMENT
??_C@_09OADNPGHP@?$CFd?3?5?$CF8?44g@ DB '%d: %8.4g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ENPGBMIC@?$CD?$CDpreviewing_picker@
CONST	SEGMENT
??_C@_0BE@ENPGBMIC@?$CD?$CDpreviewing_picker@ DB '##previewing_picker', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KEDLMDJL@Alpha?5Bar@
CONST	SEGMENT
??_C@_09KEDLMDJL@Alpha?5Bar@ DB 'Alpha Bar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
CONST	SEGMENT
??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@ DB '(%d,%d,%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFBFGFJL@?$CD?$CDselectable@
CONST	SEGMENT
??_C@_0N@KFBFGFJL@?$CD?$CDselectable@ DB '##selectable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMCCFHEI@Copy?5as?4?4@
CONST	SEGMENT
??_C@_09NMCCFHEI@Copy?5as?4?4@ DB 'Copy as..', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
CONST	SEGMENT
??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@ DB '('
	DB	'%.3ff, %.3ff, %.3ff, %.3ff)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDBEKFBH@0?4?4255@
CONST	SEGMENT
??_C@_06FDBEKFBH@0?4?4255@ DB '0..255', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDNPBJBM@0?400?4?41?400@
CONST	SEGMENT
??_C@_0L@MDNPBJBM@0?400?4?41?400@ DB '0.00..1.00', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CAADKAK@HSV@
CONST	SEGMENT
??_C@_03CAADKAK@HSV@ DB 'HSV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJOBKKAE@Hex@
CONST	SEGMENT
??_C@_03CJOBKKAE@Hex@ DB 'Hex', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@
CONST	SEGMENT
??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@ DB 'H'
	DB	': %.3f, S: %.3f, V: %.3f, A: %.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICFFBAI@RGB@
CONST	SEGMENT
??_C@_03ICFFBAI@RGB@ DB 'RGB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
CONST	SEGMENT
??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@ DB '#'
	DB	'%02X%02X%02X%02X', 0aH, 'R:%d, G:%d, B:%d, A:%d', 0aH, '(%.3f'
	DB	', %.3f, %.3f, %.3f)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@
CONST	SEGMENT
??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@ DB 'H'
	DB	': %.3f, S: %.3f, V: %.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCCDBEFL@?$CD?$CDpreview@
CONST	SEGMENT
??_C@_09JCCDBEFL@?$CD?$CDpreview@ DB '##preview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
CONST	SEGMENT
??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@ DB '#'
	DB	'%02X%02X%02X', 0aH, 'R: %d, G: %d, B: %d', 0aH, '(%.3f, %.3f,'
	DB	' %.3f)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05JICEKLIF@?$CD?$CDhsv@
CONST	SEGMENT
??_C@_05JICEKLIF@?$CD?$CDhsv@ DB '##hsv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOAMFJMJ@?$CD?$CDhex@
CONST	SEGMENT
??_C@_05BOAMFJMJ@?$CD?$CDhex@ DB '##hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@
CONST	SEGMENT
??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@ DB '##original', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCABMAIH@?$CD?$CDrgb@
CONST	SEGMENT
??_C@_05JCABMAIH@?$CD?$CDrgb@ DB '##rgb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAEKHIAN@alpha@
CONST	SEGMENT
??_C@_05IAEKHIAN@alpha@ DB 'alpha', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCPBJHAO@Original@
CONST	SEGMENT
??_C@_08DCPBJHAO@Original@ DB 'Original', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CPGMCOJE@sv@
CONST	SEGMENT
??_C@_02CPGMCOJE@sv@ DB 'sv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKJJMKFG@hue@
CONST	SEGMENT
??_C@_03GKJJMKFG@hue@ DB 'hue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAKAMBBI@picker@
CONST	SEGMENT
??_C@_06MAKAMBBI@picker@ DB 'picker', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPLPHHG@hsv@
CONST	SEGMENT
??_C@_03PPLPHHG@hsv@ DB 'hsv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@
CONST	SEGMENT
??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@ DB '##ColorButton', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@ DB '%02X%02X%02X%02X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNGMMMAL@M?3000@
CONST	SEGMENT
??_C@_05BNGMMMAL@M?3000@ DB 'M:000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
CONST	SEGMENT
??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@ DB '#%02X%02X%02X%02'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGKAEDCN@V?3?$CF0?43f@
CONST	SEGMENT
??_C@_07KGKAEDCN@V?3?$CF0?43f@ DB 'V:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFNLLALM@M?30?4000@
CONST	SEGMENT
??_C@_07FFNLLALM@M?30?4000@ DB 'M:0.000', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPJBGADE@H?3?$CF0?43f@
CONST	SEGMENT
??_C@_07MPJBGADE@H?3?$CF0?43f@ DB 'H:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OOEAENEJ@S?3?$CF0?43f@
CONST	SEGMENT
??_C@_07OOEAENEJ@S?3?$CF0?43f@ DB 'S:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOFBHMPM@B?3?$CF0?43f@
CONST	SEGMENT
??_C@_07FOFBHMPM@B?3?$CF0?43f@ DB 'B:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NANOHLBP@A?3?$CF0?43f@
CONST	SEGMENT
??_C@_07NANOHLBP@A?3?$CF0?43f@ DB 'A:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCOKENNH@R?3?$CF0?43f@
CONST	SEGMENT
??_C@_07CCOKENNH@R?3?$CF0?43f@ DB 'R:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGLBHCJI@G?3?$CF0?43f@
CONST	SEGMENT
??_C@_07BGLBHCJI@G?3?$CF0?43f@ DB 'G:%0.3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPCLLPPH@V?3?$CF3d@
CONST	SEGMENT
??_C@_05MPCLLPPH@V?3?$CF3d@ DB 'V:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONBKDNLK@?$CF0?43f@
CONST	SEGMENT
??_C@_05ONBKDNLK@?$CF0?43f@ DB '%0.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGPHNMBM@H?3?$CF3d@
CONST	SEGMENT
??_C@_05PGPHNMBM@H?3?$CF3d@ DB 'H:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPOGCOEE@S?3?$CF3d@
CONST	SEGMENT
??_C@_05JPOGCOEE@S?3?$CF3d@ DB 'S:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHGMPPHK@B?3?$CF3d@
CONST	SEGMENT
??_C@_05FHGMPPHK@B?3?$CF3d@ DB 'B:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NBPIINNE@A?3?$CF3d@
CONST	SEGMENT
??_C@_05NBPIINNE@A?3?$CF3d@ DB 'A:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FELKPNOB@R?3?$CF3d@
CONST	SEGMENT
??_C@_05FELKPNOB@R?3?$CF3d@ DB 'R:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKBGOMJ@G?3?$CF3d@
CONST	SEGMENT
??_C@_05HKBGOMJ@G?3?$CF3d@ DB 'G:%3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDMNBDBJ@?$CD?$CDW@
CONST	SEGMENT
??_C@_03KDMNBDBJ@?$CD?$CDW@ DB '##W', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GOOLIKIF@?$CF3d@
CONST	SEGMENT
??_C@_03GOOLIKIF@?$CF3d@ DB '%3d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNEODOJH@?$CD?$CDY@
CONST	SEGMENT
??_C@_03DNEODOJH@?$CD?$CDY@ DB '##Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BGGDGNFE@?$CD?$CDZ@
CONST	SEGMENT
??_C@_03BGGDGNFE@?$CD?$CDZ@ DB '##Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KMDCELMD@?$CFc?5?$FL?$CF02d?$FN?5where?5?$CF03d?0?5insert?5?$CF0@
CONST	SEGMENT
??_C@_0EH@KMDCELMD@?$CFc?5?$FL?$CF02d?$FN?5where?5?$CF03d?0?5insert?5?$CF0@ DB '%'
	DB	'c [%02d] where %03d, insert %03d, delete %03d, char_storage %'
	DB	'03d "%s"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03CEFFAPNG@?$CD?$CDX@
CONST	SEGMENT
??_C@_03CEFFAPNG@?$CD?$CDX@ DB '##X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KOMDKONB@undo_point?3?5?$CFd?0?5redo_point?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0EJ@KOMDKONB@undo_point?3?5?$CFd?0?5redo_point?3?5?$CFd?0@ DB 'undo'
	DB	'_point: %d, redo_point: %d, undo_char_point: %d, redo_char_po'
	DB	'int: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBJMPEMP@undopoints@
CONST	SEGMENT
??_C@_0L@NBJMPEMP@undopoints@ DB 'undopoints', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KFHJPBJM@CurLenW?3?5?$CFd?0?5CurLenA?3?5?$CFd?0?5Curso@
CONST	SEGMENT
??_C@_0DI@KFHJPBJM@CurLenW?3?5?$CFd?0?5CurLenA?3?5?$CFd?0?5Curso@ DB 'Cur'
	DB	'LenW: %d, CurLenA: %d, Cursor: %d, Selection: %d..%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FCPBEJDK@has_preferred_x?3?5?$CFd?5?$CI?$CF?42f?$CJ@
CONST	SEGMENT
??_C@_0BL@FCPBEJDK@has_preferred_x?3?5?$CFd?5?$CI?$CF?42f?$CJ@ DB 'has_pr'
	DB	'eferred_x: %d (%.2f)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CONLABCH@?$CD?$CDmax@
CONST	SEGMENT
??_C@_05CONLABCH@?$CD?$CDmax@ DB '##max', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BGBNDAJ@ID?3?50x?$CF08X?0?5ActiveID?3?50x?$CF08X@
CONST	SEGMENT
??_C@_0BN@BGBNDAJ@ID?3?50x?$CF08X?0?5ActiveID?3?50x?$CF08X@ DB 'ID: 0x%08'
	DB	'X, ActiveID: 0x%08X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf@ DB '%lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFAOFEI@?$CD?$CDmin@
CONST	SEGMENT
??_C@_05DMFAOFEI@?$CD?$CDmin@ DB '##min', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OINFJHGD@?$CFI64u@
CONST	SEGMENT
??_C@_05OINFJHGD@?$CFI64u@ DB '%I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d@
CONST	SEGMENT
??_C@_05LLAMLEHD@?$CFI64d@ DB '%I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJKELFKG@U64@
CONST	SEGMENT
??_C@_03LJKELFKG@U64@ DB 'U64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJDFNAML@U32@
CONST	SEGMENT
??_C@_03OJDFNAML@U32@ DB 'U32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMMPOKHK@S64@
CONST	SEGMENT
??_C@_03JMMPOKHK@S64@ DB 'S64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IONNMBKB@U16@
CONST	SEGMENT
??_C@_03IONNMBKB@U16@ DB 'U16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MMFOIPBH@S32@
CONST	SEGMENT
??_C@_03MMFOIPBH@S32@ DB 'S32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HNFGHGEN@U8@
CONST	SEGMENT
??_C@_02HNFGHGEN@U8@ DB 'U8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLLGJOHN@S16@
CONST	SEGMENT
??_C@_03KLLGJOHN@S16@ DB 'S16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
CONST	SEGMENT
??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@ DB '*Unknown item*', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02HJNLAKPP@S8@
CONST	SEGMENT
??_C@_02HJNLAKPP@S8@ DB 'S8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@
CONST	SEGMENT
??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@ DB '##Combo_%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LNBMNBNO@?$CD?$CDComboPopup@
CONST	SEGMENT
??_C@_0N@LNBMNBNO@?$CD?$CDComboPopup@ DB '##ComboPopup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLHJFGPH@?5?$HM@
CONST	SEGMENT
??_C@_02LLHJFGPH@?5?$HM@ DB ' |', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IODDEFBI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CC@IODDEFBI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'-------------------------------', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHDGHODJ@?$CI?5?$CJ@
CONST	SEGMENT
??_C@_03MHDGHODJ@?$CI?5?$CJ@ DB '( )', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@
CONST	SEGMENT
??_C@_06KLKJBGEJ@?$CF?40f?$CF?$CF@ DB '%.0f%%', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFOPMNLJ@?$FL?5?$FN@
CONST	SEGMENT
??_C@_03PFOPMNLJ@?$FL?5?$FN@ DB '[ ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KFJJABDB@?$CIx?$CJ@
CONST	SEGMENT
??_C@_03KFJJABDB@?$CIx?$CJ@ DB '(x)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDMNMOAD@?$FL?$HO?$FN@
CONST	SEGMENT
??_C@_03JDMNMOAD@?$FL?$HO?$FN@ DB '[~]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JHEALCLB@?$FLx?$FN@
CONST	SEGMENT
??_C@_03JHEALCLB@?$FLx?$FN@ DB '[x]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FEBONNKO@?$CDSCROLLY@
CONST	SEGMENT
??_C@_08FEBONNKO@?$CDSCROLLY@ DB '#SCROLLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBHDMMP@?$CDimage@
CONST	SEGMENT
??_C@_06EBHDMMP@?$CDimage@ DB '#image', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENAFOMOP@?$CDSCROLLX@
CONST	SEGMENT
??_C@_08ENAFOMOP@?$CDSCROLLX@ DB '#SCROLLX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN@ DB ']', 00H			; `string'
?STB_TEXTEDIT_NEWLINE@ImStb@@3GA DW 0aH			; ImStb::STB_TEXTEDIT_NEWLINE
	ORG $+4
?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B DQ 0000000000000001H ; GDataTypeInfo
	DQ	FLAT:??_C@_02HJNLAKPP@S8@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	0000000000000001H
	DQ	FLAT:??_C@_02HNFGHGEN@U8@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	0000000000000002H
	DQ	FLAT:??_C@_03KLLGJOHN@S16@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	0000000000000002H
	DQ	FLAT:??_C@_03IONNMBKB@U16@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_03MMFOIPBH@S32@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	FLAT:??_C@_02DPKJAMEF@?$CFd@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_03OJDFNAML@U32@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	FLAT:??_C@_02GMHACPFF@?$CFu@
	DQ	0000000000000008H
	DQ	FLAT:??_C@_03JMMPOKHK@S64@
	DQ	FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	DQ	FLAT:??_C@_05LLAMLEHD@?$CFI64d@
	DQ	0000000000000008H
	DQ	FLAT:??_C@_03LJKELFKG@U64@
	DQ	FLAT:??_C@_05OINFJHGD@?$CFI64u@
	DQ	FLAT:??_C@_05OINFJHGD@?$CFI64u@
	DQ	0000000000000004H
	DQ	FLAT:??_C@_05KNFBNCOH@float@
	DQ	FLAT:??_C@_04GFJLOHHD@?$CF?43f@
	DQ	FLAT:??_C@_02NJPGOMH@?$CFf@
	DQ	0000000000000008H
	DQ	FLAT:??_C@_06BNJCAIGJ@double@
	DQ	FLAT:??_C@_02NJPGOMH@?$CFf@
	DQ	FLAT:??_C@_03DLDNIBIK@?$CFlf@
PUBLIC	??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z	; ImGui::RoundScalarWithFormatT<double>
PUBLIC	??$ScaleValueFromRatioT@NNN@ImGui@@YANHMNN_NMM@Z ; ImGui::ScaleValueFromRatioT<double,double,double>
PUBLIC	??$ScaleRatioFromValueT@NNN@ImGui@@YAMHNNN_NMM@Z ; ImGui::ScaleRatioFromValueT<double,double,double>
PUBLIC	??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z	; ImGui::RoundScalarWithFormatT<float>
PUBLIC	??$ScaleValueFromRatioT@MMM@ImGui@@YAMHMMM_NMM@Z ; ImGui::ScaleValueFromRatioT<float,float,float>
PUBLIC	??$ScaleRatioFromValueT@MMM@ImGui@@YAMHMMM_NMM@Z ; ImGui::ScaleRatioFromValueT<float,float,float>
PUBLIC	??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64>
PUBLIC	??$ScaleValueFromRatioT@_K_JN@ImGui@@YA_KHM_K0_NMM@Z ; ImGui::ScaleValueFromRatioT<unsigned __int64,__int64,double>
PUBLIC	??$ScaleRatioFromValueT@_K_JN@ImGui@@YAMH_K00_NMM@Z ; ImGui::ScaleRatioFromValueT<unsigned __int64,__int64,double>
PUBLIC	??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64>
PUBLIC	??$ScaleValueFromRatioT@_J_JN@ImGui@@YA_JHM_J0_NMM@Z ; ImGui::ScaleValueFromRatioT<__int64,__int64,double>
PUBLIC	??$ScaleRatioFromValueT@_J_JN@ImGui@@YAMH_J00_NMM@Z ; ImGui::ScaleRatioFromValueT<__int64,__int64,double>
PUBLIC	??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z	; ImGui::RoundScalarWithFormatT<unsigned int>
PUBLIC	??$ScaleValueFromRatioT@IHM@ImGui@@YAIHMII_NMM@Z ; ImGui::ScaleValueFromRatioT<unsigned int,int,float>
PUBLIC	??$ScaleRatioFromValueT@IHM@ImGui@@YAMHIII_NMM@Z ; ImGui::ScaleRatioFromValueT<unsigned int,int,float>
PUBLIC	??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z	; ImGui::RoundScalarWithFormatT<int>
PUBLIC	??$ScaleValueFromRatioT@HHM@ImGui@@YAHHMHH_NMM@Z ; ImGui::ScaleValueFromRatioT<int,int,float>
PUBLIC	??$ScaleRatioFromValueT@HHM@ImGui@@YAMHHHH_NMM@Z ; ImGui::ScaleRatioFromValueT<int,int,float>
PUBLIC	??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z	; ImGui::DragBehaviorT<double,double,double>
PUBLIC	??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z	; ImGui::DragBehaviorT<float,float,float>
PUBLIC	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
PUBLIC	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
PUBLIC	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z	; ImGui::DragBehaviorT<unsigned int,int,float>
PUBLIC	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z	; ImGui::DragBehaviorT<int,int,float>
PUBLIC	??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z	; ImGui::CheckboxFlagsT<int>
PUBLIC	?_grow_capacity@?$ImVector@UImGuiNavTreeNodeData@@@@QEBAHH@Z ; ImVector<ImGuiNavTreeNodeData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z ; ImVector<ImGuiNavTreeNodeData>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QEBAHH@Z ; ImVector<ImGuiPtrOrIndex>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z ; ImVector<ImGuiPtrOrIndex>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QEBAHH@Z ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z ; ImVector<ImGuiShrinkWidthItem>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ; ImVector<ImGuiTabItem>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z	; ImVector<ImGuiTabItem>::reserve
PUBLIC	??A?$ImVector@G@@QEBAAEBGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?reserve_discard@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve_discard
PUBLIC	??A?$ImVector@M@@QEBAAEBMH@Z			; ImVector<float>::operator[]
PUBLIC	?back@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAAEAUImGuiNavTreeNodeData@@XZ ; ImVector<ImGuiNavTreeNodeData>::back
PUBLIC	?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z ; ImVector<ImGuiNavTreeNodeData>::resize
PUBLIC	?GetIndex@?$ImPool@UImGuiTabBar@@@@QEBAHPEBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::GetIndex
PUBLIC	?Contains@?$ImPool@UImGuiTabBar@@@@QEBA_NPEBUImGuiTabBar@@@Z ; ImPool<ImGuiTabBar>::Contains
PUBLIC	?empty@?$ImVector@UImGuiPtrOrIndex@@@@QEBA_NXZ	; ImVector<ImGuiPtrOrIndex>::empty
PUBLIC	?back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAAEAUImGuiPtrOrIndex@@XZ ; ImVector<ImGuiPtrOrIndex>::back
PUBLIC	?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z ; ImVector<ImGuiPtrOrIndex>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXXZ ; ImVector<ImGuiPtrOrIndex>::pop_back
PUBLIC	??A?$ImVector@UImGuiShrinkWidthItem@@@@QEAAAEAUImGuiShrinkWidthItem@@H@Z ; ImVector<ImGuiShrinkWidthItem>::operator[]
PUBLIC	?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z ; ImVector<ImGuiShrinkWidthItem>::resize
PUBLIC	??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
PUBLIC	?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z	; ImVector<ImGuiTabItem>::resize
PUBLIC	?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z ; ImVector<ImGuiTabItem>::push_back
PUBLIC	?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z ; ImVector<ImGuiTabItem>::erase
PUBLIC	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z	; ImGui::TabItemCalcSize
PUBLIC	?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z ; ImGui::TabBarProcessReorder
PUBLIC	?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z ; ImGui::TabBarQueueReorderFromMousePos
PUBLIC	??0ImGuiTabBarSection@@QEAA@XZ			; ImGuiTabBarSection::ImGuiTabBarSection
PUBLIC	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z		; ImGui::MenuItemEx
PUBLIC	?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z		; ImGui::BeginMenuEx
PUBLIC	?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z ; ImGui::BeginViewportSideBar
PUBLIC	?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z	; ImGuiMenuColumns::DeclColumns
PUBLIC	?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z	; ImGuiMenuColumns::CalcNextTotalWidth
PUBLIC	?TreePushOverrideID@ImGui@@YAXI@Z		; ImGui::TreePushOverrideID
PUBLIC	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z		; ImGui::TreeNodeBehavior
PUBLIC	?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z		; ImGui::TreeNodeUpdateNextOpen
PUBLIC	?TreeNodeSetOpen@ImGui@@YAXI_N@Z		; ImGui::TreeNodeSetOpen
PUBLIC	?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z	; ImGui::ColorPickerOptionsPopup
PUBLIC	?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z	; ImGui::ColorEditOptionsPopup
PUBLIC	?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z		; ImGui::ColorTooltip
PUBLIC	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx
PUBLIC	??0ImGuiInputTextCallbackData@@QEAA@XZ		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
PUBLIC	?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z	; ImGuiInputTextState::OnKeyPressed
PUBLIC	?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z ; ImGui::InputScalarNWidth
PUBLIC	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z	; ImGui::InputScalarN
PUBLIC	?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z ; ImGui::TempInputScalar
PUBLIC	?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z ; ImGui::TempInputText
PUBLIC	?ImParseFormatPrecision@@YAHPEBDH@Z		; ImParseFormatPrecision
PUBLIC	?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z ; ImParseFormatSanitizeForScanning
PUBLIC	?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z ; ImParseFormatSanitizeForPrinting
PUBLIC	?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z ; ImParseFormatTrimDecorations
PUBLIC	?ImParseFormatFindEnd@@YAPEBDPEBD@Z		; ImParseFormatFindEnd
PUBLIC	?ImParseFormatFindStart@@YAPEBDPEBD@Z		; ImParseFormatFindStart
PUBLIC	?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z	; ImGui::DragBehavior
PUBLIC	?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z		; ImGui::DataTypeClamp
PUBLIC	?DataTypeCompare@ImGui@@YAHHPEBX0@Z		; ImGui::DataTypeCompare
PUBLIC	?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z	; ImGui::DataTypeApplyFromText
PUBLIC	?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z	; ImGui::DataTypeApplyOp
PUBLIC	?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z ; ImGui::DataTypeFormatString
PUBLIC	?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z ; ImGui::DataTypeGetInfo
PUBLIC	?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z	; ImGui::BeginComboPopup
PUBLIC	?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z ; ImGui::ShrinkWidths
PUBLIC	?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z		; ImGui::SeparatorTextEx
PUBLIC	?SeparatorEx@ImGui@@YAXHM@Z			; ImGui::SeparatorEx
PUBLIC	?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ; ImGui::ImageButton
PUBLIC	?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z ; ImGui::ImageButtonEx
PUBLIC	?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z ; ImGui::ScrollbarEx
PUBLIC	?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarRect
PUBLIC	?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
PUBLIC	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z	; ImGui::ArrowButtonEx
PUBLIC	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z	; ImGui::ButtonEx
PUBLIC	?TextWrappedV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextWrappedV
PUBLIC	?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z	; ImGui::TextColoredV
PUBLIC	?TextEx@ImGui@@YAXPEBD0H@Z			; ImGui::TextEx
PUBLIC	?GetInputTextState@ImGui@@YAPEAUImGuiInputTextState@@I@Z ; ImGui::GetInputTextState
PUBLIC	?TempInputIsActive@ImGui@@YA_NI@Z		; ImGui::TempInputIsActive
PUBLIC	??0ImGuiTabItem@@QEAA@XZ			; ImGuiTabItem::ImGuiTabItem
PUBLIC	?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ ; ImGuiViewportP::GetBuildWorkRect
PUBLIC	??0ImGuiPtrOrIndex@@QEAA@H@Z			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
PUBLIC	??0ImGuiPtrOrIndex@@QEAA@PEAX@Z			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
PUBLIC	?ClearFlags@ImGuiNextItemData@@QEAAXXZ		; ImGuiNextItemData::ClearFlags
PUBLIC	?SelectAll@ImGuiInputTextState@@QEAAXXZ		; ImGuiInputTextState::SelectAll
PUBLIC	?ClearSelection@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::ClearSelection
PUBLIC	?HasSelection@ImGuiInputTextState@@QEBA_NXZ	; ImGuiInputTextState::HasSelection
PUBLIC	?CursorClamp@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::CursorClamp
PUBLIC	?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ	; ImGuiInputTextState::CursorAnimReset
PUBLIC	?GetTR@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetTR
PUBLIC	?GetTL@ImRect@@QEBA?AUImVec2@@XZ		; ImRect::GetTL
PUBLIC	?GetArea@ImRect@@QEBAMXZ			; ImRect::GetArea
PUBLIC	?GetCharAdvance@ImFont@@QEBAMG@Z		; ImFont::GetCharAdvance
PUBLIC	?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimVtx
PUBLIC	?EndCombo@ImGui@@YAXXZ				; ImGui::EndCombo
PUBLIC	?AlignTextToFramePadding@ImGui@@YAXXZ		; ImGui::AlignTextToFramePadding
PUBLIC	?Spacing@ImGui@@YAXXZ				; ImGui::Spacing
PUBLIC	?BeginMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMenuBar
PUBLIC	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z	; ImGui::DragScalar
PUBLIC	?BeginMainMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMainMenuBar
PUBLIC	?NewLine@ImGui@@YAXXZ				; ImGui::NewLine
PUBLIC	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z	; ImGui::ColorPicker4
PUBLIC	?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z		; ImGui::InputFloat
PUBLIC	?BeginMenu@ImGui@@YA_NPEBD_N@Z			; ImGui::BeginMenu
PUBLIC	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton
PUBLIC	?EndMenu@ImGui@@YAXXZ				; ImGui::EndMenu
PUBLIC	?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextWithHint
PUBLIC	?BeginCombo@ImGui@@YA_NPEBD0H@Z			; ImGui::BeginCombo
PUBLIC	?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z		; ImGui::InputFloat3
PUBLIC	?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::Combo
PUBLIC	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z	; ImGui::InvisibleButton
PUBLIC	?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z		; ImGui::DragInt
PUBLIC	?CollapsingHeader@ImGui@@YA_NPEBDH@Z		; ImGui::CollapsingHeader
PUBLIC	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z	; ImGui::InputScalar
PUBLIC	?EndMenuBar@ImGui@@YAXXZ			; ImGui::EndMenuBar
PUBLIC	?EndMainMenuBar@ImGui@@YAXXZ			; ImGui::EndMainMenuBar
PUBLIC	?SeparatorText@ImGui@@YAXPEBD@Z			; ImGui::SeparatorText
PUBLIC	?RadioButton@ImGui@@YA_NPEBD_N@Z		; ImGui::RadioButton
PUBLIC	?TextWrapped@ImGui@@YAXPEBDZZ			; ImGui::TextWrapped
PUBLIC	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z		; ImGui::ColorEdit4
PUBLIC	?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z ; ImGuiInputTextCallbackData::InsertChars
PUBLIC	?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z ; ImGuiInputTextCallbackData::DeleteChars
PUBLIC	??0ImGuiTabBar@@QEAA@XZ				; ImGuiTabBar::ImGuiTabBar
PUBLIC	?Update@ImGuiMenuColumns@@QEAAXM_N@Z		; ImGuiMenuColumns::Update
PUBLIC	?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z ; ImGui::TabBarAddTab
PUBLIC	?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z ; ImGui::SplitterBehavior
PUBLIC	?TextV@ImGui@@YAXPEBDPEAD@Z			; ImGui::TextV
PUBLIC	?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ; ImGui::TabItemBackground
PUBLIC	?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ; ImGui::TabBarFindTabByID
PUBLIC	?InputTextDeactivateHook@ImGui@@YAXI@Z		; ImGui::InputTextDeactivateHook
PUBLIC	?MenuItem@ImGui@@YA_NPEBD0_N1@Z			; ImGui::MenuItem
PUBLIC	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z		; ImGui::Checkbox
PUBLIC	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z		; ImGui::DragFloat
PUBLIC	?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ	; ImGui::TextColored
PUBLIC	?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText
PUBLIC	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?TextUnformatted@ImGui@@YAXPEBD0@Z		; ImGui::TextUnformatted
PUBLIC	?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ; ImGui::TabBarFindMostRecentlySelectedTabForActiveWindow
PUBLIC	?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z		; ImGui::Button
PUBLIC	?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z	; ImGui::BeginListBox
PUBLIC	?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z		; ImGui::CheckboxFlags
PUBLIC	?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z ; ImGui::TabItemLabelAndCloseButton
PUBLIC	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
PUBLIC	?TabBarGetTabName@ImGui@@YAPEBDPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarGetTabName
PUBLIC	?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z ; ImGui::Image
PUBLIC	?EndTabBar@ImGui@@YAXXZ				; ImGui::EndTabBar
PUBLIC	?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z		; ImGui::CloseButton
PUBLIC	?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z		; ImGui::Combo
PUBLIC	?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z ; ImGui::TabItemEx
PUBLIC	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ; ImGui::TabItemCalcSize
PUBLIC	?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z ; ImGui::CollapseButton
PUBLIC	?EndListBox@ImGui@@YAXXZ			; ImGui::EndListBox
PUBLIC	?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z	; ImGui::TabBarRemoveTab
PUBLIC	?TabBarQueueFocus@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarQueueFocus
PUBLIC	?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z		; ImGui::Scrollbar
PUBLIC	?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@H@Z ; ImGui::TabBarQueueReorder
PUBLIC	?Separator@ImGui@@YAXXZ				; ImGui::Separator
PUBLIC	?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ; ImGui::TabBarCloseTab
PUBLIC	?Text@ImGui@@YAXPEBDZZ				; ImGui::Text
PUBLIC	?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z ; ImGui::BeginTabBarEx
PUBLIC	?Dummy@ImGui@@YAXAEBUImVec2@@@Z			; ImGui::Dummy
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z DD imagerel $LN37
	DD	imagerel $LN37+273
	DD	imagerel $unwind$??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z DD imagerel $LN37
	DD	imagerel $LN37+277
	DD	imagerel $unwind$??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z DD imagerel $LN48
	DD	imagerel $LN48+306
	DD	imagerel $unwind$??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z DD imagerel $LN45
	DD	imagerel $LN45+264
	DD	imagerel $unwind$??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z DD imagerel $LN45
	DD	imagerel $LN45+263
	DD	imagerel $unwind$??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z DD imagerel $LN45
	DD	imagerel $LN45+246
	DD	imagerel $unwind$??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z DD imagerel ??$ImAtoi@H@@YAPEBDPEBDPEAH@Z
	DD	imagerel ??$ImAtoi@H@@YAPEBDPEBDPEAH@Z+122
	DD	imagerel $unwind$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251
	DD	imagerel $LN251+83
	DD	imagerel $unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251+83
	DD	imagerel $LN251+328
	DD	imagerel $chain$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251+328
	DD	imagerel $LN251+478
	DD	imagerel $chain$3$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251+478
	DD	imagerel $LN251+546
	DD	imagerel $chain$4$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251+546
	DD	imagerel $LN251+566
	DD	imagerel $chain$5$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD imagerel $LN251+566
	DD	imagerel $LN251+909
	DD	imagerel $chain$6$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259
	DD	imagerel $LN259+80
	DD	imagerel $unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259+80
	DD	imagerel $LN259+316
	DD	imagerel $chain$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259+316
	DD	imagerel $LN259+471
	DD	imagerel $chain$3$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259+471
	DD	imagerel $LN259+539
	DD	imagerel $chain$4$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259+539
	DD	imagerel $LN259+559
	DD	imagerel $chain$5$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD imagerel $LN259+559
	DD	imagerel $LN259+867
	DD	imagerel $chain$6$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242
	DD	imagerel $LN242+68
	DD	imagerel $unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+68
	DD	imagerel $LN242+321
	DD	imagerel $chain$0$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+321
	DD	imagerel $LN242+329
	DD	imagerel $chain$1$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+329
	DD	imagerel $LN242+471
	DD	imagerel $chain$3$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+471
	DD	imagerel $LN242+538
	DD	imagerel $chain$4$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+538
	DD	imagerel $LN242+555
	DD	imagerel $chain$5$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD imagerel $LN242+555
	DD	imagerel $LN242+845
	DD	imagerel $chain$6$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239
	DD	imagerel $LN239+68
	DD	imagerel $unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+68
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+296
	DD	imagerel $LN239+304
	DD	imagerel $chain$1$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+304
	DD	imagerel $LN239+446
	DD	imagerel $chain$3$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+446
	DD	imagerel $LN239+513
	DD	imagerel $chain$4$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+513
	DD	imagerel $LN239+530
	DD	imagerel $chain$5$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD imagerel $LN239+530
	DD	imagerel $LN239+820
	DD	imagerel $chain$6$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+67
	DD	imagerel $LN247+294
	DD	imagerel $chain$0$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+294
	DD	imagerel $LN247+302
	DD	imagerel $chain$1$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+302
	DD	imagerel $LN247+444
	DD	imagerel $chain$3$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+444
	DD	imagerel $LN247+511
	DD	imagerel $chain$4$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+511
	DD	imagerel $LN247+527
	DD	imagerel $chain$5$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD imagerel $LN247+527
	DD	imagerel $LN247+800
	DD	imagerel $chain$6$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+67
	DD	imagerel $LN247+293
	DD	imagerel $chain$0$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+293
	DD	imagerel $LN247+301
	DD	imagerel $chain$1$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+301
	DD	imagerel $LN247+443
	DD	imagerel $chain$3$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+443
	DD	imagerel $LN247+510
	DD	imagerel $chain$4$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+510
	DD	imagerel $LN247+526
	DD	imagerel $chain$5$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD imagerel $LN247+526
	DD	imagerel $LN247+799
	DD	imagerel $chain$6$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z DD imagerel $LN13
	DD	imagerel $LN13+77
	DD	imagerel $unwind$??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+134
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN26+134
	DD	imagerel $LN26+145
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD imagerel $LN26+129
	DD	imagerel $LN26+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+134
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN26+134
	DD	imagerel $LN26+145
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+126
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN26+126
	DD	imagerel $LN26+137
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve_discard@?$ImVector@D@@QEAAXH@Z DD imagerel $LN25
	DD	imagerel $LN25+99
	DD	imagerel $unwind$?reserve_discard@?$ImVector@D@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+200
	DD	imagerel $chain$1$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN38+200
	DD	imagerel $LN38+218
	DD	imagerel $chain$3$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD imagerel $LN38+218
	DD	imagerel $LN38+231
	DD	imagerel $chain$4$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD imagerel $LN35+72
	DD	imagerel $LN35+173
	DD	imagerel $chain$0$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD imagerel $LN35+173
	DD	imagerel $LN35+209
	DD	imagerel $chain$1$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN38+26
	DD	imagerel $LN38+200
	DD	imagerel $chain$1$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN38+200
	DD	imagerel $LN38+218
	DD	imagerel $chain$3$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD imagerel $LN38+218
	DD	imagerel $LN38+231
	DD	imagerel $chain$4$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD imagerel $LN12
	DD	imagerel $LN12+70
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z DD imagerel $LN11
	DD	imagerel $LN11+128
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z DD imagerel $LN40
	DD	imagerel $LN40+299
	DD	imagerel $unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+70
	DD	imagerel $unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+70
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+319
	DD	imagerel $chain$0$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+319
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel $chain$1$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+421
	DD	imagerel $chain$2$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+421
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+551
	DD	imagerel $chain$3$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+551
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+564
	DD	imagerel $chain$4$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+564
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+616
	DD	imagerel $chain$5$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD imagerel ?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+843
	DD	imagerel $unwind$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD imagerel $LN56
	DD	imagerel $LN56+183
	DD	imagerel $unwind$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD imagerel $LN56+183
	DD	imagerel $LN56+313
	DD	imagerel $chain$3$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD imagerel $LN56+313
	DD	imagerel $LN56+359
	DD	imagerel $chain$4$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD imagerel $LN41+39
	DD	imagerel $LN41+164
	DD	imagerel $chain$2$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD imagerel $LN41+164
	DD	imagerel $LN41+295
	DD	imagerel $chain$4$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD imagerel $LN41+295
	DD	imagerel $LN41+326
	DD	imagerel $chain$5$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD imagerel $LN41+326
	DD	imagerel $LN41+335
	DD	imagerel $chain$6$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel $unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel $chain$1$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+751
	DD	imagerel $chain$3$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+751
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+881
	DD	imagerel $chain$6$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+881
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+2959
	DD	imagerel $chain$7$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+2959
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+3885
	DD	imagerel $chain$8$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+3885
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+4198
	DD	imagerel $chain$9$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD imagerel $LN158
	DD	imagerel $LN158+94
	DD	imagerel $unwind$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD imagerel $LN158+94
	DD	imagerel $LN158+1402
	DD	imagerel $chain$9$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD imagerel $LN158+1402
	DD	imagerel $LN158+1461
	DD	imagerel $chain$10$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419
	DD	imagerel $LN419+244
	DD	imagerel $unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419+244
	DD	imagerel $LN419+322
	DD	imagerel $chain$9$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419+322
	DD	imagerel $LN419+361
	DD	imagerel $chain$10$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419+361
	DD	imagerel $LN419+623
	DD	imagerel $chain$12$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419+623
	DD	imagerel $LN419+2855
	DD	imagerel $chain$15$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD imagerel $LN419+2855
	DD	imagerel $LN419+2904
	DD	imagerel $chain$16$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z DD imagerel $LN81
	DD	imagerel $LN81+364
	DD	imagerel $unwind$?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z DD imagerel $LN60
	DD	imagerel $LN60+365
	DD	imagerel $unwind$?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD imagerel $LN345
	DD	imagerel $LN345+100
	DD	imagerel $unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD imagerel $LN345+100
	DD	imagerel $LN345+628
	DD	imagerel $chain$12$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD imagerel $LN345+628
	DD	imagerel $LN345+3249
	DD	imagerel $chain$13$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD imagerel $LN345+3249
	DD	imagerel $LN345+3275
	DD	imagerel $chain$14$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z DD imagerel $LN22
	DD	imagerel $LN22+255
	DD	imagerel $unwind$?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130
	DD	imagerel $LN130+78
	DD	imagerel $unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+78
	DD	imagerel $LN130+127
	DD	imagerel $chain$0$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+127
	DD	imagerel $LN130+276
	DD	imagerel $chain$1$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+276
	DD	imagerel $LN130+347
	DD	imagerel $chain$3$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+347
	DD	imagerel $LN130+800
	DD	imagerel $chain$6$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+800
	DD	imagerel $LN130+928
	DD	imagerel $chain$7$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+928
	DD	imagerel $LN130+936
	DD	imagerel $chain$8$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+936
	DD	imagerel $LN130+944
	DD	imagerel $chain$9$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN130+944
	DD	imagerel $LN130+972
	DD	imagerel $chain$10$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181
	DD	imagerel $LN181+116
	DD	imagerel $unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+116
	DD	imagerel $LN181+274
	DD	imagerel $chain$1$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+274
	DD	imagerel $LN181+779
	DD	imagerel $chain$3$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+779
	DD	imagerel $LN181+1382
	DD	imagerel $chain$4$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+1382
	DD	imagerel $LN181+1413
	DD	imagerel $chain$5$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+1413
	DD	imagerel $LN181+1429
	DD	imagerel $chain$6$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD imagerel $LN181+1429
	DD	imagerel $LN181+1456
	DD	imagerel $chain$7$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159+65
	DD	imagerel $LN159+81
	DD	imagerel $chain$1$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159+81
	DD	imagerel $LN159+414
	DD	imagerel $chain$3$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159+414
	DD	imagerel $LN159+547
	DD	imagerel $chain$4$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159+547
	DD	imagerel $LN159+857
	DD	imagerel $chain$5$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD imagerel $LN159+857
	DD	imagerel $LN159+886
	DD	imagerel $chain$6$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel $unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+55
	DD	imagerel $chain$0$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+55
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+456
	DD	imagerel $chain$10$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+456
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+702
	DD	imagerel $chain$11$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+702
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+961
	DD	imagerel $chain$12$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+59
	DD	imagerel $unwind$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+59
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+182
	DD	imagerel $chain$0$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+182
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+187
	DD	imagerel $chain$1$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorEditRestoreH@@YAXPEBMPEAM@Z DD imagerel ?ColorEditRestoreH@@YAXPEBMPEAM@Z
	DD	imagerel ?ColorEditRestoreH@@YAXPEBMPEAM@Z+104
	DD	imagerel $unwind$?ColorEditRestoreH@@YAXPEBMPEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN1589
	DD	imagerel $LN1589+13388
	DD	imagerel $unwind$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z DD imagerel ?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z
	DD	imagerel ?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z+434
	DD	imagerel $unwind$?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z DD imagerel ?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z
	DD	imagerel ?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z+501
	DD	imagerel $unwind$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD imagerel ?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
	DD	imagerel ?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z+192
	DD	imagerel $unwind$?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD imagerel ?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
	DD	imagerel ?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z+161
	DD	imagerel $unwind$?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z DD imagerel ?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z
	DD	imagerel ?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z+106
	DD	imagerel $unwind$?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD imagerel ?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
	DD	imagerel ?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z+106
	DD	imagerel $unwind$?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+47
	DD	imagerel $unwind$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+47
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+329
	DD	imagerel $chain$2$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+329
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+338
	DD	imagerel $chain$3$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+41
	DD	imagerel $unwind$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+41
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+619
	DD	imagerel $chain$3$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+619
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+626
	DD	imagerel $chain$4$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+118
	DD	imagerel $unwind$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+118
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+314
	DD	imagerel $chain$2$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+314
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+418
	DD	imagerel $chain$3$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+120
	DD	imagerel $unwind$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+120
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+296
	DD	imagerel $chain$2$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+296
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+341
	DD	imagerel $chain$3$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel $unwind$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+51
	DD	imagerel $chain$0$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+51
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+177
	DD	imagerel $chain$1$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+177
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+225
	DD	imagerel $chain$2$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+225
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+231
	DD	imagerel $chain$3$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel $unwind$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+47
	DD	imagerel $chain$0$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+47
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+134
	DD	imagerel $chain$1$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+134
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+169
	DD	imagerel $chain$2$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+169
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+175
	DD	imagerel $chain$3$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z DD imagerel ?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
	DD	imagerel ?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z+3416
	DD	imagerel $unwind$?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z DD imagerel ?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z
	DD	imagerel ?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z+161
	DD	imagerel $unwind$?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+45
	DD	imagerel $unwind$?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD imagerel ?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+150
	DD	imagerel $unwind$?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD imagerel ?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
	DD	imagerel ?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z+144
	DD	imagerel $unwind$?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+135
	DD	imagerel $unwind$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+135
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+225
	DD	imagerel $chain$0$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+225
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+402
	DD	imagerel $chain$1$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD imagerel ?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	imagerel ?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z+100
	DD	imagerel $unwind$?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD imagerel ?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
	DD	imagerel ?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z+94
	DD	imagerel $unwind$?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z DD imagerel ?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z
	DD	imagerel ?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z+409
	DD	imagerel $unwind$?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z DD imagerel ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z
	DD	imagerel ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z+390
	DD	imagerel $unwind$?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z DD imagerel ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z+194
	DD	imagerel $unwind$?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+91
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+330
	DD	imagerel $chain$4$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+330
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+344
	DD	imagerel $chain$5$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+309
	DD	imagerel $chain$4$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+309
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+323
	DD	imagerel $chain$5$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+323
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+339
	DD	imagerel $chain$6$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+21
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+21
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+304
	DD	imagerel $chain$3$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+304
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+317
	DD	imagerel $chain$4$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+35
	DD	imagerel $unwind$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+35
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+172
	DD	imagerel $chain$1$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+172
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+212
	DD	imagerel $chain$2$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+212
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+246
	DD	imagerel $chain$3$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+46
	DD	imagerel $unwind$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+46
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+207
	DD	imagerel $chain$0$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+207
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+245
	DD	imagerel $chain$1$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z DD imagerel ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z+218
	DD	imagerel $unwind$?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD imagerel $LN53
	DD	imagerel $LN53+81
	DD	imagerel $unwind$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD imagerel $LN53+81
	DD	imagerel $LN53+549
	DD	imagerel $chain$1$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD imagerel $LN53+549
	DD	imagerel $LN53+640
	DD	imagerel $chain$2$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD imagerel $LN53
	DD	imagerel $LN53+66
	DD	imagerel $unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD imagerel $LN53+66
	DD	imagerel $LN53+560
	DD	imagerel $chain$2$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD imagerel $LN53+560
	DD	imagerel $LN53+643
	DD	imagerel $chain$3$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z DD imagerel $LN241
	DD	imagerel $LN241+1332
	DD	imagerel $unwind$?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z DD imagerel $LN15
	DD	imagerel $LN15+206
	DD	imagerel $unwind$?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD imagerel $LN33+31
	DD	imagerel $LN33+157
	DD	imagerel $chain$1$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD imagerel $LN33+157
	DD	imagerel $LN33+169
	DD	imagerel $chain$2$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z DD imagerel $LN33
	DD	imagerel $LN33+157
	DD	imagerel $unwind$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z DD imagerel $LN110
	DD	imagerel $LN110+1172
	DD	imagerel $unwind$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z DD imagerel $LN94
	DD	imagerel $LN94+458
	DD	imagerel $unwind$?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD imagerel $LN120
	DD	imagerel $LN120+112
	DD	imagerel $unwind$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD imagerel $LN120+112
	DD	imagerel $LN120+845
	DD	imagerel $chain$3$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD imagerel $LN120+845
	DD	imagerel $LN120+895
	DD	imagerel $chain$4$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD imagerel $LN110
	DD	imagerel $LN110+79
	DD	imagerel $unwind$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD imagerel $LN110+79
	DD	imagerel $LN110+947
	DD	imagerel $chain$0$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD imagerel $LN110+947
	DD	imagerel $LN110+963
	DD	imagerel $chain$1$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD imagerel $LN88
	DD	imagerel $LN88+479
	DD	imagerel $unwind$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD imagerel $LN88+479
	DD	imagerel $LN88+1105
	DD	imagerel $chain$3$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD imagerel $LN88+1105
	DD	imagerel $LN88+1177
	DD	imagerel $chain$4$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132
	DD	imagerel $LN132+90
	DD	imagerel $unwind$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132+90
	DD	imagerel $LN132+131
	DD	imagerel $chain$3$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132+131
	DD	imagerel $LN132+513
	DD	imagerel $chain$5$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132+513
	DD	imagerel $LN132+546
	DD	imagerel $chain$6$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132+546
	DD	imagerel $LN132+584
	DD	imagerel $chain$7$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?SeparatorEx@ImGui@@YAXHM@Z DD imagerel $LN132+584
	DD	imagerel $LN132+1132
	DD	imagerel $chain$9$?SeparatorEx@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD imagerel $LN54
	DD	imagerel $LN54+61
	DD	imagerel $unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD imagerel $LN54+61
	DD	imagerel $LN54+355
	DD	imagerel $chain$0$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD imagerel $LN54+355
	DD	imagerel $LN54+378
	DD	imagerel $chain$1$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD imagerel $LN72
	DD	imagerel $LN72+265
	DD	imagerel $unwind$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD imagerel $LN72+265
	DD	imagerel $LN72+574
	DD	imagerel $chain$6$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD imagerel $LN72+574
	DD	imagerel $LN72+901
	DD	imagerel $chain$7$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD imagerel $LN72+901
	DD	imagerel $LN72+948
	DD	imagerel $chain$8$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157
	DD	imagerel $LN157+235
	DD	imagerel $unwind$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+235
	DD	imagerel $LN157+255
	DD	imagerel $chain$1$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+255
	DD	imagerel $LN157+263
	DD	imagerel $chain$2$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+263
	DD	imagerel $LN157+1138
	DD	imagerel $chain$8$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+1138
	DD	imagerel $LN157+1268
	DD	imagerel $chain$9$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+1268
	DD	imagerel $LN157+1467
	DD	imagerel $chain$10$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD imagerel $LN157+1467
	DD	imagerel $LN157+1517
	DD	imagerel $chain$11$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z DD imagerel $LN37
	DD	imagerel $LN37+197
	DD	imagerel $unwind$?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z DD imagerel $LN13
	DD	imagerel $LN13+113
	DD	imagerel $unwind$?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD imagerel $LN45
	DD	imagerel $LN45+254
	DD	imagerel $unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD imagerel $LN45+254
	DD	imagerel $LN45+615
	DD	imagerel $chain$2$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD imagerel $LN45+615
	DD	imagerel $LN45+657
	DD	imagerel $chain$3$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD imagerel $LN64
	DD	imagerel $LN64+103
	DD	imagerel $unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD imagerel $LN64+103
	DD	imagerel $LN64+491
	DD	imagerel $chain$1$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD imagerel $LN64+491
	DD	imagerel $LN64+862
	DD	imagerel $chain$2$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+153
	DD	imagerel $unwind$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z DD imagerel $LN25
	DD	imagerel $LN25+174
	DD	imagerel $unwind$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285
	DD	imagerel $LN285+85
	DD	imagerel $unwind$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+85
	DD	imagerel $LN285+291
	DD	imagerel $chain$8$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+291
	DD	imagerel $LN285+639
	DD	imagerel $chain$12$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+639
	DD	imagerel $LN285+989
	DD	imagerel $chain$14$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+989
	DD	imagerel $LN285+1385
	DD	imagerel $chain$15$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+1385
	DD	imagerel $LN285+2024
	DD	imagerel $chain$16$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?TextEx@ImGui@@YAXPEBD0H@Z DD imagerel $LN285+2024
	DD	imagerel $LN285+2049
	DD	imagerel $chain$17$?TextEx@ImGui@@YAXPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ DD imagerel $LN26
	DD	imagerel $LN26+145
	DD	imagerel $unwind$?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Spacing@ImGui@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+73
	DD	imagerel $unwind$?Spacing@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN86
	DD	imagerel $LN86+77
	DD	imagerel $unwind$?BeginMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN86+77
	DD	imagerel $LN86+99
	DD	imagerel $chain$4$?BeginMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN86+99
	DD	imagerel $LN86+390
	DD	imagerel $chain$5$?BeginMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN86+390
	DD	imagerel $LN86+700
	DD	imagerel $chain$6$?BeginMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?BeginMenuBar@ImGui@@YA_NXZ DD imagerel $LN86+700
	DD	imagerel $LN86+721
	DD	imagerel $chain$7$?BeginMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD imagerel $LN306
	DD	imagerel $LN306+147
	DD	imagerel $unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD imagerel $LN306+147
	DD	imagerel $LN306+539
	DD	imagerel $chain$0$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD imagerel $LN306+539
	DD	imagerel $LN306+2424
	DD	imagerel $chain$1$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginMainMenuBar@ImGui@@YA_NXZ DD imagerel $LN140
	DD	imagerel $LN140+662
	DD	imagerel $unwind$?BeginMainMenuBar@ImGui@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NewLine@ImGui@@YAXXZ DD imagerel $LN14
	DD	imagerel $LN14+148
	DD	imagerel $unwind$?NewLine@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197
	DD	imagerel $LN1197+115
	DD	imagerel $unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197+115
	DD	imagerel $LN1197+123
	DD	imagerel $chain$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197+123
	DD	imagerel $LN1197+8245
	DD	imagerel $chain$12$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197+8245
	DD	imagerel $LN1197+8691
	DD	imagerel $chain$13$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197+8691
	DD	imagerel $LN1197+8802
	DD	imagerel $chain$14$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD imagerel $LN1197+8802
	DD	imagerel $LN1197+8832
	DD	imagerel $chain$15$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132
	DD	imagerel $LN132+320
	DD	imagerel $unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+320
	DD	imagerel $LN132+334
	DD	imagerel $chain$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+334
	DD	imagerel $LN132+730
	DD	imagerel $chain$5$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+730
	DD	imagerel $LN132+1349
	DD	imagerel $chain$6$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+1349
	DD	imagerel $LN132+1528
	DD	imagerel $chain$7$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+1528
	DD	imagerel $LN132+1856
	DD	imagerel $chain$8$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD imagerel $LN132+1856
	DD	imagerel $LN132+1960
	DD	imagerel $chain$9$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndMenu@ImGui@@YAXXZ DD imagerel $LN19
	DD	imagerel $LN19+164
	DD	imagerel $unwind$?EndMenu@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+66
	DD	imagerel $unwind$?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN255
	DD	imagerel $LN255+571
	DD	imagerel $unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN255+571
	DD	imagerel $LN255+584
	DD	imagerel $chain$0$?BeginCombo@ImGui@@YA_NPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN255+584
	DD	imagerel $LN255+1762
	DD	imagerel $chain$4$?BeginCombo@ImGui@@YA_NPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN255+1762
	DD	imagerel $LN255+1827
	DD	imagerel $chain$5$?BeginCombo@ImGui@@YA_NPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD imagerel $LN255+1827
	DD	imagerel $LN255+1917
	DD	imagerel $chain$6$?BeginCombo@ImGui@@YA_NPEBD0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN52
	DD	imagerel $LN52+113
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN52+113
	DD	imagerel $LN52+133
	DD	imagerel $chain$0$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN52+133
	DD	imagerel $LN52+268
	DD	imagerel $chain$1$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN52+268
	DD	imagerel $LN52+332
	DD	imagerel $chain$2$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD imagerel $LN52+332
	DD	imagerel $LN52+359
	DD	imagerel $chain$3$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD imagerel $LN18
	DD	imagerel $LN18+270
	DD	imagerel $unwind$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CollapsingHeader@ImGui@@YA_NPEBDH@Z DD imagerel $LN8
	DD	imagerel $LN8+101
	DD	imagerel $unwind$?CollapsingHeader@ImGui@@YA_NPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360
	DD	imagerel $LN360+109
	DD	imagerel $unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360+109
	DD	imagerel $LN360+376
	DD	imagerel $chain$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360+376
	DD	imagerel $LN360+1245
	DD	imagerel $chain$4$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360+1245
	DD	imagerel $LN360+1882
	DD	imagerel $chain$5$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360+1882
	DD	imagerel $LN360+1949
	DD	imagerel $chain$6$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD imagerel $LN360+1949
	DD	imagerel $LN360+2064
	DD	imagerel $chain$7$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndMenuBar@ImGui@@YAXXZ DD imagerel $LN59
	DD	imagerel $LN59+581
	DD	imagerel $unwind$?EndMenuBar@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndMainMenuBar@ImGui@@YAXXZ DD imagerel $LN31
	DD	imagerel $LN31+207
	DD	imagerel $unwind$?EndMainMenuBar@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RadioButton@ImGui@@YA_NPEBD_N@Z DD imagerel $LN122
	DD	imagerel $LN122+514
	DD	imagerel $unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?RadioButton@ImGui@@YA_NPEBD_N@Z DD imagerel $LN122+514
	DD	imagerel $LN122+1352
	DD	imagerel $chain$3$?RadioButton@ImGui@@YA_NPEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?RadioButton@ImGui@@YA_NPEBD_N@Z DD imagerel $LN122+1352
	DD	imagerel $LN122+1489
	DD	imagerel $chain$4$?RadioButton@ImGui@@YA_NPEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextWrapped@ImGui@@YAXPEBDZZ DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$?TextWrapped@ImGui@@YAXPEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838
	DD	imagerel $LN838+110
	DD	imagerel $unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+110
	DD	imagerel $LN838+118
	DD	imagerel $chain$0$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+118
	DD	imagerel $LN838+126
	DD	imagerel $chain$1$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+126
	DD	imagerel $LN838+151
	DD	imagerel $chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+151
	DD	imagerel $LN838+160
	DD	imagerel $chain$5$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+160
	DD	imagerel $LN838+2849
	DD	imagerel $chain$11$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+2849
	DD	imagerel $LN838+2955
	DD	imagerel $chain$12$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+2955
	DD	imagerel $LN838+3140
	DD	imagerel $chain$13$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+3140
	DD	imagerel $LN838+3433
	DD	imagerel $chain$14$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+3433
	DD	imagerel $LN838+3592
	DD	imagerel $chain$15$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+3592
	DD	imagerel $LN838+3875
	DD	imagerel $chain$16$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+3875
	DD	imagerel $LN838+3934
	DD	imagerel $chain$17$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$18$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD imagerel $LN838+3934
	DD	imagerel $LN838+3962
	DD	imagerel $chain$18$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD imagerel $LN31
	DD	imagerel $LN31+79
	DD	imagerel $unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD imagerel $LN31+79
	DD	imagerel $LN31+305
	DD	imagerel $chain$1$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD imagerel $LN31+305
	DD	imagerel $LN31+306
	DD	imagerel $chain$2$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Update@ImGuiMenuColumns@@QEAAXM_N@Z DD imagerel $LN61
	DD	imagerel $LN61+365
	DD	imagerel $unwind$?Update@ImGuiMenuColumns@@QEAAXM_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z DD imagerel $LN18
	DD	imagerel $LN18+231
	DD	imagerel $unwind$?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD imagerel $LN76
	DD	imagerel $LN76+92
	DD	imagerel $unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD imagerel $LN76+92
	DD	imagerel $LN76+742
	DD	imagerel $chain$1$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD imagerel $LN76+742
	DD	imagerel $LN76+776
	DD	imagerel $chain$2$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$?TextV@ImGui@@YAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?TextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN34+97
	DD	imagerel $LN34+193
	DD	imagerel $chain$2$?TextV@ImGui@@YAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?TextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN34+193
	DD	imagerel $LN34+235
	DD	imagerel $chain$3$?TextV@ImGui@@YAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?TextV@ImGui@@YAXPEBDPEAD@Z DD imagerel $LN34+235
	DD	imagerel $LN34+266
	DD	imagerel $chain$4$?TextV@ImGui@@YAXPEBDPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z DD imagerel $LN139
	DD	imagerel $LN139+1354
	DD	imagerel $unwind$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputTextDeactivateHook@ImGui@@YAXI@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?InputTextDeactivateHook@ImGui@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?InputTextDeactivateHook@ImGui@@YAXI@Z DD imagerel $LN30+50
	DD	imagerel $LN30+112
	DD	imagerel $chain$0$?InputTextDeactivateHook@ImGui@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?InputTextDeactivateHook@ImGui@@YAXI@Z DD imagerel $LN30+112
	DD	imagerel $LN30+206
	DD	imagerel $chain$3$?InputTextDeactivateHook@ImGui@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?InputTextDeactivateHook@ImGui@@YAXI@Z DD imagerel $LN30+206
	DD	imagerel $LN30+212
	DD	imagerel $chain$4$?InputTextDeactivateHook@ImGui@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MenuItem@ImGui@@YA_NPEBD0_N1@Z DD imagerel $LN4
	DD	imagerel $LN4+21
	DD	imagerel $unwind$?MenuItem@ImGui@@YA_NPEBD0_N1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN119
	DD	imagerel $LN119+464
	DD	imagerel $unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN119+464
	DD	imagerel $LN119+493
	DD	imagerel $chain$1$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN119+493
	DD	imagerel $LN119+814
	DD	imagerel $chain$2$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN119+814
	DD	imagerel $LN119+1079
	DD	imagerel $chain$3$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD imagerel $LN119+1079
	DD	imagerel $LN119+1224
	DD	imagerel $chain$4$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ DD imagerel $LN27
	DD	imagerel $LN27+163
	DD	imagerel $unwind$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN189
	DD	imagerel $LN189+126
	DD	imagerel $unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN189+126
	DD	imagerel $LN189+147
	DD	imagerel $chain$2$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN189+147
	DD	imagerel $LN189+589
	DD	imagerel $chain$3$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN189+589
	DD	imagerel $LN189+756
	DD	imagerel $chain$4$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD imagerel $LN189+756
	DD	imagerel $LN189+2139
	DD	imagerel $chain$5$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN132
	DD	imagerel $LN132+139
	DD	imagerel $unwind$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN132+139
	DD	imagerel $LN132+574
	DD	imagerel $chain$0$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD imagerel $LN132+574
	DD	imagerel $LN132+1085
	DD	imagerel $chain$1$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z DD imagerel $LN15
	DD	imagerel $LN15+77
	DD	imagerel $unwind$?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120
	DD	imagerel $LN120+361
	DD	imagerel $unwind$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120+361
	DD	imagerel $LN120+609
	DD	imagerel $chain$3$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120+609
	DD	imagerel $LN120+664
	DD	imagerel $chain$4$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120+664
	DD	imagerel $LN120+769
	DD	imagerel $chain$5$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120+769
	DD	imagerel $LN120+1123
	DD	imagerel $chain$6$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD imagerel $LN120+1123
	DD	imagerel $LN120+1174
	DD	imagerel $chain$7$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z DD imagerel $LN366
	DD	imagerel $LN366+2006
	DD	imagerel $unwind$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102
	DD	imagerel $LN102+94
	DD	imagerel $unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+94
	DD	imagerel $LN102+490
	DD	imagerel $chain$5$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+490
	DD	imagerel $LN102+709
	DD	imagerel $chain$6$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+709
	DD	imagerel $LN102+724
	DD	imagerel $chain$7$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+724
	DD	imagerel $LN102+776
	DD	imagerel $chain$8$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+776
	DD	imagerel $LN102+866
	DD	imagerel $chain$9$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+866
	DD	imagerel $LN102+912
	DD	imagerel $chain$10$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+912
	DD	imagerel $LN102+964
	DD	imagerel $chain$11$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD imagerel $LN102+964
	DD	imagerel $LN102+991
	DD	imagerel $chain$12$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndTabBar@ImGui@@YAXXZ DD imagerel $LN47
	DD	imagerel $LN47+40
	DD	imagerel $unwind$?EndTabBar@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?EndTabBar@ImGui@@YAXXZ DD imagerel $LN47+40
	DD	imagerel $LN47+285
	DD	imagerel $chain$0$?EndTabBar@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?EndTabBar@ImGui@@YAXXZ DD imagerel $LN47+285
	DD	imagerel $LN47+296
	DD	imagerel $chain$1$?EndTabBar@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD imagerel $LN98
	DD	imagerel $LN98+428
	DD	imagerel $unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD imagerel $LN98+428
	DD	imagerel $LN98+903
	DD	imagerel $chain$0$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD imagerel $LN98+903
	DD	imagerel $LN98+964
	DD	imagerel $chain$1$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD imagerel $LN651
	DD	imagerel $LN651+1156
	DD	imagerel $unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD imagerel $LN651+1156
	DD	imagerel $LN651+1618
	DD	imagerel $chain$8$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD imagerel $LN651+1618
	DD	imagerel $LN651+3367
	DD	imagerel $chain$9$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD imagerel $LN651+3367
	DD	imagerel $LN651+3427
	DD	imagerel $chain$10$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD imagerel $LN8
	DD	imagerel $LN8+69
	DD	imagerel $unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85
	DD	imagerel $LN85+29
	DD	imagerel $unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+29
	DD	imagerel $LN85+52
	DD	imagerel $chain$1$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+52
	DD	imagerel $LN85+412
	DD	imagerel $chain$5$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+412
	DD	imagerel $LN85+552
	DD	imagerel $chain$6$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+552
	DD	imagerel $LN85+599
	DD	imagerel $chain$7$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+599
	DD	imagerel $LN85+706
	DD	imagerel $chain$8$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD imagerel $LN85+706
	DD	imagerel $LN85+792
	DD	imagerel $chain$9$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndListBox@ImGui@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+18
	DD	imagerel $unwind$?EndListBox@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z DD imagerel $LN33
	DD	imagerel $LN33+175
	DD	imagerel $unwind$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z DD imagerel $LN58
	DD	imagerel $LN58+439
	DD	imagerel $unwind$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Text@ImGui@@YAXPEBDZZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$?Text@ImGui@@YAXPEBDZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD imagerel $LN90
	DD	imagerel $LN90+67
	DD	imagerel $unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD imagerel $LN90+67
	DD	imagerel $LN90+455
	DD	imagerel $chain$1$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD imagerel $LN90+455
	DD	imagerel $LN90+942
	DD	imagerel $chain$2$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD imagerel $LN90+942
	DD	imagerel $LN90+963
	DD	imagerel $chain$3$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN48
	DD	imagerel $LN48+71
	DD	imagerel $unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN48+71
	DD	imagerel $LN48+259
	DD	imagerel $chain$3$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN48+259
	DD	imagerel $LN48+365
	DD	imagerel $chain$4$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD imagerel $LN48+365
	DD	imagerel $LN48+386
	DD	imagerel $chain$5$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+71
	DD	imagerel $unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD 060021H
	DD	049800H
	DD	058800H
	DD	067800H
	DD	imagerel $LN48
	DD	imagerel $LN48+71
	DD	imagerel $unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD 081f21H
	DD	04981fH
	DD	058810H
	DD	06780aH
	DD	076805H
	DD	imagerel $LN48
	DD	imagerel $LN48+71
	DD	imagerel $unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Dummy@ImGui@@YAXAEBUImVec2@@@Z DD 021619H
	DD	0110107H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD 021H
	DD	imagerel $LN90
	DD	imagerel $LN90+67
	DD	imagerel $unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD 020021H
	DD	012e400H
	DD	imagerel $LN90
	DD	imagerel $LN90+67
	DD	imagerel $unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD 041021H
	DD	012e410H
	DD	0105408H
	DD	imagerel $LN90
	DD	imagerel $LN90+67
	DD	imagerel $unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z DD 081601H
	DD	0133416H
	DD	0f0129216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Text@ImGui@@YAXPEBDZZ DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z DD 082319H
	DD	066814H
	DD	012640fH
	DD	011340fH
	DD	0700bd20fH
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndListBox@ImGui@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+29
	DD	imagerel $unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 060021H
	DD	068800H
	DD	077800H
	DD	086800H
	DD	imagerel $LN85+29
	DD	imagerel $LN85+52
	DD	imagerel $chain$1$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 021H
	DD	imagerel $LN85+52
	DD	imagerel $LN85+412
	DD	imagerel $chain$5$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 020821H
	DD	01a7408H
	DD	imagerel $LN85+52
	DD	imagerel $LN85+412
	DD	imagerel $chain$5$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 084921H
	DD	068849H
	DD	077844H
	DD	08680cH
	DD	012f404H
	DD	imagerel $LN85+29
	DD	imagerel $LN85+52
	DD	imagerel $chain$1$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 041421H
	DD	013c414H
	DD	0196404H
	DD	imagerel $LN85
	DD	imagerel $LN85+29
	DD	imagerel $unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z DD 051d19H
	DD	014010eH
	DD	05005e007H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD 021H
	DD	imagerel $LN651
	DD	imagerel $LN651+1156
	DD	imagerel $unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD 060021H
	DD	012e800H
	DD	013d800H
	DD	014c800H
	DD	imagerel $LN651
	DD	imagerel $LN651+1156
	DD	imagerel $unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD 0e3f21H
	DD	012e83fH
	DD	013d836H
	DD	014c82dH
	DD	015b824H
	DD	016a81bH
	DD	0179812H
	DD	0188809H
	DD	imagerel $LN651
	DD	imagerel $LN651+1156
	DD	imagerel $unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z DD 010ad19H
	DD	036f4adH
	DD	041c4a5H
	DD	0197821H
	DD	01a681dH
	DD	0370119H
	DD	0d009e00bH
	DD	060067007H
	DD	050043005H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN98
	DD	imagerel $LN98+428
	DD	imagerel $unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD 020621H
	DD	06a806H
	DD	imagerel $LN98
	DD	imagerel $LN98+428
	DD	imagerel $unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z DD 0133f19H
	DD	079831H
	DD	08882cH
	DD	097827H
	DD	0a6823H
	DD	01d741fH
	DD	01c641fH
	DD	01b341fH
	DD	016011fH
	DD	0e012f014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?EndTabBar@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+40
	DD	imagerel $unwind$?EndTabBar@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?EndTabBar@ImGui@@YAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN47
	DD	imagerel $LN47+40
	DD	imagerel $unwind$?EndTabBar@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndTabBar@ImGui@@YAXXZ DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+94
	DD	imagerel $unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 021H
	DD	imagerel $LN102+709
	DD	imagerel $LN102+724
	DD	imagerel $chain$7$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 021H
	DD	imagerel $LN102+724
	DD	imagerel $LN102+776
	DD	imagerel $chain$8$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 020821H
	DD	023e408H
	DD	imagerel $LN102+724
	DD	imagerel $LN102+776
	DD	imagerel $chain$8$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 020821H
	DD	024f408H
	DD	imagerel $LN102+709
	DD	imagerel $LN102+724
	DD	imagerel $chain$7$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 021H
	DD	imagerel $LN102+94
	DD	imagerel $LN102+490
	DD	imagerel $chain$5$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 020821H
	DD	0d6808H
	DD	imagerel $LN102+94
	DD	imagerel $LN102+490
	DD	imagerel $chain$5$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 0c5221H
	DD	08b852H
	DD	09a834H
	DD	0a9822H
	DD	0b8819H
	DD	0c7810H
	DD	0227408H
	DD	imagerel $LN102
	DD	imagerel $LN102+94
	DD	imagerel $unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z DD 072219H
	DD	01c0114H
	DD	0c006d008H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z DD 0b3c01H
	DD	03683cH
	DD	0f01b821fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 021H
	DD	imagerel $LN120
	DD	imagerel $LN120+361
	DD	imagerel $unwind$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 021H
	DD	imagerel $LN120+609
	DD	imagerel $LN120+664
	DD	imagerel $chain$4$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 020921H
	DD	0c9809H
	DD	imagerel $LN120+609
	DD	imagerel $LN120+664
	DD	imagerel $chain$4$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 020821H
	DD	0e7808H
	DD	imagerel $LN120+361
	DD	imagerel $LN120+609
	DD	imagerel $chain$3$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 08f821H
	DD	0f68f8H
	DD	020e4d5H
	DD	0ab817H
	DD	029c408H
	DD	imagerel $LN120
	DD	imagerel $LN120+361
	DD	imagerel $unwind$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z DD 0e3919H
	DD	09c82bH
	DD	0ba823H
	DD	0d881bH
	DD	0210116H
	DD	0d009f00bH
	DD	060067007H
	DD	050043005H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z DD 020a01H
	DD	03006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+139
	DD	imagerel $unwind$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 020421H
	DD	0275404H
	DD	imagerel $LN132
	DD	imagerel $LN132+139
	DD	imagerel $unwind$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z DD 01b5c19H
	DD	07e84dH
	DD	08d847H
	DD	09c83fH
	DD	0ab837H
	DD	0ba82fH
	DD	0c982aH
	DD	0d8825H
	DD	0e7820H
	DD	0f681bH
	DD	0283416H
	DD	0200116H
	DD	0e00df00fH
	DD	07009c00bH
	DD	06008H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN189
	DD	imagerel $LN189+126
	DD	imagerel $unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN189+126
	DD	imagerel $LN189+147
	DD	imagerel $chain$2$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 020821H
	DD	0bc808H
	DD	imagerel $LN189+126
	DD	imagerel $LN189+147
	DD	imagerel $chain$2$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 061521H
	DD	0da815H
	DD	0e980dH
	DD	0f8805H
	DD	imagerel $LN189
	DD	imagerel $LN189+126
	DD	imagerel $unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z DD 0134319H
	DD	0cb835H
	DD	010782dH
	DD	0116828H
	DD	02d7423H
	DD	02c6423H
	DD	02b3423H
	DD	0240123H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ DD 051701H
	DD	070138217H
	DD	050116012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z DD 011619H
	DD	0a207H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+464
	DD	imagerel $unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 021H
	DD	imagerel $LN119+464
	DD	imagerel $LN119+493
	DD	imagerel $chain$1$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 020621H
	DD	07d806H
	DD	imagerel $LN119+464
	DD	imagerel $LN119+493
	DD	imagerel $chain$1$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 041621H
	DD	08c816H
	DD	0c8809H
	DD	imagerel $LN119
	DD	imagerel $LN119+464
	DD	imagerel $unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Checkbox@ImGui@@YA_NPEBDPEA_N@Z DD 0154619H
	DD	09b838H
	DD	0aa830H
	DD	0b982bH
	DD	0d7826H
	DD	0e6822H
	DD	027641eH
	DD	026341eH
	DD	01e011eH
	DD	0e011f013H
	DD	0700dc00fH
	DD	0500cH
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuItem@ImGui@@YA_NPEBD0_N1@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?InputTextDeactivateHook@ImGui@@YAXI@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?InputTextDeactivateHook@ImGui@@YAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?InputTextDeactivateHook@ImGui@@YAXI@Z DD 040521H
	DD	066405H
	DD	077400H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?InputTextDeactivateHook@ImGui@@YAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?InputTextDeactivateHook@ImGui@@YAXI@Z DD 020521H
	DD	077405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?InputTextDeactivateHook@ImGui@@YAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputTextDeactivateHook@ImGui@@YAXI@Z DD 020d01H
	DD	03009320dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z DD 0156301H
	DD	04a863H
	DD	05985eH
	DD	068855H
	DD	077848H
	DD	086844H
	DD	019641bH
	DD	018541bH
	DD	017341bH
	DD	012011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?TextV@ImGui@@YAXPEBDPEAD@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$?TextV@ImGui@@YAXPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?TextV@ImGui@@YAXPEBDPEAD@Z DD 040021H
	DD	0cf400H
	DD	0b5400H
	DD	imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$?TextV@ImGui@@YAXPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?TextV@ImGui@@YAXPEBDPEAD@Z DD 061621H
	DD	0cf416H
	DD	0b540aH
	DD	0a3405H
	DD	imagerel $LN34
	DD	imagerel $LN34+97
	DD	imagerel $unwind$?TextV@ImGui@@YAXPEBDPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextV@ImGui@@YAXPEBDPEAD@Z DD 040901H
	DD	0e0055209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+92
	DD	imagerel $unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD 040d21H
	DD	07680dH
	DD	0146408H
	DD	imagerel $LN76
	DD	imagerel $LN76+92
	DD	imagerel $unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z DD 0c3001H
	DD	067830H
	DD	017d41eH
	DD	016741eH
	DD	015341eH
	DD	0f014f21eH
	DD	05010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z DD 020601H
	DD	03002b206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Update@ImGuiMenuColumns@@QEAAXM_N@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+79
	DD	imagerel $unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD 040a21H
	DD	09f40aH
	DD	083405H
	DD	imagerel $LN31
	DD	imagerel $LN31+79
	DD	imagerel $unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z DD 061601H
	DD	0a5416H
	DD	0e0123216H
	DD	0600f7010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$18$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 021H
	DD	imagerel $LN838
	DD	imagerel $LN838+110
	DD	imagerel $unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 021H
	DD	imagerel $LN838+110
	DD	imagerel $LN838+118
	DD	imagerel $chain$0$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 021H
	DD	imagerel $LN838+118
	DD	imagerel $LN838+126
	DD	imagerel $chain$1$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 021H
	DD	imagerel $LN838+126
	DD	imagerel $LN838+151
	DD	imagerel $chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 0e0021H
	DD	013f800H
	DD	014e800H
	DD	015d800H
	DD	016c800H
	DD	017b800H
	DD	018a800H
	DD	0199800H
	DD	imagerel $LN838+126
	DD	imagerel $LN838+151
	DD	imagerel $chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 021H
	DD	imagerel $LN838+126
	DD	imagerel $LN838+151
	DD	imagerel $chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 040021H
	DD	013f800H
	DD	016c800H
	DD	imagerel $LN838+151
	DD	imagerel $LN838+160
	DD	imagerel $chain$5$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 0c4421H
	DD	013f844H
	DD	014e83bH
	DD	015d824H
	DD	016c81bH
	DD	017b812H
	DD	018a809H
	DD	imagerel $LN838+151
	DD	imagerel $LN838+160
	DD	imagerel $chain$5$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 020921H
	DD	0199809H
	DD	imagerel $LN838+126
	DD	imagerel $LN838+151
	DD	imagerel $chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 061921H
	DD	01a8819H
	DD	01b7810H
	DD	01c6808H
	DD	imagerel $LN838+118
	DD	imagerel $LN838+126
	DD	imagerel $chain$1$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 020821H
	DD	03af408H
	DD	imagerel $LN838+110
	DD	imagerel $LN838+118
	DD	imagerel $chain$0$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 020821H
	DD	045d408H
	DD	imagerel $LN838
	DD	imagerel $LN838+110
	DD	imagerel $unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z DD 082619H
	DD	03b0118H
	DD	0c007e009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextWrapped@ImGui@@YAXPEBDZZ DD 031a01H
	DD	07016421aH
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?RadioButton@ImGui@@YA_NPEBD_N@Z DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+514
	DD	imagerel $unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?RadioButton@ImGui@@YA_NPEBD_N@Z DD 083f21H
	DD	08f83fH
	DD	09e82dH
	DD	0ad811H
	DD	02ed408H
	DD	imagerel $LN122
	DD	imagerel $LN122+514
	DD	imagerel $unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RadioButton@ImGui@@YA_NPEBD_N@Z DD 0175119H
	DD	0bc842H
	DD	0cb83aH
	DD	0da832H
	DD	0e982aH
	DD	0f8825H
	DD	0107820H
	DD	011681cH
	DD	0240118H
	DD	0e00bf00dH
	DD	07007c009H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndMainMenuBar@ImGui@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndMenuBar@ImGui@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 021H
	DD	imagerel $LN360
	DD	imagerel $LN360+109
	DD	imagerel $unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 021H
	DD	imagerel $LN360+109
	DD	imagerel $LN360+376
	DD	imagerel $chain$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 040021H
	DD	0b8800H
	DD	0c7800H
	DD	imagerel $LN360+109
	DD	imagerel $LN360+376
	DD	imagerel $chain$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 061921H
	DD	0b8819H
	DD	0c7810H
	DD	0d6808H
	DD	imagerel $LN360+109
	DD	imagerel $LN360+376
	DD	imagerel $chain$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 041721H
	DD	01cc417H
	DD	0275408H
	DD	imagerel $LN360
	DD	imagerel $LN360+109
	DD	imagerel $unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z DD 082319H
	DD	01d0111H
	DD	0e008f00aH
	DD	07004d006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CollapsingHeader@ImGui@@YA_NPEBDH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z DD 011619H
	DD	0c207H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD 061e19H
	DD	010640fH
	DD	0f340fH
	DD	0700bb20fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+113
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 021H
	DD	imagerel $LN52+113
	DD	imagerel $LN52+133
	DD	imagerel $chain$0$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 020521H
	DD	08f405H
	DD	imagerel $LN52+113
	DD	imagerel $LN52+133
	DD	imagerel $chain$0$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 020821H
	DD	0125408H
	DD	imagerel $LN52
	DD	imagerel $LN52+113
	DD	imagerel $unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z DD 071d19H
	DD	0e00a820eH
	DD	0c006d008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 021H
	DD	imagerel $LN255
	DD	imagerel $LN255+571
	DD	imagerel $unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 020021H
	DD	0109800H
	DD	imagerel $LN255+571
	DD	imagerel $LN255+584
	DD	imagerel $chain$0$?BeginCombo@ImGui@@YA_NPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 082e21H
	DD	0eb82eH
	DD	0fa823H
	DD	0109816H
	DD	0127808H
	DD	imagerel $LN255+571
	DD	imagerel $LN255+584
	DD	imagerel $chain$0$?BeginCombo@ImGui@@YA_NPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 020821H
	DD	0136808H
	DD	imagerel $LN255
	DD	imagerel $LN255+571
	DD	imagerel $unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginCombo@ImGui@@YA_NPEBD0H@Z DD 0134819H
	DD	0be83aH
	DD	0cd832H
	DD	0dc82aH
	DD	0118822H
	DD	032341dH
	DD	028011dH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndMenu@ImGui@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+320
	DD	imagerel $unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 021H
	DD	imagerel $LN132+320
	DD	imagerel $LN132+334
	DD	imagerel $chain$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 040021H
	DD	0fc800H
	DD	0147800H
	DD	imagerel $LN132+320
	DD	imagerel $LN132+334
	DD	imagerel $chain$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 020821H
	DD	0147808H
	DD	imagerel $LN132+334
	DD	imagerel $LN132+730
	DD	imagerel $chain$5$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 0a3921H
	DD	0cf839H
	DD	0de830H
	DD	0ed824H
	DD	0fc817H
	DD	010b809H
	DD	imagerel $LN132+320
	DD	imagerel $LN132+334
	DD	imagerel $chain$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 020921H
	DD	0138809H
	DD	imagerel $LN132
	DD	imagerel $LN132+320
	DD	imagerel $unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z DD 0113d19H
	DD	011a82fH
	DD	0129827H
	DD	0156822H
	DD	037341eH
	DD	02c011eH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 021H
	DD	imagerel $LN1197
	DD	imagerel $LN1197+115
	DD	imagerel $unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 021H
	DD	imagerel $LN1197+115
	DD	imagerel $LN1197+123
	DD	imagerel $chain$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 0160021H
	DD	01cf800H
	DD	01de800H
	DD	01ed800H
	DD	01fc800H
	DD	020b800H
	DD	021a800H
	DD	0229800H
	DD	0238800H
	DD	0247800H
	DD	0256800H
	DD	04dd400H
	DD	imagerel $LN1197+115
	DD	imagerel $LN1197+123
	DD	imagerel $chain$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 0186f21H
	DD	01cf86fH
	DD	01de866H
	DD	01ed85dH
	DD	01fc854H
	DD	020b84bH
	DD	021a842H
	DD	0229839H
	DD	0238830H
	DD	0247827H
	DD	025681fH
	DD	04dd410H
	DD	04ec408H
	DD	imagerel $LN1197+115
	DD	imagerel $LN1197+123
	DD	imagerel $chain$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 020821H
	DD	04f7408H
	DD	imagerel $LN1197
	DD	imagerel $LN1197+115
	DD	imagerel $unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z DD 072819H
	DD	0500117H
	DD	0e006f008H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NewLine@ImGui@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginMainMenuBar@ImGui@@YA_NXZ DD 081b01H
	DD	03681bH
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD 021H
	DD	imagerel $LN306
	DD	imagerel $LN306+147
	DD	imagerel $unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD 020521H
	DD	0126805H
	DD	imagerel $LN306
	DD	imagerel $LN306+147
	DD	imagerel $unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z DD 0134219H
	DD	0ea834H
	DD	0f982cH
	DD	0108827H
	DD	0117822H
	DD	031341dH
	DD	026011dH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?BeginMenuBar@ImGui@@YA_NXZ DD 021H
	DD	imagerel $LN86
	DD	imagerel $LN86+77
	DD	imagerel $unwind$?BeginMenuBar@ImGui@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?BeginMenuBar@ImGui@@YA_NXZ DD 021H
	DD	imagerel $LN86+77
	DD	imagerel $LN86+99
	DD	imagerel $chain$4$?BeginMenuBar@ImGui@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?BeginMenuBar@ImGui@@YA_NXZ DD 020521H
	DD	048805H
	DD	imagerel $LN86+77
	DD	imagerel $LN86+99
	DD	imagerel $chain$4$?BeginMenuBar@ImGui@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?BeginMenuBar@ImGui@@YA_NXZ DD 0a1621H
	DD	057816H
	DD	066811H
	DD	012740cH
	DD	0116408H
	DD	0105404H
	DD	imagerel $LN86
	DD	imagerel $LN86+77
	DD	imagerel $unwind$?BeginMenuBar@ImGui@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginMenuBar@ImGui@@YA_NXZ DD 021719H
	DD	03004d208H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Spacing@ImGui@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ DD 054a01H
	DD	0784aH
	DD	01683eH
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?TextEx@ImGui@@YAXPEBD0H@Z DD 021H
	DD	imagerel $LN285
	DD	imagerel $LN285+85
	DD	imagerel $unwind$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?TextEx@ImGui@@YAXPEBD0H@Z DD 021H
	DD	imagerel $LN285+85
	DD	imagerel $LN285+291
	DD	imagerel $chain$8$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?TextEx@ImGui@@YAXPEBD0H@Z DD 021H
	DD	imagerel $LN285+291
	DD	imagerel $LN285+639
	DD	imagerel $chain$12$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?TextEx@ImGui@@YAXPEBD0H@Z DD 041621H
	DD	0cb816H
	DD	0da809H
	DD	imagerel $LN285+291
	DD	imagerel $LN285+639
	DD	imagerel $chain$12$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?TextEx@ImGui@@YAXPEBD0H@Z DD 083821H
	DD	024f438H
	DD	025e430H
	DD	09e81fH
	DD	0bc809H
	DD	imagerel $LN285+85
	DD	imagerel $LN285+291
	DD	imagerel $chain$8$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?TextEx@ImGui@@YAXPEBD0H@Z DD 012a821H
	DD	0e98a8H
	DD	0107895H
	DD	026d48dH
	DD	08f837H
	DD	0ad82fH
	DD	0f881fH
	DD	0116817H
	DD	027740bH
	DD	02e3404H
	DD	imagerel $LN285
	DD	imagerel $LN285+85
	DD	imagerel $unwind$?TextEx@ImGui@@YAXPEBD0H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextEx@ImGui@@YAXPEBD0H@Z DD 052119H
	DD	0280112H
	DD	06005c007H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TextWrappedV@ImGui@@YAXPEBDPEAD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+103
	DD	imagerel $unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD 040d21H
	DD	08880dH
	DD	097805H
	DD	imagerel $LN64
	DD	imagerel $LN64+103
	DD	imagerel $unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z DD 0d3119H
	DD	01d7423H
	DD	01c6423H
	DD	01b3423H
	DD	0140123H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+254
	DD	imagerel $unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD 062221H
	DD	0a7822H
	DD	0b6814H
	DD	01fe408H
	DD	imagerel $LN45
	DD	imagerel $LN45+254
	DD	imagerel $unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z DD 0b2c19H
	DD	08981eH
	DD	098819H
	DD	0180114H
	DD	07007f009H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z DD 053501H
	DD	07835H
	DD	01682cH
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 021H
	DD	imagerel $LN157
	DD	imagerel $LN157+235
	DD	imagerel $unwind$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 040021H
	DD	0aa800H
	DD	0c8800H
	DD	imagerel $LN157+235
	DD	imagerel $LN157+255
	DD	imagerel $chain$1$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 040021H
	DD	0aa800H
	DD	0c8800H
	DD	imagerel $LN157+255
	DD	imagerel $LN157+263
	DD	imagerel $chain$2$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 0c4d21H
	DD	06e84dH
	DD	07d831H
	DD	09b82bH
	DD	0aa822H
	DD	0c8819H
	DD	0d7808H
	DD	imagerel $LN157+255
	DD	imagerel $LN157+263
	DD	imagerel $chain$2$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 020821H
	DD	01ec408H
	DD	imagerel $LN157+235
	DD	imagerel $LN157+255
	DD	imagerel $chain$1$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 041021H
	DD	01f7410H
	DD	0286408H
	DD	imagerel $LN157
	DD	imagerel $LN157+235
	DD	imagerel $unwind$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z DD 0d3619H
	DD	08c827H
	DD	0b981fH
	DD	0e681aH
	DD	0200116H
	DD	0e009f00bH
	DD	03005d007H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD 021H
	DD	imagerel $LN72
	DD	imagerel $LN72+265
	DD	imagerel $unwind$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD 0c0021H
	DD	0aa800H
	DD	0b9800H
	DD	0c8800H
	DD	0d7800H
	DD	0e6800H
	DD	026f400H
	DD	imagerel $LN72
	DD	imagerel $LN72+265
	DD	imagerel $unwind$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD 0e4b21H
	DD	0aa84bH
	DD	0b9842H
	DD	0c8839H
	DD	0d782eH
	DD	0e6822H
	DD	026f415H
	DD	025e408H
	DD	imagerel $LN72
	DD	imagerel $LN72+265
	DD	imagerel $unwind$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z DD 0d3819H
	DD	08c82aH
	DD	09b821H
	DD	0273418H
	DD	01e0118H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD 021H
	DD	imagerel $LN54
	DD	imagerel $LN54+61
	DD	imagerel $unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD 020521H
	DD	0e7405H
	DD	imagerel $LN54
	DD	imagerel $LN54+61
	DD	imagerel $unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z DD 081301H
	DD	0105413H
	DD	0f3413H
	DD	0f00f9213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?SeparatorEx@ImGui@@YAXHM@Z DD 0a1d21H
	DD	01a641dH
	DD	089800H
	DD	0a7800H
	DD	0b6800H
	DD	01be400H
	DD	imagerel $LN132
	DD	imagerel $LN132+90
	DD	imagerel $unwind$?SeparatorEx@ImGui@@YAXHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?SeparatorEx@ImGui@@YAXHM@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+90
	DD	imagerel $unwind$?SeparatorEx@ImGui@@YAXHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?SeparatorEx@ImGui@@YAXHM@Z DD 021H
	DD	imagerel $LN132+90
	DD	imagerel $LN132+131
	DD	imagerel $chain$3$?SeparatorEx@ImGui@@YAXHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?SeparatorEx@ImGui@@YAXHM@Z DD 042221H
	DD	06b822H
	DD	07a805H
	DD	imagerel $LN132+90
	DD	imagerel $LN132+131
	DD	imagerel $chain$3$?SeparatorEx@ImGui@@YAXHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?SeparatorEx@ImGui@@YAXHM@Z DD 081321H
	DD	089813H
	DD	0a780eH
	DD	0b6809H
	DD	01be404H
	DD	imagerel $LN132
	DD	imagerel $LN132+90
	DD	imagerel $unwind$?SeparatorEx@ImGui@@YAXHM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SeparatorEx@ImGui@@YAXHM@Z DD 092a19H
	DD	09881cH
	DD	01d7417H
	DD	01c3417H
	DD	0180117H
	DD	0500cH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+479
	DD	imagerel $unwind$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD 083121H
	DD	0ad831H
	DD	0e9824H
	DD	0107810H
	DD	02af408H
	DD	imagerel $LN88
	DD	imagerel $LN88+479
	DD	imagerel $unwind$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z DD 0155119H
	DD	08f842H
	DD	09e83aH
	DD	0bc832H
	DD	0cb82aH
	DD	0da822H
	DD	0f881dH
	DD	0116818H
	DD	0240114H
	DD	07007e009H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD 021H
	DD	imagerel $LN110
	DD	imagerel $LN110+79
	DD	imagerel $unwind$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD 020521H
	DD	083405H
	DD	imagerel $LN110
	DD	imagerel $LN110+79
	DD	imagerel $unwind$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z DD 061501H
	DD	026815H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD 021H
	DD	imagerel $LN120
	DD	imagerel $LN120+112
	DD	imagerel $unwind$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD 081221H
	DD	097812H
	DD	0a680dH
	DD	01ee408H
	DD	01c6404H
	DD	imagerel $LN120
	DD	imagerel $LN120+112
	DD	imagerel $unwind$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z DD 072319H
	DD	0160115H
	DD	0c008f00aH
	DD	030057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z DD 073919H
	DD	0ce439H
	DD	07005c209H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z DD 0a2301H
	DD	046823H
	DD	0f6414H
	DD	0e5414H
	DD	0d3414H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z DD 046301H
	DD	063463H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD 041421H
	DD	077414H
	DD	066405H
	DD	imagerel $LN33
	DD	imagerel $LN33+31
	DD	imagerel $unwind$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z DD 0a1801H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0f0147218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z DD 0b2919H
	DD	01c3417H
	DD	0140117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	098H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+66
	DD	imagerel $unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD 040a21H
	DD	0ef40aH
	DD	0de405H
	DD	imagerel $LN53
	DD	imagerel $LN53+66
	DD	imagerel $unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z DD 064201H
	DD	0c5442H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+81
	DD	imagerel $unwind$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD 020521H
	DD	0be405H
	DD	imagerel $LN53
	DD	imagerel $LN53+81
	DD	imagerel $unwind$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z DD 085101H
	DD	0a5451H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z DD 041801H
	DD	06818H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 021H
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+46
	DD	imagerel $unwind$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 020421H
	DD	03404H
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+46
	DD	imagerel $unwind$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 021H
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+35
	DD	imagerel $unwind$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 020021H
	DD	07400H
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+35
	DD	imagerel $unwind$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 040e21H
	DD	0740eH
	DD	023405H
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+35
	DD	imagerel $unwind$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 021H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+21
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 082521H
	DD	06f425H
	DD	05e41bH
	DD	045410H
	DD	033405H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+21
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 020301H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 0a0021H
	DD	0f400H
	DD	07e400H
	DD	06c400H
	DD	056400H
	DD	045400H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 021H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 0a2e21H
	DD	0f42eH
	DD	07e420H
	DD	06c415H
	DD	05640aH
	DD	045405H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 030701H
	DD	070030207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 021H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 0a2e21H
	DD	0f42eH
	DD	07e420H
	DD	06c415H
	DD	05640aH
	DD	045405H
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
	DD	imagerel ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z+27
	DD	imagerel $unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 030701H
	DD	070030207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z DD 062901H
	DD	077429H
	DD	063421H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z DD 0c9001H
	DD	0c7490H
	DD	0b348bH
	DD	0d5412H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	06006c008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z DD 0e2b01H
	DD	04882bH
	DD	057824H
	DD	06681eH
	DD	0127415H
	DD	0116415H
	DD	0103415H
	DD	0e011d215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD 061601H
	DD	046816H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z DD 061601H
	DD	046816H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD 021H
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+135
	DD	imagerel $unwind$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD 020521H
	DD	0ce405H
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
	DD	imagerel ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z+135
	DD	imagerel $unwind$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z DD 0a1801H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0f0147218H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z DD 0145419H
	DD	078854H
	DD	08784fH
	DD	096847H
	DD	014f43fH
	DD	015e434H
	DD	016642dH
	DD	01f5423H
	DD	0170110H
	DD	0c007d009H
	DD	030047005H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 021H
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel $unwind$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 021H
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+47
	DD	imagerel $chain$0$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020521H
	DD	076405H
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+47
	DD	imagerel $chain$0$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020521H
	DD	063405H
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z+29
	DD	imagerel $unwind$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 021H
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel $unwind$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 021H
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+51
	DD	imagerel $chain$0$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020521H
	DD	077405H
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+51
	DD	imagerel $chain$0$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020521H
	DD	066405H
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
	DD	imagerel ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z+30
	DD	imagerel $unwind$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD 021H
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+120
	DD	imagerel $unwind$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD 040c21H
	DD	08640cH
	DD	063405H
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
	DD	imagerel ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z+120
	DD	imagerel $unwind$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z DD 063801H
	DD	075438H
	DD	09740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD 021H
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+118
	DD	imagerel $unwind$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD 040d21H
	DD	09640dH
	DD	083405H
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
	DD	imagerel ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z+118
	DD	imagerel $unwind$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z DD 084101H
	DD	0ae441H
	DD	0b540eH
	DD	0f00a320eH
	DD	07006c008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 021H
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+41
	DD	imagerel $unwind$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 082021H
	DD	0b7420H
	DD	06f40fH
	DD	0ce40aH
	DD	0a6405H
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+41
	DD	imagerel $unwind$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 030701H
	DD	050036207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 021H
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+47
	DD	imagerel $unwind$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 061a21H
	DD	0ae41aH
	DD	09740aH
	DD	085405H
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
	DD	imagerel ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z+47
	DD	imagerel $unwind$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z DD 040901H
	DD	0f0053209H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z DD 031619H
	DD	07003e207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z DD 0a1901H
	DD	0103419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DB 08H
	DB	'Q', 04H
	DB	00H
	DB	'=w'
	DB	02H
	DB	'q', 02H
	DB	04H
	DB	'x'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@G@@QEAA@XZ
	DB	081H
	DB	02H
	DB	046H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
	DD	imagerel $ip2state$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z DD 01e7319H
	DD	023f862H
	DD	024e85aH
	DD	025d852H
	DD	026c84aH
	DD	027b842H
	DD	028a83aH
	DD	0299832H
	DD	02a882aH
	DD	02b7825H
	DD	02c6821H
	DD	05b011dH
	DD	0e00df00fH
	DD	0c009d00bH
	DD	060067007H
	DD	050043005H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
	DD	022aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorEditRestoreH@@YAXPEBMPEAM@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD 021H
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+59
	DD	imagerel $unwind$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD 020521H
	DD	036805H
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
	DD	imagerel ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z+59
	DD	imagerel $unwind$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorEditRestoreHS@@YAXPEBMPEAM11@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD 020021H
	DD	01f3400H
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel $unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD 080021H
	DD	07d800H
	DD	0aa800H
	DD	0b9800H
	DD	01f3400H
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+55
	DD	imagerel $chain$0$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD 0146e21H
	DD	01f346eH
	DD	06f843H
	DD	07d83dH
	DD	08c832H
	DD	09b821H
	DD	0aa819H
	DD	0b9814H
	DD	0c880fH
	DD	0d780aH
	DD	0e6805H
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+55
	DD	imagerel $chain$0$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD 020421H
	DD	01ee404H
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
	DD	imagerel ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z+43
	DD	imagerel $unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z DD 051c19H
	DD	020010dH
	DD	060057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 021H
	DD	imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 020021H
	DD	0185400H
	DD	imagerel $LN159+65
	DD	imagerel $LN159+81
	DD	imagerel $chain$1$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 020821H
	DD	0185408H
	DD	imagerel $LN159+81
	DD	imagerel $LN159+414
	DD	imagerel $chain$3$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 041821H
	DD	097818H
	DD	0a6808H
	DD	imagerel $LN159+65
	DD	imagerel $LN159+81
	DD	imagerel $chain$1$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 041021H
	DD	016f410H
	DD	017e408H
	DD	imagerel $LN159
	DD	imagerel $LN159+65
	DD	imagerel $unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z DD 061f19H
	DD	019010dH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	088H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN181
	DD	imagerel $LN181+116
	DD	imagerel $unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN181+116
	DD	imagerel $LN181+274
	DD	imagerel $chain$1$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN181+274
	DD	imagerel $LN181+779
	DD	imagerel $chain$3$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 020821H
	DD	021f408H
	DD	imagerel $LN181+274
	DD	imagerel $LN181+779
	DD	imagerel $chain$3$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 041021H
	DD	0a7810H
	DD	0b6808H
	DD	imagerel $LN181+116
	DD	imagerel $LN181+274
	DD	imagerel $chain$1$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 041321H
	DD	020e413H
	DD	01f3408H
	DD	imagerel $LN181
	DD	imagerel $LN181+116
	DD	imagerel $unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z DD 072219H
	DD	0180114H
	DD	0c006d008H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN130
	DD	imagerel $LN130+78
	DD	imagerel $unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN130+78
	DD	imagerel $LN130+127
	DD	imagerel $chain$0$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN130+127
	DD	imagerel $LN130+276
	DD	imagerel $chain$1$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 021H
	DD	imagerel $LN130+276
	DD	imagerel $LN130+347
	DD	imagerel $chain$3$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 061321H
	DD	058813H
	DD	06780dH
	DD	010d408H
	DD	imagerel $LN130+276
	DD	imagerel $LN130+347
	DD	imagerel $chain$3$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 041421H
	DD	076814H
	DD	0126408H
	DD	imagerel $LN130+127
	DD	imagerel $LN130+276
	DD	imagerel $chain$1$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 020821H
	DD	01a3408H
	DD	imagerel $LN130+78
	DD	imagerel $LN130+127
	DD	imagerel $chain$0$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 020821H
	DD	0117408H
	DD	imagerel $LN130
	DD	imagerel $LN130+78
	DD	imagerel $unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z DD 061e19H
	DD	013010fH
	DD	0e006f008H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z DD 0a3901H
	DD	08e439H
	DD	07742dH
	DD	063426H
	DD	09540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD 021H
	DD	imagerel $LN345
	DD	imagerel $LN345+100
	DD	imagerel $unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD 020921H
	DD	0148809H
	DD	imagerel $LN345+100
	DD	imagerel $LN345+628
	DD	imagerel $chain$12$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD 01a7921H
	DD	0df879H
	DD	0ee870H
	DD	0fd863H
	DD	010c857H
	DD	011b84eH
	DD	012a845H
	DD	013983cH
	DD	0157833H
	DD	016682bH
	DD	02ee423H
	DD	02fd41bH
	DD	0307413H
	DD	0376408H
	DD	imagerel $LN345
	DD	imagerel $LN345+100
	DD	imagerel $unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z DD 062419H
	DD	0310116H
	DD	0c005f007H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 021H
	DD	imagerel $LN419
	DD	imagerel $LN419+244
	DD	imagerel $unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 061921H
	DD	08f819H
	DD	0107810H
	DD	0116808H
	DD	imagerel $LN419+361
	DD	imagerel $LN419+623
	DD	imagerel $chain$12$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 0e7621H
	DD	0f8876H
	DD	09e800H
	DD	0ad800H
	DD	0bc800H
	DD	0cb800H
	DD	0da800H
	DD	0e9800H
	DD	imagerel $LN419
	DD	imagerel $LN419+244
	DD	imagerel $unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 021H
	DD	imagerel $LN419
	DD	imagerel $LN419+244
	DD	imagerel $unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 0c3621H
	DD	09e836H
	DD	0ad82dH
	DD	0bc824H
	DD	0cb81bH
	DD	0da812H
	DD	0e9809H
	DD	imagerel $LN419
	DD	imagerel $LN419+244
	DD	imagerel $unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z DD 0ec401H
	DD	02cd4c4H
	DD	024f467H
	DD	02de45cH
	DD	02b6451H
	DD	0250112H
	DD	07004c006H
	DD	050023003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD 021H
	DD	imagerel $LN158
	DD	imagerel $LN158+94
	DD	imagerel $unwind$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD 0129721H
	DD	07b897H
	DD	05d847H
	DD	06c838H
	DD	089832H
	DD	098829H
	DD	0a7820H
	DD	0b6818H
	DD	021f410H
	DD	020c408H
	DD	imagerel $LN158
	DD	imagerel $LN158+94
	DD	imagerel $unwind$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z DD 095b01H
	DD	01e345bH
	DD	0180113H
	DD	0d00ae00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel $unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 020021H
	DD	0c6800H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel $chain$1$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+751
	DD	imagerel $chain$3$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 062d21H
	DD	08a82dH
	DD	09981fH
	DD	0a8809H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+751
	DD	imagerel $chain$3$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 042a21H
	DD	0c682aH
	DD	023e404H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+63
	DD	imagerel $chain$1$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 040b21H
	DD	022c40bH
	DD	0217404H
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z+49
	DD	imagerel $unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z DD 092819H
	DD	0b781aH
	DD	01a0115H
	DD	0d008f00aH
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD 021H
	DD	imagerel $LN41+39
	DD	imagerel $LN41+164
	DD	imagerel $chain$2$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD 041721H
	DD	02e417H
	DD	095405H
	DD	imagerel $LN41+39
	DD	imagerel $LN41+164
	DD	imagerel $chain$2$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD 060f21H
	DD	03740fH
	DD	04640aH
	DD	083405H
	DD	imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z DD 030801H
	DD	0f0044208H
	DD	0c002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+183
	DD	imagerel $unwind$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD 083321H
	DD	029833H
	DD	038828H
	DD	047819H
	DD	056805H
	DD	imagerel $LN56
	DD	imagerel $LN56+183
	DD	imagerel $unwind$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z DD 060f01H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 01da801H
	DD	05e8a8H
	DD	06d88aH
	DD	07c87fH
	DD	08b879H
	DD	09a86bH
	DD	0a985dH
	DD	0b8839H
	DD	0c7832H
	DD	0d682bH
	DD	022641bH
	DD	021541bH
	DD	020341bH
	DD	01c011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+319
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel $chain$1$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+421
	DD	imagerel $chain$2$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 020821H
	DD	016e408H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+421
	DD	imagerel $chain$2$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 020821H
	DD	0155408H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+319
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+403
	DD	imagerel $chain$1$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 021H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+70
	DD	imagerel $unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 020421H
	DD	076804H
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
	DD	imagerel ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z+70
	DD	imagerel $unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z DD 0a3001H
	DD	058830H
	DD	067829H
	DD	0173412H
	DD	0f00bf212H
	DD	060087009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z DD 060f01H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN38
	DD	imagerel $LN38+26
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve_discard@?$ImVector@D@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z DD 020a01H
	DD	03006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 021H
	DD	imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 021H
	DD	imagerel $LN247+67
	DD	imagerel $LN247+293
	DD	imagerel $chain$0$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 021H
	DD	imagerel $LN247+293
	DD	imagerel $LN247+301
	DD	imagerel $chain$1$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 040b21H
	DD	03880bH
	DD	0ce405H
	DD	imagerel $LN247+293
	DD	imagerel $LN247+301
	DD	imagerel $chain$1$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 020821H
	DD	0167408H
	DD	imagerel $LN247+67
	DD	imagerel $LN247+293
	DD	imagerel $chain$0$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 020521H
	DD	047805H
	DD	imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z DD 0b3c01H
	DD	02983cH
	DD	056832H
	DD	0f00ac20eH
	DD	0c006d008H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 021H
	DD	imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 021H
	DD	imagerel $LN247+67
	DD	imagerel $LN247+294
	DD	imagerel $chain$0$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 021H
	DD	imagerel $LN247+294
	DD	imagerel $LN247+302
	DD	imagerel $chain$1$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 040b21H
	DD	03880bH
	DD	0ce405H
	DD	imagerel $LN247+294
	DD	imagerel $LN247+302
	DD	imagerel $chain$1$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 020821H
	DD	0167408H
	DD	imagerel $LN247+67
	DD	imagerel $LN247+294
	DD	imagerel $chain$0$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 020521H
	DD	047805H
	DD	imagerel $LN247
	DD	imagerel $LN247+67
	DD	imagerel $unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z DD 0b3c01H
	DD	02983cH
	DD	056832H
	DD	0f00ac20eH
	DD	0c006d008H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 021H
	DD	imagerel $LN239
	DD	imagerel $LN239+68
	DD	imagerel $unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 021H
	DD	imagerel $LN239+68
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 021H
	DD	imagerel $LN239+296
	DD	imagerel $LN239+304
	DD	imagerel $chain$1$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 040b21H
	DD	03880bH
	DD	0ce405H
	DD	imagerel $LN239+296
	DD	imagerel $LN239+304
	DD	imagerel $chain$1$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 020821H
	DD	0167408H
	DD	imagerel $LN239+68
	DD	imagerel $LN239+296
	DD	imagerel $chain$0$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 020521H
	DD	047805H
	DD	imagerel $LN239
	DD	imagerel $LN239+68
	DD	imagerel $unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z DD 0b3d01H
	DD	02983dH
	DD	056833H
	DD	0f00ac20eH
	DD	0c006d008H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 021H
	DD	imagerel $LN242
	DD	imagerel $LN242+68
	DD	imagerel $unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 021H
	DD	imagerel $LN242+68
	DD	imagerel $LN242+321
	DD	imagerel $chain$0$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 021H
	DD	imagerel $LN242+321
	DD	imagerel $LN242+329
	DD	imagerel $chain$1$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 040b21H
	DD	03880bH
	DD	0ce405H
	DD	imagerel $LN242+321
	DD	imagerel $LN242+329
	DD	imagerel $chain$1$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 020821H
	DD	0167408H
	DD	imagerel $LN242+68
	DD	imagerel $LN242+321
	DD	imagerel $chain$0$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 020521H
	DD	047805H
	DD	imagerel $LN242
	DD	imagerel $LN242+68
	DD	imagerel $unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z DD 0b3d01H
	DD	02983dH
	DD	056833H
	DD	0f00ac20eH
	DD	0c006d008H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 021H
	DD	imagerel $LN259
	DD	imagerel $LN259+80
	DD	imagerel $unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 021H
	DD	imagerel $LN259+80
	DD	imagerel $LN259+316
	DD	imagerel $chain$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 020021H
	DD	0107400H
	DD	imagerel $LN259+80
	DD	imagerel $LN259+316
	DD	imagerel $chain$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 061621H
	DD	049816H
	DD	0107410H
	DD	0116408H
	DD	imagerel $LN259+80
	DD	imagerel $LN259+316
	DD	imagerel $chain$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 020621H
	DD	058806H
	DD	imagerel $LN259
	DD	imagerel $LN259+80
	DD	imagerel $unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z DD 0f4801H
	DD	02c848H
	DD	03b838H
	DD	06782fH
	DD	07682aH
	DD	0120110H
	DD	0e007f009H
	DD	05003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 021H
	DD	imagerel $LN251
	DD	imagerel $LN251+83
	DD	imagerel $unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 021H
	DD	imagerel $LN251+83
	DD	imagerel $LN251+328
	DD	imagerel $chain$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 020021H
	DD	0107400H
	DD	imagerel $LN251+83
	DD	imagerel $LN251+328
	DD	imagerel $chain$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 061521H
	DD	067815H
	DD	0107410H
	DD	0116408H
	DD	imagerel $LN251+83
	DD	imagerel $LN251+328
	DD	imagerel $chain$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 020621H
	DD	049806H
	DD	imagerel $LN251
	DD	imagerel $LN251+83
	DD	imagerel $unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z DD 0f4f01H
	DD	02c84fH
	DD	03b83aH
	DD	058830H
	DD	07682aH
	DD	0120110H
	DD	0e007f009H
	DD	05003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$ImAtoi@H@@YAPEBDPEBDPEAH@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z DD 031b19H
	DD	0120109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z DD 031b19H
	DD	0120109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z DD 031b19H
	DD	0120109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z DD 031b19H
	DD	0120109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z DD 021919H
	DD	0130107H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z DD 021919H
	DD	0130107H
	DD	imagerel __GSHandlerCheck
	DD	080H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Dummy@ImGui@@YAXAEBUImVec2@@@Z
_TEXT	SEGMENT
bb$ = 32
__$ArrayPad$ = 48
size$ = 144
?Dummy@ImGui@@YAXAEBUImVec2@@@Z PROC			; ImGui::Dummy, COMDAT

; 1350 : {

$LN48:
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rdx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1352 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	$LN26@Dummy

; 1356 :     ItemSize(size);

	movss	xmm1, DWORD PTR __real@bf800000
	movaps	XMMWORD PTR [rsp+112], xmm6
	movaps	XMMWORD PTR [rsp+96], xmm7
	movaps	XMMWORD PTR [rsp+80], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm8, DWORD PTR [rax+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1352 :     if (window->SkipItems)

	movaps	XMMWORD PTR [rsp+64], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm7, xmm8
	movss	xmm9, DWORD PTR [rax+316]
	addss	xmm7, DWORD PTR [rcx]
	movaps	xmm6, xmm9
	addss	xmm6, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1356 :     ItemSize(size);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10132:     ImGuiWindow* window = g.CurrentWindow;
; 10133: 
; 10134:     // Set item data
; 10135:     // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
; 10136:     g.LastItemData.ID = id;

	xor	ecx, ecx

; 10137:     g.LastItemData.Rect = bb;

	movaps	xmm0, xmm8
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm9

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	shufps	xmm0, xmm0, 198				; 000000c6H
	movss	xmm0, xmm7
	mov	DWORD PTR [r10+18620], eax

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	shufps	xmm0, xmm0, 39				; 00000027H
	movss	xmm0, xmm6
	mov	DWORD PTR [r10+18616], ecx
	shufps	xmm0, xmm0, 57				; 00000039H
	movups	XMMWORD PTR [r10+18628], xmm0
	mov	DWORD PTR [r10+18624], ecx
	movups	XMMWORD PTR [r10+18644], xmm0
	mov	QWORD PTR [r10+18592], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm6, DWORD PTR [rax+628]
	movaps	xmm6, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10137:     g.LastItemData.Rect = bb;

	movups	XMMWORD PTR bb$[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN34@Dummy
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm9
	jbe	SHORT $LN34@Dummy
	comiss	xmm7, DWORD PTR [rax+624]
	jbe	SHORT $LN34@Dummy
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm8
	jbe	SHORT $LN34@Dummy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN25@Dummy
$LN34@Dummy:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], cl
	je	SHORT $LN46@Dummy
$LN25@Dummy:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN46@Dummy

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN46@Dummy:
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm9, XMMWORD PTR [rsp+64]
$LN26@Dummy:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1358 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	ret	0
?Dummy@ImGui@@YAXAEBUImVec2@@@Z ENDP			; ImGui::Dummy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z
_TEXT	SEGMENT
$T3 = 48
$T4 = 48
c$5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
tab_bar$ = 128
tab_bar_bb$ = 136
flags$ = 144
dock_node$ = 152
?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z PROC ; ImGui::BeginTabBarEx, COMDAT

; 7596 : {

$LN90:
	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+16], rdx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 80					; 00000050H

; 7597 :     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r13, r9
	mov	r12d, r8d
	mov	r15, rdx
	mov	rbx, rcx
	mov	rdi, r10

; 7598 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rsi, QWORD PTR [r10+16408]

; 7599 :     if (window->SkipItems)

	cmp	BYTE PTR [rsi+240], 0
	je	SHORT $LN2@BeginTabBa

; 7600 :         return false;

	xor	al, al
	jmp	$LN1@BeginTabBa
$LN2@BeginTabBa:
	mov	QWORD PTR [rsp+128], rbp
	mov	QWORD PTR [rsp+144], r14

; 7601 : 
; 7602 :     if ((flags & ImGuiTabBarFlags_DockNode) == 0)

	mov	r14d, r12d
	and	r14d, 1048576				; 00100000H
	jne	SHORT $LN3@BeginTabBa

; 7603 :         PushOverrideID(tab_bar->ID);

	mov	ecx, DWORD PTR [rcx+20]
	call	?PushOverrideID@ImGui@@YAXI@Z		; ImGui::PushOverrideID
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN3@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 674  :     bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }

	mov	rdx, QWORD PTR [r10+19848]
	xor	r9d, r9d
	mov	r8d, -1
	cmp	rbx, rdx
	jb	SHORT $LN13@BeginTabBa
	movsxd	rax, DWORD PTR [r10+19840]
	imul	rcx, rax, 152				; 00000098H
	add	rcx, rdx
	cmp	rbx, rcx
	jae	SHORT $LN13@BeginTabBa

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	mov	rcx, rbx

; 1271 :     ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }

	mov	QWORD PTR $T8[rsp], r9

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sub	rcx, rdx
	mov	rax, 485440633518672411			; 06bca1af286bca1bH
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1271 :     ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }

	mov	DWORD PTR $T8[rsp+8], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7577 :         return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));

	jmp	SHORT $LN12@BeginTabBa
$LN13@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1270 :     ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }

	mov	QWORD PTR $T8[rsp], rbx
	mov	DWORD PTR $T8[rsp+8], r8d
$LN12@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ebp, DWORD PTR [rdi+19880]
	mov	ecx, DWORD PTR [rdi+19884]
	cmp	ebp, ecx
	jne	$LN32@BeginTabBa
	inc	ebp

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN30@BeginTabBa
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN31@BeginTabBa
$LN30@BeginTabBa:
	mov	eax, 8
$LN31@BeginTabBa:
	cmp	eax, ebp
	cmovg	ebp, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	ebp, ecx
	jle	SHORT $LN32@BeginTabBa
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	r10, r10
	je	SHORT $LN37@BeginTabBa

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [r10+244]
$LN37@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, ebp
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rdi+19888]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	r15, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN47@BeginTabBa
	movsxd	r8, DWORD PTR [rdi+19880]
	mov	rcx, rax
	shl	r8, 4
	call	memcpy
	mov	rcx, QWORD PTR [rdi+19888]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN45@BeginTabBa

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN45@BeginTabBa

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN45@BeginTabBa:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN47@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rdi+19888], r15
	mov	r15, QWORD PTR tab_bar_bb$[rsp]
	mov	DWORD PTR [rdi+19884], ebp
$LN32@BeginTabBa:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rcx, DWORD PTR [rdi+19880]
	mov	rax, QWORD PTR [rdi+19888]
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR $T8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7611 :     if (tab_bar->CurrFrameVisible == g.FrameCount)

	mov	rbp, QWORD PTR [rsp+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movups	XMMWORD PTR [rax+rcx*8], xmm0
	inc	DWORD PTR [rdi+19880]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7607 :     g.CurrentTabBar = tab_bar;

	mov	QWORD PTR [rdi+19832], rbx

; 7608 : 
; 7609 :     // Append with multiple BeginTabBar()/EndTabBar() pairs.
; 7610 :     tab_bar->BackupCursorPos = window->DC.CursorPos;

	movsd	xmm0, QWORD PTR [rsi+312]

; 7611 :     if (tab_bar->CurrFrameVisible == g.FrameCount)

	mov	ecx, DWORD PTR [rbx+36]
	movsd	QWORD PTR [rbx+128], xmm0
	cmp	ecx, DWORD PTR [rdi+16240]
	jne	SHORT $LN4@BeginTabBa

; 7613 :         window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);

	movss	xmm1, DWORD PTR [rbx+116]
	addss	xmm1, DWORD PTR [rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7613 :         window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);

	movss	DWORD PTR [rsi+312], xmm0
	movss	DWORD PTR [rsi+316], xmm1

; 7614 :         tab_bar->BeginCount++;

	inc	BYTE PTR [rbx+106]

; 7615 :         return true;

	jmp	$LN10@BeginTabBa
$LN4@BeginTabBa:

; 7616 :     }
; 7617 : 
; 7618 :     // Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable
; 7619 :     if ((flags & ImGuiTabBarFlags_Reorderable) != (tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (tab_bar->TabsAddedNew && !(flags & ImGuiTabBarFlags_Reorderable)))

	mov	eax, DWORD PTR [rbx+16]
	mov	r8d, r12d
	and	r8d, 1
	and	eax, 1
	cmp	r8d, eax
	jne	SHORT $LN68@BeginTabBa
	cmp	BYTE PTR [rbx+109], 0
	mov	edx, ecx
	je	SHORT $LN54@BeginTabBa
	test	r8d, r8d
	jne	SHORT $LN54@BeginTabBa
$LN68@BeginTabBa:

; 7620 :         if ((flags & ImGuiTabBarFlags_DockNode) == 0) // FIXME: TabBar with DockNode can now be hybrid

	mov	edx, ecx
	test	r14d, r14d
	jne	SHORT $LN54@BeginTabBa

; 7621 :             ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByBeginOrder);

	movsxd	rax, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	rax, 1
	jbe	SHORT $LN54@BeginTabBa
	mov	rcx, QWORD PTR [rbx+8]
	lea	r9, OFFSET FLAT:?TabItemComparerByBeginOrder@@YAHPEBX0@Z ; TabItemComparerByBeginOrder
	lea	r8d, QWORD PTR [r14+56]
	mov	rdx, rax
	call	QWORD PTR __imp_qsort
	mov	edx, DWORD PTR [rbx+36]
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN54@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7622 :     tab_bar->TabsAddedNew = false;

	mov	BYTE PTR [rbx+109], 0

; 7623 : 
; 7624 :     // Flags
; 7625 :     if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
; 7626 :         flags |= ImGuiTabBarFlags_FittingPolicyDefault_;
; 7627 : 
; 7628 :     tab_bar->Flags = flags;

	mov	ecx, r12d
	or	ecx, 64					; 00000040H
	test	r12b, 192				; 000000c0H
	cmovne	ecx, r12d
	mov	DWORD PTR [rbx+16], ecx

; 7629 :     tab_bar->BarRect = tab_bar_bb;

	movups	xmm0, XMMWORD PTR [r15]

; 7630 :     tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()
; 7631 :     tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;

	mov	DWORD PTR [rbx+40], edx
	mov	BYTE PTR [rbx+107], 1
	movups	XMMWORD PTR [rbx+44], xmm0

; 7632 :     tab_bar->CurrFrameVisible = g.FrameCount;

	mov	eax, DWORD PTR [rdi+16240]
	mov	DWORD PTR [rbx+36], eax

; 7633 :     tab_bar->PrevTabsContentsHeight = tab_bar->CurrTabsContentsHeight;

	mov	eax, DWORD PTR [rbx+60]
	mov	DWORD PTR [rbx+64], eax

; 7634 :     tab_bar->CurrTabsContentsHeight = 0.0f;

	xor	eax, eax
	mov	DWORD PTR [rbx+60], eax

; 7643 : 
; 7644 :     // Draw separator
; 7645 :     const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive);

	mov	eax, ecx
	movss	xmm1, DWORD PTR [rdi+14632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7635 :     tab_bar->ItemSpacingY = g.Style.ItemSpacing.y;

	movss	DWORD PTR [rbx+116], xmm1

; 7643 : 
; 7644 :     // Draw separator
; 7645 :     const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive);

	not	eax
	movsd	xmm0, QWORD PTR [rdi+14612]
	and	eax, 2097152				; 00200000H
	addss	xmm1, DWORD PTR [rbx+56]
	movsd	QWORD PTR [rbx+120], xmm0
	or	rax, 51380224				; 03100000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7637 :     tab_bar->TabsActiveCount = 0;

	mov	DWORD PTR [rbx+110], -65536		; ffff0000H

; 7638 :     tab_bar->LastTabItemIdx = -1;
; 7639 :     tab_bar->BeginCount = 1;

	mov	BYTE PTR [rbx+106], 1

; 7640 : 
; 7641 :     // Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap
; 7642 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.y + tab_bar->ItemSpacingY);

	movss	DWORD PTR [rsi+312], xmm0
	movss	DWORD PTR [rsi+316], xmm1

; 7643 : 
; 7644 :     // Draw separator
; 7645 :     const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive);

	shr	rax, 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+r10+14552]
	movups	XMMWORD PTR c$5[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r10+14552]
	movss	DWORD PTR c$5[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7646 :     const float y = tab_bar->BarRect.Max.y - 1.0f;

	movss	xmm4, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7646 :     const float y = tab_bar->BarRect.Max.y - 1.0f;

	movss	xmm3, DWORD PTR [rbx+56]

; 7647 :     if (dock_node != NULL)

	mov	rcx, QWORD PTR [rsi+728]
	subss	xmm3, xmm4
	movss	DWORD PTR [rsp+32], xmm4
	movss	DWORD PTR $T4[rsp+4], xmm3
	movss	DWORD PTR $T7[rsp+4], xmm3
	test	r13, r13
	je	SHORT $LN9@BeginTabBa

; 7648 :     {
; 7649 :         const float separator_min_x = dock_node->Pos.x + window->WindowBorderSize;
; 7650 :         const float separator_max_x = dock_node->Pos.x + dock_node->Size.x - window->WindowBorderSize;

	movss	xmm1, DWORD PTR [r13+72]

; 7651 :         window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);

	lea	r8, QWORD PTR $T4[rsp]
	movss	xmm2, DWORD PTR [rsi+140]
	lea	rdx, QWORD PTR $T7[rsp]
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [r13+80]
	subss	xmm0, xmm2
	addss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm0
	movss	DWORD PTR $T7[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7652 :     }

	jmp	SHORT $LN88@BeginTabBa
$LN9@BeginTabBa:

; 7653 :     else
; 7654 :     {
; 7655 :         const float separator_min_x = tab_bar->BarRect.Min.x - IM_FLOOR(window->WindowPadding.x * 0.5f);
; 7656 :         const float separator_max_x = tab_bar->BarRect.Max.x + IM_FLOOR(window->WindowPadding.x * 0.5f);

	movss	xmm0, DWORD PTR [rsi+128]

; 7657 :         window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);

	lea	r8, QWORD PTR $T6[rsp]
	mulss	xmm0, DWORD PTR __real@3f000000
	lea	rdx, QWORD PTR $T3[rsp]
	movss	xmm1, DWORD PTR [rbx+44]
	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	movaps	xmm0, xmm2
	subss	xmm1, xmm2
	addss	xmm0, DWORD PTR [rbx+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm1
	movss	DWORD PTR $T6[rsp], xmm0
$LN88@BeginTabBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7659 :     return true;

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN10@BeginTabBa:
	mov	r14, QWORD PTR [rsp+144]
	mov	al, 1
$LN1@BeginTabBa:

; 7660 : }

	mov	rbx, QWORD PTR [rsp+152]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z ENDP ; ImGui::BeginTabBarEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Text@ImGui@@YAXPEBDZZ
_TEXT	SEGMENT
fmt$ = 48
?Text@ImGui@@YAXPEBDZZ PROC				; ImGui::Text, COMDAT

; 260  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 261  :     va_list args;
; 262  :     va_start(args, fmt);

	lea	rdx, QWORD PTR fmt$[rsp+8]

; 263  :     TextV(fmt, args);

	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 264  :     va_end(args);
; 265  : }

	add	rsp, 40					; 00000028H
	ret	0
?Text@ImGui@@YAXPEBDZZ ENDP				; ImGui::Text
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z PROC ; ImGui::TabBarCloseTab, COMDAT

; 8062 :     if (tab->Flags & ImGuiTabItemFlags_Button)

	mov	eax, DWORD PTR [rdx+4]
	bt	eax, 21
	jb	SHORT $LN6@TabBarClos

; 8063 :         return; // A button appended with TabItemButton().
; 8064 : 
; 8065 :     if (!(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

	test	al, 1
	mov	eax, DWORD PTR [rdx]
	jne	SHORT $LN3@TabBarClos

; 8066 :     {
; 8067 :         // This will remove a frame of lag for selecting another tab on closure.
; 8068 :         // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
; 8069 :         tab->WantClose = true;

	mov	BYTE PTR [rdx+48], 1

; 8070 :         if (tab_bar->VisibleTabId == tab->ID)

	cmp	DWORD PTR [rcx+32], eax
	jne	SHORT $LN6@TabBarClos

; 8071 :         {
; 8072 :             tab->LastFrameVisible = -1;
; 8073 :             tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;

	xor	eax, eax
	mov	DWORD PTR [rdx+16], -1
	mov	QWORD PTR [rcx+24], rax

; 8081 :     }
; 8082 : }

	ret	0
$LN3@TabBarClos:

; 8074 :         }
; 8075 :     }
; 8076 :     else
; 8077 :     {
; 8078 :         // Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
; 8079 :         if (tab_bar->VisibleTabId != tab->ID)

	cmp	DWORD PTR [rcx+32], eax
	je	SHORT $LN6@TabBarClos

; 8080 :             TabBarQueueFocus(tab_bar, tab);

	mov	DWORD PTR [rcx+28], eax
$LN6@TabBarClos:

; 8081 :     }
; 8082 : }

	ret	0
?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarCloseTab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Separator@ImGui@@YAXXZ
_TEXT	SEGMENT
?Separator@ImGui@@YAXXZ PROC				; ImGui::Separator, COMDAT

; 1464 :     ImGuiContext& g = *GImGui;
; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN1@Separator

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]

; 1473 :     SeparatorEx(flags, 1.0f);

	movss	xmm1, DWORD PTR __real@3f800000
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6
	jmp	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN1@Separator:

; 1474 : }

	ret	0
?Separator@ImGui@@YAXXZ ENDP				; ImGui::Separator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@H@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
offset$ = 24
?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@H@Z PROC ; ImGui::TabBarQueueReorder, COMDAT

; 8131 :     IM_ASSERT(offset != 0);
; 8132 :     IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
; 8133 :     tab_bar->ReorderRequestTabId = tab->ID;

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+100], eax

; 8134 :     tab_bar->ReorderRequestOffset = (ImS16)offset;

	mov	WORD PTR [rcx+104], r8w

; 8135 : }

	ret	0
?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@H@Z ENDP ; ImGui::TabBarQueueReorder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z
_TEXT	SEGMENT
scroll$ = 64
bb$ = 72
__$ArrayPad$ = 88
axis$ = 128
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z PROC		; ImGui::Scrollbar, COMDAT

; 886  : {

$LN58:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	movaps	XMMWORD PTR [rsp+96], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 887  :     ImGuiContext& g = *GImGui;
; 888  :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movsxd	rsi, ecx

; 889  :     const ImGuiID id = GetWindowScrollbarID(window, axis);

	mov	edx, esi
	mov	rbx, QWORD PTR [rax+16408]
	mov	rcx, rbx
	call	?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ; ImGui::GetWindowScrollbarID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 877  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)

	mov	rcx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm4, DWORD PTR [rbx+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 877  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)

	xor	rcx, 1
	movss	xmm5, DWORD PTR [rbx+140]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	movaps	xmm3, xmm6
	movaps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 889  :     const ImGuiID id = GetWindowScrollbarID(window, axis);

	mov	r10d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	addss	xmm3, DWORD PTR [rbx+88]
	addss	xmm1, DWORD PTR [rbx+92]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 875  :     const ImRect inner_rect = window->InnerRect;

	movups	xmm2, XMMWORD PTR [rbx+560]

; 878  :     IM_ASSERT(scrollbar_size > 0.0f);
; 879  :     if (axis == ImGuiAxis_X)

	test	esi, esi
	jne	SHORT $LN9@Scrollbar

; 899  :     }

	cmp	BYTE PTR [rbx+233], sil

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	subss	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 899  :     }

	mov	edx, 448				; 000001c0H

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	shufps	xmm2, xmm2, 170				; 000000aaH

; 899  :     }

	mov	eax, 320				; 00000140H

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	subss	xmm2, xmm5

; 899  :     }

	cmovne	edx, eax

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	movaps	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	subss	xmm0, DWORD PTR [rbx+rcx*4+224]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	maxss	xmm4, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+4], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 899  :     }

	jmp	SHORT $LN6@Scrollbar
$LN9@Scrollbar:
	mov	eax, DWORD PTR [rbx+20]

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	subss	xmm3, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm2
	and	eax, 1025				; 00000401H
	shufps	xmm1, xmm2, 85				; 00000055H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 904  :         if (!window->ScrollbarX)

	cmp	eax, 1

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	shufps	xmm2, xmm2, 255				; 000000ffH

; 904  :         if (!window->ScrollbarX)

	mov	edx, 288				; 00000120H

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	subss	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+8], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	subss	xmm0, DWORD PTR [rbx+rcx*4+224]

; 904  :         if (!window->ScrollbarX)

	mov	ecx, 256				; 00000100H
	cmovne	edx, ecx
	cmp	BYTE PTR [rbx+232], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp+12], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	maxss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 904  :         if (!window->ScrollbarX)

	jne	SHORT $LN6@Scrollbar

; 905  :             rounding_corners |= ImDrawFlags_RoundCornersBottomRight;

	bts	edx, 7
$LN6@Scrollbar:

; 906  :     }
; 907  :     float size_avail = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
; 908  :     float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;

	movss	xmm0, DWORD PTR [rbx+rsi*4+128]

; 909  :     ImS64 scroll = (ImS64)window->Scroll[axis];
; 910  :     ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_avail, (ImS64)size_contents, rounding_corners);

	lea	r9, QWORD PTR scroll$[rsp]
	cvttss2si rax, DWORD PTR [rbx+rsi*4+184]
	mov	DWORD PTR [rsp+48], edx
	mov	r8d, esi
	mov	edx, r10d
	addss	xmm0, xmm0
	mov	QWORD PTR scroll$[rsp], rax
	addss	xmm0, DWORD PTR [rbx+rsi*4+104]
	cvttss2si rcx, xmm0
	movss	xmm0, DWORD PTR [rbx+rsi*4+568]
	subss	xmm0, DWORD PTR [rbx+rsi*4+560]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR bb$[rsp]
	cvttss2si rax, xmm0
	mov	QWORD PTR [rsp+32], rax
	call	?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z ; ImGui::ScrollbarEx
	xorps	xmm0, xmm0

; 911  :     window->Scroll[axis] = (float)scroll;

	cvtsi2ss xmm0, QWORD PTR scroll$[rsp]
	movss	DWORD PTR [rbx+rsi*4+184], xmm0

; 912  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [rsp+96]
	mov	rsp, r11
	pop	rdi
	ret	0
?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z ENDP		; ImGui::Scrollbar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarQueueFocus@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
?TabBarQueueFocus@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z PROC ; ImGui::TabBarQueueFocus, COMDAT

; 8126 :     tab_bar->NextSelectedTabId = tab->ID;

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+28], eax

; 8127 : }

	ret	0
?TabBarQueueFocus@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarQueueFocus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
tab_bar$ = 48
tab_id$ = 56
?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z PROC	; ImGui::TabBarRemoveTab, COMDAT

; 8051 : {

$LN33:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx

; 7982 :     if (tab_id != 0)

	test	edx, edx
	je	SHORT $LN2@TabBarRemo

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	movsxd	r8, DWORD PTR [rcx]
	xor	eax, eax
	test	r8d, r8d
	jle	SHORT $LN2@TabBarRemo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r9, QWORD PTR [rcx+8]
	mov	rdx, r9
$LL10@TabBarRemo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rdx], edi
	je	SHORT $LN21@TabBarRemo

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	rdx, 56					; 00000038H
	cmp	eax, r8d
	jl	SHORT $LL10@TabBarRemo

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	jmp	SHORT $LN2@TabBarRemo
$LN21@TabBarRemo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	imul	rdx, rcx, 56				; 00000038H
	lea	rax, QWORD PTR [rdx+r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8052 :     if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))

	test	rax, rax
	je	SHORT $LN2@TabBarRemo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1941 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rdx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	mov	rax, r8
	imul	rcx, rdx, 56				; 00000038H
	sub	rax, rdx
	imul	r8, rax, 56				; 00000038H
	add	rcx, r9
	sub	r8, 56					; 00000038H
	lea	rdx, QWORD PTR [rcx+56]
	call	memmove
	dec	DWORD PTR [rbx]
$LN2@TabBarRemo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8054 :     if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }

	cmp	DWORD PTR [rbx+32], edi
	jne	SHORT $LN3@TabBarRemo
	mov	DWORD PTR [rbx+32], 0
$LN3@TabBarRemo:

; 8055 :     if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }

	cmp	DWORD PTR [rbx+24], edi
	jne	SHORT $LN4@TabBarRemo
	mov	DWORD PTR [rbx+24], 0
$LN4@TabBarRemo:

; 8056 :     if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }

	cmp	DWORD PTR [rbx+28], edi
	jne	SHORT $LN5@TabBarRemo
	mov	DWORD PTR [rbx+28], 0
$LN5@TabBarRemo:

; 8057 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z ENDP	; ImGui::TabBarRemoveTab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndListBox@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndListBox@ImGui@@YAXXZ PROC				; ImGui::EndListBox, COMDAT

; 6683 : {

$LN6:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5786 :     EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6691 : }

	add	rsp, 40					; 00000028H

; 6684 :     ImGuiContext& g = *GImGui;
; 6685 :     ImGuiWindow* window = g.CurrentWindow;
; 6686 :     IM_ASSERT((window->Flags & ImGuiWindowFlags_ChildWindow) && "Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?");
; 6687 :     IM_UNUSED(window);
; 6688 : 
; 6689 :     EndChildFrame();
; 6690 :     EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label

	jmp	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
?EndListBox@ImGui@@YAXXZ ENDP				; ImGui::EndListBox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z
_TEXT	SEGMENT
hovered$ = 48
held$ = 49
c$4 = 56
c$5 = 56
$T6 = 56
bb$ = 72
__$ArrayPad$ = 88
id$ = 192
pos$ = 200
dock_node$ = 208
?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z PROC ; ImGui::CollapseButton, COMDAT

; 838  : {

$LN85:
	mov	r11, rsp
	push	rbx
	push	rbp
	push	r14
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR [r11+16], rsi
	mov	r14, r8

; 839  :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ebx, ecx
	mov	QWORD PTR [r11-32], r12

; 843  :     ItemAdd(bb, id);

	xor	r9d, r9d
	mov	QWORD PTR [r11-40], r15
	xor	r8d, r8d
	movaps	XMMWORD PTR [r11-56], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm2, DWORD PTR [rsi+15696]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	xmm3, DWORD PTR [rsi+14612]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [rdx]
	addss	xmm2, DWORD PTR [rdx+4]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	xmm1, DWORD PTR [rsi+14616]
	addss	xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 840  :     ImGuiWindow* window = g.CurrentWindow;

	mov	rbp, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	addss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 838  : {

	movaps	XMMWORD PTR [rsp+112], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	xmm0, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	QWORD PTR bb$[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 843  :     ItemAdd(bb, id);

	mov	edx, ecx
	lea	rcx, QWORD PTR [r11-112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+8], xmm3
	movss	DWORD PTR bb$[rsp+12], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 843  :     ItemAdd(bb, id);

	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 844  :     bool hovered, held;
; 845  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

	lea	r9, QWORD PTR held$[rsp]
	mov	DWORD PTR [rsp+32], 0
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, ebx
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 846  : 
; 847  :     // Render
; 848  :     //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
; 849  :     ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	r10d, BYTE PTR held$[rsp]
	movzx	ebx, al
	movzx	r9d, BYTE PTR hovered$[rsp]
	test	r10b, r10b
	je	SHORT $LN8@CollapseBu
	test	r9b, r9b
	je	SHORT $LN8@CollapseBu
	mov	eax, 23
	jmp	SHORT $LN9@CollapseBu
$LN8@CollapseBu:
	xor	eax, eax
	test	r9b, r9b
	setne	al
	add	rax, 21
$LN9@CollapseBu:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$5[rsp]
	add	rax, 14
	add	rax, rax
	movss	xmm6, DWORD PTR [r8+14552]
	movups	xmm0, XMMWORD PTR [r8+rax*8+14552]
	movups	XMMWORD PTR c$5[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$5[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r8+14776]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rsp]
	mov	r15d, eax

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$4[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$4[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 851  :     if (hovered || held)

	movss	xmm7, DWORD PTR bb$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r12d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 851  :     if (hovered || held)

	movss	xmm6, DWORD PTR bb$[rsp]
	movss	xmm8, DWORD PTR __real@3f800000
	test	r9b, r9b
	jne	SHORT $LN3@CollapseBu
	test	r10b, r10b
	je	$LN45@CollapseBu
$LN3@CollapseBu:

; 852  :         window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col);

	movss	xmm3, DWORD PTR __real@3f000000
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	movss	xmm1, DWORD PTR bb$[rsp+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 852  :         window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col);

	movss	xmm2, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	addss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 852  :         window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col);

	mulss	xmm2, xmm3
	mov	QWORD PTR [rsp+208], rdi
	mov	rdi, QWORD PTR [rbp+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	mulss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 852  :         window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col);

	addss	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	movss	xmm1, DWORD PTR bb$[rsp+12]
	addss	xmm1, xmm7
	mulss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	subss	xmm1, xmm3

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	r15d, -16777216				; ff000000H
	je	SHORT $LN83@CollapseBu
	comiss	xmm3, xmm2
	ja	SHORT $LN83@CollapseBu

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, rdi
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	r8d, DWORD PTR [rdi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r15d
	mov	rdx, QWORD PTR [rdi+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	mov	DWORD PTR [rdi+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rdi+120], 0
$LN83@CollapseBu:
	mov	rdi, QWORD PTR [rsp+208]
$LN45@CollapseBu:
	mov	r15, QWORD PTR [rsp+144]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 854  :     if (dock_node)

	mov	rcx, QWORD PTR [rbp+728]
	addss	xmm6, DWORD PTR [rsi+14612]
	addss	xmm7, DWORD PTR [rsi+14616]
	movaps	xmm0, xmm6
	unpcklps xmm0, xmm7
	movq	rdx, xmm0
	test	r14, r14
	je	SHORT $LN4@CollapseBu

; 855  :         RenderArrowDockMenu(window->DrawList, bb.Min + g.Style.FramePadding, g.FontSize, text_col);

	movss	xmm2, DWORD PTR [rsi+15696]
	mov	r9d, r12d
	call	?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z ; ImGui::RenderArrowDockMenu
	jmp	SHORT $LN5@CollapseBu
$LN4@CollapseBu:

; 856  :     else
; 857  :         RenderArrow(window->DrawList, bb.Min + g.Style.FramePadding, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

	cmp	BYTE PTR [rbp+238], 0
	mov	eax, 1
	mov	r9d, 3
	movss	DWORD PTR [rsp+32], xmm8
	cmovne	r9d, eax
	mov	r8d, r12d
	call	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
$LN5@CollapseBu:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5501 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5502 :     if (g.ActiveId)

	movaps	xmm8, XMMWORD PTR [rsp+96]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	ecx, DWORD PTR [rax+16504]
	mov	r12, QWORD PTR [rsp+152]
	mov	rsi, QWORD PTR [rsp+200]
	test	ecx, ecx
	je	SHORT $LN71@CollapseBu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 860  :     if (IsItemActive() && IsMouseDragging(0))

	cmp	ecx, DWORD PTR [rax+18616]
	jne	SHORT $LN71@CollapseBu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9001 :     if (!g.IO.MouseDown[button])

	cmp	BYTE PTR [rax+3600], 0
	je	SHORT $LN71@CollapseBu

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movss	xmm1, DWORD PTR [rax+116]

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rax+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
	setae	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 860  :     if (IsItemActive() && IsMouseDragging(0))

	test	al, al
	je	SHORT $LN71@CollapseBu

; 861  :         StartMouseMovingWindowOrNode(window, dock_node, true);

	mov	r8b, 1
	mov	rdx, r14
	mov	rcx, rbp
	call	?StartMouseMovingWindowOrNode@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiDockNode@@_N@Z ; ImGui::StartMouseMovingWindowOrNode
$LN71@CollapseBu:

; 862  : 
; 863  :     return pressed;
; 864  : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	r14
	pop	rbp
	pop	rbx
	ret	0
?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z ENDP ; ImGui::CollapseButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
window$ = 56
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z PROC ; ImGui::TabItemCalcSize, COMDAT

; 8695 : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 8696 :     return TabItemCalcSize(window->Name, window->HasCloseButton || (window->Flags & ImGuiWindowFlags_UnsavedDocument));

	cmp	BYTE PTR [rdx+245], 0
	mov	rbx, rcx
	jne	SHORT $LN3@TabItemCal
	test	DWORD PTR [rdx+20], 1048576		; 00100000H
	jne	SHORT $LN3@TabItemCal
	mov	rdx, QWORD PTR [rdx+8]
	xor	r8d, r8d
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize
	mov	rax, rbx

; 8697 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@TabItemCal:

; 8696 :     return TabItemCalcSize(window->Name, window->HasCloseButton || (window->Flags & ImGuiWindowFlags_UnsavedDocument));

	mov	rdx, QWORD PTR [rdx+8]
	mov	r8b, 1
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize
	mov	rax, rbx

; 8697 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z ENDP ; ImGui::TabItemCalcSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z
_TEXT	SEGMENT
tab_contents_visible$1$ = 80
tab_just_unsaved$1$ = 81
text_clipped$ = 81
held$ = 82
just_closed$ = 83
hovered$ = 83
want_clip_rect$1$ = 84
pressed$1$ = 85
flags$1$ = 88
tv3008 = 92
$T4 = 96
docked_window$GSCopy$1$ = 104
tv2852 = 112
tv2880 = 116
tv3011 = 120
$T5 = 128
$T6 = 136
size$ = 136
p_open$GSCopy$1$ = 144
c$7 = 152
$T8 = 152
$T9 = 152
window$1$ = 168
label$GSCopy$1$ = 176
req$10 = 192
$T11 = 192
bb$ = 256
$T12 = 256
$T13 = 256
__$ArrayPad$ = 272
tab_bar$ = 496
label$ = 504
p_open$ = 512
flags$ = 520
docked_window$ = 528
?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z PROC ; ImGui::TabItemEx, COMDAT

; 8376 : {

$LN651:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	lea	rbp, QWORD PTR [rax-232]
	sub	rsp, 440				; 000001b8H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rax, QWORD PTR docked_window$[rbp-256]
	mov	rbx, rcx

; 8377 :     // Layout whole tab bar if not already done
; 8378 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14d, r9d
	mov	DWORD PTR flags$1$[rsp], r9d
	mov	rdi, r8
	mov	QWORD PTR p_open$GSCopy$1$[rbp-256], r8
	mov	r13, rdx

; 8379 :     if (tab_bar->WantLayout)

	cmp	BYTE PTR [rbx+107], 0
	mov	rsi, rcx
	mov	QWORD PTR label$GSCopy$1$[rbp-256], rdx
	mov	QWORD PTR docked_window$GSCopy$1$[rsp], rax
	je	SHORT $LN2@TabItemEx

; 8380 :     {
; 8381 :         ImGuiNextItemData backup_next_item_data = g.NextItemData;

	movups	xmm7, XMMWORD PTR [rcx+18592]
	movsd	xmm6, QWORD PTR [rcx+18608]

; 8382 :         TabBarLayout(tab_bar);

	mov	rcx, rbx
	call	?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ; ImGui::TabBarLayout

; 8383 :         g.NextItemData = backup_next_item_data;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR docked_window$GSCopy$1$[rsp]
	movups	XMMWORD PTR [rsi+18592], xmm7
	movsd	QWORD PTR [rsi+18608], xmm6
$LN2@TabItemEx:

; 8384 :     }
; 8385 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rdx, QWORD PTR [rsi+16408]
	mov	QWORD PTR [rsp+520], r12
	mov	QWORD PTR [rsp+432], r15
	mov	QWORD PTR window$1$[rbp-256], rdx

; 8386 :     if (window->SkipItems)

	cmp	BYTE PTR [rdx+240], 0
	jne	SHORT $LN530@TabItemEx

; 7959 :     if (docked_window != NULL)

	test	rax, rax
	je	SHORT $LN339@TabItemEx

; 7960 :     {
; 7961 :         IM_UNUSED(tab_bar);
; 7962 :         IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
; 7963 :         ImGuiID id = docked_window->TabId;

	mov	r15d, DWORD PTR [rax+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4019 :     if (g.ActiveId == id)

	cmp	DWORD PTR [rcx+16504], r15d
	jne	SHORT $LN343@TabItemEx

; 4020 :         g.ActiveIdIsAlive = id;

	mov	DWORD PTR [rcx+16508], r15d
$LN343@TabItemEx:

; 4021 :     if (g.ActiveIdPreviousFrame == id)

	cmp	DWORD PTR [rcx+16552], r15d
	jne	SHORT $LN340@TabItemEx

; 4022 :         g.ActiveIdPreviousFrameIsAlive = true;

	mov	BYTE PTR [rcx+16556], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7965 :         return id;

	jmp	SHORT $LN340@TabItemEx
$LN339@TabItemEx:

; 7966 :     }
; 7967 :     else
; 7968 :     {
; 7969 :         ImGuiWindow* window = GImGui->CurrentWindow;
; 7970 :         return window->GetID(label);

	mov	rcx, QWORD PTR [rcx+16408]
	mov	rdx, r13
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	r15d, eax
$LN340@TabItemEx:

; 8387 :         return false;
; 8388 : 
; 8389 :     const ImGuiStyle& style = g.Style;
; 8390 :     const ImGuiID id = TabBarCalcTabID(tab_bar, label, docked_window);
; 8391 : 
; 8392 :     // If the user called us with *p_open == false, we early out and don't render.
; 8393 :     // We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
; 8394 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
; 8395 :     if (p_open && !*p_open)

	test	rdi, rdi
	je	SHORT $LN4@TabItemEx
	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LN4@TabItemEx

; 8397 :         ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);

	xorps	xmm0, xmm0
	lea	rcx, QWORD PTR $T13[rbp-256]
	mov	r9d, 8
	xor	r8d, r8d
	mov	edx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movups	XMMWORD PTR $T13[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8397 :         ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);

	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
$LN530@TabItemEx:

; 8654 : }

	xor	al, al
	jmp	$LN1@TabItemEx
$LN4@TabItemEx:

; 8398 :         return false;
; 8399 :     }
; 8400 : 
; 8401 :     IM_ASSERT(!p_open || !(flags & ImGuiTabItemFlags_Button));
; 8402 :     IM_ASSERT((flags & (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing
; 8403 : 
; 8404 :     // Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
; 8405 :     if (flags & ImGuiTabItemFlags_NoCloseButton)

	xor	r9d, r9d
	bt	r14d, 20
	jae	SHORT $LN5@TabItemEx

; 8406 :         p_open = NULL;

	mov	QWORD PTR p_open$GSCopy$1$[rbp-256], r9
	jmp	SHORT $LN7@TabItemEx
$LN5@TabItemEx:

; 8407 :     else if (p_open == NULL)

	test	rdi, rdi
	jne	SHORT $LN7@TabItemEx

; 8408 :         flags |= ImGuiTabItemFlags_NoCloseButton;

	bts	r14d, 20
	mov	DWORD PTR flags$1$[rsp], r14d
$LN7@TabItemEx:

; 7982 :     if (tab_id != 0)

	test	r15d, r15d
	je	SHORT $LN348@TabItemEx

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	edx, DWORD PTR [rbx]
	mov	eax, r9d
	test	edx, edx
	jle	SHORT $LN348@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR [rbx+8]
	mov	rcx, r8
	npad	5
$LL349@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rcx], r15d
	je	SHORT $LN505@TabItemEx

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	rcx, 56					; 00000038H
	cmp	eax, edx
	jl	SHORT $LL349@TabItemEx
$LN348@TabItemEx:

; 7986 :     return NULL;

	mov	rdi, r9
$LN346@TabItemEx:

; 8409 : 
; 8410 :     // Acquire tab data
; 8411 :     ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
; 8412 :     bool tab_is_new = false;

	xor	r12b, r12b

; 8413 :     if (tab == NULL)

	test	rdi, rdi
	jne	$LN8@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2700 :     ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }

	mov	QWORD PTR $T11[rbp-256], r9
	mov	QWORD PTR $T11[rbp-248], r9
	mov	QWORD PTR $T11[rbp-232], r9
	mov	DWORD PTR $T11[rbp-224], r9d
	mov	QWORD PTR $T11[rbp-208], r9
	mov	QWORD PTR $T11[rbp-240], -1
	mov	QWORD PTR $T11[rbp-220], -1082130432	; ffffffffbf800000H
	mov	DWORD PTR $T11[rbp-212], -1		; ffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN372@TabItemEx
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN376@TabItemEx
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN377@TabItemEx
$LN505@TabItemEx:

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rdi, rax, 56				; 00000038H
	add	rdi, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7985 :                 return &tab_bar->Tabs[n];

	jmp	SHORT $LN346@TabItemEx
$LN376@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN377@TabItemEx:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
	xor	r9d, r9d
$LN372@TabItemEx:
	movsxd	rax, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8418 :         tab_bar->TabsAddedNew = tab_is_new = true;

	mov	r12b, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movups	xmm0, XMMWORD PTR $T11[rbp-256]
	movups	xmm1, XMMWORD PTR $T11[rbp-240]
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm0, XMMWORD PTR $T11[rbp-224]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movsd	xmm1, QWORD PTR $T11[rbp-208]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movsd	QWORD PTR [rcx+rax+48], xmm1
	movsxd	rcx, DWORD PTR [rbx]

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	imul	rdi, rcx, 56				; 00000038H

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	eax, DWORD PTR [rcx+1]
	mov	DWORD PTR [rbx], eax

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	add	rdi, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8417 :         tab->ID = id;

	mov	DWORD PTR [rdi], r15d

; 8418 :         tab_bar->TabsAddedNew = tab_is_new = true;

	mov	BYTE PTR [rbx+109], r12b
$LN8@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, rdi
	mov	rax, 5270498306774157605		; 4924924924924925H
	sub	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8420 :     tab_bar->LastTabItemIdx = (ImS16)tab_bar->Tabs.index_from_ptr(tab);

	and	r14d, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8423 :     ImVec2 size = TabItemCalcSize(label, (p_open != NULL) || (flags & ImGuiTabItemFlags_UnsavedDocument));

	cmp	QWORD PTR p_open$GSCopy$1$[rbp-256], 0
	mov	WORD PTR [rbx+112], dx
	jne	SHORT $LN510@TabItemEx
	test	r14d, r14d
	jne	SHORT $LN510@TabItemEx
	xor	r8d, r8d
	mov	r14d, r9d
	jmp	SHORT $LN61@TabItemEx
$LN510@TabItemEx:
	mov	r8b, 1
$LN61@TabItemEx:
	mov	rdx, r13
	lea	rcx, QWORD PTR size$[rbp-256]
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize

; 8424 :     tab->RequestedWidth = -1.0f;

	mov	DWORD PTR [rdi+36], -1082130432		; bf800000H

; 8425 :     if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)

	test	BYTE PTR [rsi+18592], 1
	je	SHORT $LN533@TabItemEx

; 8426 :         size.x = tab->RequestedWidth = g.NextItemData.Width;

	movss	xmm1, DWORD PTR [rsi+18600]
	movss	DWORD PTR [rdi+36], xmm1
	jmp	SHORT $LN9@TabItemEx
$LN533@TabItemEx:

; 8425 :     if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)

	movss	xmm1, DWORD PTR size$[rbp-256]
$LN9@TabItemEx:

; 8427 :     if (tab_is_new)

	movss	xmm6, DWORD PTR __real@3f800000
	test	r12b, r12b
	je	SHORT $LN10@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm6
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8428 :         tab->Width = ImMax(1.0f, size.x);

	movss	DWORD PTR [rdi+28], xmm0
$LN10@TabItemEx:

; 8429 :     tab->ContentWidth = size.x;

	movss	DWORD PTR [rdi+32], xmm1

; 8430 :     tab->BeginOrder = tab_bar->TabsActiveCount++;
; 8431 : 
; 8432 :     const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);
; 8433 :     const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;
; 8434 :     const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);
; 8435 :     const bool tab_just_unsaved = (flags & ImGuiTabItemFlags_UnsavedDocument) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument);

	lea	r10, QWORD PTR [rdi+4]
	movzx	ecx, WORD PTR [rbx+110]
	lea	eax, DWORD PTR [rcx+1]
	mov	WORD PTR [rbx+110], ax
	mov	r9d, DWORD PTR [rdi+16]
	mov	WORD PTR [rdi+44], cx
	inc	r9d
	mov	eax, DWORD PTR [rbx+16]
	mov	r13d, DWORD PTR [rbx+40]
	mov	ecx, DWORD PTR [rsi+16240]
	inc	r13d
	shr	eax, 21
	and	al, 1
	mov	DWORD PTR tv2880[rsp], ecx
	mov	DWORD PTR tv3011[rsp], eax
	mov	DWORD PTR tv2852[rsp], r9d
	test	r14d, r14d
	je	SHORT $LN62@TabItemEx
	test	BYTE PTR [r10], 1
	mov	QWORD PTR $T5[rbp-256], r10
	jne	SHORT $LN62@TabItemEx
	mov	BYTE PTR tab_just_unsaved$1$[rsp], 1
	jmp	SHORT $LN63@TabItemEx
$LN62@TabItemEx:
	mov	BYTE PTR tab_just_unsaved$1$[rsp], 0
	mov	QWORD PTR $T5[rbp-256], r10
$LN63@TabItemEx:

; 8436 :     const bool is_tab_button = (flags & ImGuiTabItemFlags_Button) != 0;

	mov	r8d, DWORD PTR flags$1$[rsp]
	mov	r14d, r8d

; 8437 :     tab->LastFrameVisible = g.FrameCount;
; 8438 :     tab->Flags = flags;
; 8439 :     tab->Window = docked_window;

	mov	rdx, QWORD PTR docked_window$GSCopy$1$[rsp]
	shr	r14d, 21
	and	r14b, 1
	mov	DWORD PTR [rdi+16], ecx
	mov	DWORD PTR tv3008[rsp], r14d
	mov	DWORD PTR [r10], r8d
	mov	QWORD PTR [rdi+8], rdx

; 8440 : 
; 8441 :     // Append name _WITH_ the zero-terminator
; 8442 :     // (regular tabs are permitted in a DockNode tab bar, but window tabs not permitted in a non-DockNode tab bar)
; 8443 :     if (docked_window != NULL)

	test	rdx, rdx
	je	SHORT $LN11@TabItemEx

; 8444 :     {
; 8445 :         IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
; 8446 :         tab->NameOffset = -1;

	mov	DWORD PTR [rdi+40], -1

; 8447 :     }

	jmp	SHORT $LN12@TabItemEx
$LN11@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2420 :     int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }

	mov	eax, DWORD PTR [rbx+136]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8450 :         tab->NameOffset = (ImS32)tab_bar->TabsNames.size();

	test	eax, eax
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, 0
	cmove	ecx, eax

; 8451 :         tab_bar->TabsNames.append(label, label + strlen(label) + 1);

	mov	rax, -1
	mov	DWORD PTR [rdi+40], ecx
	mov	rcx, QWORD PTR label$GSCopy$1$[rbp-256]
$LL532@TabItemEx:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL532@TabItemEx
	lea	r8, QWORD PTR [rcx+1]
	mov	rdx, rcx
	add	r8, rax
	lea	rcx, QWORD PTR [rbx+136]
	call	?append@ImGuiTextBuffer@@QEAAXPEBD0@Z	; ImGuiTextBuffer::append
	mov	ecx, DWORD PTR tv2880[rsp]
	mov	rdx, QWORD PTR docked_window$GSCopy$1$[rsp]
	mov	r9d, DWORD PTR tv2852[rsp]
	mov	r8d, DWORD PTR flags$1$[rsp]
	mov	r10, QWORD PTR $T5[rbp-256]
$LN12@TabItemEx:

; 8452 :     }
; 8453 : 
; 8454 :     // Update selected tab
; 8455 :     if (!is_tab_button)

	test	r14b, r14b
	jne	SHORT $LN17@TabItemEx

; 8456 :     {
; 8457 :         if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)

	cmp	r9d, ecx
	jge	SHORT $LN15@TabItemEx
	test	BYTE PTR [rbx+16], 2
	je	SHORT $LN15@TabItemEx
	cmp	DWORD PTR [rbx+28], 0
	jne	SHORT $LN15@TabItemEx

; 8458 :             if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)

	cmp	r13d, ecx
	jge	SHORT $LN16@TabItemEx
	cmp	DWORD PTR [rbx+24], 0
	jne	SHORT $LN15@TabItemEx
$LN16@TabItemEx:

; 8459 :                 TabBarQueueFocus(tab_bar, tab); // New tabs gets activated

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+28], eax
$LN15@TabItemEx:

; 8460 :         if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // _SetSelected can only be passed on explicit tab bar

	test	r8b, 2
	je	SHORT $LN17@TabItemEx
	cmp	DWORD PTR [rbx+24], r15d
	je	SHORT $LN17@TabItemEx

; 8461 :             TabBarQueueFocus(tab_bar, tab);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+28], eax
$LN17@TabItemEx:

; 8462 :     }
; 8463 : 
; 8464 :     // Lock visibility
; 8465 :     // (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)
; 8466 :     bool tab_contents_visible = (tab_bar->VisibleTabId == id);

	cmp	DWORD PTR [rbx+32], r15d
	sete	r14b
	mov	BYTE PTR tab_contents_visible$1$[rsp], r14b

; 8467 :     if (tab_contents_visible)

	jne	SHORT $LN519@TabItemEx

; 8468 :         tab_bar->VisibleTabWasSubmitted = true;

	lea	r8, QWORD PTR [rbx+24]
	mov	BYTE PTR [rbx+108], 1
	mov	QWORD PTR $T4[rsp], r8

; 8469 : 
; 8470 :     // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
; 8471 :     if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing && docked_window == NULL)

	jmp	SHORT $LN20@TabItemEx
$LN519@TabItemEx:
	cmp	DWORD PTR [rbx+24], 0
	lea	rax, QWORD PTR [rbx+24]
	mov	r8, rax
	mov	QWORD PTR $T4[rsp], rax
	jne	SHORT $LN20@TabItemEx
	mov	QWORD PTR $T4[rsp], rax
	cmp	r13d, ecx
	jge	SHORT $LN20@TabItemEx
	mov	QWORD PTR $T4[rsp], rax
	test	rdx, rdx
	jne	SHORT $LN20@TabItemEx

; 8472 :         if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))

	cmp	DWORD PTR [rbx], 1
	mov	QWORD PTR $T4[rsp], rax
	jne	SHORT $LN20@TabItemEx
	test	BYTE PTR [rbx+16], 2
	mov	QWORD PTR $T4[rsp], rax
	jne	SHORT $LN20@TabItemEx

; 8473 :             tab_contents_visible = true;

	mov	r14b, 1
	mov	QWORD PTR $T4[rsp], rax
	mov	BYTE PTR tab_contents_visible$1$[rsp], r14b
$LN20@TabItemEx:

; 8474 : 
; 8475 :     // Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted
; 8476 :     // and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.
; 8477 :     if (tab_appearing && (!tab_bar_appearing || tab_is_new))

	cmp	r9d, ecx
	jge	SHORT $LN21@TabItemEx
	cmp	r13d, ecx
	jge	SHORT $LN22@TabItemEx
	test	r12b, r12b
	je	SHORT $LN21@TabItemEx
$LN22@TabItemEx:
	xorps	xmm0, xmm0

; 8479 :         ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);

	lea	rcx, QWORD PTR $T12[rbp-256]
	mov	r9d, 8
	xor	r8d, r8d
	mov	edx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movups	XMMWORD PTR $T12[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8479 :         ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav);

	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 8480 :         if (is_tab_button)

	cmp	BYTE PTR tv3008[rsp], 0
	jne	$LN530@TabItemEx

; 8652 :         return pressed;
; 8653 :     return tab_contents_visible;

	movzx	eax, r14b
	jmp	$LN1@TabItemEx
$LN21@TabItemEx:
	movaps	XMMWORD PTR [rsp+384], xmm8
	movaps	XMMWORD PTR [rsp+368], xmm9
	movaps	XMMWORD PTR [rsp+352], xmm10
	movaps	XMMWORD PTR [rsp+336], xmm11
	movaps	XMMWORD PTR [rsp+320], xmm12
	movaps	XMMWORD PTR [rsp+304], xmm13
	movaps	XMMWORD PTR [rsp+288], xmm14

; 8481 :             return false;
; 8482 :         return tab_contents_visible;
; 8483 :     }
; 8484 : 
; 8485 :     if (tab_bar->SelectedTabId == id)

	cmp	DWORD PTR [r8], r15d
	jne	SHORT $LN24@TabItemEx

; 8486 :         tab->LastFrameSelected = g.FrameCount;

	mov	eax, DWORD PTR [rsi+16240]
	mov	DWORD PTR [rdi+20], eax
$LN24@TabItemEx:

; 8487 : 
; 8488 :     // Backup current layout position
; 8489 :     const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;

	mov	r13, QWORD PTR window$1$[rbp-256]

; 8490 : 
; 8491 :     // Layout
; 8492 :     const bool is_central_section = (tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;

	mov	edx, DWORD PTR [r10]

; 8493 :     size.x = tab->Width;

	movss	xmm0, DWORD PTR [rdi+28]
	movss	xmm8, DWORD PTR [rdi+24]
	movss	xmm13, DWORD PTR [r13+312]
	movss	xmm14, DWORD PTR [r13+316]
	and	edx, 192				; 000000c0H

; 8494 :     if (is_central_section)

	jne	SHORT $LN25@TabItemEx

; 8495 :         window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2(IM_FLOOR(tab->Offset - tab_bar->ScrollingAnim), 0.0f);

	subss	xmm8, DWORD PTR [rbx+76]
	cvttss2si eax, xmm8
	movd	xmm8, eax
	cvtdq2ps xmm8, xmm8
$LN25@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm11, DWORD PTR size$[rbp-252]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8498 :     ImVec2 pos = window->DC.CursorPos;

	mov	eax, 4
	xorps	xmm12, xmm12
	addss	xmm8, DWORD PTR [rbx+44]
	movss	xmm10, DWORD PTR [rax+rbx+44]
	addss	xmm10, xmm12
	movss	DWORD PTR [r13+312], xmm8
	movaps	xmm9, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8498 :     ImVec2 pos = window->DC.CursorPos;

	addss	xmm9, xmm0
	movss	DWORD PTR [r13+316], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm11, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-252], xmm10
	movss	DWORD PTR bb$[rbp-248], xmm9
	movss	DWORD PTR bb$[rbp-244], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8502 :     const bool want_clip_rect = is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX || bb.Max.x > tab_bar->ScrollingRectMaxX);

	test	edx, edx
	jne	SHORT $LN512@TabItemEx
	movss	xmm2, DWORD PTR [rbx+92]
	comiss	xmm2, xmm8
	ja	SHORT $LN523@TabItemEx
	comiss	xmm9, DWORD PTR [rbx+96]
	jbe	SHORT $LN512@TabItemEx
$LN523@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8504 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	lea	rdx, QWORD PTR $T6[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8504 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	lea	rcx, QWORD PTR $T9[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm10
	movss	DWORD PTR $T6[rbp-252], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8504 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	movaps	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8504 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	maxss	xmm1, xmm2
	mov	r14b, 1
	movzx	r8d, r14b
	mov	BYTE PTR want_clip_rect$1$[rsp], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-252], xmm0
	movss	DWORD PTR $T9[rbp-256], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8504 :         PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar->ScrollingRectMaxX, bb.Max.y), true);

	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	jmp	SHORT $LN27@TabItemEx
$LN512@TabItemEx:

; 8502 :     const bool want_clip_rect = is_central_section && (bb.Min.x < tab_bar->ScrollingRectMinX || bb.Max.x > tab_bar->ScrollingRectMaxX);

	xor	r14b, r14b
	mov	BYTE PTR want_clip_rect$1$[rsp], r14b
$LN27@TabItemEx:

; 8507 :     ItemSize(bb.GetSize(), style.FramePadding.y);

	movss	xmm1, DWORD PTR [rsi+14616]
	subss	xmm9, xmm8
	movss	xmm7, DWORD PTR [r13+336]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm11, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8506 :     ImVec2 backup_cursor_max_pos = window->DC.CursorMaxPos;

	movss	xmm6, DWORD PTR [r13+340]

; 8507 :     ItemSize(bb.GetSize(), style.FramePadding.y);

	lea	rcx, QWORD PTR $T8[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp-256], xmm9
	movss	DWORD PTR $T8[rbp-252], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8507 :     ItemSize(bb.GetSize(), style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 8508 :     window->DC.CursorMaxPos = backup_cursor_max_pos;
; 8509 : 
; 8510 :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	movss	DWORD PTR [r13+336], xmm7
	mov	edx, r15d
	movss	DWORD PTR [r13+340], xmm6
	lea	rcx, QWORD PTR bb$[rbp-256]
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	movaps	xmm11, XMMWORD PTR [rsp+336]
	movaps	xmm10, XMMWORD PTR [rsp+352]
	movaps	xmm9, XMMWORD PTR [rsp+368]
	movaps	xmm8, XMMWORD PTR [rsp+384]
	test	al, al
	jne	SHORT $LN28@TabItemEx

; 8511 :     {
; 8512 :         if (want_clip_rect)

	test	r14b, r14b
	je	SHORT $LN29@TabItemEx

; 8513 :             PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
$LN29@TabItemEx:

; 8514 :         window->DC.CursorPos = backup_main_cursor_pos;
; 8515 :         return tab_contents_visible;

	movzx	eax, BYTE PTR tab_contents_visible$1$[rsp]
	movss	DWORD PTR [r13+312], xmm13
	movss	DWORD PTR [r13+316], xmm14
	jmp	$LN645@TabItemEx
$LN28@TabItemEx:

; 8516 :     }
; 8517 : 
; 8518 :     // Click to Select a tab
; 8519 :     ImGuiButtonFlags button_flags = ((is_tab_button ? ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlags_AllowOverlap);

	mov	r12d, DWORD PTR tv3008[rsp]
	movzx	r14d, r12b
	inc	r14d
	shl	r14d, 4
	bts	r14d, 12

; 8520 :     if (g.DragDropActive && !g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW)) // FIXME: May be an opt-in property of the payload to disable this

	cmp	BYTE PTR [rsi+19544], 0
	je	SHORT $LN30@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2333 :     bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }

	cmp	DWORD PTR [rsi+19580], -1
	je	SHORT $LN529@TabItemEx
	lea	rdx, QWORD PTR [rsi+19584]
	lea	rcx, OFFSET FLAT:??_C@_09CHGPIMJN@_IMWINDOW@
	call	strcmp
	test	eax, eax
	je	SHORT $LN30@TabItemEx
$LN529@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8521 :         button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;

	bts	r14d, 9
$LN30@TabItemEx:

; 8522 :     bool hovered, held;
; 8523 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	lea	r9, QWORD PTR held$[rsp]
	mov	DWORD PTR [rsp+32], r14d
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, r15d
	lea	rcx, QWORD PTR bb$[rbp-256]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR pressed$1$[rsp], al

; 8524 :     if (pressed && !is_tab_button)

	test	al, al
	je	SHORT $LN31@TabItemEx
	test	r12b, r12b
	jne	SHORT $LN31@TabItemEx

; 8525 :         TabBarQueueFocus(tab_bar, tab);

	mov	ecx, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+28], ecx
$LN31@TabItemEx:

; 8526 : 
; 8527 :     // Transfer active id window so the active id is not owned by the dock host (as StartMouseMovingWindow()
; 8528 :     // will only do it on the drag). This allows FocusWindow() to be more conservative in how it clears active id.
; 8529 :     if (held && docked_window && g.ActiveId == id && g.ActiveIdIsJustActivated)

	mov	r13, QWORD PTR docked_window$GSCopy$1$[rsp]
	movzx	ecx, BYTE PTR held$[rsp]
	test	r13, r13
	je	SHORT $LN69@TabItemEx
	test	cl, cl
	je	SHORT $LN32@TabItemEx
	cmp	DWORD PTR [rsi+16504], r15d
	jne	SHORT $LN32@TabItemEx
	cmp	BYTE PTR [rsi+16516], 0
	je	SHORT $LN32@TabItemEx

; 8530 :         g.ActiveIdWindow = docked_window;

	mov	QWORD PTR [rsi+16536], r13
$LN32@TabItemEx:

; 8531 : 
; 8532 :     // Drag and drop a single floating window node moves it
; 8533 :     ImGuiDockNode* node = docked_window ? docked_window->DockNode : NULL;

	mov	rax, QWORD PTR [r13+1096]

; 8534 :     const bool single_floating_window_node = node && node->IsFloatingNode() && (node->Windows.Size == 1);

	test	rax, rax
	je	SHORT $LN69@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1720 :     bool                    IsFloatingNode() const  { return ParentNode == NULL && (MergedFlags & ImGuiDockNodeFlags_DockSpace) == 0; }

	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN69@TabItemEx
	test	DWORD PTR [rax+16], 1024		; 00000400H
	jne	SHORT $LN69@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8534 :     const bool single_floating_window_node = node && node->IsFloatingNode() && (node->Windows.Size == 1);

	cmp	DWORD PTR [rax+48], 1
	jne	SHORT $LN69@TabItemEx
	mov	al, 1
	jmp	SHORT $LN70@TabItemEx
$LN69@TabItemEx:
	xor	al, al
$LN70@TabItemEx:

; 8535 :     if (held && single_floating_window_node && IsMouseDragging(0, 0.0f))

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	edx, 1
	test	cl, cl
	je	$LN487@TabItemEx
	test	al, al
	je	SHORT $LN33@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9001 :     if (!g.IO.MouseDown[button])

	cmp	BYTE PTR [r14+3600], 0
	je	SHORT $LN33@TabItemEx

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [r14+14288]
	comiss	xmm0, xmm12
	setae	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8535 :     if (held && single_floating_window_node && IsMouseDragging(0, 0.0f))

	test	al, al
	je	SHORT $LN33@TabItemEx

; 8536 :     {
; 8537 :         // Move
; 8538 :         StartMouseMovingWindow(docked_window);

	mov	rcx, r13
	call	?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z ; ImGui::StartMouseMovingWindow

; 8539 :     }

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	$LN487@TabItemEx
$LN33@TabItemEx:

; 8540 :     else if (held && !tab_appearing && IsMouseDragging(0))

	mov	eax, DWORD PTR tv2852[rsp]
	cmp	eax, DWORD PTR tv2880[rsp]
	jl	$LN487@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9001 :     if (!g.IO.MouseDown[button])

	cmp	BYTE PTR [r14+3600], 0
	je	$LN487@TabItemEx

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movss	xmm1, DWORD PTR [r14+116]

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [r14+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
	setae	al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8540 :     else if (held && !tab_appearing && IsMouseDragging(0))

	test	al, al
	je	$LN487@TabItemEx

; 8541 :     {
; 8542 :         // Drag and drop: re-order tabs
; 8543 :         int drag_dir = 0;
; 8544 :         float drag_distance_from_edge_x = 0.0f;
; 8545 :         if (!g.DragDropActive && ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) || (docked_window != NULL)))

	movss	xmm7, DWORD PTR bb$[rbp-256]
	xor	r9d, r9d
	mov	r12d, r9d
	xorps	xmm5, xmm5
	cmp	BYTE PTR [rsi+19544], r9b
	jne	SHORT $LN40@TabItemEx
	test	BYTE PTR [rbx+16], dl
	jne	SHORT $LN37@TabItemEx
	test	r13, r13
	je	$LN487@TabItemEx
$LN37@TabItemEx:

; 8546 :         {
; 8547 :             // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
; 8548 :             if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)

	movss	xmm1, DWORD PTR [rsi+248]
	comiss	xmm12, xmm1
	jbe	SHORT $LN524@TabItemEx
	movss	xmm0, DWORD PTR [rsi+3592]
	comiss	xmm7, xmm0
	jbe	SHORT $LN524@TabItemEx

; 8549 :             {
; 8550 :                 drag_dir = -1;
; 8551 :                 drag_distance_from_edge_x = bb.Min.x - g.IO.MousePos.x;

	movaps	xmm5, xmm7
	mov	r12d, -1
	subss	xmm5, xmm0

; 8552 :                 TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
; 8553 :             }

	jmp	SHORT $LN646@TabItemEx
$LN524@TabItemEx:

; 8554 :             else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)

	comiss	xmm1, xmm12
	jbe	SHORT $LN40@TabItemEx
	movss	xmm0, DWORD PTR [rsi+3592]
	movss	xmm1, DWORD PTR bb$[rbp-248]
	comiss	xmm0, xmm1
	jbe	SHORT $LN40@TabItemEx

; 8555 :             {
; 8556 :                 drag_dir = +1;
; 8557 :                 drag_distance_from_edge_x = g.IO.MousePos.x - bb.Max.x;

	movaps	xmm5, xmm0
	mov	r12d, edx
	subss	xmm5, xmm1
$LN646@TabItemEx:

; 8558 :                 TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
; 8559 :             }
; 8560 :         }
; 8561 : 
; 8562 :         // Extract a Dockable window out of it's tab bar
; 8563 :         if (docked_window != NULL && !(docked_window->Flags & ImGuiWindowFlags_NoMove))

	mov	r8, QWORD PTR [rsi+3592]
	mov	rdx, rdi
	mov	rcx, rbx
	call	?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z ; ImGui::TabBarQueueReorderFromMousePos
	mov	edx, 1
	xor	r9d, r9d
$LN40@TabItemEx:
	test	r13, r13
	je	$LN487@TabItemEx
	test	BYTE PTR [r13+20], 4
	jne	$LN487@TabItemEx

; 8564 :         {
; 8565 :             // We use a variable threshold to distinguish dragging tabs within a tab bar and extracting them out of the tab bar
; 8566 :             bool undocking_tab = (g.DragDropActive && g.DragDropPayload.SourceId == id);

	cmp	BYTE PTR [rsi+19544], 0
	movss	xmm6, DWORD PTR bb$[rbp-252]
	je	SHORT $LN71@TabItemEx
	cmp	DWORD PTR [rsi+19572], r15d
	je	$LN518@TabItemEx
$LN71@TabItemEx:

; 8567 :             if (!undocking_tab) //&& (!g.IO.ConfigDockingWithShift || g.IO.KeyShift)
; 8568 :             {
; 8569 :                 float threshold_base = g.FontSize;

	movss	xmm2, DWORD PTR [rsi+15696]
	xor	al, al
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rsi+14248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8571 :                 float threshold_y = (threshold_base * 1.5f) + ImClamp((ImFabs(g.IO.MouseDragMaxDistanceAbs[0].x) - threshold_base * 2.0f) * 0.20f, 0.0f, threshold_base * 4.0f);

	movaps	xmm0, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8571 :                 float threshold_y = (threshold_base * 1.5f) + ImClamp((ImFabs(g.IO.MouseDragMaxDistanceAbs[0].x) - threshold_base * 2.0f) * 0.20f, 0.0f, threshold_base * 4.0f);

	addss	xmm0, xmm2
	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR __real@400ccccd
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3e4ccccd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm12, xmm1
	ja	SHORT $LN464@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8571 :                 float threshold_y = (threshold_base * 1.5f) + ImClamp((ImFabs(g.IO.MouseDragMaxDistanceAbs[0].x) - threshold_base * 2.0f) * 0.20f, 0.0f, threshold_base * 4.0f);

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@40800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	minss	xmm0, xmm1
	movaps	xmm12, xmm0
$LN464@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8574 :                 float distance_from_edge_y = ImMax(bb.Min.y - g.IO.MousePos.y, g.IO.MousePos.y - bb.Max.y);

	movss	xmm0, DWORD PTR [rsi+3596]
	movaps	xmm1, xmm6
	mulss	xmm2, DWORD PTR __real@3fc00000
	subss	xmm1, xmm0

; 8575 :                 if (distance_from_edge_y >= threshold_y)

	movzx	r8d, al
	subss	xmm0, DWORD PTR bb$[rbp-244]
	addss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8575 :                 if (distance_from_edge_y >= threshold_y)

	comiss	xmm1, xmm2
	cmovae	r8d, edx

; 8576 :                     undocking_tab = true;
; 8577 :                 if (drag_distance_from_edge_x > threshold_x)

	comiss	xmm5, xmm3
	jbe	SHORT $LN45@TabItemEx

; 8578 :                     if ((drag_dir < 0 && TabBarGetTabOrder(tab_bar, tab) == 0) || (drag_dir > 0 && TabBarGetTabOrder(tab_bar, tab) == tab_bar->Tabs.Size - 1))

	test	r12d, r12d
	jns	SHORT $LN647@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, rdi
	mov	rax, 5270498306774157605		; 4924924924924925H
	sub	rcx, QWORD PTR [rbx+8]
	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8578 :                     if ((drag_dir < 0 && TabBarGetTabOrder(tab_bar, tab) == 0) || (drag_dir > 0 && TabBarGetTabOrder(tab_bar, tab) == tab_bar->Tabs.Size - 1))

	test	edx, edx
	jmp	SHORT $LN648@TabItemEx
$LN647@TabItemEx:
	jle	SHORT $LN45@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, rdi
	mov	rax, 5270498306774157605		; 4924924924924925H
	sub	rcx, QWORD PTR [rbx+8]
	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8578 :                     if ((drag_dir < 0 && TabBarGetTabOrder(tab_bar, tab) == 0) || (drag_dir > 0 && TabBarGetTabOrder(tab_bar, tab) == tab_bar->Tabs.Size - 1))

	mov	eax, DWORD PTR [rbx]
	dec	eax
	cmp	edx, eax
$LN648@TabItemEx:

; 8579 :                         undocking_tab = true;
; 8580 :             }
; 8581 : 
; 8582 :             if (undocking_tab)

	je	SHORT $LN518@TabItemEx
$LN45@TabItemEx:
	test	r8b, r8b
	je	$LN487@TabItemEx
$LN518@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 15552:     ctx->DockContext.Requests.push_back(req);

	lea	r14, QWORD PTR [rsi+24040]

; 15056:         DockTargetWindow = DockPayload = UndockTargetWindow = NULL;

	mov	QWORD PTR req$10[rbp-232], r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [r14]
	mov	ecx, DWORD PTR [r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 15056:         DockTargetWindow = DockPayload = UndockTargetWindow = NULL;

	mov	QWORD PTR req$10[rbp-248], r9

; 15057:         DockTargetNode = UndockTargetNode = NULL;

	mov	QWORD PTR req$10[rbp-200], r9
	mov	QWORD PTR req$10[rbp-240], r9

; 15058:         DockSplitDir = ImGuiDir_None;

	mov	DWORD PTR req$10[rbp-224], -1

; 15059:         DockSplitRatio = 0.5f;

	mov	DWORD PTR req$10[rbp-220], 1056964608	; 3f000000H

; 15060:         DockSplitOuter = false;

	mov	BYTE PTR req$10[rbp-216], 0

; 15550:     req.Type = ImGuiDockRequestType_Undock;

	mov	DWORD PTR req$10[rbp-256], 2

; 15551:     req.UndockTargetWindow = window;

	mov	QWORD PTR req$10[rbp-208], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN474@TabItemEx
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN478@TabItemEx
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN479@TabItemEx
$LN478@TabItemEx:
	mov	eax, 8
$LN479@TabItemEx:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, r14

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiDockRequest@@@@QEAAXH@Z ; ImVector<ImGuiDockRequest>::reserve
$LN474@TabItemEx:
	movsxd	rcx, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8588 :                 SetActiveID(g.MovingWindow->MoveId, g.MovingWindow);

	mov	rdx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR [r14+8]
	movaps	xmm0, XMMWORD PTR req$10[rbp-256]
	movaps	xmm1, XMMWORD PTR req$10[rbp-240]
	shl	rcx, 6
	movups	XMMWORD PTR [rcx+rax], xmm0
	movaps	xmm0, XMMWORD PTR req$10[rbp-224]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movaps	xmm1, XMMWORD PTR req$10[rbp-208]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movups	XMMWORD PTR [rcx+rax+48], xmm1
	inc	DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8587 :                 g.MovingWindow = docked_window;

	mov	QWORD PTR [rsi+16432], r13

; 8588 :                 SetActiveID(g.MovingWindow->MoveId, g.MovingWindow);

	mov	ecx, DWORD PTR [r13+172]
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 8589 :                 g.ActiveIdClickOffset -= g.MovingWindow->Pos - bb.Min;

	mov	rax, QWORD PTR [rsi+16432]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2546 : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [rsi+16524]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5621 :     ImGuiContext& g = *GImGui;

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rax+80]
	movss	xmm2, DWORD PTR [rax+84]
	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8590 :                 g.ActiveIdNoClearOnFocusLoss = true;

	mov	BYTE PTR [rsi+16518], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, xmm6

; 2546 : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	subss	xmm0, xmm1
	movss	DWORD PTR [rsi+16524], xmm0
	movss	xmm0, DWORD PTR [rsi+16528]
	subss	xmm0, xmm2
	movss	DWORD PTR [rsi+16528], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r14+19161], 0

; 5623 :     g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;

	mov	DWORD PTR [r14+18568], 15

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al

; 5624 :     g.ActiveIdUsingAllKeyboardKeys = true;

	mov	BYTE PTR [r14+18572], 1

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	mov	BYTE PTR [r14+19160], al

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r14+19216], 0
$LN487@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8608 :     const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));

	cmp	BYTE PTR held$[rsp], 0
	mov	r13, QWORD PTR window$1$[rbp-256]
	movzx	r12d, BYTE PTR hovered$[rsp]
	mov	r13, QWORD PTR [r13+728]
	jne	SHORT $LN73@TabItemEx
	test	r12b, r12b
	jne	SHORT $LN73@TabItemEx
	cmp	BYTE PTR tab_contents_visible$1$[rsp], r12b
	je	SHORT $LN74@TabItemEx
	movzx	eax, BYTE PTR tv3011[rsp]
	xor	rax, 1
	lea	rax, QWORD PTR [rax*2+35]
	jmp	SHORT $LN76@TabItemEx
$LN74@TabItemEx:
	cmp	BYTE PTR tv3011[rsp], 0
	mov	eax, 36					; 00000024H
	mov	ecx, 33					; 00000021H
	cmovne	eax, ecx
	jmp	SHORT $LN76@TabItemEx
$LN73@TabItemEx:
	mov	eax, 34					; 00000022H
$LN76@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 14

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rbp-256]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [r14+rax*8+14552]
	movups	XMMWORD PTR c$7[rbp-256], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r14+14552]
	movss	DWORD PTR c$7[rbp-244], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8609 :     TabItemBackground(display_draw_list, bb, flags, tab_col);

	mov	r14d, DWORD PTR flags$1$[rsp]
	lea	rdx, QWORD PTR bb$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8609 :     TabItemBackground(display_draw_list, bb, flags, tab_col);

	mov	r8d, r14d
	mov	rcx, r13
	call	?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ; ImGui::TabItemBackground

; 8610 :     RenderNavHighlight(bb, id);

	mov	r8d, 1
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	edx, r15d
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 8611 : 
; 8612 :     // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
; 8613 :     const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);

	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered

; 8614 :     if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) && !is_tab_button)

	test	al, al
	je	SHORT $LN49@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8912 :     return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+1]
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8614 :     if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)) && !is_tab_button)

	test	al, al
	jne	SHORT $LN50@TabItemEx
	mov	ecx, 1
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN49@TabItemEx
$LN50@TabItemEx:
	cmp	BYTE PTR tv3008[rsp], 0
	jne	SHORT $LN49@TabItemEx

; 8615 :         TabBarQueueFocus(tab_bar, tab);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+28], eax
$LN49@TabItemEx:

; 8616 : 
; 8617 :     if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)

	test	BYTE PTR [rbx+16], 8
	je	SHORT $LN51@TabItemEx

; 8618 :         flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;

	or	r14d, 4
	mov	DWORD PTR flags$1$[rsp], r14d
$LN51@TabItemEx:

; 8619 : 
; 8620 :     // Render tab label, process close button
; 8621 :     const ImGuiID close_button_id = p_open ? GetIDWithSeed("#CLOSE", NULL, docked_window ? docked_window->ID : id) : 0;

	cmp	QWORD PTR p_open$GSCopy$1$[rbp-256], 0
	je	SHORT $LN79@TabItemEx
	mov	rax, QWORD PTR docked_window$GSCopy$1$[rsp]
	test	rax, rax
	je	SHORT $LN77@TabItemEx
	mov	r8d, DWORD PTR [rax+16]
	call	?GetIDWithSeed@ImGui@@YAIPEBD0I@Z	; ImGui::GetIDWithSeed
	jmp	SHORT $LN649@TabItemEx
$LN77@TabItemEx:
	mov	r8d, r15d
	call	?GetIDWithSeed@ImGui@@YAIPEBD0I@Z	; ImGui::GetIDWithSeed
	jmp	SHORT $LN649@TabItemEx
$LN79@TabItemEx:
	xor	eax, eax
$LN649@TabItemEx:

; 8622 :     bool just_closed;
; 8623 :     bool text_clipped;
; 8624 :     TabItemLabelAndCloseButton(display_draw_list, bb, tab_just_unsaved ? (flags & ~ImGuiTabItemFlags_UnsavedDocument) : flags, tab_bar->FramePadding, label, id, close_button_id, tab_contents_visible, &just_closed, &text_clipped);

	mov	ecx, DWORD PTR flags$1$[rsp]
	lea	rdx, QWORD PTR bb$[rbp-256]
	movss	xmm1, DWORD PTR [rbx+124]
	mov	r14d, eax
	movss	xmm0, DWORD PTR [rbx+120]
	mov	eax, ecx
	and	eax, -2
	unpcklps xmm0, xmm1
	cmp	BYTE PTR tab_just_unsaved$1$[rsp], 0
	movq	r9, xmm0
	cmovne	ecx, eax
	lea	rax, QWORD PTR text_clipped$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	r8d, ecx
	lea	rax, QWORD PTR just_closed$[rsp]
	mov	rcx, r13
	mov	QWORD PTR [rsp+64], rax
	movzx	eax, BYTE PTR tab_contents_visible$1$[rsp]
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR label$GSCopy$1$[rbp-256]
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], r15d
	mov	QWORD PTR [rsp+32], rax
	call	?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z ; ImGui::TabItemLabelAndCloseButton

; 8625 :     if (just_closed && p_open != NULL)

	cmp	BYTE PTR just_closed$[rsp], 0
	mov	r13, QWORD PTR $T5[rbp-256]
	je	SHORT $LN443@TabItemEx
	mov	rax, QWORD PTR p_open$GSCopy$1$[rbp-256]
	test	rax, rax
	je	SHORT $LN443@TabItemEx

; 8626 :     {
; 8627 :         *p_open = false;

	mov	BYTE PTR [rax], 0

; 8062 :     if (tab->Flags & ImGuiTabItemFlags_Button)

	mov	eax, DWORD PTR [r13]
	bt	eax, 21
	jb	SHORT $LN443@TabItemEx

; 8063 :         return; // A button appended with TabItemButton().
; 8064 : 
; 8065 :     if (!(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))

	test	al, 1
	mov	eax, DWORD PTR [rdi]
	jne	SHORT $LN440@TabItemEx

; 8066 :     {
; 8067 :         // This will remove a frame of lag for selecting another tab on closure.
; 8068 :         // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
; 8069 :         tab->WantClose = true;

	mov	BYTE PTR [rdi+48], 1

; 8070 :         if (tab_bar->VisibleTabId == tab->ID)

	cmp	DWORD PTR [rbx+32], eax
	jne	SHORT $LN443@TabItemEx

; 8071 :         {
; 8072 :             tab->LastFrameVisible = -1;
; 8073 :             tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;

	mov	rax, QWORD PTR $T4[rsp]
	xor	ecx, ecx
	mov	DWORD PTR [rdi+16], -1
	mov	DWORD PTR [rbx+28], ecx
	mov	DWORD PTR [rax], ecx

; 8074 :         }
; 8075 :     }

	jmp	SHORT $LN443@TabItemEx
$LN440@TabItemEx:

; 8076 :     else
; 8077 :     {
; 8078 :         // Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
; 8079 :         if (tab_bar->VisibleTabId != tab->ID)

	cmp	DWORD PTR [rbx+32], eax
	je	SHORT $LN443@TabItemEx

; 8080 :             TabBarQueueFocus(tab_bar, tab);

	mov	DWORD PTR [rbx+28], eax
$LN443@TabItemEx:

; 8628 :         TabBarCloseTab(tab_bar, tab);
; 8629 :     }
; 8630 : 
; 8631 :     // Forward Hovered state so IsItemHovered() after Begin() can work (even though we are technically hovering our parent)
; 8632 :     // That state is copied to window->DockTabItemStatusFlags by our caller.
; 8633 :     if (docked_window && (hovered || g.HoveredId == close_button_id))

	cmp	QWORD PTR docked_window$GSCopy$1$[rsp], 0
	je	SHORT $LN53@TabItemEx
	test	r12b, r12b
	jne	SHORT $LN526@TabItemEx
	cmp	DWORD PTR [rsi+16484], r14d
	jne	SHORT $LN53@TabItemEx
$LN526@TabItemEx:

; 8634 :         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;

	or	DWORD PTR [rsi+18624], 128		; 00000080H
$LN53@TabItemEx:

; 8635 : 
; 8636 :     // Restore main window position so user can draw there
; 8637 :     if (want_clip_rect)

	cmp	BYTE PTR want_clip_rect$1$[rsp], 0
	je	SHORT $LN55@TabItemEx

; 8638 :         PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
$LN55@TabItemEx:

; 8639 :     window->DC.CursorPos = backup_main_cursor_pos;
; 8640 : 
; 8641 :     // Tooltip
; 8642 :     // (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-> seems ok)
; 8643 :     // (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)
; 8644 :     // FIXME: This is a mess.
; 8645 :     // FIXME: We may want disabled tab to still display the tooltip?
; 8646 :     if (text_clipped && g.HoveredId == id && !held)

	cmp	BYTE PTR text_clipped$[rsp], 0
	mov	rax, QWORD PTR window$1$[rbp-256]
	movss	DWORD PTR [rax+312], xmm13
	movss	DWORD PTR [rax+316], xmm14
	je	SHORT $LN57@TabItemEx
	cmp	DWORD PTR [rsi+16484], r15d
	jne	SHORT $LN57@TabItemEx
	cmp	BYTE PTR held$[rsp], 0
	jne	SHORT $LN57@TabItemEx

; 8647 :         if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip) && !(tab->Flags & ImGuiTabItemFlags_NoTooltip))

	test	BYTE PTR [rbx+16], 32			; 00000020H
	jne	SHORT $LN57@TabItemEx
	test	BYTE PTR [r13], 16
	jne	SHORT $LN57@TabItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rcx, QWORD PTR label$GSCopy$1$[rbp-256]
	mov	rdx, rcx

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rcx, -1
	jae	SHORT $LN535@TabItemEx
	npad	3
$LL452@TabItemEx:
	movzx	eax, BYTE PTR [rdx]
	test	al, al
	je	SHORT $LN535@TabItemEx
	cmp	al, 35					; 00000023H
	jne	SHORT $LN455@TabItemEx
	cmp	BYTE PTR [rdx+1], al
	je	SHORT $LN535@TabItemEx
$LN455@TabItemEx:

; 3332 :         text_display_end++;

	inc	rdx
	cmp	rdx, -1
	jb	SHORT $LL452@TabItemEx
$LN535@TabItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8648 :             SetItemTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);

	sub	edx, ecx
	mov	r8, rcx
	lea	rcx, OFFSET FLAT:??_C@_04EBNJJJJI@?$CF?4?$CKs@
	call	?SetItemTooltip@ImGui@@YAXPEBDZZ	; ImGui::SetItemTooltip
$LN57@TabItemEx:

; 8649 : 
; 8650 :     IM_ASSERT(!is_tab_button || !(tab_bar->SelectedTabId == tab->ID && is_tab_button)); // TabItemButton should not be selected
; 8651 :     if (is_tab_button)

	cmp	BYTE PTR tv3008[rsp], 0
	movzx	eax, BYTE PTR tab_contents_visible$1$[rsp]
	movzx	ecx, BYTE PTR pressed$1$[rsp]
	cmovne	eax, ecx
$LN645@TabItemEx:
	movaps	xmm13, XMMWORD PTR [rsp+304]
	movaps	xmm12, XMMWORD PTR [rsp+320]
	movaps	xmm14, XMMWORD PTR [rsp+288]
$LN1@TabItemEx:
	mov	r15, QWORD PTR [rsp+432]

; 8654 : }

	mov	r12, QWORD PTR [rsp+520]
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+416]
	movaps	xmm7, XMMWORD PTR [rsp+400]
	add	rsp, 440				; 000001b8H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z ENDP ; ImGui::TabItemEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z
_TEXT	SEGMENT
label$ = 64
current_item$ = 72
items$ = 80
items_count$ = 88
height_in_items$dead$ = 96
?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z PROC		; ImGui::Combo, COMDAT

; 1951 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 1952 :     const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);

	mov	DWORD PTR [rsp+32], r9d
	mov	r9, r8
	call	?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ; ImGui::Combo

; 1953 :     return value_changed;
; 1954 : }

	add	rsp, 56					; 00000038H
	ret	0
?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z ENDP		; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z
_TEXT	SEGMENT
held$ = 48
hovered$ = 49
$T3 = 56
$T4 = 56
center$ = 56
bb$ = 56
c$5 = 72
c$6 = 72
$T7 = 72
$T8 = 72
bb_interact$ = 72
__$ArrayPad$ = 88
id$ = 208
pos$ = 216
?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z PROC		; ImGui::CloseButton, COMDAT

; 799  : {

$LN98:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 176				; 000000b0H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax

; 800  :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	xmm6, QWORD PTR [rdx]
	movsd	QWORD PTR bb$[rbp-105], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 806  :     ImRect bb_interact = bb;

	movss	xmm7, DWORD PTR bb$[rbp-101]
	mov	rdi, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm9, DWORD PTR [rsi+15696]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	xmm8, DWORD PTR [rsi+14612]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm9
	addss	xmm0, DWORD PTR [rdx]

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	xmm1, DWORD PTR [rsi+14616]
	addss	xmm8, xmm8

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm9, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	movss	xmm2, DWORD PTR [rdi+556]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	addss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	subss	xmm2, DWORD PTR [rdi+548]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 806  :     ImRect bb_interact = bb;

	movss	DWORD PTR bb_interact$[rbp-105], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm8, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 806  :     ImRect bb_interact = bb;

	movss	DWORD PTR bb_interact$[rbp-101], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	movss	xmm0, DWORD PTR [rdi+552]
	subss	xmm0, DWORD PTR [rdi+544]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm9, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 806  :     ImRect bb_interact = bb;

	movss	DWORD PTR bb_interact$[rbp-97], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	mulss	xmm2, xmm0
	movaps	xmm0, xmm8
	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 806  :     ImRect bb_interact = bb;

	movss	DWORD PTR bb_interact$[rbp-93], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	movaps	xmm1, xmm9
	subss	xmm1, xmm7
	mulss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 808  :     if (area_to_visible_ratio < 1.5f)

	movss	xmm0, DWORD PTR __real@3fc00000
	divss	xmm2, xmm1
	comiss	xmm0, xmm2
	jbe	SHORT $LN2@CloseButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movaps	xmm0, xmm8

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movaps	xmm1, xmm7

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, DWORD PTR __real@be800000
	cvttss2si eax, xmm0
	movaps	xmm0, xmm9
	subss	xmm0, xmm7
	movd	xmm3, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvtdq2ps xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, DWORD PTR __real@be800000
	cvttss2si eax, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	addss	xmm3, xmm8
	movd	xmm2, eax

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvtdq2ps xmm2, xmm2

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	DWORD PTR bb_interact$[rbp-105], xmm0
	subss	xmm1, xmm2
	movss	DWORD PTR bb_interact$[rbp-97], xmm3
	addss	xmm2, xmm9
	movss	DWORD PTR bb_interact$[rbp-101], xmm1
	movss	DWORD PTR bb_interact$[rbp-93], xmm2
$LN2@CloseButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 813  :     bool is_clipped = !ItemAdd(bb_interact, id);

	xor	r9d, r9d
	lea	rcx, QWORD PTR bb_interact$[rbp-105]
	xor	r8d, r8d
	mov	edx, r14d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 814  : 
; 815  :     bool hovered, held;
; 816  :     bool pressed = ButtonBehavior(bb_interact, id, &hovered, &held);

	lea	r9, QWORD PTR held$[rbp-105]
	mov	DWORD PTR [rsp+32], 0
	lea	r8, QWORD PTR hovered$[rbp-105]
	mov	edx, r14d
	lea	rcx, QWORD PTR bb_interact$[rbp-105]
	movzx	ebx, al
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	movzx	r15d, al

; 817  :     if (is_clipped)

	test	bl, bl
	je	$LN1@CloseButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	mov	ecx, 592				; 00000250H
	cmp	BYTE PTR held$[rbp-105], 0
	mov	eax, 576				; 00000240H
	movaps	XMMWORD PTR [rsp+96], xmm10
	cmovne	eax, ecx

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$6[rbp-105]
	movups	xmm0, XMMWORD PTR [rax+r8+14552]
	movups	XMMWORD PTR c$6[rbp-105], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r8+14552]
	movss	DWORD PTR c$6[rbp-93], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 824  :     if (hovered)

	cmp	BYTE PTR hovered$[rbp-105], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	addss	xmm8, xmm6
	movss	xmm6, DWORD PTR __real@3f000000
	addss	xmm9, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 824  :     if (hovered)

	movss	xmm10, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	mulss	xmm8, xmm6
	mulss	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR center$[rbp-105], xmm8
	movss	DWORD PTR center$[rbp-101], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 824  :     if (hovered)

	je	SHORT $LN82@CloseButto

; 825  :         window->DrawList->AddCircleFilled(center, ImMax(2.0f, g.FontSize * 0.5f + 1.0f), col);

	movss	xmm0, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR __real@40000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 825  :         window->DrawList->AddCircleFilled(center, ImMax(2.0f, g.FontSize * 0.5f + 1.0f), col);

	mov	rbx, QWORD PTR [rdi+728]
	mulss	xmm0, xmm6
	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN82@CloseButto
	comiss	xmm6, xmm2
	ja	SHORT $LN82@CloseButto

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR center$[rbp-105]
	mov	rcx, rbx
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	r8d, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r14d
	mov	rdx, QWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	mov	DWORD PTR [rbx+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rbx+120], 0
$LN82@CloseButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r8+14776]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$5[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 827  :     float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;

	movss	xmm7, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$5[rbp-105], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 827  :     float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;

	mulss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r8+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 827  :     float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;

	mulss	xmm7, DWORD PTR __real@3f350481
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	DWORD PTR c$5[rbp-93], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 827  :     float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;

	subss	xmm7, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 830  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);

	mov	rcx, QWORD PTR [rdi+728]
	subss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2546 : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	subss	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 830  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);

	movss	DWORD PTR [rsp+32], xmm10
	movaps	xmm6, xmm7
	lea	r8, QWORD PTR $T4[rbp-105]
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	lea	rdx, QWORD PTR $T8[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm6
	movaps	xmm1, xmm6
	addss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 830  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rbp-105], xmm0
	movaps	xmm0, xmm8
	movss	DWORD PTR $T4[rbp-101], xmm1
	addss	xmm0, xmm7
	movaps	xmm1, xmm9
	addss	xmm1, xmm7
	movss	DWORD PTR $T8[rbp-105], xmm0
	movss	DWORD PTR $T8[rbp-101], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 830  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 831  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	mov	rcx, QWORD PTR [rdi+728]
	lea	r8, QWORD PTR $T7[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 831  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	movss	DWORD PTR [rsp+32], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm7
	addss	xmm0, xmm8
	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 831  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	mov	r9d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm7, xmm8
	addss	xmm6, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 831  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	lea	rdx, QWORD PTR $T3[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rbp-105], xmm0
	movss	DWORD PTR $T7[rbp-101], xmm1
	movss	DWORD PTR $T3[rbp-105], xmm7
	movss	DWORD PTR $T3[rbp-101], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 831  :     window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine

; 832  : 
; 833  :     return pressed;

	movaps	xmm10, XMMWORD PTR [rsp+96]
	movzx	eax, r15b
$LN1@CloseButto:

; 834  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z ENDP		; ImGui::CloseButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndTabBar@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndTabBar@ImGui@@YAXXZ PROC				; ImGui::EndTabBar, COMDAT

; 7663 : {

$LN47:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 7664 :     ImGuiContext& g = *GImGui;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdi, rdx

; 7665 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rsi, QWORD PTR [rdx+16408]

; 7666 :     if (window->SkipItems)

	cmp	BYTE PTR [rsi+240], 0
	jne	$LN1@EndTabBar
	mov	QWORD PTR [rsp+48], rbx

; 7667 :         return;
; 7668 : 
; 7669 :     ImGuiTabBar* tab_bar = g.CurrentTabBar;

	mov	rbx, QWORD PTR [rdx+19832]

; 7670 :     if (tab_bar == NULL)

	test	rbx, rbx
	je	$LN45@EndTabBar

; 7671 :     {
; 7672 :         IM_ASSERT_USER_ERROR(tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!");
; 7673 :         return;
; 7674 :     }
; 7675 : 
; 7676 :     // Fallback in case no TabItem have been submitted
; 7677 :     if (tab_bar->WantLayout)

	cmp	BYTE PTR [rbx+107], 0
	je	SHORT $LN4@EndTabBar

; 7678 :         TabBarLayout(tab_bar);

	mov	rcx, rbx
	call	?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ; ImGui::TabBarLayout
	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN4@EndTabBar:

; 7682 :     if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)

	cmp	BYTE PTR [rbx+108], 0
	jne	SHORT $LN7@EndTabBar
	cmp	DWORD PTR [rbx+32], 0
	je	SHORT $LN7@EndTabBar

; 7679 : 
; 7680 :     // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
; 7681 :     const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);

	mov	eax, DWORD PTR [rbx+40]
	inc	eax
	cmp	eax, DWORD PTR [rdi+16240]

; 7682 :     if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)

	jl	SHORT $LN7@EndTabBar

; 7686 :     }
; 7687 :     else
; 7688 :     {
; 7689 :         window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->PrevTabsContentsHeight;

	movss	xmm1, DWORD PTR [rbx+64]
	addss	xmm1, DWORD PTR [rbx+56]
	jmp	SHORT $LN6@EndTabBar
$LN7@EndTabBar:

; 7684 :         tab_bar->CurrTabsContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, tab_bar->CurrTabsContentsHeight);

	movss	xmm1, DWORD PTR [rbx+56]
	movss	xmm0, DWORD PTR [rsi+316]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, DWORD PTR [rbx+60]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7684 :         tab_bar->CurrTabsContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, tab_bar->CurrTabsContentsHeight);

	movss	DWORD PTR [rbx+60], xmm0

; 7685 :         window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->CurrTabsContentsHeight;

	addss	xmm1, xmm0
$LN6@EndTabBar:

; 7690 :     }
; 7691 :     if (tab_bar->BeginCount > 1)

	movss	DWORD PTR [rsi+316], xmm1
	cmp	BYTE PTR [rbx+106], 1
	jle	SHORT $LN8@EndTabBar

; 7692 :         window->DC.CursorPos = tab_bar->BackupCursorPos;

	movsd	xmm0, QWORD PTR [rbx+128]
	movsd	QWORD PTR [rsi+312], xmm0
$LN8@EndTabBar:

; 7693 : 
; 7694 :     tab_bar->LastTabItemIdx = -1;
; 7695 :     if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)

	test	DWORD PTR [rbx+16], 1048576		; 00100000H
	mov	WORD PTR [rbx+112], -1
	jne	SHORT $LN9@EndTabBar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
$LN9@EndTabBar:
	movsxd	rcx, DWORD PTR [rdi+19880]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdi+19880], eax

; 1912 :     inline bool         empty() const                       { return Size == 0; }

	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7699 :     g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());

	jne	SHORT $LN11@EndTabBar
	xor	eax, eax
	jmp	SHORT $LN30@EndTabBar
$LN11@EndTabBar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	sub	rcx, 2
	shl	rcx, 4
	add	rcx, QWORD PTR [rdi+19888]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7570 :     return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LN30@EndTabBar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rcx+8]
	imul	rax, rax, 152				; 00000098H
	add	rax, QWORD PTR [rdx+19848]
$LN30@EndTabBar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7699 :     g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());

	mov	QWORD PTR [rdi+19832], rax
$LN45@EndTabBar:
	mov	rbx, QWORD PTR [rsp+48]
$LN1@EndTabBar:

; 7700 : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?EndTabBar@ImGui@@YAXXZ ENDP				; ImGui::EndTabBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z
_TEXT	SEGMENT
c$1 = 64
$T2 = 64
$T3 = 64
c$4 = 80
c$5 = 80
$T6 = 96
bb$ = 96
__$ArrayPad$ = 112
user_texture_id$ = 272
size$ = 280
uv0$ = 288
uv1$ = 296
tint_col$ = 304
border_col$ = 312
?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z PROC	; ImGui::Image, COMDAT

; 1013 : {

$LN102:
	push	rbp
	push	rbx
	push	rsi
	push	r12
	push	r13
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 224				; 000000e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1013 : {

	mov	r12, r9
	mov	r11, QWORD PTR border_col$[rbp-185]
	mov	r13, r8
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r10+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1015 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN71@Image

; 1019 :     if (border_col.w > 0.0f)

	movss	xmm0, DWORD PTR [r11+12]
	mov	QWORD PTR [rsp+272], rdi
	movaps	XMMWORD PTR [rsp+192], xmm7
	movaps	XMMWORD PTR [rsp+176], xmm8
	movaps	XMMWORD PTR [rsp+160], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm9, DWORD PTR [rbx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1015 :     if (window->SkipItems)

	movaps	XMMWORD PTR [rsp+144], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm7, xmm9
	movss	xmm10, DWORD PTR [rbx+316]
	addss	xmm7, DWORD PTR [rdx]
	movaps	xmm8, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1015 :     if (window->SkipItems)

	movaps	XMMWORD PTR [rsp+128], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm8, DWORD PTR [rdx+4]
	xorps	xmm11, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-185], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1019 :     if (border_col.w > 0.0f)

	comiss	xmm0, xmm11
	movss	DWORD PTR bb$[rbp-173], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-181], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1019 :     if (border_col.w > 0.0f)

	movss	DWORD PTR bb$[rbp-177], xmm7
	jbe	SHORT $LN3@Image
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm7, DWORD PTR __real@40000000

; 2545 : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	addss	xmm8, DWORD PTR __real@40000000
	movss	DWORD PTR bb$[rbp-177], xmm7
	movss	DWORD PTR bb$[rbp-173], xmm8
$LN3@Image:

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T2[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movaps	xmm0, xmm7
	subss	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rbp-181], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movss	xmm1, DWORD PTR __real@bf800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rbp-185], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10132:     ImGuiWindow* window = g.CurrentWindow;
; 10133: 
; 10134:     // Set item data
; 10135:     // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
; 10136:     g.LastItemData.ID = id;

	xor	edi, edi

; 10137:     g.LastItemData.Rect = bb;

	movups	xmm0, XMMWORD PTR bb$[rbp-185]

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	mov	DWORD PTR [r10+18620], eax

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	mov	DWORD PTR [r10+18616], edi
	movups	XMMWORD PTR [r10+18628], xmm0
	mov	DWORD PTR [r10+18624], edi
	movups	XMMWORD PTR [r10+18644], xmm0
	mov	QWORD PTR [r10+18592], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm8, DWORD PTR [rax+628]
	jbe	SHORT $LN44@Image
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm10
	jbe	SHORT $LN44@Image
	comiss	xmm7, DWORD PTR [rax+624]
	jbe	SHORT $LN44@Image
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm9
	jbe	SHORT $LN44@Image
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN35@Image
$LN44@Image:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], dil
	je	$LN99@Image
$LN35@Image:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$[rbp-177]
	lea	rcx, QWORD PTR bb$[rbp-185]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN36@Image

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN36@Image:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1025 :     if (border_col.w > 0.0f)

	movss	xmm0, DWORD PTR [r11+12]
	comiss	xmm0, xmm11
	jbe	$LN5@Image
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	xmm0, XMMWORD PTR [r11]

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$1[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1025 :     if (border_col.w > 0.0f)

	movaps	XMMWORD PTR [rsp+208], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	XMMWORD PTR c$1[rbp-185], xmm0

; 3100 :     c.w *= style.Alpha;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r10+14552]
	movss	DWORD PTR c$1[rbp-173], xmm0

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1027 :         window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);

	movss	xmm6, DWORD PTR __real@3f800000
	lea	r8, QWORD PTR bb$[rbp-177]
	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb$[rbp-185]
	movss	DWORD PTR [rsp+48], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1027 :         window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);

	mov	DWORD PTR [rsp+40], edi
	movss	DWORD PTR [rsp+32], xmm11
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	mov	rax, QWORD PTR tint_col$[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm7, xmm6
	subss	xmm8, xmm6
	addss	xmm9, xmm6
	addss	xmm10, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	xmm0, XMMWORD PTR [rax]

; 3100 :     c.w *= style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$5[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rbp-185], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	XMMWORD PTR c$5[rbp-185], xmm0

; 3100 :     c.w *= style.Alpha;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rbp-181], xmm8
	movss	DWORD PTR $T6[rbp-185], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	movss	DWORD PTR c$5[rbp-173], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rbp-181], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1028 :         window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));

	mov	rcx, QWORD PTR [rbx+728]
	lea	r9, QWORD PTR $T3[rbp-185]
	mov	DWORD PTR [rsp+48], eax
	lea	r8, QWORD PTR $T6[rbp-185]
	mov	QWORD PTR [rsp+40], r12
	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], r13
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
	movaps	xmm6, XMMWORD PTR [rsp+208]

; 1029 :     }

	jmp	$LN99@Image
$LN5@Image:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	mov	rax, QWORD PTR tint_col$[rbp-185]

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1032 :         window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));

	mov	rbx, QWORD PTR [rbx+728]
	mov	QWORD PTR [rsp+288], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR c$4[rbp-185], xmm0

; 3100 :     c.w *= style.Alpha;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r10+14552]
	movss	DWORD PTR c$4[rbp-173], xmm0

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1612 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	$LN100@Image
	mov	QWORD PTR [rsp+280], r14

; 1613 :         return;
; 1614 : 
; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

	mov	r14, QWORD PTR [rbx+152]

; 1616 :     if (push_texture_id)

	cmp	rsi, r14
	je	SHORT $LN70@Image

; 1617 :         PushTextureID(user_texture_id);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
$LN70@Image:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

	mov	edx, 6
	mov	rcx, rbx
	lea	r8d, QWORD PTR [rdx-2]
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

	mov	r9, r13
	mov	DWORD PTR [rsp+40], r15d
	lea	r8, QWORD PTR bb$[rbp-177]
	mov	QWORD PTR [rsp+32], r12
	lea	rdx, QWORD PTR bb$[rbp-185]
	mov	rcx, rbx
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

	cmp	rsi, r14
	mov	r14, QWORD PTR [rsp+280]
	je	SHORT $LN100@Image
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rbx+104], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 618  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	test	eax, eax
	je	SHORT $LN76@Image
	mov	rax, QWORD PTR [rbx+112]
	mov	rdi, QWORD PTR [rax+rcx*8-16]
$LN76@Image:

; 619  :     _OnChangedTextureID();

	mov	rcx, rbx
	mov	QWORD PTR [rbx+152], rdi
	call	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
$LN100@Image:
	mov	r15, QWORD PTR [rsp+288]
$LN99@Image:
	movaps	xmm9, XMMWORD PTR [rsp+160]
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
	movaps	xmm10, XMMWORD PTR [rsp+144]
	mov	rdi, QWORD PTR [rsp+272]
	movaps	xmm11, XMMWORD PTR [rsp+128]
$LN71@Image:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1034 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 224				; 000000e0H
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z ENDP	; ImGui::Image
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarGetTabName@ImGui@@YAPEBDPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab$ = 16
?TabBarGetTabName@ImGui@@YAPEBDPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z PROC ; ImGui::TabBarGetTabName, COMDAT

; 8020 :     if (tab->Window)

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN2@TabBarGetT

; 8021 :         return tab->Window->Name;

	mov	rax, QWORD PTR [rax+8]

; 8026 : }

	ret	0
$LN2@TabBarGetT:

; 8022 :     if (tab->NameOffset == -1)

	movsxd	rax, DWORD PTR [rdx+40]
	cmp	eax, -1
	jne	SHORT $LN3@TabBarGetT

; 8023 :         return "N/A";

	lea	rax, OFFSET FLAT:??_C@_03HPADHAHE@N?1A@

; 8026 : }

	ret	0
$LN3@TabBarGetT:

; 8024 :     IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
; 8025 :     return tab_bar->TabsNames.Buf.Data + tab->NameOffset;

	add	rax, QWORD PTR [rcx+144]

; 8026 : }

	ret	0
?TabBarGetTabName@ImGui@@YAPEBDPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z ENDP ; ImGui::TabBarGetTabName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z
_TEXT	SEGMENT
tv2374 = 32
window$1$ = 40
bb$ = 144
test_owner_id$1$ = 152
id$ = 152
out_hovered$ = 160
out_held$ = 168
tv2518 = 176
flags$ = 176
?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z PROC	; ImGui::ButtonBehavior, COMDAT

; 479  : {

$LN366:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H
	mov	r10d, DWORD PTR flags$[rsp]
	mov	r9, rcx

; 480  :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 488  :     if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)

	mov	ecx, r10d
	or	ecx, 1
	movaps	XMMWORD PTR [rsp+48], xmm6
	test	r10b, 7
	mov	edi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 488  :     if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)

	cmovne	ecx, r10d

; 493  :     ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);

	mov	r14d, ecx
	or	r14d, 32				; 00000020H
	test	ecx, 1008				; 000003f0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	r15, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 493  :     ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);

	cmovne	r14d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	QWORD PTR window$1$[rsp], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 493  :     ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);

	cmp	DWORD PTR [rbx+18616], edx
	jne	SHORT $LN63@ButtonBeha
	mov	edx, DWORD PTR [rbx+18620]
	jmp	SHORT $LN64@ButtonBeha
$LN63@ButtonBeha:
	mov	edx, DWORD PTR [rbx+18584]
$LN64@ButtonBeha:

; 494  :     if (flags & ImGuiButtonFlags_AllowOverlap)
; 495  :         item_flags |= ImGuiItemFlags_AllowOverlap;
; 496  :     if (flags & ImGuiButtonFlags_Repeat)
; 497  :         item_flags |= ImGuiItemFlags_ButtonRepeat;
; 498  : 
; 499  :     ImGuiWindow* backup_hovered_window = g.HoveredWindow;

	mov	rsi, QWORD PTR [rbx+16416]
	mov	ecx, edx
	bts	ecx, 9
	bt	r14d, 12
	cmovae	ecx, edx
	mov	edx, ecx
	or	edx, 2
	bt	r14d, 10
	cmovae	edx, ecx
	mov	DWORD PTR tv2374[rsp], edx

; 500  :     const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;

	bt	r14d, 11
	jae	SHORT $LN65@ButtonBeha
	test	rsi, rsi
	je	SHORT $LN65@ButtonBeha
	mov	rax, QWORD PTR [r15+968]
	cmp	QWORD PTR [rsi+968], rax
	jne	SHORT $LN65@ButtonBeha
	mov	bpl, 1

; 501  :     if (flatten_hovered_children)
; 502  :         g.HoveredWindow = window;

	mov	QWORD PTR [rbx+16416], r15
	jmp	SHORT $LN9@ButtonBeha
$LN65@ButtonBeha:

; 500  :     const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;

	xor	bpl, bpl
$LN9@ButtonBeha:

; 503  : 
; 504  : #ifdef IMGUI_ENABLE_TEST_ENGINE
; 505  :     // Alternate registration spot, for when caller didn't use ItemAdd()
; 506  :     if (id != 0 && g.LastItemData.ID != id)
; 507  :         IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
; 508  : #endif
; 509  : 
; 510  :     bool pressed = false;
; 511  :     bool hovered = ItemHoverable(bb, id, item_flags);

	mov	r8d, edx
	mov	rcx, r9
	mov	edx, edi
	xor	r12b, r12b
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@IH@Z ; ImGui::ItemHoverable
	movzx	r13d, al
	mov	DWORD PTR tv2518[rsp], r13d

; 512  : 
; 513  :     // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
; 514  :     if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))

	xor	r13d, r13d
	cmp	BYTE PTR [rbx+19544], r12b
	je	$LN246@ButtonBeha
	bt	r14d, 9
	jae	SHORT $LN246@ButtonBeha
	test	BYTE PTR [rbx+19548], 4
	jne	SHORT $LN246@ButtonBeha

; 515  :         if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))

	mov	ecx, 128				; 00000080H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN246@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4001 :     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 517  :             hovered = true;

	mov	cl, 1
	mov	DWORD PTR tv2518[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4002 :     g.HoveredId = id;

	mov	DWORD PTR [r10+16484], edi

; 4003 :     g.HoveredIdAllowOverlap = false;

	mov	BYTE PTR [r10+16492], r12b

; 4004 :     if (id != 0 && g.HoveredIdPreviousFrame != id)

	test	edi, edi
	je	SHORT $LN192@ButtonBeha
	cmp	DWORD PTR [r10+16488], edi
	je	SHORT $LN192@ButtonBeha

; 4005 :         g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;

	mov	QWORD PTR [r10+16496], r13
$LN192@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 519  :             if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)

	movss	xmm1, DWORD PTR [rbx+16496]
	movss	xmm2, DWORD PTR __real@3f333333
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [rbx+24]
	comiss	xmm2, xmm0
	jb	SHORT $LN12@ButtonBeha
	comiss	xmm1, xmm2
	jb	SHORT $LN12@ButtonBeha

; 520  :             {
; 521  :                 pressed = true;
; 522  :                 g.DragDropHoldJustPressedId = id;
; 523  :                 FocusWindow(window);

	xor	edx, edx
	mov	DWORD PTR [rbx+19664], edi
	mov	rcx, r15
	mov	r12b, 1
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
$LN246@ButtonBeha:

; 524  :             }
; 525  :         }
; 526  : 
; 527  :     if (flatten_hovered_children)

	mov	ecx, DWORD PTR tv2518[rsp]
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN12@ButtonBeha:
	test	bpl, bpl
	je	SHORT $LN13@ButtonBeha

; 528  :         g.HoveredWindow = backup_hovered_window;

	mov	QWORD PTR [rbx+16416], rsi
$LN13@ButtonBeha:

; 529  : 
; 530  :     // Mouse handling
; 531  :     const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;

	bt	r14d, 21

; 532  :     if (hovered)

	mov	edx, -1
	mov	esi, edi
	xorps	xmm6, xmm6
	cmovb	esi, r13d
	mov	DWORD PTR test_owner_id$1$[rsp], esi
	lea	r11d, QWORD PTR [rdx+2]
	test	cl, cl
	je	$LN35@ButtonBeha

; 533  :     {
; 534  :         // Poll mouse buttons
; 535  :         // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
; 536  :         // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
; 537  :         int mouse_button_clicked = -1;

	mov	ebp, edx

; 538  :         int mouse_button_released = -1;

	mov	r15d, edx

; 540  :             if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.

	test	r14b, r11b
	je	SHORT $LN2@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8919 :     if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)

	cmp	BYTE PTR [r10+3600], r13b
	je	SHORT $LN16@ButtonBeha

; 8920 :         return false;
; 8921 :     const float t = g.IO.MouseDownDuration[button];

	movss	xmm0, DWORD PTR [r10+14208]

; 8922 :     if (t < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN16@ButtonBeha

; 8923 :         return false;
; 8924 :     IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
; 8925 : 
; 8926 :     const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
; 8927 :     const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);

	ucomiss	xmm0, xmm6
	jp	SHORT $LN16@ButtonBeha
	jne	SHORT $LN16@ButtonBeha

; 8928 :     if (!pressed)
; 8929 :         return false;
; 8930 : 
; 8931 :     if (!TestKeyOwner(MouseButtonToKey(button), owner_id))

	mov	edx, esi
	mov	ecx, 641				; 00000281H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	cmovne	ebp, r13d
$LN16@ButtonBeha:

; 8948 :     return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)

	cmp	BYTE PTR [r10+14190], r13b
	je	SHORT $LN2@ButtonBeha
	mov	edx, esi
	mov	ecx, 641				; 00000281H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	cmovne	r15d, r13d
$LN2@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 540  :             if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.

	test	r14b, 2
	je	SHORT $LN208@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8919 :     if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)

	cmp	BYTE PTR [r10+3601], r13b
	je	SHORT $LN205@ButtonBeha

; 8920 :         return false;
; 8921 :     const float t = g.IO.MouseDownDuration[button];

	movss	xmm0, DWORD PTR [r10+14212]

; 8922 :     if (t < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN205@ButtonBeha

; 8923 :         return false;
; 8924 :     IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
; 8925 : 
; 8926 :     const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
; 8927 :     const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);

	ucomiss	xmm0, xmm6
	jp	SHORT $LN205@ButtonBeha
	jne	SHORT $LN205@ButtonBeha

; 8928 :     if (!pressed)
; 8929 :         return false;
; 8930 : 
; 8931 :     if (!TestKeyOwner(MouseButtonToKey(button), owner_id))

	mov	edx, esi
	mov	ecx, 642				; 00000282H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN205@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 542  :                 if (IsMouseClicked(button, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }

	cmp	ebp, -1
	cmove	ebp, r11d
$LN205@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8948 :     return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)

	cmp	BYTE PTR [r10+14191], r13b
	je	SHORT $LN208@ButtonBeha
	mov	edx, esi
	mov	ecx, 642				; 00000282H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN208@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 543  :                 if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }

	cmp	r15d, -1
	cmove	r15d, r11d
$LN208@ButtonBeha:

; 540  :             if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.

	test	r14b, 4
	je	SHORT $LN221@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8919 :     if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)

	mov	r11d, 2
	cmp	BYTE PTR [r10+3602], r13b
	je	SHORT $LN218@ButtonBeha

; 8920 :         return false;
; 8921 :     const float t = g.IO.MouseDownDuration[button];

	movss	xmm0, DWORD PTR [r10+14216]

; 8922 :     if (t < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN218@ButtonBeha

; 8923 :         return false;
; 8924 :     IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
; 8925 : 
; 8926 :     const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
; 8927 :     const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);

	ucomiss	xmm0, xmm6
	jp	SHORT $LN218@ButtonBeha
	jne	SHORT $LN218@ButtonBeha

; 8928 :     if (!pressed)
; 8929 :         return false;
; 8930 : 
; 8931 :     if (!TestKeyOwner(MouseButtonToKey(button), owner_id))

	mov	edx, esi
	mov	ecx, 643				; 00000283H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN218@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 542  :                 if (IsMouseClicked(button, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }

	cmp	ebp, -1
	cmove	ebp, r11d
$LN218@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8948 :     return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)

	cmp	BYTE PTR [r10+14192], r13b
	je	SHORT $LN221@ButtonBeha
	mov	edx, esi
	mov	ecx, 643				; 00000283H
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN221@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 543  :                 if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }

	cmp	r15d, -1
	cmove	r15d, r11d
$LN221@ButtonBeha:

; 544  :             }
; 545  : 
; 546  :         // Process initial action
; 547  :         if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))

	bt	r14d, 16
	jae	SHORT $LN19@ButtonBeha
	cmp	BYTE PTR [rbx+3624], r13b
	jne	$LN34@ButtonBeha
	cmp	BYTE PTR [rbx+3625], r13b
	jne	$LN34@ButtonBeha
	cmp	BYTE PTR [rbx+3626], r13b
	jne	$LN34@ButtonBeha
$LN19@ButtonBeha:

; 548  :         {
; 549  :             if (mouse_button_clicked != -1 && g.ActiveId != id)

	cmp	ebp, -1
	je	$LN251@ButtonBeha
	cmp	DWORD PTR [rbx+16504], edi
	je	$LN251@ButtonBeha

; 550  :             {
; 551  :                 if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))

	bt	r14d, 20
	jb	SHORT $LN21@ButtonBeha

; 552  :                     SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);

	lea	edx, DWORD PTR [rbp+641]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9668 :     ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);

	mov	rcx, r10
	call	?GetKeyOwnerData@ImGui@@YAPEAUImGuiKeyOwnerData@@PEAUImGuiContext@@W4ImGuiKey@@@Z ; ImGui::GetKeyOwnerData

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+4], edi
	mov	DWORD PTR [rax], edi

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+8], r13w
$LN21@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 553  :                 if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))

	test	r14b, 96				; 00000060H
	je	SHORT $LN223@ButtonBeha

; 554  :                 {
; 555  :                     SetActiveID(id, window);

	mov	rdx, QWORD PTR window$1$[rsp]
	mov	ecx, edi
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 556  :                     g.ActiveIdMouseButton = mouse_button_clicked;
; 557  :                     if (!(flags & ImGuiButtonFlags_NoNavFocus))

	mov	esi, r14d
	mov	DWORD PTR [rbx+16548], ebp
	and	esi, 262144				; 00040000H
	jne	SHORT $LN23@ButtonBeha

; 558  :                         SetFocusID(id, window);

	mov	rdx, QWORD PTR window$1$[rsp]
	mov	ecx, edi
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
$LN23@ButtonBeha:

; 559  :                     FocusWindow(window);

	mov	rcx, QWORD PTR window$1$[rsp]
	xor	edx, edx
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN22@ButtonBeha
$LN223@ButtonBeha:
	mov	esi, r14d
	and	esi, 262144				; 00040000H
$LN22@ButtonBeha:

; 560  :                 }
; 561  :                 if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))

	test	r14b, 16
	jne	SHORT $LN25@ButtonBeha
	bt	r14d, 8
	jae	SHORT $LN251@ButtonBeha
	movsxd	rax, ebp
	cmp	WORD PTR [rbx+rax*2+14170], 2
	jne	SHORT $LN251@ButtonBeha
$LN25@ButtonBeha:

; 562  :                 {
; 563  :                     pressed = true;
; 564  :                     if (flags & ImGuiButtonFlags_NoHoldingActiveId)

	bt	r14d, 17

; 565  :                         ClearActiveID();
; 566  :                     else
; 567  :                         SetActiveID(id, window); // Hold on ID
; 568  :                     if (!(flags & ImGuiButtonFlags_NoNavFocus))

	mov	ecx, r13d
	mov	rdx, r13
	mov	r12b, 1
	cmovae	rdx, QWORD PTR window$1$[rsp]
	cmovae	ecx, edi
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	test	esi, esi
	mov	rsi, QWORD PTR window$1$[rsp]
	jne	SHORT $LN28@ButtonBeha

; 569  :                         SetFocusID(id, window);

	mov	rdx, rsi
	mov	ecx, edi
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
$LN28@ButtonBeha:

; 570  :                     g.ActiveIdMouseButton = mouse_button_clicked;
; 571  :                     FocusWindow(window);

	xor	edx, edx
	mov	DWORD PTR [rbx+16548], ebp
	mov	rcx, rsi
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN24@ButtonBeha
$LN251@ButtonBeha:

; 572  :                 }
; 573  :             }
; 574  :             if (flags & ImGuiButtonFlags_PressedOnRelease)

	mov	rsi, QWORD PTR window$1$[rsp]
$LN24@ButtonBeha:
	mov	ebp, DWORD PTR tv2374[rsp]
	test	r14b, r14b
	jns	SHORT $LN30@ButtonBeha

; 575  :             {
; 576  :                 if (mouse_button_released != -1)

	cmp	r15d, -1
	je	SHORT $LN30@ButtonBeha

; 577  :                 {
; 578  :                     const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior

	test	bpl, 2
	je	SHORT $LN67@ButtonBeha
	movsxd	rax, r15d
	movss	xmm0, DWORD PTR [rbx+rax*4+14228]
	comiss	xmm0, DWORD PTR [rbx+120]
	jae	SHORT $LN31@ButtonBeha
$LN67@ButtonBeha:

; 579  :                     if (!has_repeated_at_least_once)
; 580  :                         pressed = true;

	mov	r12b, 1
$LN31@ButtonBeha:

; 581  :                     if (!(flags & ImGuiButtonFlags_NoNavFocus))

	bt	r14d, 18
	jb	SHORT $LN32@ButtonBeha

; 582  :                         SetFocusID(id, window);

	mov	rdx, rsi
	mov	ecx, edi
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
$LN32@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN30@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 589  :             if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))

	cmp	DWORD PTR [rbx+16504], edi
	jne	SHORT $LN260@ButtonBeha
	test	bpl, 2
	je	SHORT $LN260@ButtonBeha

; 590  :                 if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, test_owner_id, ImGuiInputFlags_Repeat))

	movsxd	rdx, DWORD PTR [rbx+16548]
	movss	xmm0, DWORD PTR [rbx+rdx*4+14208]
	comiss	xmm0, xmm6
	jbe	SHORT $LN260@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8919 :     if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)

	cmp	BYTE PTR [rdx+r10+3600], r13b
	je	SHORT $LN260@ButtonBeha

; 8920 :         return false;
; 8921 :     const float t = g.IO.MouseDownDuration[button];

	movss	xmm1, DWORD PTR [r10+rdx*4+14208]

; 8922 :     if (t < 0.0f)

	comiss	xmm6, xmm1
	ja	SHORT $LN260@ButtonBeha

; 8923 :         return false;
; 8924 :     IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
; 8925 : 
; 8926 :     const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
; 8927 :     const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);

	ucomiss	xmm1, xmm6
	jp	SHORT $LN244@ButtonBeha
	je	SHORT $LN179@ButtonBeha
$LN244@ButtonBeha:
	movss	xmm2, DWORD PTR [r10+120]
	comiss	xmm1, xmm2
	jbe	SHORT $LN260@ButtonBeha
	movss	xmm3, DWORD PTR [r10+124]
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [r10+24]
	call	?CalcTypematicRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicRepeatAmount
	test	eax, eax
	jle	SHORT $LN260@ButtonBeha
$LN179@ButtonBeha:

; 8928 :     if (!pressed)
; 8929 :         return false;
; 8930 : 
; 8931 :     if (!TestKeyOwner(MouseButtonToKey(button), owner_id))

	mov	esi, DWORD PTR test_owner_id$1$[rsp]
	lea	ecx, DWORD PTR [rdx+641]
	mov	edx, esi
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN34@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 594  :         if (pressed)

	mov	r12b, 1
	jmp	SHORT $LN235@ButtonBeha
$LN260@ButtonBeha:
	mov	esi, DWORD PTR test_owner_id$1$[rsp]
$LN34@ButtonBeha:
	test	r12b, r12b
	je	SHORT $LN253@ButtonBeha
$LN235@ButtonBeha:

; 595  :             g.NavDisableHighlight = true;

	mov	BYTE PTR [rbx+19158], 1
$LN253@ButtonBeha:

; 596  :     }
; 597  : 
; 598  :     // Gamepad/Keyboard navigation
; 599  :     // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
; 600  :     if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))

	mov	ecx, DWORD PTR tv2518[rsp]
	mov	r11d, 1
	mov	r15, QWORD PTR window$1$[rsp]
	lea	edx, QWORD PTR [r11-2]
$LN35@ButtonBeha:
	cmp	DWORD PTR [rbx+19104], edi
	jne	SHORT $LN38@ButtonBeha
	cmp	BYTE PTR [rbx+19158], r13b
	jne	SHORT $LN38@ButtonBeha
	cmp	BYTE PTR [rbx+19159], r13b
	je	SHORT $LN38@ButtonBeha
	mov	eax, DWORD PTR [rbx+16504]
	test	eax, eax
	je	SHORT $LN37@ButtonBeha
	cmp	eax, edi
	je	SHORT $LN37@ButtonBeha
	cmp	eax, DWORD PTR [r15+172]
	jne	SHORT $LN38@ButtonBeha
$LN37@ButtonBeha:

; 601  :         if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))

	bt	r14d, 19
	movzx	ecx, cl
	cmovae	ecx, r11d
	mov	DWORD PTR tv2518[rsp], ecx
$LN38@ButtonBeha:

; 602  :             hovered = true;
; 603  :     if (g.NavActivateDownId == id)

	cmp	DWORD PTR [rbx+19116], edi
	jne	$LN43@ButtonBeha

; 604  :     {
; 605  :         bool nav_activated_by_code = (g.NavActivateId == id);
; 606  :         bool nav_activated_by_inputs = (g.NavActivatePressedId == id);

	cmp	DWORD PTR [rbx+19120], edi
	sete	cl

; 607  :         if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))

	je	$LN40@ButtonBeha
	test	BYTE PTR tv2374[rsp], 2
	je	$LN40@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [r10+12020]
	maxss	xmm0, DWORD PTR [r10+12036]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 614  :             nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;

	movss	xmm3, DWORD PTR [rbx+124]
	movss	xmm2, DWORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, DWORD PTR [r10+13588]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8611 :     if (t1 == 0.0f)

	ucomiss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 614  :             nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;

	movaps	xmm1, xmm0
	subss	xmm1, DWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8611 :     if (t1 == 0.0f)

	jp	SHORT $LN135@ButtonBeha
	jne	SHORT $LN135@ButtonBeha

; 8612 :         return 1;

	mov	r13d, r11d
	jmp	SHORT $LN134@ButtonBeha
$LN135@ButtonBeha:

; 8613 :     if (t0 >= t1)

	comiss	xmm1, xmm0
	jae	SHORT $LN134@ButtonBeha

; 8614 :         return 0;
; 8615 :     if (repeat_rate <= 0.0f)

	comiss	xmm6, xmm3
	jb	SHORT $LN137@ButtonBeha

; 8616 :         return (t0 < repeat_delay) && (t1 >= repeat_delay);

	comiss	xmm2, xmm1
	jbe	SHORT $LN134@ButtonBeha
	comiss	xmm0, xmm2
	jb	SHORT $LN134@ButtonBeha
	mov	r13d, r11d
	jmp	SHORT $LN134@ButtonBeha
$LN137@ButtonBeha:

; 8617 :     const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);

	comiss	xmm2, xmm1
	jbe	SHORT $LN141@ButtonBeha
	mov	eax, edx
	jmp	SHORT $LN142@ButtonBeha
$LN141@ButtonBeha:
	subss	xmm1, xmm2
	divss	xmm1, xmm3
	cvttss2si eax, xmm1
$LN142@ButtonBeha:

; 8618 :     const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);

	comiss	xmm2, xmm0
	ja	SHORT $LN144@ButtonBeha
	subss	xmm0, xmm2
	divss	xmm0, xmm3
	cvttss2si edx, xmm0
$LN144@ButtonBeha:

; 8619 :     const int count = count_t1 - count_t0;

	sub	edx, eax

; 8620 :     return count;

	mov	r13d, edx
$LN134@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 614  :             nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;

	test	r13d, r13d
	setg	cl
$LN40@ButtonBeha:

; 615  :         }
; 616  :         if (nav_activated_by_code || nav_activated_by_inputs)

	cmp	DWORD PTR [rbx+19112], edi
	je	SHORT $LN42@ButtonBeha
	test	cl, cl
	je	SHORT $LN43@ButtonBeha
$LN42@ButtonBeha:

; 617  :         {
; 618  :             // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
; 619  :             pressed = true;
; 620  :             SetActiveID(id, window);

	mov	rdx, r15
	mov	ecx, edi
	mov	r12b, 1
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 621  :             g.ActiveIdSource = g.NavInputSource;

	mov	eax, DWORD PTR [rbx+19148]
	mov	DWORD PTR [rbx+16544], eax

; 622  :             if (!(flags & ImGuiButtonFlags_NoNavFocus))

	bt	r14d, 18
	jb	SHORT $LN247@ButtonBeha

; 623  :                 SetFocusID(id, window);

	mov	rdx, r15
	mov	ecx, edi
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID
$LN247@ButtonBeha:

; 624  :         }
; 625  :     }
; 626  : 
; 627  :     // Process while held
; 628  :     bool held = false;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN43@ButtonBeha:
	xor	bpl, bpl

; 629  :     if (g.ActiveId == id)

	cmp	DWORD PTR [rbx+16504], edi
	jne	$LN261@ButtonBeha

; 630  :     {
; 631  :         if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	eax, DWORD PTR [rbx+16544]
	cmp	eax, 1
	jne	$LN45@ButtonBeha

; 632  :         {
; 633  :             if (g.ActiveIdIsJustActivated)

	cmp	BYTE PTR [rbx+16516], bpl
	je	SHORT $LN47@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR [rbx+3592]
	movss	xmm0, DWORD PTR [rbx+3596]
	mov	rax, QWORD PTR bb$[rsp]
	subss	xmm1, DWORD PTR [rax]
	subss	xmm0, DWORD PTR [rax+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 634  :                 g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

	movss	DWORD PTR [rbx+16524], xmm1
	movss	DWORD PTR [rbx+16528], xmm0
$LN47@ButtonBeha:

; 635  : 
; 636  :             const int mouse_button = g.ActiveIdMouseButton;

	movsxd	rdi, DWORD PTR [rbx+16548]

; 637  :             if (mouse_button == -1)

	cmp	edi, -1
	jne	SHORT $LN48@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 641  :             }

	mov	r13d, DWORD PTR tv2518[rsp]
	jmp	$LN51@ButtonBeha
$LN48@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8907 :     return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.

	cmp	BYTE PTR [rdi+r10+3600], bpl
	je	SHORT $LN50@ButtonBeha
	lea	ecx, DWORD PTR [rdi+641]
	mov	edx, esi
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN50@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 644  :                 held = true;

	mov	r13d, DWORD PTR tv2518[rsp]
	mov	bpl, 1

; 645  :             }

	jmp	$LN51@ButtonBeha
$LN50@ButtonBeha:

; 646  :             else
; 647  :             {
; 648  :                 bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;

	mov	r13d, DWORD PTR tv2518[rsp]
	test	r13b, r13b
	je	SHORT $LN69@ButtonBeha
	test	r14b, 32				; 00000020H
	jne	SHORT $LN53@ButtonBeha
$LN69@ButtonBeha:

; 649  :                 bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;

	mov	eax, r14d
	shr	eax, 6
	test	al, 1

; 650  :                 if ((release_in || release_anywhere) && !g.DragDropActive)

	je	SHORT $LN54@ButtonBeha
$LN53@ButtonBeha:
	cmp	BYTE PTR [rbx+19544], bpl
	jne	SHORT $LN54@ButtonBeha

; 651  :                 {
; 652  :                     // Report as pressed when releasing the mouse (this is the most common path)
; 653  :                     bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;

	bt	r14d, 8
	jae	SHORT $LN71@ButtonBeha
	cmp	BYTE PTR [rdi+rbx+14190], bpl
	je	SHORT $LN71@ButtonBeha
	cmp	WORD PTR [rbx+rdi*2+14180], 2
	jne	SHORT $LN71@ButtonBeha
	mov	sil, 1
	jmp	SHORT $LN72@ButtonBeha
$LN71@ButtonBeha:
	xor	sil, sil
$LN72@ButtonBeha:

; 654  :                     bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>

	test	BYTE PTR tv2374[rsp], 2
	je	SHORT $LN73@ButtonBeha
	movss	xmm0, DWORD PTR [rbx+rdi*4+14228]
	comiss	xmm0, DWORD PTR [rbx+120]
	jb	SHORT $LN73@ButtonBeha
	mov	r10b, 1
	jmp	SHORT $LN74@ButtonBeha
$LN73@ButtonBeha:
	xor	r10b, r10b
$LN74@ButtonBeha:

; 655  :                     bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);

	mov	edx, DWORD PTR test_owner_id$1$[rsp]
	lea	ecx, DWORD PTR [rdi+641]
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner

; 656  :                     if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)

	test	sil, sil
	jne	SHORT $LN54@ButtonBeha
	test	r10b, r10b
	jne	SHORT $LN54@ButtonBeha
	test	al, al
	movzx	r12d, r12b
	mov	eax, 1
	cmovne	r12d, eax
$LN54@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN51@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 661  :             if (!(flags & ImGuiButtonFlags_NoNavFocus))

	bt	r14d, 18
	jb	SHORT $LN58@ButtonBeha

; 662  :                 g.NavDisableHighlight = true;

	mov	BYTE PTR [rbx+19158], 1

; 663  :         }

	jmp	SHORT $LN58@ButtonBeha
$LN45@ButtonBeha:

; 664  :         else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN263@ButtonBeha

; 665  :         {
; 666  :             // When activated using Nav, we hold on the ActiveID until activation button is released
; 667  :             if (g.NavActivateDownId != id)

	cmp	DWORD PTR [rbx+19116], edi
	je	SHORT $LN263@ButtonBeha
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN263@ButtonBeha:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 670  :         if (pressed)

	mov	r13d, DWORD PTR tv2518[rsp]
$LN58@ButtonBeha:
	test	r12b, r12b
	je	SHORT $LN59@ButtonBeha

; 671  :             g.ActiveIdHasBeenPressedBefore = true;

	mov	BYTE PTR [rbx+16519], 1
	jmp	SHORT $LN59@ButtonBeha
$LN261@ButtonBeha:

; 629  :     if (g.ActiveId == id)

	mov	r13d, DWORD PTR tv2518[rsp]
$LN59@ButtonBeha:

; 672  :     }
; 673  : 
; 674  :     if (out_hovered) *out_hovered = hovered;

	mov	rax, QWORD PTR out_hovered$[rsp]
	test	rax, rax
	je	SHORT $LN60@ButtonBeha
	mov	BYTE PTR [rax], r13b
$LN60@ButtonBeha:

; 675  :     if (out_held) *out_held = held;

	mov	rax, QWORD PTR out_held$[rsp]
	test	rax, rax
	je	SHORT $LN245@ButtonBeha
	mov	BYTE PTR [rax], bpl
$LN245@ButtonBeha:

; 676  : 
; 677  :     return pressed;
; 678  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	movzx	eax, r12b
	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ENDP	; ImGui::ButtonBehavior
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z
_TEXT	SEGMENT
flags$1$ = 64
label_size$ = 72
c$2 = 80
text_size$3 = 80
button_pos$ = 80
draw_list$GSCopy$1$ = 96
frame_padding$ = 104
text_ellipsis_clip_bb$ = 112
__$ArrayPad$ = 128
draw_list$ = 320
bb$ = 328
flags$ = 336
label$ = 352
tab_id$ = 360
close_button_id$ = 368
is_contents_visible$ = 376
out_just_closed$ = 384
out_text_clipped$ = 392
?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z PROC ; ImGui::TabItemLabelAndCloseButton, COMDAT

; 8727 : {

$LN120:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r15
	lea	rbp, QWORD PTR [rax-56]
	sub	rsp, 264				; 00000108H
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-136], xmm10
	movaps	XMMWORD PTR [rax-168], xmm12
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, QWORD PTR label$[rbp-256]
	mov	r10, rcx
	mov	r13, QWORD PTR out_just_closed$[rbp-256]
	mov	rbx, rdx
	mov	rsi, QWORD PTR out_text_clipped$[rbp-256]

; 8728 :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR draw_list$GSCopy$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rcx, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8727 : {

	mov	DWORD PTR flags$1$[rsp], r8d
	mov	QWORD PTR frame_padding$[rsp], r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r15, -1
	jae	SHORT $LN96@TabItemLab
$LL34@TabItemLab:
	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN96@TabItemLab
	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 35					; 00000023H
	jne	SHORT $LN93@TabItemLab
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN96@TabItemLab
$LN93@TabItemLab:

; 3332 :         text_display_end++;

	mov	rcx, rax
	cmp	rax, -1
	jb	SHORT $LL34@TabItemLab
$LN96@TabItemLab:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm2, DWORD PTR [rdi+15696]
	xorps	xmm12, xmm12

; 5418 :     if (text == text_display_end)

	cmp	r15, rcx
	jne	SHORT $LN31@TabItemLab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR label_size$[rsp+4], xmm2
	xorps	xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN118@TabItemLab
$LN31@TabItemLab:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$3[rsp]
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR [rdi+15688]
	mov	QWORD PTR [rsp+40], r15
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$3[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58
	mov	r8d, DWORD PTR flags$1$[rsp]
	mov	r10, QWORD PTR draw_list$GSCopy$1$[rsp]
	cvttss2si eax, xmm0

; 5428 : 
; 5429 :     return text_size;

	movss	xmm0, DWORD PTR text_size$3[rsp+4]
	movss	DWORD PTR label_size$[rsp+4], xmm0
	movd	xmm3, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm3, xmm3
$LN118@TabItemLab:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8731 :     if (out_just_closed)

	movss	DWORD PTR label_size$[rsp], xmm3
	test	r13, r13
	je	SHORT $LN2@TabItemLab

; 8732 :         *out_just_closed = false;

	mov	BYTE PTR [r13], 0
$LN2@TabItemLab:

; 8733 :     if (out_text_clipped)

	test	rsi, rsi
	je	SHORT $LN3@TabItemLab

; 8734 :         *out_text_clipped = false;

	mov	BYTE PTR [rsi], 0
$LN3@TabItemLab:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm10, DWORD PTR [rbx+8]
	movss	xmm2, DWORD PTR [rbx]
	movaps	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8736 :     if (bb.GetWidth() <= 1.0f)

	movss	xmm8, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8736 :     if (bb.GetWidth() <= 1.0f)

	comiss	xmm8, xmm0
	jae	$LN18@TabItemLab

; 8748 :     ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);

	movss	xmm4, DWORD PTR frame_padding$[rsp]
	movss	xmm1, DWORD PTR frame_padding$[rsp+4]
	addss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8748 :     ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);

	subss	xmm10, xmm4
	mov	QWORD PTR [rsp+328], r12

; 8749 :     ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;

	movss	DWORD PTR text_ellipsis_clip_bb$[rsp+12], xmm0
	movaps	XMMWORD PTR [rsp+160], xmm11
	movss	DWORD PTR text_ellipsis_clip_bb$[rsp], xmm2
	movss	DWORD PTR text_ellipsis_clip_bb$[rsp+8], xmm10
	addss	xmm1, DWORD PTR [rbx+4]
	movss	DWORD PTR text_ellipsis_clip_bb$[rsp+4], xmm1

; 8750 : 
; 8751 :     // Return clipped state ignoring the close button
; 8752 :     if (out_text_clipped)

	test	rsi, rsi
	je	SHORT $LN5@TabItemLab

; 8753 :     {
; 8754 :         *out_text_clipped = (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x;

	addss	xmm2, xmm3
	comiss	xmm2, xmm10
	seta	al
	mov	BYTE PTR [rsi], al
$LN5@TabItemLab:

; 8759 :     const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x * 2.0f - button_sz), bb.Min.y);

	mulss	xmm4, DWORD PTR __real@40000000

; 8760 : 
; 8761 :     // Close Button & Unsaved Marker
; 8762 :     // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
; 8763 :     //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
; 8764 :     //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
; 8765 :     //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
; 8766 :     bool close_button_pressed = false;

	xor	sil, sil

; 8767 :     bool close_button_visible = false;

	xor	dl, dl

; 8768 :     if (close_button_id != 0)

	mov	r12d, DWORD PTR close_button_id$[rbp-256]
	movss	xmm3, DWORD PTR [rbx+8]
	movss	xmm11, DWORD PTR [rdi+15696]
	movaps	xmm0, xmm3
	movss	xmm5, DWORD PTR [rbx]
	subss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm4, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR button_pos$[rsp+4], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8759 :     const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x * 2.0f - button_sz), bb.Min.y);

	subss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR button_pos$[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8768 :     if (close_button_id != 0)

	test	r12d, r12d
	je	SHORT $LN9@TabItemLab

; 8769 :         if (is_contents_visible || bb.GetWidth() >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))

	cmp	BYTE PTR is_contents_visible$[rbp-256], dl
	jne	SHORT $LN88@TabItemLab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movaps	xmm1, xmm3

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm11
	maxss	xmm0, DWORD PTR [rdi+14696]

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8769 :         if (is_contents_visible || bb.GetWidth() >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))

	comiss	xmm1, xmm0
	jb	SHORT $LN9@TabItemLab
$LN88@TabItemLab:

; 8770 :             if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id)

	mov	eax, DWORD PTR [rdi+16484]
	mov	ecx, DWORD PTR tab_id$[rbp-256]
	cmp	eax, ecx
	je	SHORT $LN10@TabItemLab
	cmp	eax, r12d
	je	SHORT $LN10@TabItemLab
	mov	eax, DWORD PTR [rdi+16504]
	cmp	eax, ecx
	je	SHORT $LN10@TabItemLab
	cmp	eax, r12d
	jne	SHORT $LN9@TabItemLab
$LN10@TabItemLab:

; 8771 :                 close_button_visible = true;

	mov	dl, 1
$LN9@TabItemLab:
	mov	QWORD PTR [rsp+256], r14

; 8772 :     bool unsaved_marker_visible = (flags & ImGuiTabItemFlags_UnsavedDocument) != 0 && (button_pos.x + button_sz <= bb.Max.x);

	test	r8b, 1
	je	SHORT $LN89@TabItemLab
	movaps	xmm0, xmm2
	addss	xmm0, xmm11
	comiss	xmm3, xmm0
	jb	SHORT $LN89@TabItemLab
	mov	r14b, 1
	jmp	SHORT $LN21@TabItemLab
$LN89@TabItemLab:
	xor	r14b, r14b
$LN21@TabItemLab:
	movaps	XMMWORD PTR [rsp+240], xmm6
	movaps	XMMWORD PTR [rsp+224], xmm7

; 8773 : 
; 8774 :     if (close_button_visible)

	test	dl, dl
	je	$LN11@TabItemLab

; 8775 :     {
; 8776 :         ImGuiLastItemData last_item_backup = g.LastItemData;

	movups	xmm7, XMMWORD PTR [rdi+18616]
	mov	ebx, DWORD PTR [rdi+18672]

; 8777 :         PushStyleVar(ImGuiStyleVar_FramePadding, frame_padding);

	lea	rdx, QWORD PTR frame_padding$[rsp]
	movups	xmm8, XMMWORD PTR [rdi+18632]
	mov	ecx, 11
	movsd	xmm6, QWORD PTR [rdi+18664]
	movaps	XMMWORD PTR [rsp+192], xmm9
	movups	xmm9, XMMWORD PTR [rdi+18648]
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar

; 8778 :         if (CloseButton(close_button_id, button_pos))

	lea	rdx, QWORD PTR button_pos$[rsp]
	mov	ecx, r12d
	call	?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z	; ImGui::CloseButton

; 8779 :             close_button_pressed = true;
; 8780 :         PopStyleVar();

	mov	r12d, 1
	movzx	esi, al
	mov	ecx, r12d
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 8784 :         if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))

	test	BYTE PTR flags$1$[rsp], 4
	movups	XMMWORD PTR [rdi+18616], xmm7
	movups	XMMWORD PTR [rdi+18632], xmm8
	movups	XMMWORD PTR [rdi+18648], xmm9
	movaps	xmm9, XMMWORD PTR [rsp+192]
	movsd	QWORD PTR [rdi+18664], xmm6
	mov	DWORD PTR [rdi+18672], ebx
	jne	SHORT $LN14@TabItemLab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8912 :     return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	xor	r8d, r8d
	lea	ecx, QWORD PTR [rdx+2]
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8784 :         if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))

	test	al, al
	cmovne	esi, r12d
$LN14@TabItemLab:

; 8798 :     {
; 8799 :         text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);

	subss	xmm10, xmm11
	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movaps	xmm1, xmm10

; 8800 :         text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;

	test	r14b, r14b
	jne	$LN94@TabItemLab
	jmp	$LN27@TabItemLab
$LN11@TabItemLab:

; 8785 :             close_button_pressed = true;
; 8786 :     }
; 8787 :     else if (unsaved_marker_visible)

	test	r14b, r14b
	je	$LN22@TabItemLab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rdi+14776]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movss	xmm6, DWORD PTR [rdi+14612]
	movss	xmm7, DWORD PTR [rdi+14616]
	addss	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$2[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	addss	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	mulss	xmm0, DWORD PTR [rdi+14552]
	movss	DWORD PTR c$2[rsp+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm2
	addss	xmm0, xmm11

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm6, xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm4
	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	addss	xmm6, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm7, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	mulss	xmm6, DWORD PTR __real@3f000000
	addss	xmm7, xmm4
	mulss	xmm7, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8790 :         RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8790 :         RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));

	unpcklps xmm0, xmm7
	mov	rcx, r10
	movq	rdx, xmm0
	call	?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
$LN22@TabItemLab:

; 8791 :     }
; 8792 : 
; 8793 :     // This is all rather complicated
; 8794 :     // (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)
; 8795 :     // FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..
; 8796 :     float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;

	movss	xmm1, DWORD PTR [rbx+8]
	subss	xmm1, xmm8

; 8797 :     if (close_button_visible || unsaved_marker_visible)

	test	r14b, r14b
	je	SHORT $LN16@TabItemLab

; 8798 :     {
; 8799 :         text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);

	movaps	xmm0, xmm11
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	subss	xmm10, xmm0
	movaps	xmm1, xmm10
$LN94@TabItemLab:

; 8800 :         text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;

	movaps	xmm12, xmm0
$LN27@TabItemLab:
	movss	xmm0, DWORD PTR text_ellipsis_clip_bb$[rsp+8]
	subss	xmm0, xmm12
	movss	DWORD PTR text_ellipsis_clip_bb$[rsp+8], xmm0
$LN16@TabItemLab:

; 8801 :         ellipsis_max_x = text_pixel_clip_bb.Max.x;
; 8802 :     }
; 8803 :     RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &label_size);

	mov	rcx, QWORD PTR draw_list$GSCopy$1$[rsp]
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR text_ellipsis_clip_bb$[rsp+8]
	mov	QWORD PTR [rsp+48], 0
	lea	rdx, QWORD PTR text_ellipsis_clip_bb$[rsp]
	mov	QWORD PTR [rsp+40], r15
	movaps	xmm3, xmm10
	movss	DWORD PTR [rsp+32], xmm1
	call	?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z ; ImGui::RenderTextEllipsis
	movaps	xmm11, XMMWORD PTR [rsp+160]
	movaps	xmm7, XMMWORD PTR [rsp+224]
	movaps	xmm6, XMMWORD PTR [rsp+240]
	mov	r14, QWORD PTR [rsp+256]
	mov	r12, QWORD PTR [rsp+328]

; 8804 : 
; 8805 : #if 0
; 8806 :     if (!is_contents_visible)
; 8807 :         g.Style.Alpha = backup_alpha;
; 8808 : #endif
; 8809 : 
; 8810 :     if (out_just_closed)

	test	r13, r13
	je	SHORT $LN18@TabItemLab

; 8811 :         *out_just_closed = close_button_pressed;

	mov	BYTE PTR [r13], sil
$LN18@TabItemLab:

; 8812 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+264]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm12, XMMWORD PTR [r11-120]
	mov	rsp, r11
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z ENDP ; ImGui::TabItemLabelAndCloseButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z
_TEXT	SEGMENT
label$dead$ = 48
flags$ = 56
all_on$1 = 64
flags_value$dead$ = 64
?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z PROC		; ImGui::CheckboxFlags, COMDAT

; 1186 : {

$LN15:
	mov	DWORD PTR [rsp+24], r8d
	push	rbx
	sub	rsp, 32					; 00000020H

; 1161 :     bool all_on = (*flags & flags_value) == flags_value;

	movzx	eax, BYTE PTR [rdx+2]

; 1162 :     bool any_on = (*flags & flags_value) != 0;
; 1163 :     bool pressed;
; 1164 :     if (!all_on && any_on)
; 1165 :     {
; 1166 :         ImGuiContext& g = *GImGui;
; 1167 :         g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
; 1168 :         pressed = Checkbox(label, &all_on);
; 1169 :     }
; 1170 :     else
; 1171 :     {
; 1172 :         pressed = Checkbox(label, &all_on);
; 1173 : 
; 1174 :     }
; 1175 :     if (pressed)

	lea	rcx, OFFSET FLAT:??_C@_09KEDLMDJL@Alpha?5Bar@
	and	al, 1

; 1186 : {

	mov	rbx, rdx

; 1175 :     if (pressed)

	lea	rdx, QWORD PTR all_on$1[rsp]
	mov	BYTE PTR all_on$1[rsp], al
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox
	test	al, al
	je	SHORT $LN10@CheckboxFl

; 1176 :     {
; 1177 :         if (all_on)

	cmp	BYTE PTR all_on$1[rsp], 0
	mov	ecx, DWORD PTR [rbx]
	je	SHORT $LN7@CheckboxFl

; 1178 :             *flags |= flags_value;

	bts	ecx, 16

; 1187 :     return CheckboxFlagsT(label, flags, flags_value);
; 1188 : }

	mov	DWORD PTR [rbx], ecx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@CheckboxFl:

; 1180 :             *flags &= ~flags_value;

	btr	ecx, 16

; 1187 :     return CheckboxFlagsT(label, flags, flags_value);
; 1188 : }

	mov	DWORD PTR [rbx], ecx
$LN10@CheckboxFl:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z ENDP		; ImGui::CheckboxFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z
_TEXT	SEGMENT
text_size$4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
bb$ = 72
frame_bb$ = 88
__$ArrayPad$ = 104
label$ = 304
size_arg$ = 312
?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z PROC	; ImGui::BeginListBox, COMDAT

; 6644 : {

$LN132:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 256				; 00000100H
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [r11-120], xmm10
	movaps	XMMWORD PTR [r11-136], xmm11
	movaps	XMMWORD PTR [r11-152], xmm12
	movaps	XMMWORD PTR [r11-168], xmm13
	movaps	XMMWORD PTR [rsp+112], xmm14
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 6645 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r15, rdx
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6647 :     if (window->SkipItems)

	cmp	BYTE PTR [rsi+240], 0
	jne	$LN77@BeginListB
	mov	QWORD PTR [r11+16], rbp

; 6651 :     const ImGuiID id = GetID(label);

	call	?GetID@ImGui@@YAIPEBD@Z			; ImGui::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6651 :     const ImGuiID id = GetID(label);

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN114@BeginListB
$LL16@BeginListB:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN114@BeginListB
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN111@BeginListB
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN114@BeginListB
$LN111@BeginListB:

; 3332 :         text_display_end++;

	mov	rdx, rcx
	cmp	rcx, -1
	jb	SHORT $LL16@BeginListB
$LN114@BeginListB:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm14, DWORD PTR [rbp+15696]

; 5418 :     if (text == text_display_end)

	xor	r12d, r12d
	xorps	xmm12, xmm12
	cmp	rdi, rdx
	jne	SHORT $LN13@BeginListB
	xorps	xmm8, xmm8

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN10@BeginListB
$LN13@BeginListB:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movaps	xmm2, xmm14
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [rbp+15688]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR text_size$4[rsp]
	mov	QWORD PTR [rsp+40], rdi
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$4[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm14, DWORD PTR text_size$4[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm8, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm8, xmm8
$LN10@BeginListB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6656 :     ImVec2 size = ImFloor(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10415:     return g.FontSize + g.Style.ItemSpacing.y;

	movss	xmm3, DWORD PTR [rbp+14632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6656 :     ImVec2 size = ImFloor(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));

	lea	rcx, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10415:     return g.FontSize + g.Style.ItemSpacing.y;

	addss	xmm3, DWORD PTR [rbp+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6656 :     ImVec2 size = ImFloor(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));

	movss	xmm1, DWORD PTR [rbx+14616]
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR [r15]
	addss	xmm1, xmm1
	mulss	xmm3, DWORD PTR __real@40e80000
	addss	xmm3, xmm1
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize

; 6659 :     ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm8, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvttss2si ecx, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm11, DWORD PTR [rsi+312]
	movss	xmm9, DWORD PTR [rsi+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvttss2si eax, DWORD PTR [rax+4]
	movd	xmm10, ecx
	cvtdq2ps xmm10, xmm10
	movd	xmm13, eax
	cvtdq2ps xmm13, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm10, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR frame_bb$[rsp], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	maxss	xmm13, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR frame_bb$[rsp+4], xmm9
	movss	DWORD PTR frame_bb$[rsp+8], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm13, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR frame_bb$[rsp+12], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6659 :     ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN6@BeginListB
	movaps	xmm0, xmm8
	addss	xmm0, DWORD PTR [rbx+14636]
	jmp	SHORT $LN7@BeginListB
$LN6@BeginListB:
	xorps	xmm0, xmm0
$LN7@BeginListB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1207 :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!

	mov	QWORD PTR [rbx+18592], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm6, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8447 :     return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));

	mov	rax, QWORD PTR [rbp+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	mov	rbp, QWORD PTR [rsp+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm7, xmm13
	addss	xmm7, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp], xmm11
	movss	DWORD PTR bb$[rsp+4], xmm9

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm9

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+8], xmm6
	movss	DWORD PTR bb$[rsp+12], xmm7

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	$LN112@BeginListB
	comiss	xmm7, DWORD PTR [rax+628]
	jbe	$LN112@BeginListB
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm11
	jbe	$LN112@BeginListB
	comiss	xmm6, DWORD PTR [rax+624]
	jbe	$LN112@BeginListB
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6671 :     if (label_size.x > 0.0f)

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
	comiss	xmm8, xmm12
	jbe	SHORT $LN4@BeginListB

; 6672 :     {
; 6673 :         ImVec2 label_pos = ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y);

	movaps	xmm6, xmm10
	movaps	xmm7, xmm9
	addss	xmm6, DWORD PTR [rbx+14636]
	addss	xmm7, DWORD PTR [rbx+14616]

; 6674 :         RenderText(label_pos, label);

	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, rdi
	movaps	xmm0, xmm6
	unpcklps xmm0, xmm7
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm1, DWORD PTR [rsi+336]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6674 :         RenderText(label_pos, label);

	addss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rsi+340]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm14, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm1, xmm8
	maxss	xmm0, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6675 :         window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, label_pos + label_size);

	movss	DWORD PTR [rsi+336], xmm1
	movss	DWORD PTR [rsi+340], xmm0
$LN4@BeginListB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm10, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6678 :     BeginChildFrame(id, frame_bb.GetSize());

	mov	ecx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm13, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6678 :     BeginChildFrame(id, frame_bb.GetSize());

	lea	rdx, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm10
	movss	DWORD PTR $T5[rsp+4], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6678 :     BeginChildFrame(id, frame_bb.GetSize());

	call	?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z ; ImGui::BeginChildFrame

; 6679 :     return true;

	mov	al, 1
	jmp	$LN1@BeginListB
$LN112@BeginListB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6664 :         ItemSize(bb.GetSize(), style.FramePadding.y);

	lea	rcx, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movaps	xmm0, xmm6
	subss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6664 :         ItemSize(bb.GetSize(), style.FramePadding.y);

	movss	xmm1, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6664 :         ItemSize(bb.GetSize(), style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10132:     ImGuiWindow* window = g.CurrentWindow;
; 10133: 
; 10134:     // Set item data
; 10135:     // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
; 10136:     g.LastItemData.ID = id;
; 10137:     g.LastItemData.Rect = bb;

	movups	xmm0, XMMWORD PTR bb$[rsp]

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;

	movups	xmm1, XMMWORD PTR frame_bb$[rsp]

; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	mov	DWORD PTR [r10+18620], eax

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	mov	DWORD PTR [r10+18616], r12d
	movups	XMMWORD PTR [r10+18628], xmm0
	mov	DWORD PTR [r10+18624], r12d
	movups	XMMWORD PTR [r10+18644], xmm1
	mov	QWORD PTR [r10+18592], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm7, DWORD PTR [rax+628]
	jbe	SHORT $LN85@BeginListB
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm9
	jbe	SHORT $LN85@BeginListB
	comiss	xmm6, DWORD PTR [rax+624]
	jbe	SHORT $LN85@BeginListB
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm11
	jbe	SHORT $LN85@BeginListB
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN76@BeginListB
$LN85@BeginListB:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], r12b
	je	SHORT $LN77@BeginListB
$LN76@BeginListB:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$[rsp+8]
	lea	rcx, QWORD PTR bb$[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN77@BeginListB

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN77@BeginListB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6666 :         return false;

	xor	al, al
$LN1@BeginListB:

; 6680 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+256]
	mov	rbx, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [rsp+112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP	; ImGui::BeginListBox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z
_TEXT	SEGMENT
label$ = 8
size_arg$ = 16
?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z PROC		; ImGui::Button, COMDAT

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	jmp	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z ENDP		; ImGui::Button
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarFindMostRecentlySelectedTabForActiveWindow, COMDAT

; 8000 :     ImGuiTabItem* most_recently_selected_tab = NULL;
; 8001 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	movsxd	r8, DWORD PTR [rcx]
	xor	eax, eax
	test	r8, r8
	jle	SHORT $LN15@TabBarFind
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, QWORD PTR [rcx+8]
	npad	2
$LL4@TabBarFind:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8004 :         if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)

	test	rax, rax
	je	SHORT $LN6@TabBarFind
	mov	ecx, DWORD PTR [rdx+20]
	cmp	DWORD PTR [rax+20], ecx
	jge	SHORT $LN2@TabBarFind
$LN6@TabBarFind:

; 8005 :             if (tab->Window && tab->Window->WasActive)

	mov	rcx, QWORD PTR [rdx+8]
	test	rcx, rcx
	je	SHORT $LN2@TabBarFind
	cmp	BYTE PTR [rcx+236], 0
	cmovne	rax, rdx
$LN2@TabBarFind:

; 8000 :     ImGuiTabItem* most_recently_selected_tab = NULL;
; 8001 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	add	rdx, 56					; 00000038H
	sub	r8, 1
	jne	SHORT $LL4@TabBarFind
$LN15@TabBarFind:

; 8006 :                 most_recently_selected_tab = tab;
; 8007 :     }
; 8008 :     return most_recently_selected_tab;
; 8009 : }

	ret	0
?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarFindMostRecentlySelectedTabForActiveWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextUnformatted@ImGui@@YAXPEBD0@Z
_TEXT	SEGMENT
text$ = 8
text_end$dead$ = 16
?TextUnformatted@ImGui@@YAXPEBD0@Z PROC			; ImGui::TextUnformatted, COMDAT

; 256  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	jmp	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
?TextUnformatted@ImGui@@YAXPEBD0@Z ENDP			; ImGui::TextUnformatted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z
_TEXT	SEGMENT
selected$1$ = 64
hovered$ = 65
was_selected$1$ = 66
held$ = 67
id$1$ = 68
tv1884 = 72
text_size$2 = 72
size$ = 72
label_size$ = 80
label$GSCopy$1$ = 88
c$3 = 96
clip_rect_vec4$4 = 112
clip_rect_vec4$5 = 112
p_min$ = 112
$T6 = 112
bb$ = 128
text_max$ = 144
pos$ = 144
p_max$ = 152
text_min$ = 160
__$ArrayPad$ = 168
label$ = 336
selected$ = 344
flags$ = 352
size_arg$ = 360
?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z PROC	; ImGui::Selectable, COMDAT

; 6483 : {

$LN189:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-72]
	sub	rsp, 288				; 00000120H
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-136], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6483 : {

	mov	rsi, r9
	mov	r12d, r8d
	mov	BYTE PTR selected$1$[rsp], dl
	mov	r14, rcx
	mov	QWORD PTR label$GSCopy$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rdi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6485 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN134@Selectable
	movaps	XMMWORD PTR [r11-88], xmm8

; 6492 :     ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	movaps	XMMWORD PTR [r11-104], xmm9
	mov	rcx, rbx
	movaps	XMMWORD PTR [r11-120], xmm10
	movaps	XMMWORD PTR [r11-152], xmm12
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6492 :     ImGuiID id = window->GetID(label);

	mov	r13d, eax
	mov	DWORD PTR id$1$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, r14

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r14, -1
	jae	SHORT $LN139@Selectable
$LL55@Selectable:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN139@Selectable
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN132@Selectable
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN139@Selectable
$LN132@Selectable:

; 3332 :         text_display_end++;

	mov	rdx, rcx
	cmp	rcx, -1
	jb	SHORT $LL55@Selectable
$LN139@Selectable:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm7, DWORD PTR [r9+15696]
	xorps	xmm11, xmm11

; 5418 :     if (text == text_display_end)

	cmp	r14, rdx
	jne	SHORT $LN52@Selectable
	xorps	xmm10, xmm10

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN187@Selectable
$LN52@Selectable:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movaps	xmm2, xmm7
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [r9+15688]
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR text_size$2[rsp]
	mov	QWORD PTR [rsp+40], r14
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$2[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm7, DWORD PTR text_size$2[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm10, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm10, xmm10
$LN187@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6494 :     ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);

	movss	xmm0, DWORD PTR [rsi+4]
	ucomiss	xmm0, xmm11
	movss	DWORD PTR label_size$[rsp+4], xmm7
	movss	DWORD PTR label_size$[rsp], xmm10
	jp	SHORT $LN138@Selectable
	je	SHORT $LN36@Selectable
$LN138@Selectable:
	movaps	xmm7, xmm0
$LN36@Selectable:
	movss	xmm6, DWORD PTR [rsi]
	ucomiss	xmm6, xmm11
	jp	SHORT $LN137@Selectable
	jne	SHORT $LN137@Selectable
	movaps	xmm6, xmm10
$LN137@Selectable:

; 6495 :     ImVec2 pos = window->DC.CursorPos;

	movss	xmm8, DWORD PTR [rbx+316]

; 6497 :     ItemSize(size, 0.0f);

	lea	rcx, QWORD PTR size$[rsp]
	movss	xmm12, DWORD PTR [rbx+312]
	xorps	xmm1, xmm1
	movss	DWORD PTR pos$[rbp-252], xmm8
	addss	xmm8, DWORD PTR [rbx+368]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR size$[rsp], xmm6
	movss	DWORD PTR size$[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6497 :     ItemSize(size, 0.0f);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 6498 : 
; 6499 :     // Fill horizontal space
; 6500 :     // We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
; 6501 :     const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;

	mov	r14d, r12d
	shr	r14d, 1
	and	r14b, 1

; 6502 :     const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;

	je	SHORT $LN39@Selectable
	movss	xmm9, DWORD PTR [rbx+608]

; 6503 :     const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;

	movss	xmm1, DWORD PTR [rbx+616]
	jmp	SHORT $LN42@Selectable
$LN39@Selectable:
	movss	xmm1, DWORD PTR [rbx+600]
	movaps	xmm9, xmm12
$LN42@Selectable:

; 6504 :     if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))

	movss	xmm0, DWORD PTR [rsi]
	ucomiss	xmm0, xmm11
	jp	SHORT $LN136@Selectable
	je	SHORT $LN4@Selectable
$LN136@Selectable:
	bt	r12d, 24
	jae	SHORT $LN3@Selectable
$LN4@Selectable:

; 6505 :         size.x = ImMax(label_size.x, max_x - min_x);

	subss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm6, xmm10
	maxss	xmm6, xmm1
$LN3@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rbp-256], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6509 :     const ImVec2 text_max(min_x + size.x, pos.y + size.y);

	addss	xmm6, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR bb$[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6508 :     const ImVec2 text_min = pos;

	movaps	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm12, XMMWORD PTR [rsp+176]
	movaps	xmm10, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6508 :     const ImVec2 text_min = pos;

	unpcklps xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6508 :     const ImVec2 text_min = pos;

	movsd	QWORD PTR text_min$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR text_max$[rbp-256], xmm6
	movss	DWORD PTR bb$[rbp-248], xmm6
	movss	DWORD PTR text_max$[rbp-252], xmm10
	movss	DWORD PTR bb$[rbp-244], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6513 :     if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)

	bt	r12d, 26
	jb	SHORT $LN5@Selectable

; 6514 :     {
; 6515 :         const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;

	test	r14b, r14b
	je	SHORT $LN43@Selectable
	xorps	xmm5, xmm5
	jmp	SHORT $LN44@Selectable
$LN43@Selectable:
	movss	xmm5, DWORD PTR [rdi+14628]
$LN44@Selectable:

; 6516 :         const float spacing_y = style.ItemSpacing.y;

	movss	xmm4, DWORD PTR [rdi+14632]

; 6517 :         const float spacing_L = IM_FLOOR(spacing_x * 0.50f);

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0

; 6518 :         const float spacing_U = IM_FLOOR(spacing_y * 0.50f);

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f000000
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	cvttss2si eax, xmm0

; 6519 :         bb.Min.x -= spacing_L;
; 6520 :         bb.Min.y -= spacing_U;
; 6521 :         bb.Max.x += (spacing_x - spacing_L);

	subss	xmm5, xmm2
	subss	xmm9, xmm2
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
	addss	xmm5, xmm6
	movss	DWORD PTR bb$[rbp-256], xmm9

; 6522 :         bb.Max.y += (spacing_y - spacing_U);

	subss	xmm4, xmm3
	subss	xmm8, xmm3
	movss	DWORD PTR bb$[rbp-248], xmm5
	addss	xmm4, xmm10
	movss	DWORD PTR bb$[rbp-252], xmm8
	movss	DWORD PTR bb$[rbp-244], xmm4
$LN5@Selectable:

; 6523 :     }
; 6524 :     //if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }
; 6525 : 
; 6526 :     // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackground for every Selectable..
; 6527 :     const float backup_clip_rect_min_x = window->ClipRect.Min.x;

	movss	xmm6, DWORD PTR [rbx+624]

; 6528 :     const float backup_clip_rect_max_x = window->ClipRect.Max.x;

	movss	xmm7, DWORD PTR [rbx+632]
	movaps	xmm10, XMMWORD PTR [rsp+208]
	movaps	xmm9, XMMWORD PTR [rsp+224]
	movaps	xmm8, XMMWORD PTR [rsp+240]

; 6529 :     if (span_all_columns)

	test	r14b, r14b
	je	SHORT $LN6@Selectable

; 6530 :     {
; 6531 :         window->ClipRect.Min.x = window->ParentWorkRect.Min.x;

	mov	eax, DWORD PTR [rbx+608]
	mov	DWORD PTR [rbx+624], eax

; 6532 :         window->ClipRect.Max.x = window->ParentWorkRect.Max.x;

	mov	eax, DWORD PTR [rbx+616]
	mov	DWORD PTR [rbx+632], eax
$LN6@Selectable:

; 6533 :     }
; 6534 : 
; 6535 :     const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;

	mov	eax, r12d

; 6536 :     const bool item_add = ItemAdd(bb, id, NULL, disabled_item ? ImGuiItemFlags_Disabled : ImGuiItemFlags_None);

	lea	rcx, QWORD PTR bb$[rbp-256]
	shr	eax, 3
	xor	r8d, r8d
	and	al, 1
	mov	edx, r13d
	movzx	r15d, al
	mov	r9d, r15d
	mov	DWORD PTR tv1884[rsp], r15d
	shl	r9d, 2
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 6537 :     if (span_all_columns)

	test	r14b, r14b
	je	SHORT $LN7@Selectable

; 6538 :     {
; 6539 :         window->ClipRect.Min.x = backup_clip_rect_min_x;

	movss	DWORD PTR [rbx+624], xmm6

; 6540 :         window->ClipRect.Max.x = backup_clip_rect_max_x;

	movss	DWORD PTR [rbx+632], xmm7
$LN7@Selectable:

; 6541 :     }
; 6542 : 
; 6543 :     if (!item_add)

	test	al, al
	je	$LN134@Selectable

; 6545 : 
; 6546 :     const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;

	mov	esi, DWORD PTR [rdi+18584]
	shr	esi, 2
	and	sil, 1

; 6547 :     if (disabled_item && !disabled_global) // Only testing this as an optimization

	test	r15b, r15b
	je	SHORT $LN9@Selectable
	test	sil, sil
	jne	SHORT $LN9@Selectable

; 6548 :         BeginDisabled();

	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
$LN9@Selectable:

; 6549 : 
; 6550 :     // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
; 6551 :     // which would be advantageous since most selectable are not selected.
; 6552 :     if (span_all_columns && window->DC.CurrentColumns)

	test	r14b, r14b
	je	$LN12@Selectable
	cmp	QWORD PTR [rbx+480], 0
	je	SHORT $LN10@Selectable

; 6553 :         PushColumnsBackground();

	call	?PushColumnsBackground@ImGui@@YAXXZ	; ImGui::PushColumnsBackground
	jmp	$LN12@Selectable
$LN10@Selectable:

; 6554 :     else if (span_all_columns && g.CurrentTable)

	cmp	QWORD PTR [rdi+19728], 0
	je	$LN12@Selectable
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2290 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2291 :     ImGuiWindow* window = g.CurrentWindow;
; 2292 :     ImGuiTable* table = g.CurrentTable;

	mov	rcx, QWORD PTR [rax+19728]
	mov	r9, QWORD PTR [rax+16408]

; 2293 : 
; 2294 :     // Optimization: avoid SetCurrentChannel() + PushClipRect()
; 2295 :     table->HostBackupInnerClipRect = window->ClipRect;

	movups	xmm0, XMMWORD PTR [r9+624]
	movups	XMMWORD PTR [rcx+360], xmm0

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR [rcx+328]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rcx+328]
	movss	xmm3, DWORD PTR [rcx+332]
	movss	xmm2, DWORD PTR [rcx+336]
	movss	xmm1, DWORD PTR [rcx+340]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r9+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$5[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$5[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$5[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$5[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$5[rsp]
	movsxd	r8, DWORD PTR [rax+88]
	mov	rdx, QWORD PTR [rax+96]
	add	r8, r8
	movups	XMMWORD PTR [rdx+r8*8-16], xmm0

; 2297 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);

	movzx	r8d, WORD PTR [rcx+550]
	mov	rcx, QWORD PTR [rcx+408]
	mov	rdx, QWORD PTR [r9+728]
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN12@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6559 :     if (flags & ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }

	mov	ecx, r12d
	shr	ecx, 3
	and	ecx, 131072				; 00020000H

; 6560 :     if (flags & ImGuiSelectableFlags_NoSetKeyOwner)     { button_flags |= ImGuiButtonFlags_NoSetKeyOwner; }
; 6561 :     if (flags & ImGuiSelectableFlags_SelectOnClick)     { button_flags |= ImGuiButtonFlags_PressedOnClick; }

	mov	edx, ecx
	bts	edx, 20
	bt	r12d, 27
	cmovae	edx, ecx

; 6562 :     if (flags & ImGuiSelectableFlags_SelectOnRelease)   { button_flags |= ImGuiButtonFlags_PressedOnRelease; }

	mov	ecx, edx
	or	ecx, 16
	bt	r12d, 22
	cmovae	ecx, edx

; 6563 :     if (flags & ImGuiSelectableFlags_AllowDoubleClick)  { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }

	mov	edx, ecx
	bts	edx, 7
	bt	r12d, 23
	cmovae	edx, ecx

; 6564 :     if ((flags & ImGuiSelectableFlags_AllowOverlap) || (g.LastItemData.InFlags & ImGuiItemFlags_AllowOverlap)) { button_flags |= ImGuiButtonFlags_AllowOverlap; }

	mov	ecx, edx
	or	ecx, 288				; 00000120H
	test	r12b, 4
	cmove	ecx, edx
	test	r12b, 16
	jne	SHORT $LN19@Selectable
	test	DWORD PTR [rdi+18620], 512		; 00000200H
	je	SHORT $LN18@Selectable
$LN19@Selectable:
	bts	ecx, 12
$LN18@Selectable:

; 6565 : 
; 6566 :     const bool was_selected = selected;

	movzx	eax, BYTE PTR selected$1$[rsp]

; 6567 :     bool hovered, held;
; 6568 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);

	lea	r9, QWORD PTR held$[rsp]
	mov	DWORD PTR [rsp+32], ecx
	lea	r8, QWORD PTR hovered$[rsp]
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	BYTE PTR was_selected$1$[rsp], al
	mov	edx, r13d
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 6569 : 
; 6570 :     // Auto-select when moved into
; 6571 :     // - This will be more fully fleshed in the range-select branch
; 6572 :     // - This is not exposed as it won't nicely work with some user side handling of shift/control
; 6573 :     // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
; 6574 :     //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
; 6575 :     //   - (2) usage will fail with clipped items
; 6576 :     //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
; 6577 :     if ((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)

	movss	xmm4, DWORD PTR bb$[rbp-244]
	movzx	r15d, al
	movss	xmm5, DWORD PTR bb$[rbp-248]
	movss	xmm6, DWORD PTR bb$[rbp-252]
	movss	xmm7, DWORD PTR bb$[rbp-256]
	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movzx	r13d, BYTE PTR hovered$[rsp]
	bt	r12d, 21
	jae	SHORT $LN142@Selectable
	mov	ecx, DWORD PTR [rdi+19128]
	test	ecx, ecx
	je	SHORT $LN142@Selectable
	mov	eax, DWORD PTR [rdi+18580]
	cmp	DWORD PTR [rdi+19132], eax
	mov	eax, DWORD PTR id$1$[rsp]
	jne	SHORT $LN21@Selectable

; 6578 :         if (g.NavJustMovedToId == id)

	cmp	ecx, eax
	jne	SHORT $LN21@Selectable

; 6579 :             selected = pressed = true;

	mov	r15b, 1
	mov	BYTE PTR selected$1$[rsp], r15b

; 6580 : 
; 6581 :     // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
; 6582 :     if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))

	jmp	SHORT $LN23@Selectable
$LN142@Selectable:
	mov	eax, DWORD PTR id$1$[rsp]
$LN21@Selectable:
	test	r15b, r15b
	jne	SHORT $LN23@Selectable
	test	r13b, r13b
	je	$LN131@Selectable
	bt	r12d, 25
	jae	$LN26@Selectable
$LN23@Selectable:

; 6583 :     {
; 6584 :         if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)

	cmp	BYTE PTR [rdi+19159], 0
	jne	SHORT $LN24@Selectable
	cmp	QWORD PTR [rdi+19096], rbx
	jne	SHORT $LN24@Selectable
	mov	edx, DWORD PTR [rbx+400]
	cmp	DWORD PTR [rdi+19152], edx
	jne	SHORT $LN24@Selectable
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	movss	xmm2, DWORD PTR [rbx+328]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6586 :             SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)

	lea	r9, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	movss	xmm3, DWORD PTR [rbx+332]
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6586 :             SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)

	mov	r8d, DWORD PTR [rdi+18580]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	subss	xmm0, xmm2
	movaps	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6586 :             SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)

	mov	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	movaps	xmm0, xmm5
	subss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3037 :     inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }

	movaps	xmm1, xmm4
	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+8], xmm0
	movss	DWORD PTR $T6[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6586 :             SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)

	call	?SetNavID@ImGui@@YAXIW4ImGuiNavLayer@@IAEBUImRect@@@Z ; ImGui::SetNavID

; 6587 :             g.NavDisableHighlight = true;

	mov	BYTE PTR [rdi+19158], 1
$LN24@Selectable:

; 6588 :         }
; 6589 :     }
; 6590 :     if (pressed)

	test	r15b, r15b
	je	SHORT $LN25@Selectable
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	eax, DWORD PTR [r11+16504]
	cmp	eax, DWORD PTR id$1$[rsp]
	je	SHORT $LN99@Selectable
	test	eax, eax
	jne	SHORT $LN98@Selectable
$LN99@Selectable:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [r11+16520], 257		; 00000101H
$LN98@Selectable:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [r11+18624], 4
$LN25@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6594 :     if (selected != was_selected) //-V547

	movzx	eax, BYTE PTR selected$1$[rsp]
	cmp	al, BYTE PTR was_selected$1$[rsp]
	je	SHORT $LN26@Selectable

; 6595 :         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;

	or	DWORD PTR [rdi+18624], 8
$LN26@Selectable:

; 6596 : 
; 6597 :     // Render
; 6598 :     if (hovered || selected)

	test	r13b, r13b
	jne	SHORT $LN28@Selectable
$LN131@Selectable:
	cmp	BYTE PTR selected$1$[rsp], 0
	je	$LN79@Selectable
$LN28@Selectable:

; 6599 :     {
; 6600 :         const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	cmp	BYTE PTR held$[rsp], 0
	je	SHORT $LN45@Selectable
	test	r13b, r13b
	je	SHORT $LN45@Selectable
	mov	eax, 26
	jmp	SHORT $LN46@Selectable
$LN45@Selectable:
	xor	eax, eax
	test	r13b, r13b
	setne	al
	add	rax, 24
$LN46@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3491 :     ImGuiWindow* window = g.CurrentWindow;

	mov	r10, QWORD PTR [r11+16408]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$3[rsp]
	add	rax, 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6601 :         RenderFrame(bb.Min, bb.Max, col, false, 0.0f);

	movss	DWORD PTR p_max$[rbp-256], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6601 :         RenderFrame(bb.Min, bb.Max, col, false, 0.0f);

	movss	DWORD PTR p_max$[rbp-252], xmm4
	movss	DWORD PTR p_min$[rsp], xmm7
	movss	DWORD PTR p_min$[rsp+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r11+rax*8+14552]
	movups	XMMWORD PTR c$3[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r11+14552]
	movss	DWORD PTR c$3[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 3492 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	mov	rcx, QWORD PTR [r10+728]
	lea	rdx, QWORD PTR p_min$[rsp]

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax

; 3492 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	mov	DWORD PTR [rsp+40], 0
	lea	r8, QWORD PTR p_max$[rbp-256]
	movss	DWORD PTR [rsp+32], xmm11
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN79@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6603 :     RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);

	mov	edx, DWORD PTR id$1$[rsp]
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	r8d, 10
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 6604 : 
; 6605 :     if (span_all_columns && window->DC.CurrentColumns)

	test	r14b, r14b
	je	$LN31@Selectable
	cmp	QWORD PTR [rbx+480], 0
	je	SHORT $LN29@Selectable

; 6606 :         PopColumnsBackground();

	call	?PopColumnsBackground@ImGui@@YAXXZ	; ImGui::PopColumnsBackground
	jmp	$LN31@Selectable
$LN29@Selectable:

; 6607 :     else if (span_all_columns && g.CurrentTable)

	cmp	QWORD PTR [rdi+19728], 0
	je	$LN31@Selectable
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2302 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2303 :     ImGuiWindow* window = g.CurrentWindow;
; 2304 :     ImGuiTable* table = g.CurrentTable;

	mov	rcx, QWORD PTR [rax+19728]
	mov	r11, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, DWORD PTR [rcx+116]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [rcx+360]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rcx+360]
	movss	xmm3, DWORD PTR [rcx+364]
	movss	xmm2, DWORD PTR [rcx+368]
	movss	xmm1, DWORD PTR [rcx+372]
	movss	DWORD PTR clip_rect_vec4$4[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$4[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$4[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$4[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	imul	r10, rax, 112				; 00000070H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r11+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	add	r10, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r11+624], xmm0

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r11+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$4[rsp]
	movsxd	r9, DWORD PTR [rax+88]
	mov	rdx, QWORD PTR [rax+96]
	add	r9, r9
	movups	XMMWORD PTR [rdx+r9*8-16], xmm0

; 2309 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);

	movzx	r8d, WORD PTR [r10+92]
	mov	rdx, QWORD PTR [r11+728]
	mov	rcx, QWORD PTR [rcx+408]
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN31@Selectable:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6610 :     RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);

	mov	r8, QWORD PTR label$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	lea	rax, QWORD PTR [rdi+14712]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, QWORD PTR text_max$[rbp-256]
	lea	rax, QWORD PTR label_size$[rsp]
	xor	r9d, r9d
	lea	rcx, QWORD PTR text_min$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped

; 6611 : 
; 6612 :     // Automatically close popups
; 6613 :     if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(g.LastItemData.InFlags & ImGuiItemFlags_SelectableDontClosePopup))

	test	r15b, r15b
	je	SHORT $LN32@Selectable
	test	DWORD PTR [rbx+20], 67108864		; 04000000H
	je	SHORT $LN32@Selectable
	test	r12b, 1
	jne	SHORT $LN32@Selectable
	test	BYTE PTR [rdi+18620], 32		; 00000020H
	jne	SHORT $LN32@Selectable

; 6614 :         CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN32@Selectable:

; 6615 : 
; 6616 :     if (disabled_item && !disabled_global)

	cmp	BYTE PTR tv1884[rsp], 0
	je	SHORT $LN33@Selectable
	test	sil, sil
	jne	SHORT $LN33@Selectable

; 6617 :         EndDisabled();

	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled
$LN33@Selectable:

; 6618 : 
; 6619 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
; 6620 :     return pressed; //-V1020

	movzx	eax, r15b
	jmp	SHORT $LN1@Selectable
$LN134@Selectable:

; 6544 :         return false;

	xor	al, al
$LN1@Selectable:

; 6621 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ENDP	; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
_TEXT	SEGMENT
$T1 = 64
label$ = 96
buf$ = 104
buf_size$ = 112
flags$ = 120
callback$ = 128
user_data$ = 136
?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputText, COMDAT

; 3656 : {

$LN6:
	sub	rsp, 88					; 00000058H

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR callback$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	DWORD PTR [rsp+40], r9d
	mov	r9d, r8d
	mov	r8, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T1[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	xor	edx, edx
	mov	QWORD PTR [rsp+32], rax
	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3659 : }

	add	rsp, 88					; 00000058H
	ret	0
?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ
_TEXT	SEGMENT
col$ = 112
fmt$ = 120
?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ PROC		; ImGui::TextColored, COMDAT

; 279  : {

$LN27:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 281  :     va_start(args, fmt);

	lea	rbp, QWORD PTR [rax+24]
	mov	rsi, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR [rax-72], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 279  : {

	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR [rax-72]
	movups	xmm0, XMMWORD PTR [rbx+14776]
	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR [rax-68], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 289  :     TextV(fmt, args);

	mov	rdx, rbp
	mov	rcx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 289  :     TextV(fmt, args);

	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [r8+18824]
	cmp	eax, 1
	jl	SHORT $LN13@TextColore
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
$LN13@TextColore:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 284  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ ENDP		; ImGui::TextColored
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z
_TEXT	SEGMENT
v_min$GSCopy$ = 64
__$ArrayPad$ = 72
label$ = 96
v$ = 104
v_speed$ = 112
v_min$ = 120
v_max$ = 128
format$ = 136
flags$dead$ = 144
?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z PROC		; ImGui::DragFloat, COMDAT

; 2518 : {

$LN4:
	mov	r11, rsp
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR format$[rsp]

; 2519 :     return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);

	mov	r8, rdx
	mov	QWORD PTR [r11-40], rax
	mov	edx, 8
	lea	rax, QWORD PTR [r11+40]
	movss	DWORD PTR v_min$GSCopy$[rsp], xmm3
	mov	QWORD PTR [r11-48], rax
	movaps	xmm3, xmm2
	lea	rax, QWORD PTR [r11-24]
	mov	QWORD PTR [r11-56], rax
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z ; ImGui::DragScalar

; 2520 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ENDP		; ImGui::DragFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Checkbox@ImGui@@YA_NPEBDPEA_N@Z
_TEXT	SEGMENT
hovered$ = 64
held$ = 65
text_size$4 = 72
$T5 = 72
$T6 = 72
c$7 = 80
c$8 = 80
$T9 = 80
total_bb$ = 80
label_pos$ = 96
__$ArrayPad$ = 104
label$ = 288
v$ = 296
?Checkbox@ImGui@@YA_NPEBDPEA_N@Z PROC			; ImGui::Checkbox, COMDAT

; 1102 : {

$LN119:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 240				; 000000f0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-185], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1102 : {

	mov	r15, rdx
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1104 :     if (window->SkipItems)

	cmp	BYTE PTR [rsi+240], 0
	jne	$LN99@Checkbox

; 1109 :     const ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	mov	rcx, rsi
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1109 :     const ImGuiID id = window->GetID(label);

	mov	r12d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN101@Checkbox
$LL25@Checkbox:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN101@Checkbox
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN98@Checkbox
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN101@Checkbox
$LN98@Checkbox:

; 3332 :         text_display_end++;

	mov	rdx, rcx
	cmp	rcx, -1
	jb	SHORT $LL25@Checkbox
$LN101@Checkbox:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm2, DWORD PTR [r14+15696]
	xorps	xmm9, xmm9

; 5418 :     if (text == text_display_end)

	cmp	rdi, rdx
	jne	SHORT $LN22@Checkbox
	xorps	xmm11, xmm11

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN19@Checkbox
$LN22@Checkbox:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [r14+15688]
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR text_size$4[rbp-185]
	mov	QWORD PTR [rsp+40], rdi
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$4[rbp-185]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm2, DWORD PTR text_size$4[rbp-181]
	cvttss2si eax, xmm0
	movd	xmm11, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm11, xmm11
$LN19@Checkbox:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1114 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	comiss	xmm11, xmm9
	movss	xmm3, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm6, DWORD PTR [r14+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1114 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	movaps	xmm1, xmm3
	movss	xmm10, DWORD PTR [rsi+312]
	addss	xmm1, xmm3
	movss	xmm7, DWORD PTR [rsi+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1114 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm6, DWORD PTR [r14+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1114 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	jbe	SHORT $LN11@Checkbox
	movaps	xmm0, xmm11
	addss	xmm0, DWORD PTR [rbx+14636]
	jmp	SHORT $LN12@Checkbox
$LN11@Checkbox:
	xorps	xmm0, xmm0
$LN12@Checkbox:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-185], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1114 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-181], xmm7

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T5[rbp-185]

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-173], xmm1

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
	movss	DWORD PTR $T5[rbp-181], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movaps	xmm1, xmm3

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-177], xmm0

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-185], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1116 :     if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR total_bb$[rbp-185]
	mov	edx, r12d
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN99@Checkbox
	movaps	XMMWORD PTR [rsp+192], xmm8

; 1120 :     }
; 1121 : 
; 1122 :     bool hovered, held;
; 1123 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	lea	r9, QWORD PTR held$[rbp-185]
	movaps	XMMWORD PTR [rsp+128], xmm12
	lea	r8, QWORD PTR hovered$[rbp-185]
	mov	edx, r12d
	movaps	XMMWORD PTR [rsp+112], xmm13
	lea	rcx, QWORD PTR total_bb$[rbp-185]
	mov	DWORD PTR [rsp+32], 0
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	movzx	r14d, al

; 1124 :     if (pressed)

	test	al, al
	je	SHORT $LN4@Checkbox

; 1125 :     {
; 1126 :         *v = !(*v);

	cmp	BYTE PTR [r15], 0
	sete	cl
	mov	BYTE PTR [r15], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	edx, DWORD PTR [rcx+16504]
	cmp	edx, r12d
	je	SHORT $LN64@Checkbox
	test	edx, edx
	jne	SHORT $LN63@Checkbox
$LN64@Checkbox:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN63@Checkbox:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
$LN4@Checkbox:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm8, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1131 :     RenderNavHighlight(total_bb, id);

	lea	rcx, QWORD PTR total_bb$[rbp-185]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm12, xmm7
	addss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1131 :     RenderNavHighlight(total_bb, id);

	mov	r8d, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm12, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1131 :     RenderNavHighlight(total_bb, id);

	mov	edx, r12d
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1132 :     RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

	cmp	BYTE PTR held$[rbp-185], 0
	movss	xmm13, DWORD PTR [rbx+14620]
	movzx	ecx, BYTE PTR hovered$[rbp-185]
	je	SHORT $LN13@Checkbox
	test	cl, cl
	je	SHORT $LN13@Checkbox
	mov	eax, 9
	jmp	SHORT $LN14@Checkbox
$LN13@Checkbox:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	rax, 7
$LN14@Checkbox:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 14
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$8[rbp-185], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$8[rbp-185]
	movss	DWORD PTR c$8[rbp-173], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1132 :     RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

	movaps	xmm0, xmm8
	movss	DWORD PTR [rsp+32], xmm13
	movaps	xmm1, xmm10
	unpcklps xmm0, xmm12
	unpcklps xmm1, xmm7
	movq	rdx, xmm0
	movq	rcx, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1132 :     RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	r9b, 1
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rbp-185]
	movups	xmm0, XMMWORD PTR [rax+15064]
	movups	XMMWORD PTR c$7[rbp-185], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$7[rbp-173], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1134 :     bool mixed_value = (g.LastItemData.InFlags & ImGuiItemFlags_MixedValue) != 0;

	mov	r12d, DWORD PTR [rbx+18620]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1134 :     bool mixed_value = (g.LastItemData.InFlags & ImGuiItemFlags_MixedValue) != 0;

	movaps	xmm13, XMMWORD PTR [rsp+112]
	shr	r12d, 6
	and	r12b, 1

; 1135 :     if (mixed_value)

	je	SHORT $LN5@Checkbox

; 1139 :         ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));

	divss	xmm6, DWORD PTR __real@40666666

; 1140 :         window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);

	lea	r8, QWORD PTR $T6[rbp-185]
	mov	DWORD PTR [rsp+40], 0
	lea	rdx, QWORD PTR $T9[rbp-185]
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1139 :         ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));

	cvttss2si ecx, xmm6
	movd	xmm0, ecx

; 1140 :         window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);

	mov	rcx, QWORD PTR [rsi+728]
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm8
	subss	xmm0, xmm1
	subss	xmm12, xmm1
	movss	DWORD PTR $T6[rbp-185], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, xmm10
	movss	DWORD PTR $T6[rbp-181], xmm12
	addss	xmm1, xmm7
	movss	DWORD PTR $T9[rbp-185], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1140 :         window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);

	movss	xmm0, DWORD PTR [rbx+14620]
	movss	DWORD PTR [rsp+32], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-181], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1140 :         window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);

	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1141 :     }

	jmp	SHORT $LN7@Checkbox
$LN5@Checkbox:

; 1142 :     else if (*v)

	cmp	BYTE PTR [r15], 0
	je	SHORT $LN7@Checkbox
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1144 :         const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));

	movaps	xmm0, xmm6
	divss	xmm0, DWORD PTR __real@40c00000

; 1145 :         RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);

	mov	rcx, QWORD PTR [rsi+728]
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1145 :         RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);

	addss	xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm10
	addss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1145 :         RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);

	subss	xmm6, xmm2
	unpcklps xmm0, xmm1
	movq	rdx, xmm0
	movaps	xmm3, xmm6
	call	?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z ; ImGui::RenderCheckMark
$LN7@Checkbox:

; 1149 :     if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	addss	xmm8, DWORD PTR [rbx+14636]
	addss	xmm7, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm12, XMMWORD PTR [rsp+128]
	movss	DWORD PTR label_pos$[rbp-185], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+192]
	movss	DWORD PTR label_pos$[rbp-181], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1149 :     if (g.LogEnabled)

	je	SHORT $LN8@Checkbox

; 1150 :         LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");

	test	r12b, r12b
	je	SHORT $LN15@Checkbox
	lea	rdx, OFFSET FLAT:??_C@_03JDMNMOAD@?$FL?$HO?$FN@
	jmp	SHORT $LN16@Checkbox
$LN15@Checkbox:
	cmp	BYTE PTR [r15], 0
	lea	rax, OFFSET FLAT:??_C@_03JHEALCLB@?$FLx?$FN@
	lea	rdx, OFFSET FLAT:??_C@_03PFOPMNLJ@?$FL?5?$FN@
	cmovne	rdx, rax
$LN16@Checkbox:
	xor	r8d, r8d
	lea	rcx, QWORD PTR label_pos$[rbp-185]
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN8@Checkbox:

; 1151 :     if (label_size.x > 0.0f)

	comiss	xmm11, xmm9
	jbe	SHORT $LN9@Checkbox

; 1152 :         RenderText(label_pos, label);

	mov	rcx, QWORD PTR label_pos$[rbp-185]
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, rdi
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN9@Checkbox:

; 1153 : 
; 1154 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
; 1155 :     return pressed;

	movzx	eax, r14b
	jmp	SHORT $LN1@Checkbox
$LN99@Checkbox:

; 1117 :     {
; 1118 :         IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
; 1119 :         return false;

	xor	al, al
$LN1@Checkbox:

; 1156 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-185]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?Checkbox@ImGui@@YA_NPEBDPEA_N@Z ENDP			; ImGui::Checkbox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?MenuItem@ImGui@@YA_NPEBD0_N1@Z
_TEXT	SEGMENT
label$ = 64
shortcut$ = 72
selected$ = 80
enabled$dead$ = 88
?MenuItem@ImGui@@YA_NPEBD0_N1@Z PROC			; ImGui::MenuItem, COMDAT

; 7475 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 7476 :     return MenuItemEx(label, NULL, shortcut, selected, enabled);

	movzx	r9d, r8b
	mov	r8, rdx
	call	?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z	; ImGui::MenuItemEx

; 7477 : }

	add	rsp, 56					; 00000038H
	ret	0
?MenuItem@ImGui@@YA_NPEBD0_N1@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextDeactivateHook@ImGui@@YAXI@Z
_TEXT	SEGMENT
id$ = 48
?InputTextDeactivateHook@ImGui@@YAXI@Z PROC		; ImGui::InputTextDeactivateHook, COMDAT

; 4087 : {

$LN30:

; 4089 :     ImGuiInputTextState* state = &g.InputTextState;
; 4090 :     if (id == 0 || state->ID != id)

	test	ecx, ecx
	je	$LN28@InputTextD
	push	rbx
	sub	rsp, 32					; 00000020H

; 4088 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4089 :     ImGuiInputTextState* state = &g.InputTextState;
; 4090 :     if (id == 0 || state->ID != id)

	mov	eax, DWORD PTR [rbx+19960]
	cmp	eax, ecx
	jne	$LN3@InputTextD

; 4091 :         return;
; 4092 :     g.InputTextDeactivatedState.ID = state->ID;

	mov	DWORD PTR [rbx+23680], eax

; 4093 :     if (state->Flags & ImGuiInputTextFlags_ReadOnly)

	test	DWORD PTR [rbx+23672], 16384		; 00004000H
	mov	QWORD PTR [rsp+56], rdi
	lea	rdi, QWORD PTR [rbx+23688]
	mov	ecx, DWORD PTR [rdi+4]
	je	SHORT $LN4@InputTextD
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ecx, ecx
	jns	SHORT $LN8@InputTextD

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN8@InputTextD:
	mov	DWORD PTR [rdi], 0
	mov	rdi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4103 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@InputTextD:
	mov	QWORD PTR [rsp+48], rsi

; 4094 :     {
; 4095 :         g.InputTextDeactivatedState.TextA.resize(0); // In theory this data won't be used, but clear to be neat.
; 4096 :     }
; 4097 :     else
; 4098 :     {
; 4099 :         IM_ASSERT(state->TextA.Data != 0);
; 4100 :         g.InputTextDeactivatedState.TextA.resize(state->CurLenA + 1);

	mov	esi, DWORD PTR [rbx+19968]
	inc	esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	esi, ecx
	jle	SHORT $LN15@InputTextD

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN19@InputTextD
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN20@InputTextD
$LN19@InputTextD:
	mov	eax, 8
$LN20@InputTextD:
	cmp	eax, esi
	mov	edx, esi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN15@InputTextD:
	mov	DWORD PTR [rdi], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4101 :         memcpy(g.InputTextDeactivatedState.TextA.Data, state->TextA.Data, state->CurLenA + 1);

	mov	eax, DWORD PTR [rbx+19968]
	mov	rdx, QWORD PTR [rbx+20000]
	inc	eax
	mov	rcx, QWORD PTR [rbx+23696]
	movsxd	r8, eax
	call	memcpy
	mov	rsi, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]
$LN3@InputTextD:

; 4103 : }

	add	rsp, 32					; 00000020H
	pop	rbx
$LN28@InputTextD:
	ret	0
?InputTextDeactivateHook@ImGui@@YAXI@Z ENDP		; ImGui::InputTextDeactivateHook
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab_id$ = 16
?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z PROC ; ImGui::TabBarFindTabByID, COMDAT

; 7982 :     if (tab_id != 0)

	test	edx, edx
	je	SHORT $LN3@TabBarFind

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	movsxd	rax, DWORD PTR [rcx]
	xor	r8d, r8d
	test	eax, eax
	jle	SHORT $LN3@TabBarFind
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	r9, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	ecx, r8d
	npad	5
$LL4@TabBarFind:

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rax], edx
	je	SHORT $LN13@TabBarFind

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	r8d
	inc	rcx
	add	rax, 56					; 00000038H
	cmp	rcx, r9
	jl	SHORT $LL4@TabBarFind
$LN3@TabBarFind:

; 7985 :                 return &tab_bar->Tabs[n];
; 7986 :     return NULL;

	xor	eax, eax

; 7987 : }

	ret	0
$LN13@TabBarFind:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r8d
	imul	rax, rax, 56				; 00000038H
	add	rax, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7987 : }

	ret	0
?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z ENDP ; ImGui::TabBarFindTabByID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z
_TEXT	SEGMENT
c$1 = 48
$T2 = 176
$T3 = 176
$T4 = 176
$T5 = 176
$T6 = 176
$T7 = 176
$T8 = 176
$T9 = 176
draw_list$ = 176
bb$ = 184
flags$ = 192
col$ = 200
?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z PROC ; ImGui::TabItemBackground, COMDAT

; 8700 : {

$LN139:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm3, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8700 : {

	mov	r15d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [rdx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8700 : {

	mov	rsi, rdx

; 8703 :     const float width = bb.GetWidth();
; 8704 :     IM_UNUSED(flags);
; 8705 :     IM_ASSERT(width > 0.0f);
; 8706 :     const float rounding = ImMax(0.0f, ImMin((flags & ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));

	movss	xmm2, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8702 :     ImGuiContext& g = *GImGui;

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbp, rcx
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7

; 8703 :     const float width = bb.GetWidth();
; 8704 :     IM_UNUSED(flags);
; 8705 :     IM_ASSERT(width > 0.0f);
; 8706 :     const float rounding = ImMax(0.0f, ImMin((flags & ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));

	movss	xmm7, DWORD PTR __real@3f000000
	movaps	XMMWORD PTR [rax-72], xmm8
	mulss	xmm0, xmm7
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	XMMWORD PTR [rax-104], xmm10
	subss	xmm0, xmm2
	bt	r8d, 21
	jae	SHORT $LN4@TabItemBac
	movss	xmm1, DWORD PTR [r14+14620]
	jmp	SHORT $LN5@TabItemBac
$LN4@TabItemBac:
	movss	xmm1, DWORD PTR [r14+14688]
$LN5@TabItemBac:

; 8707 :     const float y1 = bb.Min.y + 1.0f;

	movss	xmm9, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8707 :     const float y1 = bb.Min.y + 1.0f;

	addss	xmm9, xmm2
	xorps	xmm6, xmm6
	xorps	xmm10, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8708 :     const float y2 = bb.Max.y + ((flags & ImGuiTabItemFlags_Preview) ? 0.0f : -1.0f);

	bt	r8d, 23
	jae	SHORT $LN6@TabItemBac
	xorps	xmm8, xmm8
	jmp	SHORT $LN7@TabItemBac
$LN6@TabItemBac:
	movss	xmm8, DWORD PTR __real@bf800000
$LN7@TabItemBac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rcx+120]
	mov	edi, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8708 :     const float y2 = bb.Max.y + ((flags & ImGuiTabItemFlags_Preview) ? 0.0f : -1.0f);

	addss	xmm8, DWORD PTR [rdx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp], xmm3
	movss	DWORD PTR $T9[rsp+4], xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN23@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN27@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN28@TabItemBac
$LN27@TabItemBac:
	mov	eax, edi
$LN28@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN23@TabItemBac:
	mov	rax, QWORD PTR $T9[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8710 :     draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);

	addss	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8710 :     draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbp+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp+4], xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [rbp+120]
	inc	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	comiss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [rbp+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8710 :     draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);

	addss	xmm0, DWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN32@TabItemBac
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbp+124]
	cmp	r8d, ecx
	jne	SHORT $LN35@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN39@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN40@TabItemBac
$LN39@TabItemBac:
	mov	eax, edi
$LN40@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN35@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN31@TabItemBac
$LN32@TabItemBac:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 24
	mov	DWORD PTR [rsp+32], 36			; 00000024H
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN31@TabItemBac:

; 1168 :     if (radius < 0.5f)

	comiss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8711 :     draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);

	movss	xmm0, DWORD PTR [rsi+8]
	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rsp+4], xmm9
	movss	DWORD PTR $T7[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN44@TabItemBac
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	ecx, DWORD PTR [rbp+124]
	cmp	r8d, ecx
	jne	SHORT $LN47@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN51@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN52@TabItemBac
$LN51@TabItemBac:
	mov	eax, edi
$LN52@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN47@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN43@TabItemBac
$LN44@TabItemBac:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 36					; 00000024H
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN43@TabItemBac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rsi+8]

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	ecx, DWORD PTR [rbp+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp], xmm0
	movss	DWORD PTR $T6[rsp+4], xmm8

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN58@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN62@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN63@TabItemBac
$LN62@TabItemBac:
	mov	eax, edi
$LN63@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN58@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r15d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rbp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rbp+120]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	rdx, QWORD PTR [rbp+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	xor	r15d, r15d
	mov	DWORD PTR [rbp+120], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8714 :     if (g.Style.TabBorderSize > 0.0f)

	movss	xmm0, DWORD PTR [r14+14692]
	comiss	xmm0, xmm10
	jbe	$LN2@TabItemBac

; 8715 :     {
; 8716 :         draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));

	movss	xmm0, DWORD PTR [rsi]
	addss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm8
	movss	DWORD PTR $T5[rsp], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	DWORD PTR [rbp+124], r15d
	jne	SHORT $LN71@TabItemBac
	mov	edx, edi
	lea	rcx, QWORD PTR [rbp+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN71@TabItemBac:
	mov	rax, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8717 :         draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);

	addss	xmm9, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rdx, DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8717 :         draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbp+128]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm9

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [rbp+120]
	inc	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	comiss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	DWORD PTR [rbp+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8717 :         draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);

	addss	xmm0, DWORD PTR [rsi]
	addss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN80@TabItemBac
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbp+124]
	cmp	r8d, ecx
	jne	SHORT $LN83@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN87@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN88@TabItemBac
$LN87@TabItemBac:
	mov	eax, edi
$LN88@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN83@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN79@TabItemBac
$LN80@TabItemBac:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 24
	mov	DWORD PTR [rsp+32], 36			; 00000024H
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN79@TabItemBac:

; 1168 :     if (radius < 0.5f)

	comiss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8718 :         draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);

	movss	xmm0, DWORD PTR [rsi+8]
	subss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8718 :         draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);

	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1168 :     if (radius < 0.5f)

	jbe	SHORT $LN92@TabItemBac
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	ecx, DWORD PTR [rbp+124]
	cmp	r8d, ecx
	jne	SHORT $LN95@TabItemBac
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN99@TabItemBac
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN100@TabItemBac
$LN99@TabItemBac:
	mov	eax, edi
$LN100@TabItemBac:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN95@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	inc	DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1171 :         return;

	jmp	SHORT $LN91@TabItemBac
$LN92@TabItemBac:

; 1172 :     }
; 1173 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

	mov	r9d, 36					; 00000024H
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbp
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN91@TabItemBac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8719 :         draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));

	movss	xmm0, DWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8719 :         draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));

	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+124]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm8
	movss	DWORD PTR $T2[rsp], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	ecx, r8d
	jne	SHORT $LN106@TabItemBac
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN110@TabItemBac
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [r8+rax]
$LN110@TabItemBac:
	cmp	edi, ecx
	cmovg	ecx, edi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	lea	rcx, QWORD PTR [rbp+120]
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN106@TabItemBac:
	movsxd	rdx, DWORD PTR [rbp+120]
	mov	rcx, QWORD PTR [rbp+128]
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$1[rsp]
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rbp+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+14856]
	movups	XMMWORD PTR c$1[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$1[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR [r14+14692]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbp+120]
	mov	rcx, rbp
	mov	rdx, QWORD PTR [rbp+128]
	movss	DWORD PTR [rsp+40], xmm0
	mov	DWORD PTR [rsp+32], r15d
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [rbp+120], r15d
$LN2@TabItemBac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8722 : }

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z ENDP ; ImGui::TabItemBackground
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextV@ImGui@@YAXPEBDPEAD@Z
_TEXT	SEGMENT
fmt$ = 80
args$ = 88
?TextV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::TextV, COMDAT

; 268  : {

$LN34:
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 268  : {

	mov	r14, rdx
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 270  :     if (window->SkipItems)

	mov	rax, QWORD PTR [rsi+16408]
	cmp	BYTE PTR [rax+240], 0
	jne	$LN1@TextV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1991 :     if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)

	cmp	BYTE PTR [rcx], 37			; 00000025H
	jne	SHORT $LN7@TextV
	cmp	BYTE PTR [rcx+1], 115			; 00000073H
	jne	SHORT $LN7@TextV
	cmp	BYTE PTR [rcx+2], 0
	jne	SHORT $LN7@TextV

; 1992 :     {
; 1993 :         const char* buf = va_arg(args, const char*); // Skip formatting when using "%s"

	mov	rcx, QWORD PTR [rdx]

; 1994 :         *out_buf = buf;
; 1995 :         if (out_buf_end) { *out_buf_end = buf + strlen(buf); }

	mov	rdx, -1
$LL24@TextV:
	inc	rdx
	cmp	BYTE PTR [rcx+rdx], 0
	jne	SHORT $LL24@TextV

; 1996 :     }

	jmp	$LN32@TextV
$LN7@TextV:
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp

; 1997 :     else
; 1998 :     {
; 1999 :         int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);

	movsxd	rbp, DWORD PTR [rsi+24712]
	mov	QWORD PTR [rsp+96], r15
	mov	r15, QWORD PTR [rsi+24720]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], r14
	mov	r9, rdi
	mov	r8, rbp
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, r15
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	QWORD PTR __imp___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	mov	rbx, QWORD PTR [rsp+80]
	mov	rdx, -1
	test	eax, eax
	mov	r8d, eax
	cmovs	r8d, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1959 :     if (buf == NULL)

	test	r15, r15
	je	SHORT $LN14@TextV

; 1960 :         return w;
; 1961 :     if (w == -1 || w >= (int)buf_size)

	cmp	r8d, edx
	je	SHORT $LN23@TextV
	cmp	r8d, ebp
	jl	SHORT $LN16@TextV
$LN23@TextV:

; 1962 :         w = (int)buf_size - 1;

	lea	r8d, DWORD PTR [rbp-1]
$LN16@TextV:

; 1963 :     buf[w] = 0;

	movsxd	rax, r8d
	mov	BYTE PTR [rax+r15], 0
$LN14@TextV:

; 2000 :         *out_buf = g.TempBuffer.Data;

	mov	rcx, QWORD PTR [rsi+24720]

; 2001 :         if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }

	mov	r15, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	movsxd	rdx, r8d
$LN32@TextV:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 275  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	add	rdx, rcx
	mov	r8d, 1

; 276  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi

; 275  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	jmp	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN1@TextV:

; 276  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?TextV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::TextV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z
_TEXT	SEGMENT
hovered$ = 48
held$ = 49
window$1$ = 56
bb_render$ = 64
c$1 = 80
bb_interact$ = 80
bb$ = 160
id$ = 168
axis$ = 176
size1$ = 184
size2$ = 192
min_size1$ = 200
min_size2$ = 208
hover_extend$ = 216
hover_visibility_delay$ = 224
bg_col$ = 232
?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z PROC ; ImGui::SplitterBehavior, COMDAT

; 1543 : {

$LN76:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r13
	push	rbp
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H

; 1544 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r13, r9
	mov	edi, r8d
	movaps	XMMWORD PTR [rsp+96], xmm7
	movss	xmm7, DWORD PTR hover_extend$[rbp-128]

; 1545 :     ImGuiWindow* window = g.CurrentWindow;
; 1546 : 
; 1547 :     if (!ItemAdd(bb, id, NULL, ImGuiItemFlags_NoNav))

	mov	r9d, 8
	xor	r8d, r8d
	mov	r15d, edx
	mov	rax, QWORD PTR [rbx+16408]
	mov	r14, rcx
	mov	QWORD PTR window$1$[rbp-128], rax
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN1@SplitterBe
$LN2@SplitterBe:
	mov	QWORD PTR [rsp+160], rsi
	movaps	XMMWORD PTR [rsp+112], xmm6

; 1548 :         return false;
; 1549 : 
; 1550 :     // FIXME: AFAIK the only leftover reason for passing ImGuiButtonFlags_AllowOverlap here is
; 1551 :     // to allow caller of SplitterBehavior() to call SetItemAllowOverlap() after the item.
; 1552 :     // Nowadays we would instead want to use SetNextItemAllowOverlap() before the item.
; 1553 :     ImGuiButtonFlags button_flags = ImGuiButtonFlags_FlattenChildren;
; 1554 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 1555 :     button_flags |= ImGuiButtonFlags_AllowOverlap;
; 1556 : #endif
; 1557 : 
; 1558 :     bool hovered, held;
; 1559 :     ImRect bb_interact = bb;
; 1560 :     bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));

	xorps	xmm6, xmm6
	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR bb_interact$[rbp-128], xmm0
	cmp	edi, 1
	jne	SHORT $LN14@SplitterBe
	xorps	xmm2, xmm2
	jmp	SHORT $LN15@SplitterBe
$LN14@SplitterBe:
	movaps	xmm2, xmm7
	xorps	xmm7, xmm7
$LN15@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm0, DWORD PTR bb_interact$[rbp-128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1561 :     ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);

	lea	r9, QWORD PTR held$[rbp-128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm1, DWORD PTR bb_interact$[rbp-124]
	subss	xmm0, xmm2
	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1561 :     ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);

	mov	DWORD PTR [rsp+32], 6144		; 00001800H
	lea	r8, QWORD PTR hovered$[rbp-128]
	mov	edx, r15d
	lea	rcx, QWORD PTR bb_interact$[rbp-128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	DWORD PTR bb_interact$[rbp-128], xmm0
	movss	xmm0, DWORD PTR bb_interact$[rbp-120]
	movss	DWORD PTR bb_interact$[rbp-124], xmm1
	addss	xmm0, xmm2
	movss	xmm1, DWORD PTR bb_interact$[rbp-116]
	addss	xmm1, xmm7
	movss	DWORD PTR bb_interact$[rbp-120], xmm0
	movss	DWORD PTR bb_interact$[rbp-116], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1561 :     ButtonBehavior(bb_interact, id, &hovered, &held, button_flags);

	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 1562 :     if (hovered)

	cmp	BYTE PTR hovered$[rbp-128], 0
	je	SHORT $LN3@SplitterBe

; 1563 :         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect; // for IsItemHovered(), because bb_interact is larger than bb

	or	DWORD PTR [rbx+18624], 1
$LN3@SplitterBe:

; 1564 : 
; 1565 :     if (held || (hovered && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))

	movzx	esi, BYTE PTR held$[rbp-128]
	movss	xmm7, DWORD PTR hover_visibility_delay$[rbp-128]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	sil, sil
	jne	SHORT $LN5@SplitterBe
	cmp	BYTE PTR hovered$[rbp-128], sil
	je	SHORT $LN4@SplitterBe
	cmp	DWORD PTR [rbx+16488], r15d
	jne	SHORT $LN4@SplitterBe
	movss	xmm0, DWORD PTR [rbx+16496]
	comiss	xmm0, xmm7
	jb	SHORT $LN4@SplitterBe
$LN5@SplitterBe:

; 1566 :         SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

	xor	eax, eax
	cmp	edi, 1
	setne	al
	add	eax, 3
	mov	DWORD PTR [rcx+19936], eax
$LN4@SplitterBe:

; 1567 : 
; 1568 :     ImRect bb_render = bb;

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR bb_render$[rbp-128], xmm0

; 1569 :     if (held)

	test	sil, sil
	je	$LN9@SplitterBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rbx+3592]
	movss	xmm2, DWORD PTR [rbx+3596]
	subss	xmm0, DWORD PTR [rbx+16524]
	subss	xmm2, DWORD PTR [rbx+16528]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1572 :         float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

	cmp	edi, 1
	jne	SHORT $LN16@SplitterBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm2, DWORD PTR bb_interact$[rbp-124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1572 :         float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

	jmp	SHORT $LN17@SplitterBe
$LN16@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm2, xmm0
	subss	xmm2, DWORD PTR bb_interact$[rbp-128]
$LN17@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1576 :         float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);

	mov	rax, QWORD PTR size2$[rbp-128]
	xorps	xmm3, xmm3
	movss	xmm4, DWORD PTR [r13]
	movaps	xmm1, xmm4
	subss	xmm1, DWORD PTR min_size1$[rbp-128]
	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, DWORD PTR min_size2$[rbp-128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm0
	xorps	xmm0, xmm0
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1578 :             mouse_delta = -size_1_maximum_delta;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	maxss	xmm0, xmm2

; 1579 :         if (mouse_delta > size_2_maximum_delta)

	minss	xmm3, xmm0

; 1580 :             mouse_delta = size_2_maximum_delta;
; 1581 : 
; 1582 :         // Apply resize
; 1583 :         if (mouse_delta != 0.0f)

	ucomiss	xmm3, xmm6
	jp	SHORT $LN59@SplitterBe
	je	SHORT $LN9@SplitterBe
$LN59@SplitterBe:

; 1584 :         {
; 1585 :             if (mouse_delta < 0.0f)
; 1586 :                 IM_ASSERT(*size1 + mouse_delta >= min_size1);
; 1587 :             if (mouse_delta > 0.0f)
; 1588 :                 IM_ASSERT(*size2 - mouse_delta >= min_size2);
; 1589 :             *size1 += mouse_delta;

	addss	xmm4, xmm3
	movss	DWORD PTR [r13], xmm4

; 1590 :             *size2 -= mouse_delta;

	movss	xmm0, DWORD PTR [rax]
	subss	xmm0, xmm3
	movss	DWORD PTR [rax], xmm0

; 1591 :             bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));

	test	edi, edi
	jne	SHORT $LN18@SplitterBe
	movaps	xmm2, xmm3
	xorps	xmm3, xmm3
	jmp	SHORT $LN19@SplitterBe
$LN18@SplitterBe:
	xorps	xmm2, xmm2
$LN19@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 543  :     void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }

	movss	xmm0, DWORD PTR bb_render$[rbp-128]
	movss	xmm1, DWORD PTR bb_render$[rbp-124]
	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	eax, DWORD PTR [rcx+16504]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 543  :     void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }

	addss	xmm1, xmm3
	movss	DWORD PTR bb_render$[rbp-128], xmm0
	movss	xmm0, DWORD PTR bb_render$[rbp-120]
	movss	DWORD PTR bb_render$[rbp-124], xmm1
	addss	xmm0, xmm2
	movss	xmm1, DWORD PTR bb_render$[rbp-116]
	addss	xmm1, xmm3
	movss	DWORD PTR bb_render$[rbp-120], xmm0
	movss	DWORD PTR bb_render$[rbp-116], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	cmp	eax, r15d
	je	SHORT $LN52@SplitterBe
	test	eax, eax
	jne	SHORT $LN51@SplitterBe
$LN52@SplitterBe:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN51@SplitterBe:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
$LN9@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1597 :     if (bg_col & IM_COL32_A_MASK)

	mov	r9d, DWORD PTR bg_col$[rbp-128]
	mov	rdi, QWORD PTR window$1$[rbp-128]
	test	r9d, -16777216				; ff000000H
	je	SHORT $LN12@SplitterBe

; 1598 :         window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, bg_col, 0.0f);

	mov	rcx, QWORD PTR [rdi+728]
	lea	r8, QWORD PTR bb_render$[rbp-120]
	mov	DWORD PTR [rsp+40], 0
	lea	rdx, QWORD PTR bb_render$[rbp-128]
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN12@SplitterBe:

; 1599 :     const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

	test	sil, sil
	je	SHORT $LN22@SplitterBe
	mov	eax, 688				; 000002b0H
	jmp	SHORT $LN21@SplitterBe
$LN22@SplitterBe:
	cmp	BYTE PTR hovered$[rbp-128], 0
	je	SHORT $LN20@SplitterBe
	movss	xmm0, DWORD PTR [rbx+16496]
	mov	eax, 672				; 000002a0H
	comiss	xmm0, xmm7
	jae	SHORT $LN21@SplitterBe
$LN20@SplitterBe:
	mov	eax, 656				; 00000290H
$LN21@SplitterBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+rcx+14552]
	movups	XMMWORD PTR c$1[rbp-128], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$1[rbp-128]
	movss	DWORD PTR c$1[rbp-116], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1600 :     window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);

	mov	rcx, QWORD PTR [rdi+728]
	lea	rdx, QWORD PTR bb_render$[rbp-128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1600 :     window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);

	mov	DWORD PTR [rsp+40], 0
	lea	r8, QWORD PTR bb_render$[rbp-120]
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1601 : 
; 1602 :     return held;

	movaps	xmm6, XMMWORD PTR [rsp+112]
	movzx	eax, sil
	mov	rsi, QWORD PTR [rsp+160]
$LN1@SplitterBe:

; 1603 : }

	movaps	xmm7, XMMWORD PTR [rsp+96]
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r13, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z ENDP ; ImGui::SplitterBehavior
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z
_TEXT	SEGMENT
new_tab$ = 32
tab_bar$ = 112
tab_flags$ = 120
window$ = 128
?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z PROC ; ImGui::TabBarAddTab, COMDAT

; 8031 : {

$LN18:
	push	rbx
	sub	rsp, 96					; 00000060H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2700 :     ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }

	xor	eax, eax
	mov	QWORD PTR new_tab$[rsp+36], -1082130432	; ffffffffbf800000H
	mov	QWORD PTR new_tab$[rsp+24], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8031 : {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2700 :     ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }

	mov	DWORD PTR new_tab$[rsp+32], eax
	mov	QWORD PTR new_tab$[rsp+48], rax
	mov	eax, -1
	mov	DWORD PTR new_tab$[rsp+20], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8040 :     new_tab.ID = window->TabId;

	mov	eax, DWORD PTR [r8+176]
	mov	DWORD PTR new_tab$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2700 :     ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }

	mov	eax, edx
	bts	eax, 20
	mov	DWORD PTR new_tab$[rsp+44], -1		; ffffffffH
	cmp	BYTE PTR [r8+245], 0
	cmovne	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8041 :     new_tab.Flags = tab_flags;

	mov	DWORD PTR new_tab$[rsp+4], eax

; 8042 :     new_tab.LastFrameVisible = tab_bar->CurrFrameVisible;   // Required so BeginTabBar() doesn't ditch the tab

	mov	eax, DWORD PTR [rcx+36]
	mov	DWORD PTR new_tab$[rsp+16], eax
	cmp	eax, -1

; 8043 :     if (new_tab.LastFrameVisible == -1)

	jne	SHORT $LN3@TabBarAddT

; 8044 :         new_tab.LastFrameVisible = g.FrameCount - 1;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, DWORD PTR [rax+16240]
	dec	ecx
	mov	DWORD PTR new_tab$[rsp+16], ecx
$LN3@TabBarAddT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8045 :     new_tab.Window = window;                                // Required so tab bar layout can compute the tab width before tab submission

	mov	QWORD PTR new_tab$[rsp+8], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, ecx
	jne	SHORT $LN8@TabBarAddT
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN12@TabBarAddT
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN13@TabBarAddT
$LN12@TabBarAddT:
	mov	eax, 8
$LN13@TabBarAddT:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN8@TabBarAddT:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR new_tab$[rsp]
	movups	xmm1, XMMWORD PTR new_tab$[rsp+16]
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm0, XMMWORD PTR new_tab$[rsp+32]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movsd	xmm1, QWORD PTR new_tab$[rsp+48]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movsd	QWORD PTR [rcx+rax+48], xmm1
	inc	DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8047 : }

	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z ENDP ; ImGui::TabBarAddTab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Update@ImGuiMenuColumns@@QEAAXM_N@Z
_TEXT	SEGMENT
this$ = 8
spacing$ = 16
window_reappearing$ = 24
?Update@ImGuiMenuColumns@@QEAAXM_N@Z PROC		; ImGuiMenuColumns::Update, COMDAT

; 6962 : {

$LN61:
	mov	QWORD PTR [rsp+8], rbx
	mov	rdx, rcx

; 6963 :     if (window_reappearing)

	test	r8b, r8b
	je	SHORT $LN32@Update

; 6964 :         memset(Widths, 0, sizeof(Widths));

	xor	eax, eax
	mov	QWORD PTR [rcx+18], rax
$LN32@Update:

; 6974 :     ImU16 offset = 0;

	xor	ebx, ebx

; 6965 :     Spacing = (ImU16)spacing;

	cvttss2si eax, xmm1

; 6975 :     bool want_spacing = false;

	xor	r9b, r9b

; 6965 :     Spacing = (ImU16)spacing;

	mov	r8d, ebx

; 6980 :             offset += Spacing;

	mov	r10d, ebx

; 6965 :     Spacing = (ImU16)spacing;

	mov	WORD PTR [rcx+8], ax

; 6974 :     ImU16 offset = 0;

	movzx	ecx, bx
	npad	7
$LL7@Update:

; 6976 :     for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
; 6977 :     {
; 6978 :         ImU16 width = Widths[i];

	movzx	r11d, WORD PTR [rdx+r10*2+18]

; 6979 :         if (want_spacing && width > 0)

	test	r9b, r9b
	je	SHORT $LN8@Update
	test	r11w, r11w
	je	SHORT $LN56@Update

; 6980 :             offset += Spacing;

	add	cx, WORD PTR [rdx+8]
$LN8@Update:

; 6981 :         want_spacing |= (width > 0);

	test	r11w, r11w
$LN56@Update:
	setne	al
	or	r9b, al

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r10, 1
	jne	SHORT $LN10@Update
	mov	WORD PTR [rdx+12], cx

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN12@Update
$LN10@Update:
	cmp	r10, 2
	jne	SHORT $LN11@Update
	mov	WORD PTR [rdx+14], cx

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN12@Update
$LN11@Update:
	cmp	r10, 3
	jne	SHORT $LN12@Update
	mov	WORD PTR [rdx+16], cx
$LN12@Update:

; 6987 :         }
; 6988 :         offset += width;

	add	cx, r11w
	movzx	r11d, WORD PTR [rdx+r10*2+20]
	test	r9b, r9b
	je	SHORT $LN17@Update

; 6979 :         if (want_spacing && width > 0)

	test	r11w, r11w
	je	SHORT $LN57@Update

; 6980 :             offset += Spacing;

	add	cx, WORD PTR [rdx+8]
$LN17@Update:

; 6981 :         want_spacing |= (width > 0);

	test	r11w, r11w
$LN57@Update:
	setne	al
	or	r9b, al

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	test	r8d, r8d
	jne	SHORT $LN18@Update
	mov	WORD PTR [rdx+12], cx

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN20@Update
$LN18@Update:
	cmp	r8d, 1
	jne	SHORT $LN19@Update
	mov	WORD PTR [rdx+14], cx

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN20@Update
$LN19@Update:
	cmp	r8d, 2
	jne	SHORT $LN20@Update
	mov	WORD PTR [rdx+16], cx
$LN20@Update:

; 6987 :         }
; 6988 :         offset += width;

	add	cx, r11w
	movzx	r11d, WORD PTR [rdx+r10*2+22]
	test	r9b, r9b
	je	SHORT $LN22@Update

; 6979 :         if (want_spacing && width > 0)

	test	r11w, r11w
	je	SHORT $LN58@Update

; 6980 :             offset += Spacing;

	add	cx, WORD PTR [rdx+8]
$LN22@Update:

; 6981 :         want_spacing |= (width > 0);

	test	r11w, r11w
$LN58@Update:
	setne	al
	or	r9b, al

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r8d, -1
	jne	SHORT $LN23@Update
	mov	WORD PTR [rdx+12], cx

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN25@Update
$LN23@Update:
	test	r8d, r8d
	jne	SHORT $LN24@Update
	mov	WORD PTR [rdx+14], cx

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN25@Update
$LN24@Update:
	cmp	r8d, 1
	jne	SHORT $LN25@Update
	mov	WORD PTR [rdx+16], cx
$LN25@Update:

; 6987 :         }
; 6988 :         offset += width;

	add	cx, r11w
	movzx	r11d, WORD PTR [rdx+r10*2+24]
	test	r9b, r9b
	je	SHORT $LN27@Update

; 6979 :         if (want_spacing && width > 0)

	test	r11w, r11w
	je	SHORT $LN59@Update

; 6980 :             offset += Spacing;

	add	cx, WORD PTR [rdx+8]
$LN27@Update:

; 6981 :         want_spacing |= (width > 0);

	test	r11w, r11w
$LN59@Update:
	setne	al
	or	r9b, al

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r8d, -2
	jne	SHORT $LN28@Update
	mov	WORD PTR [rdx+12], cx

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN30@Update
$LN28@Update:
	cmp	r8d, -1
	jne	SHORT $LN29@Update
	mov	WORD PTR [rdx+14], cx

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN30@Update
$LN29@Update:
	test	r8d, r8d
	jne	SHORT $LN30@Update
	mov	WORD PTR [rdx+16], cx
$LN30@Update:

; 6987 :         }
; 6988 :         offset += width;

	add	cx, r11w
	add	r8d, 4
	add	r10, 4
	cmp	r10, 4
	jl	$LL7@Update

; 6989 :     }
; 6990 :     NextTotalWidth = offset;

	movzx	eax, cx
	mov	DWORD PTR [rdx+4], eax

; 6966 :     CalcNextTotalWidth(true);
; 6967 :     memset(Widths, 0, sizeof(Widths));

	xor	eax, eax
	mov	QWORD PTR [rdx+18], rax

; 6968 :     TotalWidth = NextTotalWidth;

	mov	eax, DWORD PTR [rdx+4]

; 6969 :     NextTotalWidth = 0;

	mov	DWORD PTR [rdx+4], ebx

; 6970 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	DWORD PTR [rdx], eax
	ret	0
?Update@ImGuiMenuColumns@@QEAAXM_N@Z ENDP		; ImGuiMenuColumns::Update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiTabBar@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTabBar@@QEAA@XZ PROC				; ImGuiTabBar::ImGuiTabBar, COMDAT

; 7538 : {

	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7539 :     memset(this, 0, sizeof(*this));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	movups	XMMWORD PTR [rcx+128], xmm0
	mov	QWORD PTR [rcx+144], rax

; 7540 :     CurrFrameVisible = PrevFrameVisible = -1;

	mov	eax, -1

; 7541 :     LastTabItemIdx = -1;

	mov	WORD PTR [rcx+112], ax

; 7542 : }

	mov	rax, rcx
	mov	QWORD PTR [rcx+36], -1
	ret	0
??0ImGuiTabBar@@QEAA@XZ ENDP				; ImGuiTabBar::ImGuiTabBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
bytes_count$ = 24
?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z PROC	; ImGuiInputTextCallbackData::DeleteChars, COMDAT

; 3896 :     IM_ASSERT(pos + bytes_count <= BufTextLen);
; 3897 :     char* dst = Buf + pos;

	mov	r10, QWORD PTR [rcx+32]
	mov	r11, rcx
	movsxd	r9, edx
	add	r10, r9

; 3898 :     const char* src = Buf + pos + bytes_count;

	movsxd	rax, r8d
	add	rax, r10

; 3899 :     while (char c = *src++)

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	test	r9b, r9b
	je	SHORT $LN3@DeleteChar
	npad	1
$LL2@DeleteChar:

; 3900 :         *dst++ = c;

	mov	BYTE PTR [r10], r9b
	inc	r10
	movzx	r9d, BYTE PTR [rax]
	lea	rax, QWORD PTR [rax+1]
	test	r9b, r9b
	jne	SHORT $LL2@DeleteChar
$LN3@DeleteChar:

; 3901 :     *dst = '\0';

	mov	BYTE PTR [r10], 0

; 3902 : 
; 3903 :     if (CursorPos >= pos + bytes_count)

	lea	eax, DWORD PTR [rdx+r8]
	mov	ecx, DWORD PTR [rcx+52]
	cmp	ecx, eax
	jl	SHORT $LN4@DeleteChar

; 3904 :         CursorPos -= bytes_count;

	sub	ecx, r8d

; 3907 :     SelectionStart = SelectionEnd = CursorPos;
; 3908 :     BufDirty = true;

	mov	BYTE PTR [r11+48], 1

; 3909 :     BufTextLen -= bytes_count;

	sub	DWORD PTR [r11+40], r8d
	mov	DWORD PTR [r11+52], ecx
	mov	DWORD PTR [r11+60], ecx
	mov	DWORD PTR [r11+56], ecx

; 3910 : }

	ret	0
$LN4@DeleteChar:

; 3905 :     else if (CursorPos >= pos)

	cmp	ecx, edx
	jl	SHORT $LN6@DeleteChar

; 3906 :         CursorPos = pos;

	mov	DWORD PTR [r11+52], edx
	mov	ecx, edx
$LN6@DeleteChar:

; 3909 :     BufTextLen -= bytes_count;

	sub	DWORD PTR [r11+40], r8d
	mov	DWORD PTR [r11+60], ecx
	mov	DWORD PTR [r11+56], ecx
	mov	BYTE PTR [r11+48], 1

; 3910 : }

	ret	0
?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z ENDP	; ImGuiInputTextCallbackData::DeleteChars
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z
_TEXT	SEGMENT
this$ = 64
pos$ = 72
new_text$ = 80
new_text_end$ = 88
?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z PROC ; ImGuiInputTextCallbackData::InsertChars, COMDAT

; 3913 : {

$LN31:

; 3914 :     // Accept null ranges
; 3915 :     if (new_text == new_text_end)

	cmp	r8, r9
	je	$LN29@InsertChar
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 3913 : {

	mov	rdi, rcx
	movsxd	r14, edx

; 3916 :         return;
; 3917 : 
; 3918 :     const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	ecx, DWORD PTR [rcx+12]
	mov	rsi, r9
	shr	ecx, 18
	mov	rbp, r8
	and	cl, 1

; 3919 :     const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);

	test	r9, r9
	je	SHORT $LN8@InsertChar
	sub	esi, ebp
	jmp	SHORT $LN9@InsertChar
$LN8@InsertChar:
	mov	rax, -1
	npad	5
$LL18@InsertChar:
	inc	rax
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL18@InsertChar
	mov	esi, eax
$LN9@InsertChar:

; 3920 :     if (new_text_len + BufTextLen >= BufSize)

	mov	edx, DWORD PTR [rdi+40]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], r15
	lea	eax, DWORD PTR [rdx+rsi]
	cmp	eax, DWORD PTR [rdi+44]
	jl	SHORT $LN17@InsertChar

; 3921 :     {
; 3922 :         if (!is_resizable)

	test	cl, cl
	je	$LN28@InsertChar

; 3923 :             return;
; 3924 : 
; 3925 :         // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the mildly similar code (until we remove the U16 buffer altogether!)
; 3926 :         ImGuiContext& g = *Ctx;
; 3927 :         ImGuiInputTextState* edit_state = &g.InputTextState;

	mov	r15, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	mov	eax, 256				; 00000100H
	cmp	esi, eax
	mov	ecx, esi
	cmovle	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3930 :         int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;

	lea	eax, DWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 32					; 00000020H
	jge	SHORT $LN14@InsertChar
	mov	eax, 32					; 00000020H
	jmp	SHORT $LN15@InsertChar
$LN14@InsertChar:
	cmp	eax, ecx
	cmovg	eax, ecx
$LN15@InsertChar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3930 :         int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;

	lea	ebx, DWORD PTR [rdx+1]
	add	ebx, eax

; 3931 :         edit_state->TextA.reserve(new_buf_size + 1);

	lea	rcx, QWORD PTR [r15+19992]
	lea	edx, DWORD PTR [rbx+1]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve

; 3932 :         Buf = edit_state->TextA.Data;

	mov	rax, QWORD PTR [r15+20000]
	mov	QWORD PTR [rdi+32], rax

; 3933 :         BufSize = edit_state->BufCapacityA = new_buf_size;

	mov	DWORD PTR [r15+20028], ebx
	mov	DWORD PTR [rdi+44], ebx
$LN17@InsertChar:

; 3934 :     }
; 3935 : 
; 3936 :     if (BufTextLen != pos)

	mov	ecx, DWORD PTR [rdi+40]
	movsxd	r15, esi
	cmp	ecx, r14d
	je	SHORT $LN16@InsertChar

; 3937 :         memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));

	mov	rax, QWORD PTR [rdi+32]
	sub	ecx, r14d
	movsxd	r8, ecx
	lea	rcx, QWORD PTR [rax+r14]
	add	rcx, r15
	lea	rdx, QWORD PTR [rax+r14]
	call	memmove
$LN16@InsertChar:

; 3938 :     memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));

	mov	rcx, QWORD PTR [rdi+32]
	mov	r8, r15
	add	rcx, r14
	mov	rdx, rbp
	call	memcpy

; 3939 :     Buf[BufTextLen + new_text_len] = '\0';

	mov	eax, DWORD PTR [rdi+40]
	add	eax, esi
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi+32]
	mov	BYTE PTR [rcx+rax], 0

; 3940 : 
; 3941 :     if (CursorPos >= pos)

	mov	eax, DWORD PTR [rdi+52]
	cmp	eax, r14d
	jl	SHORT $LN6@InsertChar

; 3942 :         CursorPos += new_text_len;

	add	eax, esi
	mov	DWORD PTR [rdi+52], eax
$LN6@InsertChar:

; 3943 :     SelectionStart = SelectionEnd = CursorPos;
; 3944 :     BufDirty = true;
; 3945 :     BufTextLen += new_text_len;

	add	DWORD PTR [rdi+40], esi
	mov	DWORD PTR [rdi+60], eax
	mov	DWORD PTR [rdi+56], eax
	mov	BYTE PTR [rdi+48], 1
$LN28@InsertChar:

; 3946 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
$LN29@InsertChar:
	ret	0
?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z ENDP ; ImGuiInputTextCallbackData::InsertChars
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z
_TEXT	SEGMENT
value_changed$1$ = 64
value_changed_as_float$1$ = 65
tv4356 = 68
tv4355 = 68
components$1$ = 72
tv1931 = 76
flags$GSCopy$1$ = 80
window$1$ = 88
tv4352 = 96
tv3102 = 96
label$GSCopy$1$ = 104
w_full$1$ = 112
$T4 = 112
text_display_end$1$ = 120
$T5 = 120
flags_untouched$1$ = 136
tv4374 = 140
tv4535 = 144
v_min$ = 144
v_max$ = 144
text_size$6 = 152
v_max$ = 152
v_min$ = 152
$T7 = 152
col$GSCopy$1$ = 160
col_v4$8 = 160
f$ = 176
i$ = 200
buf$9 = 224
__$ArrayPad$ = 288
label$ = 528
col$ = 536
flags$ = 544
?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z PROC			; ImGui::ColorEdit4, COMDAT

; 5143 : {

$LN838:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	lea	rbp, QWORD PTR [rsp-216]
	sub	rsp, 472				; 000001d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5143 : {

	mov	edi, r8d
	mov	DWORD PTR flags$GSCopy$1$[rsp], r8d
	mov	r12, rdx
	mov	QWORD PTR col$GSCopy$1$[rbp-256], rdx
	mov	r14, rcx
	mov	QWORD PTR label$GSCopy$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rsi+16408]
	mov	QWORD PTR window$1$[rsp], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5145 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	je	SHORT $LN10@ColorEdit4

; 5146 :         return false;

	xor	al, al
	jmp	$LN1@ColorEdit4
$LN10@ColorEdit4:
	mov	QWORD PTR [rsp+552], r13
	mov	QWORD PTR [rsp+464], r15
	movaps	XMMWORD PTR [rsp+448], xmm6
	movaps	XMMWORD PTR [rsp+432], xmm7
	movaps	XMMWORD PTR [rsp+416], xmm8
	movaps	XMMWORD PTR [rsp+400], xmm9
	movaps	XMMWORD PTR [rsp+384], xmm10
	movaps	XMMWORD PTR [rsp+368], xmm11
	movaps	XMMWORD PTR [rsp+352], xmm12
	movaps	XMMWORD PTR [rsp+336], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm13, DWORD PTR [rsi+14616]
	addss	xmm13, xmm13
	movaps	XMMWORD PTR [rsp+320], xmm14
	movaps	XMMWORD PTR [rsp+304], xmm15
	addss	xmm13, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5151 :     const float w_full = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movss	DWORD PTR w_full$1$[rsp], xmm0
	movaps	xmm8, xmm0
	xorps	xmm9, xmm9

; 5152 :     const float w_button = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);

	test	dil, 16
	je	SHORT $LN56@ColorEdit4
	xorps	xmm12, xmm12
	jmp	SHORT $LN57@ColorEdit4
$LN56@ColorEdit4:
	movaps	xmm12, xmm13
	addss	xmm12, DWORD PTR [rsi+14636]
$LN57@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	QWORD PTR text_display_end$1$[rsp], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5153 :     const float w_inputs = w_full - w_button;

	movaps	xmm10, xmm0
	subss	xmm10, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r14, -1
	jae	SHORT $LN94@ColorEdit4
	mov	rdi, r14
$LL93@ColorEdit4:
	movzx	ecx, BYTE PTR [rdi]
	test	cl, cl
	je	SHORT $LN721@ColorEdit4
	lea	rax, QWORD PTR [rdi+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN711@ColorEdit4
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN721@ColorEdit4
$LN711@ColorEdit4:

; 3332 :         text_display_end++;

	mov	QWORD PTR text_display_end$1$[rsp], rax
	mov	rdi, rax
	cmp	rax, -1
	jb	SHORT $LL93@ColorEdit4
$LN721@ColorEdit4:
	mov	edi, DWORD PTR flags$GSCopy$1$[rsp]
$LN94@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1207 :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!

	xor	eax, eax
	mov	QWORD PTR [rsi+18592], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5157 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 5158 :     PushID(label);

	mov	rcx, r14
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 5159 :     const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);

	mov	eax, DWORD PTR [rsi+23832]
	mov	DWORD PTR tv4374[rbp-256], eax

; 5160 :     if (set_current_color_edit_id)

	test	eax, eax
	jne	SHORT $LN11@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [rbx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5161 :         g.ColorEditCurrentID = window->IDStack.back();

	mov	rax, QWORD PTR [rbx+304]
	mov	ecx, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR [rsi+23832], ecx
$LN11@ColorEdit4:

; 5162 : 
; 5163 :     // If we're not showing any slider there's no point in doing any HSV conversions
; 5164 :     const ImGuiColorEditFlags flags_untouched = flags;
; 5165 :     if (flags & ImGuiColorEditFlags_NoInputs)

	mov	eax, edi
	mov	DWORD PTR flags_untouched$1$[rbp-256], edi
	and	eax, 32					; 00000020H
	je	SHORT $LN12@ColorEdit4

; 5166 :         flags = (flags & (~ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;

	and	edi, -6291457				; ffffffffff9fffffH
	or	edi, 1048584				; 00100008H
$LN12@ColorEdit4:

; 5167 : 
; 5168 :     // Context menu: display and modify options (before defaults are applied)
; 5169 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	dil, 8
	jne	SHORT $LN13@ColorEdit4

; 5170 :         ColorEditOptionsPopup(col, flags);

	mov	edx, edi
	mov	rcx, r12
	call	?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z ; ImGui::ColorEditOptionsPopup
$LN13@ColorEdit4:

; 5171 : 
; 5172 :     // Read stored options
; 5173 :     if (!(flags & ImGuiColorEditFlags_DisplayMask_))

	mov	ecx, DWORD PTR [rsi+23828]
	test	edi, 7340032				; 00700000H
	jne	SHORT $LN698@ColorEdit4

; 5174 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);

	mov	eax, ecx
	and	eax, 7340032				; 00700000H
	or	edi, eax
$LN698@ColorEdit4:

; 5175 :     if (!(flags & ImGuiColorEditFlags_DataTypeMask_))

	test	edi, 25165824				; 01800000H
	jne	SHORT $LN15@ColorEdit4

; 5176 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DataTypeMask_);

	mov	eax, ecx
	and	eax, 25165824				; 01800000H
	or	edi, eax
$LN15@ColorEdit4:

; 5177 :     if (!(flags & ImGuiColorEditFlags_PickerMask_))

	test	edi, 100663296				; 06000000H
	jne	SHORT $LN16@ColorEdit4

; 5178 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_);

	mov	eax, ecx
	and	eax, 100663296				; 06000000H
	or	edi, eax
$LN16@ColorEdit4:

; 5179 :     if (!(flags & ImGuiColorEditFlags_InputMask_))

	test	edi, 402653184				; 18000000H
	jne	SHORT $LN17@ColorEdit4

; 5180 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_InputMask_);

	mov	eax, ecx
	and	eax, 402653184				; 18000000H
	or	edi, eax
$LN17@ColorEdit4:

; 5181 :     flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_));
; 5182 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_DisplayMask_)); // Check that only 1 is selected
; 5183 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));   // Check that only 1 is selected
; 5184 : 
; 5185 :     const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
; 5186 :     const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
; 5187 :     const int components = alpha ? 4 : 3;
; 5188 : 
; 5189 :     // Convert to the formats we need
; 5190 :     float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };

	movss	xmm3, DWORD PTR [r12]
	and	ecx, -535822337				; ffffffffe00fffffH
	movss	xmm1, DWORD PTR [r12+4]
	or	edi, ecx
	movss	xmm2, DWORD PTR [r12+8]
	mov	eax, edi
	movss	xmm11, DWORD PTR __real@3f800000
	mov	r15d, edi
	shr	eax, 1
	shr	r15d, 19
	not	al
	and	al, 1
	movss	DWORD PTR f$[rbp-256], xmm3
	movzx	edx, al
	and	r15b, 1
	movss	DWORD PTR f$[rbp-252], xmm1
	movss	DWORD PTR f$[rbp-248], xmm2
	mov	DWORD PTR flags$GSCopy$1$[rsp], edi
	mov	DWORD PTR tv1931[rsp], edx
	lea	ecx, DWORD PTR [rdx+3]
	mov	DWORD PTR components$1$[rsp], ecx
	mov	DWORD PTR tv4535[rbp-256], r15d
	test	al, al
	je	SHORT $LN58@ColorEdit4
	movss	xmm0, DWORD PTR [r12+12]
	jmp	SHORT $LN834@ColorEdit4
$LN58@ColorEdit4:
	movaps	xmm0, xmm11
$LN834@ColorEdit4:
	mov	eax, edi

; 5191 :     if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))

	movss	DWORD PTR f$[rbp-244], xmm0
	and	eax, 269484032				; 10100000H
	mov	DWORD PTR tv4352[rsp], eax
	cmp	eax, 269484032				; 10100000H
	jne	SHORT $LN18@ColorEdit4

; 5192 :         ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

	lea	rax, QWORD PTR f$[rbp-248]
	movaps	xmm0, xmm3
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR f$[rbp-256]
	lea	rax, QWORD PTR f$[rbp-252]
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	jmp	SHORT $LN835@ColorEdit4
$LN18@ColorEdit4:
	mov	eax, edi
	and	eax, 136314880				; 08200000H

; 5193 :     else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))

	cmp	eax, 136314880				; 08200000H
	jne	SHORT $LN20@ColorEdit4

; 5194 :     {
; 5195 :         // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
; 5196 :         ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

	lea	rax, QWORD PTR f$[rbp-248]
	movaps	xmm0, xmm3
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR f$[rbp-256]
	lea	rax, QWORD PTR f$[rbp-252]
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV

; 5197 :         ColorEditRestoreHS(col, &f[0], &f[1], &f[2]);

	mov	rcx, r12
	lea	r9, QWORD PTR f$[rbp-248]
	lea	r8, QWORD PTR f$[rbp-252]
	lea	rdx, QWORD PTR f$[rbp-256]
	call	?ColorEditRestoreHS@@YAXPEBMPEAM11@Z	; ColorEditRestoreHS
$LN835@ColorEdit4:

; 5198 :     }
; 5199 :     int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

	mov	edx, DWORD PTR tv1931[rsp]
	mov	ecx, DWORD PTR components$1$[rsp]
	movss	xmm3, DWORD PTR f$[rbp-256]
	movss	xmm1, DWORD PTR f$[rbp-252]
	movss	xmm2, DWORD PTR f$[rbp-248]
	movss	xmm0, DWORD PTR f$[rbp-244]
$LN20@ColorEdit4:
	comiss	xmm3, xmm9
	movss	xmm5, DWORD PTR __real@bf000000
	movss	xmm4, DWORD PTR __real@3f000000
	jb	SHORT $LN60@ColorEdit4
	movaps	xmm7, xmm4
	jmp	SHORT $LN61@ColorEdit4
$LN60@ColorEdit4:
	movaps	xmm7, xmm5
$LN61@ColorEdit4:
	comiss	xmm1, xmm9
	movss	xmm6, DWORD PTR __real@437f0000
	mulss	xmm3, xmm6
	addss	xmm3, xmm7
	cvttss2si eax, xmm3
	mov	DWORD PTR i$[rbp-256], eax
	jb	SHORT $LN62@ColorEdit4
	movaps	xmm3, xmm4
	jmp	SHORT $LN63@ColorEdit4
$LN62@ColorEdit4:
	movaps	xmm3, xmm5
$LN63@ColorEdit4:
	comiss	xmm2, xmm9
	mulss	xmm1, xmm6
	addss	xmm1, xmm3
	cvttss2si eax, xmm1
	mov	DWORD PTR i$[rbp-252], eax
	jb	SHORT $LN64@ColorEdit4
	movaps	xmm1, xmm4
	jmp	SHORT $LN65@ColorEdit4
$LN64@ColorEdit4:
	movaps	xmm1, xmm5
$LN65@ColorEdit4:
	comiss	xmm0, xmm9
	mulss	xmm2, xmm6
	addss	xmm2, xmm1
	cvttss2si eax, xmm2
	mov	DWORD PTR i$[rbp-248], eax
	jae	SHORT $LN67@ColorEdit4
	movaps	xmm4, xmm5
$LN67@ColorEdit4:

; 5200 : 
; 5201 :     bool value_changed = false;

	xor	r13b, r13b
	mulss	xmm0, xmm6

; 5202 :     bool value_changed_as_float = false;
; 5203 : 
; 5204 :     const ImVec2 pos = window->DC.CursorPos;
; 5205 :     const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;

	cmp	DWORD PTR [rsi+14700], 0
	mov	BYTE PTR value_changed$1$[rsp], r13b
	mov	BYTE PTR value_changed_as_float$1$[rsp], r13b
	addss	xmm0, xmm4
	cvttss2si eax, xmm0
	mov	DWORD PTR i$[rbp-244], eax
	movss	xmm15, DWORD PTR [rbx+312]
	movss	xmm14, DWORD PTR [rbx+316]
	jne	SHORT $LN68@ColorEdit4
	movaps	xmm0, xmm12
	jmp	SHORT $LN69@ColorEdit4
$LN68@ColorEdit4:
	movaps	xmm0, xmm9
$LN69@ColorEdit4:

; 5206 :     window->DC.CursorPos.x = pos.x + inputs_offset_x;

	addss	xmm0, xmm15

; 5207 : 
; 5208 :     if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	eax, edi
	and	eax, 32					; 00000020H
	movss	DWORD PTR [rbx+312], xmm0
	test	edi, 3145728				; 00300000H
	je	$LN699@ColorEdit4
	test	eax, eax
	jne	$LN699@ColorEdit4

; 5211 :         const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_inputs - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));

	movss	xmm2, DWORD PTR [rsi+14636]
	lea	eax, DWORD PTR [rcx-1]
	movd	xmm3, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	lea	rdx, QWORD PTR text_size$6[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5211 :         const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_inputs - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));

	movaps	xmm0, xmm2
	movaps	xmm1, xmm10
	cvtdq2ps xmm3, xmm3

; 5214 :         const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);

	mov	r14d, edi
	and	r14d, 16777216				; 01000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm7, xmm11
	movaps	xmm8, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5211 :         const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_inputs - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));

	mulss	xmm0, xmm3
	subss	xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0

; 5214 :         const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);

	lea	rcx, OFFSET FLAT:??_C@_07FFNLLALM@M?30?4000@
	divss	xmm1, xmm0
	movaps	xmm0, xmm10
	cvttss2si eax, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm7, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5212 :         const float w_item_last = ImMax(1.0f, IM_FLOOR(w_inputs - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

	addss	xmm2, xmm7
	mulss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm3, DWORD PTR __real@7f7fffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5212 :         const float w_item_last = ImMax(1.0f, IM_FLOOR(w_inputs - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

	subss	xmm0, xmm2
	cvttss2si eax, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movd	xmm1, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5214 :         const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);

	lea	rax, OFFSET FLAT:??_C@_05BNGMMMAL@M?3000@
	cmovne	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5212 :         const float w_item_last = ImMax(1.0f, IM_FLOOR(w_inputs - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	xor	ebx, ebx
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+40], rax
	movss	xmm2, DWORD PTR [rcx+15696]
	mov	rcx, QWORD PTR [rcx+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm8, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$6[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5228 :         const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;

	mov	r12d, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5214 :         const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);

	comiss	xmm0, xmm7

; 5228 :         const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;

	jae	SHORT $LN71@ColorEdit4
	bt	edi, 21
	setb	r12b
	inc	r12
$LN71@ColorEdit4:

; 5230 :         for (int n = 0; n < components; n++)

	mov	r8d, DWORD PTR components$1$[rsp]
	test	r8d, r8d
	je	$LN737@ColorEdit4

; 5235 : 
; 5236 :             // FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
; 5237 :             if (flags & ImGuiColorEditFlags_Float)

	test	r14d, r14d
	je	$LN24@ColorEdit4

; 5174 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);

	movss	xmm6, DWORD PTR __real@3b808081
	lea	r13, OFFSET FLAT:?ids@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAPEBDA
	mov	r14d, edi
	shl	r12, 5
	and	r14d, 8
	lea	rax, OFFSET FLAT:__ImageBase
	sub	r12, r13
	mov	DWORD PTR tv4356[rsp], r14d
	lea	rdi, QWORD PTR ?fmt_table_float@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA[rax]
	add	rdi, r12
	lea	r15, QWORD PTR f$[rbp-256]
	mov	r12d, DWORD PTR tv4535[rbp-256]
$LL4@ColorEdit4:

; 5231 :         {
; 5232 :             if (n > 0)

	test	ebx, ebx
	je	SHORT $LN23@ColorEdit4

; 5233 :                 SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rsi+14636]
	movaps	xmm0, xmm9
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
$LN23@ColorEdit4:

; 5234 :             SetNextItemWidth((n + 1 < components) ? w_item_one : w_item_last);

	lea	eax, DWORD PTR [rbx+1]
	mov	ebx, eax
	cmp	eax, r8d
	jge	SHORT $LN72@ColorEdit4
	movaps	xmm0, xmm7
	jmp	SHORT $LN73@ColorEdit4
$LN72@ColorEdit4:
	movaps	xmm0, xmm8
$LN73@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10323:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10324:     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;

	or	DWORD PTR [rax+18592], 1

; 10325:     g.NextItemData.Width = item_width;

	movss	DWORD PTR [rax+18600], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5239 :                 value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);

	mov	rax, QWORD PTR [rdi+r13]
	test	r12b, r12b
	je	SHORT $LN74@ColorEdit4
	movaps	xmm0, xmm9
	jmp	SHORT $LN75@ColorEdit4
$LN74@ColorEdit4:
	movaps	xmm0, xmm11
$LN75@ColorEdit4:

; 2519 :     return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);

	mov	rcx, QWORD PTR [r13]
	movaps	xmm3, xmm6
	mov	QWORD PTR [rsp+48], rax
	mov	r8, r15
	lea	rax, QWORD PTR v_max$[rbp-256]

; 5239 :                 value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);

	movss	DWORD PTR v_max$[rbp-256], xmm0

; 2519 :     return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);

	mov	QWORD PTR [rsp+40], rax
	mov	edx, 8
	lea	rax, QWORD PTR v_min$[rbp-256]

; 5239 :                 value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);

	mov	DWORD PTR v_min$[rbp-256], 0

; 2519 :     return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags);

	mov	QWORD PTR [rsp+32], rax
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z ; ImGui::DragScalar

; 5239 :                 value_changed |= DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);

	movzx	ecx, BYTE PTR value_changed$1$[rsp]
	or	cl, al

; 5240 :                 value_changed_as_float |= value_changed;

	or	BYTE PTR value_changed_as_float$1$[rsp], cl
	mov	BYTE PTR value_changed$1$[rsp], cl

; 5245 :             }
; 5246 :             if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	r14d, r14d
	jne	SHORT $LN2@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	mov	r14, QWORD PTR [rax+16408]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN725@ColorEdit4
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN725@ColorEdit4

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, r14
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN725@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5230 :         for (int n = 0; n < components; n++)

	mov	r14d, DWORD PTR tv4356[rsp]
$LN2@ColorEdit4:
	mov	r8d, DWORD PTR components$1$[rsp]
	add	r15, 4
	add	r13, 8
	cmp	ebx, r8d
	jl	$LL4@ColorEdit4

; 5241 :             }

	jmp	$LN836@ColorEdit4
$LN24@ColorEdit4:

; 5230 :         for (int n = 0; n < components; n++)

	xor	ecx, ecx
	mov	r13d, ecx
	test	r8d, r8d
	je	$LN684@ColorEdit4

; 5174 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_DisplayMask_);

	xor	eax, eax
	mov	ebx, 255				; 000000ffH

; 5244 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

	test	r15b, r15b
	mov	r14d, eax
	mov	r15d, edi
	lea	rdi, OFFSET FLAT:?ids@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAPEBDA
	cmovne	ebx, eax
	and	r15d, 8
	mov	DWORD PTR tv4355[rsp], r15d
	shl	r12, 5
	npad	7
$LL674@ColorEdit4:

; 5231 :         {
; 5232 :             if (n > 0)

	mov	edx, r13d
	test	r13d, r13d
	je	SHORT $LN675@ColorEdit4

; 5233 :                 SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rsi+14636]
	movaps	xmm0, xmm9
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
$LN675@ColorEdit4:

; 5234 :             SetNextItemWidth((n + 1 < components) ? w_item_one : w_item_last);

	lea	eax, DWORD PTR [r13+1]
	mov	r13d, eax
	cmp	eax, r8d
	jge	SHORT $LN676@ColorEdit4
	movaps	xmm0, xmm7
	jmp	SHORT $LN677@ColorEdit4
$LN676@ColorEdit4:
	movaps	xmm0, xmm8
$LN677@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10323:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5244 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

	lea	rcx, OFFSET FLAT:__ImageBase
	lea	r8, QWORD PTR i$[rbp-256]
	mov	DWORD PTR v_max$[rbp-256], ebx
	lea	r8, QWORD PTR [r8+rdx*4]

; 2573 :     return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);

	movaps	xmm3, xmm11
	mov	edx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10324:     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;

	or	DWORD PTR [rax+18592], 1

; 10325:     g.NextItemData.Width = item_width;

	movss	DWORD PTR [rax+18600], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5244 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

	lea	rax, QWORD PTR [r12+r14*8]
	mov	rcx, QWORD PTR ?fmt_table_int@?BL@??ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z@4PAY03PEBDA[rax+rcx]
	xor	eax, eax

; 2573 :     return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);

	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR [rdi+r14*8]

; 5244 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

	mov	DWORD PTR v_min$[rbp-256], eax

; 2573 :     return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);

	lea	rax, QWORD PTR v_max$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR v_min$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z ; ImGui::DragScalar

; 5244 :                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);

	or	BYTE PTR value_changed$1$[rsp], al

; 5245 :             }
; 5246 :             if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	r15d, r15d
	jne	SHORT $LN714@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	mov	r15, QWORD PTR [rax+16408]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN723@ColorEdit4
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN723@ColorEdit4

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, r15
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN723@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5230 :         for (int n = 0; n < components; n++)

	mov	r15d, DWORD PTR tv4355[rsp]
$LN714@ColorEdit4:
	mov	r8d, DWORD PTR components$1$[rsp]
	inc	r14
	cmp	r14, r8
	jl	$LL674@ColorEdit4
$LN836@ColorEdit4:

; 5247 :                 OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
; 5248 :         }
; 5249 :     }

	movzx	r13d, BYTE PTR value_changed$1$[rsp]
	mov	edi, DWORD PTR flags$GSCopy$1$[rsp]
$LN737@ColorEdit4:
	xor	ecx, ecx
$LN684@ColorEdit4:
	movss	xmm8, DWORD PTR w_full$1$[rsp]
	mov	r14d, ecx
	mov	r12, QWORD PTR col$GSCopy$1$[rbp-256]
	mov	rbx, QWORD PTR window$1$[rsp]
	jmp	$LN715@ColorEdit4
$LN699@ColorEdit4:

; 5250 :     else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	r14d, eax
	bt	edi, 22
	jae	$LN736@ColorEdit4
	test	eax, eax
	jne	$LN736@ColorEdit4

; 5251 :     {
; 5252 :         // RGB Hexadecimal Input
; 5253 :         char buf[64];
; 5254 :         if (alpha)

	mov	ebx, 255				; 000000ffH
	test	dl, dl
	je	SHORT $LN28@ColorEdit4

; 5255 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	edx, DWORD PTR i$[rbp-244]
	test	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN658@ColorEdit4
	xor	r8d, r8d
	mov	edx, r8d
	jmp	SHORT $LN659@ColorEdit4
$LN658@ColorEdit4:
	cmp	edx, ebx
	cmovg	edx, ebx
	xor	r8d, r8d
$LN659@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5255 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	ecx, DWORD PTR i$[rbp-248]
	test	ecx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN654@ColorEdit4
	mov	ecx, r8d
	jmp	SHORT $LN655@ColorEdit4
$LN654@ColorEdit4:
	cmp	ecx, ebx
	cmovg	ecx, ebx
$LN655@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5255 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	eax, DWORD PTR i$[rbp-252]
	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN638@ColorEdit4
	mov	eax, r8d
	jmp	SHORT $LN639@ColorEdit4
$LN638@ColorEdit4:
	cmp	eax, ebx
	cmovg	eax, ebx
$LN639@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5255 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	r9d, DWORD PTR i$[rbp-256]
	test	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN650@ColorEdit4
	mov	r9d, r8d
	jmp	SHORT $LN651@ColorEdit4
$LN650@ColorEdit4:
	cmp	r9d, ebx
	cmovg	r9d, ebx
$LN651@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5255 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));

	mov	DWORD PTR [rsp+48], edx
	lea	r8, OFFSET FLAT:??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
	mov	DWORD PTR [rsp+40], ecx
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$9[rbp-256]
	mov	DWORD PTR [rsp+32], eax
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
	jmp	SHORT $LN29@ColorEdit4
$LN28@ColorEdit4:

; 5257 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));

	mov	ecx, DWORD PTR i$[rbp-248]
	test	ecx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN634@ColorEdit4
	xor	edx, edx
	mov	ecx, edx
	jmp	SHORT $LN635@ColorEdit4
$LN634@ColorEdit4:
	cmp	ecx, ebx
	cmovg	ecx, ebx
	xor	edx, edx
$LN635@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5257 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));

	mov	eax, DWORD PTR i$[rbp-252]
	test	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN646@ColorEdit4
	mov	eax, edx
	jmp	SHORT $LN647@ColorEdit4
$LN646@ColorEdit4:
	cmp	eax, ebx
	cmovg	eax, ebx
$LN647@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5257 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));

	mov	r9d, DWORD PTR i$[rbp-256]
	test	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jns	SHORT $LN642@ColorEdit4
	mov	r9d, edx
	jmp	SHORT $LN643@ColorEdit4
$LN642@ColorEdit4:
	cmp	r9d, ebx
	cmovg	r9d, ebx
$LN643@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5257 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));

	mov	DWORD PTR [rsp+40], ecx
	lea	r8, OFFSET FLAT:??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
	lea	rcx, QWORD PTR buf$9[rbp-256]
	mov	DWORD PTR [rsp+32], eax
	mov	edx, 64					; 00000040H
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN29@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10323:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	lea	r8, QWORD PTR buf$9[rbp-256]
	xor	r14d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T4[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	QWORD PTR [rsp+56], r14
	lea	rcx, OFFSET FLAT:??_C@_06MNCEJPDI@?$CD?$CDText@
	mov	QWORD PTR [rsp+48], r14
	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10324:     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;

	or	DWORD PTR [rax+18592], 1

; 10325:     g.NextItemData.Width = item_width;

	movss	DWORD PTR [rax+18600], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	lea	r9d, QWORD PTR [r14+64]
	lea	rax, QWORD PTR $T4[rsp]
	mov	DWORD PTR [rsp+40], 6
	mov	QWORD PTR [rsp+32], rax
	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 5258 :         SetNextItemWidth(w_inputs);
; 5259 :         if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))

	test	al, al
	je	SHORT $LN33@ColorEdit4

; 5260 :         {
; 5261 :             value_changed = true;

	mov	r13b, 1

; 5262 :             char* p = buf;

	lea	rcx, QWORD PTR buf$9[rbp-256]
	npad	3
$LL5@ColorEdit4:

; 5263 :             while (*p == '#' || ImCharIsBlankA(*p))

	movzx	eax, BYTE PTR [rcx]
	cmp	al, 35					; 00000023H
	je	SHORT $LN31@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN31@ColorEdit4
	cmp	al, 9
	jne	SHORT $LN712@ColorEdit4
$LN31@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5264 :                 p++;

	inc	rcx
	jmp	SHORT $LL5@ColorEdit4
$LN712@ColorEdit4:

; 5265 :             i[0] = i[1] = i[2] = 0;
; 5266 :             i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)
; 5267 :             int r;
; 5268 :             if (alpha)

	lea	r9, QWORD PTR i$[rbp-252]
	mov	QWORD PTR i$[rbp-252], r14
	lea	r8, QWORD PTR i$[rbp-256]
	mov	DWORD PTR i$[rbp-256], r14d
	mov	DWORD PTR i$[rbp-244], ebx
	cmp	BYTE PTR tv1931[rsp], r14b
	je	SHORT $LN32@ColorEdit4

; 5269 :                 r = sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)

	lea	rax, QWORD PTR i$[rbp-244]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BB@DDMGLOLI@?$CF02X?$CF02X?$CF02X?$CF02X@
	lea	rax, QWORD PTR i$[rbp-248]
	mov	QWORD PTR [rsp+32], rax
	call	sscanf
	jmp	SHORT $LN33@ColorEdit4
$LN32@ColorEdit4:

; 5270 :             else
; 5271 :                 r = sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);

	lea	rax, QWORD PTR i$[rbp-248]
	lea	rdx, OFFSET FLAT:??_C@_0N@KODLFHPJ@?$CF02X?$CF02X?$CF02X@
	mov	QWORD PTR [rsp+32], rax
	call	sscanf
$LN33@ColorEdit4:

; 5272 :             IM_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.
; 5273 :         }
; 5274 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	dil, 8
	jne	SHORT $LN729@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11239:     ImGuiWindow* window = g.CurrentWindow;

	mov	rbx, QWORD PTR [rax+16408]

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	xor	eax, eax
	lea	ecx, QWORD PTR [rax+1]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN729@ColorEdit4
	xor	eax, eax
	lea	ecx, QWORD PTR [rax+32]
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN729@ColorEdit4

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, rbx
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN729@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5278 :     ImGuiWindow* picker_active_window = NULL;

	mov	rbx, QWORD PTR window$1$[rsp]
$LN736@ColorEdit4:
	xor	ecx, ecx
$LN715@ColorEdit4:
	mov	r15, rcx

; 5279 :     if (!(flags & ImGuiColorEditFlags_NoSmallPreview))

	test	dil, 16
	jne	$LN731@ColorEdit4

; 5280 :     {
; 5281 :         const float button_offset_x = ((flags & ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;

	test	r14d, r14d
	jne	SHORT $LN76@ColorEdit4
	cmp	DWORD PTR [rsi+14700], r14d
	je	SHORT $LN76@ColorEdit4
	addss	xmm10, DWORD PTR [rsi+14636]
	jmp	SHORT $LN77@ColorEdit4
$LN76@ColorEdit4:
	movaps	xmm10, xmm9
$LN77@ColorEdit4:

; 5282 :         window->DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);
; 5283 : 
; 5284 :         const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);

	cmp	BYTE PTR tv1931[rsp], 0
	addss	xmm10, xmm15
	movss	DWORD PTR [rbx+316], xmm14
	movss	DWORD PTR [rbx+312], xmm10
	je	SHORT $LN78@ColorEdit4
	movss	xmm11, DWORD PTR [r12+12]
$LN78@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5285 :         if (ColorButton("##ColorButton", col_v4, flags))

	lea	r9, QWORD PTR $T7[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm1, DWORD PTR [r12+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5285 :         if (ColorButton("##ColorButton", col_v4, flags))

	lea	rdx, QWORD PTR col_v4$8[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR col_v4$8[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5285 :         if (ColorButton("##ColorButton", col_v4, flags))

	lea	rcx, OFFSET FLAT:??_C@_0O@GLNBIEEK@?$CD?$CDColorButton@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [r12+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5285 :         if (ColorButton("##ColorButton", col_v4, flags))

	mov	r8d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR col_v4$8[rbp-248], xmm0
	movss	DWORD PTR col_v4$8[rbp-252], xmm1
	movss	DWORD PTR col_v4$8[rbp-244], xmm11

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T7[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5285 :         if (ColorButton("##ColorButton", col_v4, flags))

	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton
	test	al, al
	je	SHORT $LN716@ColorEdit4

; 5286 :         {
; 5287 :             if (!(flags & ImGuiColorEditFlags_NoPicker))

	test	dil, 4
	jne	SHORT $LN716@ColorEdit4

; 5288 :             {
; 5289 :                 // Store current color and open a picker
; 5290 :                 g.ColorPickerRef = col_v4;

	movups	xmm0, XMMWORD PTR col_v4$8[rbp-256]

; 5291 :                 OpenPopup("picker");

	lea	rcx, OFFSET FLAT:??_C@_06MAKAMBBI@picker@
	movups	XMMWORD PTR [rsi+23852], xmm0
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm1, DWORD PTR [rsi+18628]
	movss	xmm0, DWORD PTR [rsi+14632]
	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8113 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rsi+18640]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8115 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;

	or	DWORD PTR [rax+18680], 1

; 8116 :     g.NextWindowData.PosVal = pos;
; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	xor	ecx, ecx
	movss	DWORD PTR [rax+18700], xmm1
	mov	QWORD PTR [rax+18708], rcx
	movss	DWORD PTR [rax+18704], xmm0

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rax+18684], 1

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [rax+18740], 1
$LN716@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5295 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	dil, 8
	jne	SHORT $LN717@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	mov	rbx, QWORD PTR [rax+16408]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN717@ColorEdit4
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN717@ColorEdit4

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, rbx
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN717@ColorEdit4:

; 11170:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11171:     if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	eax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jg	$LN107@ColorEdit4

; 11172:     {
; 11173:         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	xor	eax, eax
	mov	DWORD PTR [rcx+18680], eax
$LN731@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5317 :     if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))

	mov	rbx, QWORD PTR label$GSCopy$1$[rsp]
$LN718@ColorEdit4:
	mov	rdx, QWORD PTR text_display_end$1$[rsp]
	movaps	xmm14, XMMWORD PTR [rsp+320]
	movaps	xmm13, XMMWORD PTR [rsp+336]
	movaps	xmm11, XMMWORD PTR [rsp+368]
	movaps	xmm10, XMMWORD PTR [rsp+384]
	cmp	rbx, rdx
	je	SHORT $LN42@ColorEdit4
	test	dil, dil
	js	SHORT $LN42@ColorEdit4

; 5318 :     {
; 5319 :         // Position not necessarily next to last submitted button (e.g. if style.ColorButtonPosition == ImGuiDir_Left),
; 5320 :         // but we need to use SameLine() to setup baseline correctly. Might want to refactor SameLine() to simplify this.
; 5321 :         SameLine(0.0f, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rsi+14636]
	movaps	xmm0, xmm9
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 5322 :         window->DC.CursorPos.x = pos.x + ((flags & ImGuiColorEditFlags_NoInputs) ? w_button : w_full + style.ItemInnerSpacing.x);

	test	r14d, r14d
	jne	SHORT $LN81@ColorEdit4
	addss	xmm8, DWORD PTR [rsi+14636]
	movaps	xmm12, xmm8
$LN81@ColorEdit4:
	mov	rax, QWORD PTR window$1$[rsp]
	addss	xmm12, xmm15

; 5323 :         TextEx(label, label_display_end);

	xor	r8d, r8d
	mov	rcx, rbx
	movss	DWORD PTR [rax+312], xmm12
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN42@ColorEdit4:

; 5324 :     }
; 5325 : 
; 5326 :     // Convert back
; 5327 :     if (value_changed && picker_active_window == NULL)

	movaps	xmm15, XMMWORD PTR [rsp+304]
	movaps	xmm12, XMMWORD PTR [rsp+352]
	movaps	xmm9, XMMWORD PTR [rsp+400]
	test	r13b, r13b
	je	$LN734@ColorEdit4
	test	r15, r15
	jne	$LN734@ColorEdit4

; 5328 :     {
; 5329 :         if (!value_changed_as_float)

	cmp	BYTE PTR value_changed_as_float$1$[rsp], r15b
	jne	SHORT $LN695@ColorEdit4

; 5330 :             for (int n = 0; n < 4; n++)
; 5331 :                 f[n] = i[n] / 255.0f;

	movdqu	xmm0, XMMWORD PTR i$[rbp-256]
	cvtdq2ps xmm1, xmm0
	divps	xmm1, XMMWORD PTR __xmm@437f0000437f0000437f0000437f0000
	movups	XMMWORD PTR f$[rbp-256], xmm1
$LN695@ColorEdit4:

; 5332 :         if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))

	mov	eax, edi
	and	eax, 136314880				; 08200000H
	cmp	eax, 136314880				; 08200000H
	jne	$LN719@ColorEdit4

; 5333 :         {
; 5334 :             g.ColorEditSavedHue = f[0];

	movss	xmm0, DWORD PTR f$[rbp-256]

; 5335 :             g.ColorEditSavedSat = f[1];
; 5336 :             ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

	lea	rax, QWORD PTR f$[rbp-248]
	movss	xmm1, DWORD PTR f$[rbp-252]
	lea	r9, QWORD PTR f$[rbp-256]
	movss	xmm2, DWORD PTR f$[rbp-248]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR f$[rbp-252]
	mov	QWORD PTR [rsp+32], rax
	movss	DWORD PTR [rsi+23840], xmm0
	movss	DWORD PTR [rsi+23844], xmm1
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 5337 :             g.ColorEditSavedID = g.ColorEditCurrentID;

	mov	eax, DWORD PTR [rsi+23832]

; 5338 :             g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));

	lea	rcx, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm6, DWORD PTR f$[rbp-256]
	movss	xmm7, DWORD PTR f$[rbp-252]
	movss	xmm8, DWORD PTR f$[rbp-248]
	movss	DWORD PTR $T5[rsp], xmm6
	movss	DWORD PTR $T5[rsp+4], xmm7
	movss	DWORD PTR $T5[rbp-248], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5337 :             g.ColorEditSavedID = g.ColorEditCurrentID;

	mov	DWORD PTR [rsi+23836], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR $T5[rbp-244], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5338 :             g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR [rsi+23848], eax
	jmp	$LN45@ColorEdit4
$LN107@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11177:     ImGuiID id = g.CurrentWindow->GetID(str_id);

	mov	r10, QWORD PTR [rcx+16408]

; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_06MAKAMBBI@picker@+1
	mov	r8b, 112				; 00000070H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [r10+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	rax, QWORD PTR [r10+304]
	mov	r9d, DWORD PTR [rax+rcx*4-4]
	not	r9d

; 2050 :     ImU32 crc = seed;

	mov	ebx, r9d
	npad	2
$LL119@ColorEdit4:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN124@ColorEdit4
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN124@ColorEdit4
	cmp	BYTE PTR [rdx+1], r8b
	cmove	ebx, r9d
$LN124@ColorEdit4:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, bl
	movzx	eax, r8b
	movzx	r8d, BYTE PTR [rdx]
	xor	rcx, rax
	shr	ebx, 8
	lea	rax, OFFSET FLAT:__ImageBase
	inc	rdx
	xor	ebx, DWORD PTR ?GCrc32LookupTable@@3QBIB[rax+rcx*4]
	test	r8b, r8b
	jne	SHORT $LL119@ColorEdit4

; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rax, QWORD PTR [r10]

; 2072 :     return ~crc;

	not	ebx

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], ebx
	jne	SHORT $LN110@ColorEdit4

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_06MAKAMBBI@picker@
	mov	edx, 11
	mov	ecx, ebx
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN110@ColorEdit4:

; 11178:     return BeginPopupEx(id, flags);

	mov	edx, 321				; 00000141H
	mov	ecx, ebx
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5298 :         if (BeginPopup("picker"))

	test	al, al
	je	$LN731@ColorEdit4

; 5299 :         {
; 5300 :             if (g.CurrentWindow->BeginCount == 1)

	mov	rax, QWORD PTR [rsi+16408]
	mov	rbx, QWORD PTR label$GSCopy$1$[rsp]
	cmp	WORD PTR [rax+248], 1
	jne	SHORT $LN40@ColorEdit4

; 5301 :             {
; 5302 :                 picker_active_window = g.CurrentWindow;

	mov	r15, rax

; 5303 :                 if (label != label_display_end)

	mov	rax, QWORD PTR text_display_end$1$[rsp]
	cmp	rbx, rax
	je	SHORT $LN41@ColorEdit4

; 5304 :                 {
; 5305 :                     TextEx(label, label_display_end);

	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rbx
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx

; 5306 :                     Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing
$LN41@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10323:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5311 :                 value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);

	lea	r9, QWORD PTR [rsi+23852]
	mulss	xmm13, DWORD PTR __real@41400000
	lea	rcx, OFFSET FLAT:??_C@_08HHEANBBL@?$CD?$CDpicker@
	mov	r8d, DWORD PTR flags_untouched$1$[rbp-256]
	mov	rdx, r12
	and	r8d, 529072130				; 1f890002H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10324:     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;

	or	DWORD PTR [rax+18592], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5309 :                 ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;

	or	r8d, 7602304				; 00740080H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10325:     g.NextItemData.Width = item_width;

	movss	DWORD PTR [rax+18600], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5311 :                 value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);

	call	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4
	or	r13b, al
$LN40@ColorEdit4:

; 5312 :             }
; 5313 :             EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	jmp	$LN718@ColorEdit4
$LN719@ColorEdit4:

; 5332 :         if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))

	movss	xmm8, DWORD PTR f$[rbp-248]
	movss	xmm7, DWORD PTR f$[rbp-252]
	movss	xmm6, DWORD PTR f$[rbp-256]
$LN45@ColorEdit4:

; 5339 :         }
; 5340 :         if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))

	cmp	DWORD PTR tv4352[rsp], 269484032	; 10100000H
	jne	SHORT $LN46@ColorEdit4

; 5341 :             ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

	lea	rax, QWORD PTR f$[rbp-248]
	movaps	xmm2, xmm8
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR f$[rbp-256]
	lea	rax, QWORD PTR f$[rbp-252]
	movaps	xmm1, xmm7
	movaps	xmm0, xmm6
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV
	movss	xmm8, DWORD PTR f$[rbp-248]
	movss	xmm7, DWORD PTR f$[rbp-252]
	movss	xmm6, DWORD PTR f$[rbp-256]
$LN46@ColorEdit4:

; 5342 : 
; 5343 :         col[0] = f[0];
; 5344 :         col[1] = f[1];
; 5345 :         col[2] = f[2];
; 5346 :         if (alpha)

	cmp	BYTE PTR tv1931[rsp], 0
	lea	r14, QWORD PTR [r12+4]
	movss	DWORD PTR [r14], xmm7
	movss	DWORD PTR [r12], xmm6
	movss	DWORD PTR [r12+8], xmm8
	je	SHORT $LN47@ColorEdit4

; 5347 :             col[3] = f[3];

	movss	xmm0, DWORD PTR f$[rbp-244]
	movss	DWORD PTR [r12+12], xmm0
	jmp	SHORT $LN47@ColorEdit4
$LN734@ColorEdit4:

; 5348 :     }
; 5349 : 
; 5350 :     if (set_current_color_edit_id)

	lea	r14, QWORD PTR [r12+4]
$LN47@ColorEdit4:
	cmp	DWORD PTR tv4374[rbp-256], 0
	movaps	xmm8, XMMWORD PTR [rsp+416]
	movaps	xmm7, XMMWORD PTR [rsp+432]
	movaps	xmm6, XMMWORD PTR [rsp+448]
	jne	SHORT $LN48@ColorEdit4

; 5351 :         g.ColorEditCurrentID = 0;

	xor	eax, eax
	mov	DWORD PTR [rsi+23832], eax
$LN48@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5353 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 5354 : 
; 5355 :     // Drag and Drop Target
; 5356 :     // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
; 5357 :     if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())

	test	BYTE PTR [rsi+18624], 1
	je	$LN720@ColorEdit4
	bt	edi, 9
	jb	$LN720@ColorEdit4
	call	?BeginDragDropTarget@ImGui@@YA_NXZ	; ImGui::BeginDragDropTarget
	test	al, al
	je	$LN720@ColorEdit4

; 5358 :     {
; 5359 :         bool accepted_drag_drop = false;
; 5360 :         if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_06LFKNFKEK@_COL3F@
	xor	bl, bl
	call	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ; ImGui::AcceptDragDropPayload
	test	rax, rax
	je	SHORT $LN50@ColorEdit4

; 5361 :         {
; 5362 :             memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512 //-V1086

	mov	rax, QWORD PTR [rax]

; 5363 :             value_changed = accepted_drag_drop = true;

	mov	bl, 1
	movzx	r13d, bl
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR [r12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r12+8], eax
$LN50@ColorEdit4:

; 5364 :         }
; 5365 :         if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))

	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_06LAOCEMMP@_COL4F@
	call	?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z ; ImGui::AcceptDragDropPayload
	test	rax, rax
	je	SHORT $LN51@ColorEdit4

; 5366 :         {
; 5367 :             memcpy((float*)col, payload->Data, sizeof(float) * components);

	mov	r8d, DWORD PTR components$1$[rsp]
	mov	rcx, r12
	mov	rdx, QWORD PTR [rax]
	shl	r8, 2
	call	memcpy

; 5368 :             value_changed = accepted_drag_drop = true;

	mov	r13b, 1

; 5369 :         }
; 5370 : 
; 5371 :         // Drag-drop payloads are always RGB
; 5372 :         if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))

	jmp	SHORT $LN710@ColorEdit4
$LN51@ColorEdit4:
	test	bl, bl
	je	SHORT $LN52@ColorEdit4
$LN710@ColorEdit4:
	bt	edi, 28
	jae	SHORT $LN52@ColorEdit4

; 5373 :             ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);

	movss	xmm2, DWORD PTR [r12+8]
	lea	rax, QWORD PTR [r12+8]
	movss	xmm1, DWORD PTR [r14]
	mov	r9, r12
	movss	xmm0, DWORD PTR [r12]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r14
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertRGBtoHSV
$LN52@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13314:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13315:     IM_ASSERT(g.DragDropActive);
; 13316:     IM_ASSERT(g.DragDropWithinTarget);
; 13317:     g.DragDropWithinTarget = false;
; 13318: 
; 13319:     // Clear drag and drop state payload right after delivery
; 13320:     if (g.DragDropPayload.Delivery)

	cmp	BYTE PTR [rax+19618], 0
	mov	BYTE PTR [rax+19546], 0
	je	SHORT $LN720@ColorEdit4

; 13321:         ClearDragDrop();

	call	?ClearDragDrop@ImGui@@YAXXZ		; ImGui::ClearDragDrop
$LN720@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5378 :     if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)

	test	r15, r15
	je	SHORT $LN53@ColorEdit4
	mov	eax, DWORD PTR [rsi+16504]
	test	eax, eax
	je	SHORT $LN53@ColorEdit4
	cmp	QWORD PTR [rsi+16536], r15
	jne	SHORT $LN53@ColorEdit4

; 5379 :         g.LastItemData.ID = g.ActiveId;

	mov	DWORD PTR [rsi+18616], eax
$LN53@ColorEdit4:
	mov	r15, QWORD PTR [rsp+464]

; 5380 : 
; 5381 :     if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId

	test	r13b, r13b
	je	SHORT $LN54@ColorEdit4
	mov	eax, DWORD PTR [rsi+18616]
	test	eax, eax
	je	SHORT $LN54@ColorEdit4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	edx, DWORD PTR [rcx+16504]
	cmp	edx, eax
	je	SHORT $LN128@ColorEdit4
	test	edx, edx
	jne	SHORT $LN127@ColorEdit4
$LN128@ColorEdit4:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN127@ColorEdit4:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
$LN54@ColorEdit4:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5384 :     return value_changed;

	movzx	eax, r13b
	mov	r13, QWORD PTR [rsp+552]
$LN1@ColorEdit4:

; 5385 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 472				; 000001d8H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z ENDP			; ImGui::ColorEdit4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextWrapped@ImGui@@YAXPEBDZZ
_TEXT	SEGMENT
fmt$ = 64
?TextWrapped@ImGui@@YAXPEBDZZ PROC			; ImGui::TextWrapped, COMDAT

; 310  : {

$LN18:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rdi
	sub	rsp, 40					; 00000028H

; 320  :     const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 311  :     va_list args;
; 312  :     va_start(args, fmt);

	lea	rdi, QWORD PTR fmt$[rsp+8]
	mov	rbx, rcx
	xorps	xmm0, xmm0

; 320  :     const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set

	mov	rcx, QWORD PTR [rax+16408]
	comiss	xmm0, DWORD PTR [rcx+504]
	seta	al

; 321  :     if (need_backup)

	test	al, al
	je	SHORT $LN4@TextWrappe

; 322  :         PushTextWrapPos(0.0f);

	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos
	mov	rdx, rdi
	mov	rcx, rbx
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+528]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7792 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();

	mov	rax, QWORD PTR [r8+536]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+528], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7792 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();

	mov	DWORD PTR [r8+504], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 315  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbx
	ret	0
$LN4@TextWrappe:

; 323  :     TextV(fmt, args);

	mov	rdx, rdi
	mov	rcx, rbx
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV

; 315  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbx
	ret	0
?TextWrapped@ImGui@@YAXPEBDZZ ENDP			; ImGui::TextWrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?RadioButton@ImGui@@YA_NPEBD_N@Z
_TEXT	SEGMENT
active$GSCopy$1$ = 64
hovered$ = 65
held$ = 66
text_size$2 = 72
$T3 = 72
center$ = 72
c$4 = 80
c$5 = 80
c$6 = 96
c$7 = 96
$T8 = 96
total_bb$ = 96
label_pos$ = 112
__$ArrayPad$ = 120
label$ = 352
active$ = 360
?RadioButton@ImGui@@YA_NPEBD_N@Z PROC			; ImGui::RadioButton, COMDAT

; 1206 : {

$LN122:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-88]
	sub	rsp, 288				; 00000120H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	movaps	XMMWORD PTR [rax-152], xmm11
	movaps	XMMWORD PTR [rax-168], xmm12
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1206 : {

	mov	rdi, rcx
	mov	BYTE PTR active$GSCopy$1$[rsp], dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r14, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1208 :     if (window->SkipItems)

	cmp	BYTE PTR [r14+240], 0
	jne	$LN98@RadioButto

; 1213 :     const ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	mov	rcx, r14
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1213 :     const ImGuiID id = window->GetID(label);

	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN101@RadioButto
$LL22@RadioButto:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN101@RadioButto
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN97@RadioButto
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN101@RadioButto
$LN97@RadioButto:

; 3332 :         text_display_end++;

	mov	rdx, rcx
	cmp	rcx, -1
	jb	SHORT $LL22@RadioButto
$LN101@RadioButto:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm1, DWORD PTR [rsi+15696]

; 5418 :     if (text == text_display_end)

	xor	r12d, r12d
	xorps	xmm9, xmm9
	cmp	rdi, rdx
	jne	SHORT $LN19@RadioButto
	xorps	xmm11, xmm11

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN16@RadioButto
$LN19@RadioButto:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movaps	xmm2, xmm1
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [rsi+15688]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR text_size$2[rsp]
	mov	QWORD PTR [rsp+40], rdi
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$2[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm1, DWORD PTR text_size$2[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm11, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm11, xmm11
$LN16@RadioButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1219 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	comiss	xmm11, xmm9
	movss	xmm3, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm6, DWORD PTR [rsi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1219 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	movaps	xmm2, xmm3
	movss	xmm12, DWORD PTR [r14+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1217 :     const ImVec2 pos = window->DC.CursorPos;

	movss	xmm7, DWORD PTR [r14+316]

; 1219 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm10, xmm12
	movaps	xmm8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm6, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1219 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm6
	addss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1219 :     const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));

	jbe	SHORT $LN10@RadioButto
	movaps	xmm1, xmm11
	addss	xmm1, DWORD PTR [rbx+14636]
	jmp	SHORT $LN11@RadioButto
$LN10@RadioButto:
	xorps	xmm1, xmm1
$LN11@RadioButto:
	addss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp+12], xmm0

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm0, xmm7

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp+8], xmm1

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm0
	movss	DWORD PTR $T3[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movaps	xmm1, xmm3
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1221 :     if (!ItemAdd(total_bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR total_bb$[rsp]
	mov	edx, r15d
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN98@RadioButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1221 :     if (!ItemAdd(total_bb, id))

	mov	QWORD PTR [rsp+368], r13
	movaps	XMMWORD PTR [rsp+160], xmm13

; 1230 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	lea	r9, QWORD PTR held$[rsp]
	movss	xmm13, DWORD PTR __real@3f800000
	lea	r8, QWORD PTR hovered$[rsp]
	movaps	XMMWORD PTR [rsp+144], xmm14
	lea	rcx, QWORD PTR total_bb$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	movaps	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1221 :     if (!ItemAdd(total_bb, id))

	movaps	XMMWORD PTR [rsp+128], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1230 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	DWORD PTR [rsp+32], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	movss	xmm12, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1230 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	mov	edx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 527  :     ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }

	mulss	xmm8, xmm12
	mulss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1225 :     center.x = IM_ROUND(center.x);

	addss	xmm8, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1225 :     center.x = IM_ROUND(center.x);

	cvttss2si eax, xmm0
	movd	xmm14, eax

; 1226 :     center.y = IM_ROUND(center.y);

	cvttss2si eax, xmm8

; 1227 :     const float radius = (square_sz - 1.0f) * 0.5f;

	movaps	xmm8, xmm6
	cvtdq2ps xmm14, xmm14
	movd	xmm15, eax
	subss	xmm8, xmm13
	cvtdq2ps xmm15, xmm15
	movss	DWORD PTR center$[rsp], xmm14
	movss	DWORD PTR center$[rsp+4], xmm15
	mulss	xmm8, xmm12

; 1230 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	movzx	r12d, al

; 1231 :     if (pressed)

	test	al, al
	je	SHORT $LN4@RadioButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	edx, DWORD PTR [rcx+16504]
	cmp	edx, r15d
	je	SHORT $LN63@RadioButto
	test	edx, edx
	jne	SHORT $LN62@RadioButto
$LN63@RadioButto:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN62@RadioButto:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
$LN4@RadioButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1234 :     RenderNavHighlight(total_bb, id);

	mov	r8d, 1
	lea	rcx, QWORD PTR total_bb$[rsp]
	mov	edx, r15d
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1235 :     const int num_segment = window->DrawList->_CalcCircleAutoSegmentCount(radius);

	mov	rsi, QWORD PTR [r14+728]
	movaps	xmm1, xmm8
	mov	rcx, rsi
	call	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount

; 1236 :     window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), num_segment);

	cmp	BYTE PTR held$[rsp], 0
	mov	r13d, eax
	movzx	ecx, BYTE PTR hovered$[rsp]
	je	SHORT $LN12@RadioButto
	test	cl, cl
	je	SHORT $LN12@RadioButto
	mov	eax, 9
	jmp	SHORT $LN13@RadioButto
$LN12@RadioButto:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	rax, 7
$LN13@RadioButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rsp]
	add	rax, 14
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rdx+rax*8+14552]
	movups	XMMWORD PTR c$7[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rdx+14552]
	movss	DWORD PTR c$7[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1236 :     window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), num_segment);

	mov	DWORD PTR [rsp+32], r13d
	movaps	xmm2, xmm8
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, rsi
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 1237 :     if (active)

	movzx	esi, BYTE PTR active$GSCopy$1$[rsp]
	test	sil, sil
	je	$LN100@RadioButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1240 :         window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));

	mov	rsi, QWORD PTR [r14+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+15064]
	movups	XMMWORD PTR c$6[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$6[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm1, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1240 :         window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));

	movaps	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1239 :         const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));

	divss	xmm6, DWORD PTR __real@40c00000
	cvttss2si ecx, xmm6
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1240 :         window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark));

	subss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN103@RadioButto
	comiss	xmm12, xmm2
	ja	SHORT $LN103@RadioButto

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)
; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, rsi
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	mov	r8d, DWORD PTR [rsi+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r15d
	mov	rdx, QWORD PTR [rsi+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	dec	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1515 :         _Path.Size--;

	mov	DWORD PTR [rsi+120], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rsi+120], 0
$LN103@RadioButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1243 :     if (style.FrameBorderSize > 0.0f)

	movzx	esi, BYTE PTR active$GSCopy$1$[rsp]
$LN100@RadioButto:
	movss	xmm6, DWORD PTR [rbx+14624]
	comiss	xmm6, xmm9
	jbe	$LN6@RadioButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm14, xmm13
	addss	xmm15, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$5[rsp]
	movups	xmm0, XMMWORD PTR [rax+14872]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$5[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp+4], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	DWORD PTR c$5[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1245 :         window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize);

	mov	rcx, QWORD PTR [r14+728]
	lea	rdx, QWORD PTR $T8[rsp]
	movss	DWORD PTR [rsp+40], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1245 :         window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize);

	movaps	xmm2, xmm8
	mov	DWORD PTR [rsp+32], r13d
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rsp]
	movups	xmm0, XMMWORD PTR [rax+14856]
	movups	XMMWORD PTR c$4[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$4[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1246 :         window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), num_segment, style.FrameBorderSize);

	movss	xmm0, DWORD PTR [rbx+14624]
	lea	rdx, QWORD PTR center$[rsp]
	mov	rcx, QWORD PTR [r14+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1246 :         window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), num_segment, style.FrameBorderSize);

	movss	DWORD PTR [rsp+40], xmm0
	movaps	xmm2, xmm8
	mov	DWORD PTR [rsp+32], r13d
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
$LN6@RadioButto:

; 1250 :     if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	addss	xmm10, DWORD PTR [rbx+14636]
	addss	xmm7, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm15, XMMWORD PTR [rsp+128]
	movaps	xmm14, XMMWORD PTR [rsp+144]
	movaps	xmm13, XMMWORD PTR [rsp+160]
	mov	r13, QWORD PTR [rsp+368]
	movss	DWORD PTR label_pos$[rsp], xmm10
	movss	DWORD PTR label_pos$[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1250 :     if (g.LogEnabled)

	je	SHORT $LN7@RadioButto

; 1251 :         LogRenderedText(&label_pos, active ? "(x)" : "( )");

	test	sil, sil
	lea	rax, OFFSET FLAT:??_C@_03KFJJABDB@?$CIx?$CJ@
	lea	rdx, OFFSET FLAT:??_C@_03MHDGHODJ@?$CI?5?$CJ@
	cmovne	rdx, rax
	lea	rcx, QWORD PTR label_pos$[rsp]
	xor	r8d, r8d
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN7@RadioButto:

; 1252 :     if (label_size.x > 0.0f)

	comiss	xmm11, xmm9
	jbe	SHORT $LN8@RadioButto

; 1253 :         RenderText(label_pos, label);

	mov	rcx, QWORD PTR label_pos$[rsp]
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, rdi
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN8@RadioButto:

; 1254 : 
; 1255 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
; 1256 :     return pressed;

	movzx	eax, r12b
	jmp	SHORT $LN1@RadioButto
$LN98@RadioButto:

; 1222 :         return false;

	xor	al, al
$LN1@RadioButto:

; 1257 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+288]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?RadioButton@ImGui@@YA_NPEBD_N@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?SeparatorText@ImGui@@YAXPEBD@Z
_TEXT	SEGMENT
label$ = 8
?SeparatorText@ImGui@@YAXPEBD@Z PROC			; ImGui::SeparatorText, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rdx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1529 :     if (window->SkipItems)

	mov	rax, QWORD PTR [rdx+16408]
	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN1@SeparatorT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	r8, rcx

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rcx, -1
	jae	SHORT $LN8@SeparatorT
	npad	2
$LL7@SeparatorT:
	movzx	eax, BYTE PTR [r8]
	test	al, al
	je	SHORT $LN8@SeparatorT
	cmp	al, 35					; 00000023H
	lea	rax, QWORD PTR [r8+1]
	jne	SHORT $LN10@SeparatorT
	cmp	BYTE PTR [rax], 35			; 00000023H
	je	SHORT $LN8@SeparatorT
$LN10@SeparatorT:

; 3332 :         text_display_end++;

	mov	r8, rax
	cmp	rax, -1
	jb	SHORT $LL7@SeparatorT
$LN8@SeparatorT:
	xorps	xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1538 :     SeparatorTextEx(0, label, FindRenderedTextEnd(label), 0.0f);

	mov	rdx, rcx
	jmp	?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z	; ImGui::SeparatorTextEx
$LN1@SeparatorT:

; 1539 : }

	ret	0
?SeparatorText@ImGui@@YAXPEBD@Z ENDP			; ImGui::SeparatorText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndMainMenuBar@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndMainMenuBar@ImGui@@YAXXZ PROC			; ImGui::EndMainMenuBar, COMDAT

; 7142 : {

$LN31:
	sub	rsp, 40					; 00000028H

; 7143 :     EndMenuBar();

	call	?EndMenuBar@ImGui@@YAXXZ		; ImGui::EndMenuBar

; 7144 : 
; 7145 :     // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
; 7146 :     // FIXME: With this strategy we won't be able to restore a NULL focus.
; 7147 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 7148 :     if (g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer_Main && !g.NavAnyRequest)

	mov	rax, QWORD PTR [rcx+19096]
	cmp	QWORD PTR [rcx+16408], rax
	jne	$LN4@EndMainMen
	cmp	DWORD PTR [rcx+19152], 0
	jne	$LN4@EndMainMen
	cmp	BYTE PTR [rcx+19160], 0
	jne	$LN4@EndMainMen
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7637 :     int start_idx = g.WindowsFocusOrder.Size - 1;

	mov	edx, DWORD PTR [rcx+16328]
	dec	edx

; 7638 :     if (under_this_window != NULL)

	test	rax, rax
	je	SHORT $LN10@EndMainMen

; 7639 :     {
; 7640 :         // Aim at root window behind us, if we are in a child window that's our own root (see #4640)
; 7641 :         int offset = -1;
; 7642 :         while (under_this_window->Flags & ImGuiWindowFlags_ChildWindow)

	test	DWORD PTR [rax+20], 16777216		; 01000000H
	mov	r8d, -1
	je	SHORT $LN6@EndMainMen

; 7645 :             offset = 0;

	xor	r8d, r8d
	npad	3
$LL5@EndMainMen:

; 7643 :         {
; 7644 :             under_this_window = under_this_window->ParentWindow;

	mov	rax, QWORD PTR [rax+936]
	test	DWORD PTR [rax+20], 16777216		; 01000000H
	jne	SHORT $LL5@EndMainMen
$LN6@EndMainMen:

; 12719:     int order = window->FocusOrder;

	movsx	edx, WORD PTR [rax+256]

; 7647 :         start_idx = FindWindowFocusIndex(under_this_window) + offset;

	add	edx, r8d
$LN10@EndMainMen:

; 7648 :     }
; 7649 :     for (int i = start_idx; i >= 0; i--)

	test	edx, edx
	js	SHORT $LN29@EndMainMen
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+16336]
	movsxd	rdx, edx
	lea	r8, QWORD PTR [rax+rdx*8]
	npad	4
$LL9@EndMainMen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7652 :         ImGuiWindow* window = g.WindowsFocusOrder[i];

	mov	rcx, QWORD PTR [r8]

; 7653 :         IM_ASSERT(window == window->RootWindow);
; 7654 :         if (window == ignore_window || !window->WasActive)

	test	rcx, rcx
	je	SHORT $LN7@EndMainMen
	cmp	BYTE PTR [rcx+236], 0
	je	SHORT $LN7@EndMainMen

; 7655 :             continue;
; 7656 :         if (filter_viewport != NULL && window->Viewport != filter_viewport)
; 7657 :             continue;
; 7658 :         if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))

	mov	eax, DWORD PTR [rcx+20]
	and	eax, 262656				; 00040200H
	cmp	eax, 262656				; 00040200H
	jne	SHORT $LN22@EndMainMen
$LN7@EndMainMen:

; 7648 :     }
; 7649 :     for (int i = start_idx; i >= 0; i--)

	sub	r8, 8
	sub	rdx, 1
	jns	SHORT $LL9@EndMainMen
$LN29@EndMainMen:

; 7659 :         {
; 7660 :             // FIXME-DOCK: When ImGuiFocusRequestFlags_RestoreFocusedChild is set...
; 7661 :             // This is failing (lagging by one frame) for docked windows.
; 7662 :             // If A and B are docked into window and B disappear, at the NewFrame() call site window->NavLastChildNavWindow will still point to B.
; 7663 :             // We might leverage the tab order implicitly stored in window->DockNodeAsHost->TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
; 7664 :             // to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
; 7665 :             FocusWindow(window, flags);
; 7666 :             return;
; 7667 :         }
; 7668 :     }
; 7669 :     FocusWindow(NULL, flags);

	xor	ecx, ecx
$LN22@EndMainMen:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7151 :     End();

	mov	edx, 3
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
$LN4@EndMainMen:

; 7152 : }

	add	rsp, 40					; 00000028H

; 7151 :     End();

	jmp	?End@ImGui@@YAXXZ			; ImGui::End
?EndMainMenuBar@ImGui@@YAXXZ ENDP			; ImGui::EndMainMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndMenuBar@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndMenuBar@ImGui@@YAXXZ PROC				; ImGui::EndMenuBar, COMDAT

; 7037 : {

$LN59:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rdi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7039 :     if (window->SkipItems)

	cmp	BYTE PTR [rdi+240], 0
	jne	$LN1@EndMenuBar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11830:     return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;

	cmp	BYTE PTR [rbx+19217], 0
	je	$LN7@EndMenuBar
	cmp	DWORD PTR [rbx+19296], 0
	jne	$LN7@EndMenuBar
	cmp	DWORD PTR [rbx+19392], 0
	jne	$LN7@EndMenuBar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7044 :     if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))

	cmp	DWORD PTR [rbx+19232], 1
	ja	$LN7@EndMenuBar
	mov	rcx, QWORD PTR [rbx+19096]
	test	DWORD PTR [rcx+20], 268435456		; 10000000H
	je	$LN7@EndMenuBar

; 7045 :     {
; 7046 :         // Try to find out if the request is for one of our child menu
; 7047 :         ImGuiWindow* nav_earliest_child = g.NavWindow;
; 7048 :         while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))

	mov	rax, QWORD PTR [rcx+936]
	test	rax, rax
	je	SHORT $LN46@EndMenuBar
$LL2@EndMenuBar:
	test	DWORD PTR [rax+20], 268435456		; 10000000H
	je	SHORT $LN46@EndMenuBar

; 7049 :             nav_earliest_child = nav_earliest_child->ParentWindow;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+936]
	test	rax, rax
	jne	SHORT $LL2@EndMenuBar
$LN46@EndMenuBar:

; 7050 :         if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)

	cmp	QWORD PTR [rcx+936], rdi
	jne	$LN7@EndMenuBar
	cmp	DWORD PTR [rcx+496], 0
	jne	$LN7@EndMenuBar
	test	BYTE PTR [rbx+19220], 128		; 00000080H
	jne	$LN7@EndMenuBar

; 7051 :         {
; 7052 :             // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
; 7053 :             // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)
; 7054 :             const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
; 7055 :             IM_ASSERT(window->DC.NavLayersActiveMaskNext & (1 << layer)); // Sanity check (FIXME: Seems unnecessary)
; 7056 :             FocusWindow(window);

	xor	edx, edx
	mov	rcx, rdi
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11479:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7057 :             SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);

	mov	ecx, DWORD PTR [rdi+1004]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11485:     g.NavWindow->NavLastIds[nav_layer] = id;

	mov	rax, QWORD PTR [r10+19096]
	mov	DWORD PTR [r10+19152], 1
	mov	DWORD PTR [r10+19104], ecx
	mov	DWORD PTR [r10+19108], 0
	mov	DWORD PTR [rax+1004], ecx

; 11486:     g.NavWindow->NavRectRel[nav_layer] = rect_rel;

	movups	xmm0, XMMWORD PTR [rdi+1024]
	mov	rax, QWORD PTR [r10+19096]
	movups	XMMWORD PTR [rax+1024], xmm0

; 11474:     g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;

	mov	rax, QWORD PTR [r10+19096]
	movsxd	rdx, DWORD PTR [r10+19152]
	mov	rcx, QWORD PTR [rax+984]
	mov	DWORD PTR [rcx+rdx*8+1040], 2139095039	; 7f7fffffH
	mov	rax, QWORD PTR [r10+19096]
	movsxd	rdx, DWORD PTR [r10+19152]
	mov	rcx, QWORD PTR [rax+984]
	mov	DWORD PTR [rcx+rdx*8+1044], 2139095039	; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7060 :             NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat

	mov	r8d, DWORD PTR [rbx+19220]
	mov	r9d, DWORD PTR [rbx+19224]
	mov	edx, DWORD PTR [rbx+19240]
	mov	ecx, DWORD PTR [rbx+19232]
	mov	WORD PTR [rbx+19157], 257		; 00000101H
	mov	BYTE PTR [rbx+19159], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r10+19161], 0

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r10+19216], 0

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al

; 11892:     g.NavMoveForwardToNextFrame = true;

	mov	BYTE PTR [r10+19218], 1

; 11893:     g.NavMoveDir = move_dir;
; 11894:     g.NavMoveClipDir = clip_dir;
; 11895:     g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;

	bts	r8d, 7

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	mov	BYTE PTR [r10+19160], al

; 11895:     g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;

	mov	DWORD PTR [r10+19220], r8d
	mov	DWORD PTR [r10+19232], ecx
	mov	DWORD PTR [r10+19240], edx

; 11896:     g.NavMoveScrollFlags = scroll_flags;

	mov	DWORD PTR [r10+19224], r9d
$LN7@EndMenuBar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7067 :     PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7069 :     window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.

	movss	xmm0, DWORD PTR [rdi+312]
	subss	xmm0, DWORD PTR [rdi+80]
	movss	DWORD PTR [rdi+412], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rbx+18904]
	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7070 :     g.GroupStack.back().EmitItem = false;

	mov	rax, QWORD PTR [rbx+18912]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7070 :     g.GroupStack.back().EmitItem = false;

	mov	BYTE PTR [rax+rcx*8-2], 0

; 7071 :     EndGroup(); // Restore position on layer 0

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 7072 :     window->DC.LayoutType = ImGuiLayoutType_Vertical;

	mov	DWORD PTR [rdi+492], 1

; 7073 :     window->DC.IsSameLine = false;

	mov	BYTE PTR [rdi+376], 0

; 7074 :     window->DC.NavLayerCurrent = ImGuiNavLayer_Main;

	mov	DWORD PTR [rdi+400], 0

; 7075 :     window->DC.MenuBarAppending = false;

	mov	BYTE PTR [rdi+411], 0
$LN1@EndMenuBar:

; 7076 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?EndMenuBar@ImGui@@YAXXZ ENDP				; ImGui::EndMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z
_TEXT	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
p_step$1$ = 72
label$GSCopy$1$ = 80
buf$ = 96
__$ArrayPad$ = 160
label$ = 288
data_type$ = 296
p_data$ = 304
p_step$ = 312
p_step_fast$ = 320
format$ = 328
flags$ = 336
?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z PROC		; ImGui::InputScalar, COMDAT

; 3449 : {

$LN360:
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3449 : {

	mov	rsi, r9
	mov	rdi, QWORD PTR format$[rsp]
	mov	rbx, r8
	mov	QWORD PTR p_step$1$[rsp], r9
	mov	r13, rcx
	movsxd	r15, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r14+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3449 : {

	mov	QWORD PTR label$GSCopy$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3451 :     if (window->SkipItems)

	mov	rax, QWORD PTR [r14+16408]
	cmp	BYTE PTR [rax+240], 0
	je	SHORT $LN2@InputScala

; 3452 :         return false;

	xor	al, al
	jmp	$LN1@InputScala
$LN2@InputScala:
	mov	QWORD PTR [rsp+312], rbp

; 3453 : 
; 3454 :     ImGuiContext& g = *GImGui;
; 3455 :     ImGuiStyle& style = g.Style;
; 3456 : 
; 3457 :     if (format == NULL)

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+224], r12
	test	rdi, rdi
	jne	SHORT $LN3@InputScala

; 2006 :     return &GDataTypeInfo[data_type];

	mov	rax, r15
	shl	rax, 5

; 3458 :         format = DataTypeGetInfo(data_type)->PrintFmt;

	mov	rdi, QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B[rax+rcx+16]
$LN3@InputScala:

; 3459 : 
; 3460 :     char buf[64];
; 3461 :     DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);

	mov	r9, rbx
	mov	QWORD PTR [rsp+32], rdi
	mov	r8d, r15d
	lea	rcx, QWORD PTR buf$[rsp]
	mov	edx, 64					; 00000040H
	call	?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z ; ImGui::DataTypeFormatString

; 3462 : 
; 3463 :     // Testing ActiveId as a minor optimization as filtering is not needed until active
; 3464 :     if (g.ActiveId == 0 && (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)

	cmp	DWORD PTR [r14+16504], 0
	mov	r12d, DWORD PTR flags$[rsp]
	jne	SHORT $LN4@InputScala
	test	r12d, 131075				; 00020003H
	jne	SHORT $LN4@InputScala

; 3396 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	lea	eax, DWORD PTR [r15-8]
	cmp	eax, 1
	jbe	SHORT $LN60@InputScala

; 3398 :     const char format_last_char = format[0] ? format[strlen(format) - 1] : 0;

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LN275@InputScala
	mov	rax, -1
$LL282@InputScala:
	cmp	BYTE PTR [rdi+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL282@InputScala
	movzx	eax, BYTE PTR [rax+rdi-1]

; 3399 :     return (format_last_char == 'x' || format_last_char == 'X') ? ImGuiInputTextFlags_CharsHexadecimal : ImGuiInputTextFlags_CharsDecimal;

	sub	al, 88					; 00000058H
	test	al, 223					; 000000dfH
	jne	SHORT $LN275@InputScala
	mov	eax, 2
	jmp	SHORT $LN58@InputScala
$LN275@InputScala:
	mov	eax, 1
	jmp	SHORT $LN58@InputScala
$LN60@InputScala:

; 3397 :         return ImGuiInputTextFlags_CharsScientific;

	mov	eax, 131072				; 00020000H
$LN58@InputScala:

; 3465 :         flags |= InputScalar_DefaultCharsFilter(data_type, format);

	or	r12d, eax
$LN4@InputScala:

; 3466 :     flags |= ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoMarkEdited; // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.

	or	r12d, 134217744				; 08000010H

; 3467 : 
; 3468 :     bool value_changed = false;

	xor	bpl, bpl

; 3469 :     if (p_step == NULL)

	test	rsi, rsi
	jne	SHORT $LN5@InputScala

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	QWORD PTR [rsp+56], rsi
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+48], rsi
	lea	r9d, QWORD PTR [rsi+64]
	mov	DWORD PTR [rsp+40], r12d
	lea	r8, QWORD PTR buf$[rsp]
	xor	edx, edx
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T3[rsp], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3470 :     {
; 3471 :         if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))

	test	al, al
	je	$LN14@InputScala

; 3472 :             value_changed = DataTypeApplyFromText(buf, data_type, p_data, format);

	mov	r9, rdi
	lea	rcx, QWORD PTR buf$[rsp]
	mov	r8, rbx
	mov	edx, r15d
	call	?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z ; ImGui::DataTypeApplyFromText
	movzx	ebp, al

; 3473 :     }

	jmp	$LN6@InputScala
$LN5@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+208], xmm6
	movaps	XMMWORD PTR [rsp+192], xmm7
	movaps	XMMWORD PTR [rsp+176], xmm8

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm6, DWORD PTR [rax+14616]
	addss	xmm6, xmm6
	addss	xmm6, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3478 :         BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 3479 :         PushID(label);

	mov	rcx, r13
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 3480 :         SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));

	movaps	xmm2, xmm6
	addss	xmm2, DWORD PTR [r14+14636]
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10323:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3480 :         SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));

	addss	xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	lea	r8, QWORD PTR buf$[rsp]
	xor	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T2[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	QWORD PTR [rsp+56], rsi
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10324:     g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;

	or	DWORD PTR [rax+18592], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	xor	edx, edx

; 3480 :         SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));

	subss	xmm0, xmm2

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], r12d
	lea	r9d, QWORD PTR [rsi+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10325:     g.NextItemData.Width = item_width;

	movss	DWORD PTR [rax+18600], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3658 :     return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3481 :         if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view

	test	al, al
	je	SHORT $LN8@InputScala

; 3482 :             value_changed = DataTypeApplyFromText(buf, data_type, p_data, format);

	mov	r9, rdi
	lea	rcx, QWORD PTR buf$[rsp]
	mov	r8, rbx
	mov	edx, r15d
	call	?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z ; ImGui::DataTypeApplyFromText
	movzx	ebp, al
$LN8@InputScala:

; 3483 :         IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Inputable);
; 3484 : 
; 3485 :         // Step buttons
; 3486 :         const ImVec2 backup_frame_padding = style.FramePadding;

	movss	xmm7, DWORD PTR [r14+14612]

; 3487 :         style.FramePadding.x = style.FramePadding.y;

	mov	eax, DWORD PTR [r14+14616]
	movss	xmm8, DWORD PTR [r14+14616]
	mov	DWORD PTR [r14+14612], eax

; 3488 :         ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
; 3489 :         if (flags & ImGuiInputTextFlags_ReadOnly)

	and	r12d, 16384				; 00004000H
	je	SHORT $LN9@InputScala

; 3490 :             BeginDisabled();

	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
$LN9@InputScala:

; 3491 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r14+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3492 :         if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))

	lea	rcx, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3492 :         if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))

	mov	r8d, 9216				; 00002400H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3492 :         if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))

	lea	rdx, QWORD PTR $T5[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	mov	rdi, QWORD PTR p_step_fast$[rsp]
	mov	r10d, -32768				; ffffffffffff8000H
	mov	r11d, 32767				; 00007fffH
	mov	r13, -9223372036854775808		; 8000000000000000H
	mov	r9, 9223372036854775807			; 7fffffffffffffffH
	test	al, al
	je	$LN276@InputScala

; 3493 :         {
; 3494 :             DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);

	cmp	BYTE PTR [r14+3624], sil
	je	SHORT $LN16@InputScala
	mov	rdx, rdi
	test	rdi, rdi
	jne	SHORT $LN17@InputScala
$LN16@InputScala:
	mov	rdx, QWORD PTR p_step$1$[rsp]
$LN17@InputScala:

; 2035 :     switch (data_type)

	cmp	r15d, 9
	ja	$LN99@InputScala
	lea	r8, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN281@InputScala[r8+r15*4]
	add	rcx, r8
	jmp	rcx
$LN69@InputScala:

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	movsx	r8d, BYTE PTR [rdx]
	movsx	ecx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8b, r8b
	jle	SHORT $LN351@InputScala
	lea	eax, DWORD PTR [r8-128]
	cmp	ecx, eax
	jge	SHORT $LN267@InputScala
	mov	cl, -128				; ffffffffffffff80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN99@InputScala
$LN267@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8b, r8b
$LN351@InputScala:
	jns	SHORT $LN107@InputScala
	lea	eax, DWORD PTR [r8+127]
	cmp	ecx, eax
	jle	SHORT $LN107@InputScala
	mov	cl, 127					; 0000007fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN99@InputScala
$LN107@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	cl, r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN99@InputScala
$LN72@InputScala:

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	movzx	ecx, BYTE PTR [rdx]
	movzx	eax, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	cl, cl
	je	SHORT $LN114@InputScala
	cmp	al, cl
	jae	SHORT $LN114@InputScala
	xor	al, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [rbx], al

; 2044 :             return;

	jmp	$LN99@InputScala
$LN114@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	al, cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [rbx], al

; 2044 :             return;

	jmp	$LN99@InputScala
$LN75@InputScala:

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	movsx	r8d, WORD PTR [rdx]
	movsx	edx, WORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8w, r8w
	jle	SHORT $LN352@InputScala
	lea	eax, DWORD PTR [r8-32768]
	cmp	edx, eax
	jge	SHORT $LN268@InputScala
	movzx	eax, r10w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [rbx], ax

; 2048 :             return;

	jmp	$LN99@InputScala
$LN268@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8w, r8w
$LN352@InputScala:
	jns	SHORT $LN123@InputScala
	lea	eax, DWORD PTR [r8+32767]
	cmp	edx, eax
	jle	SHORT $LN123@InputScala
	mov	eax, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [rbx], ax

; 2048 :             return;

	jmp	$LN99@InputScala
$LN123@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	dx, r8w
	movzx	eax, dx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [rbx], dx

; 2048 :             return;

	jmp	$LN99@InputScala
$LN78@InputScala:

; 2051 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	movzx	ecx, WORD PTR [rdx]
	movzx	eax, WORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	cx, cx
	je	SHORT $LN130@InputScala
	cmp	ax, cx
	jb	SHORT $LN129@InputScala
$LN130@InputScala:
	sub	ax, cx
	movzx	esi, ax
$LN129@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2051 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	mov	WORD PTR [rbx], si

; 2052 :             return;

	jmp	$LN99@InputScala
$LN81@InputScala:

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	r8d, DWORD PTR [rdx]
	mov	ecx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8d, r8d
	jle	SHORT $LN353@InputScala
	lea	eax, DWORD PTR [r8-2147483648]
	cmp	ecx, eax
	jge	SHORT $LN139@InputScala
	mov	ecx, -2147483648			; ffffffff80000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [rbx], ecx

; 2056 :             return;

	jmp	$LN99@InputScala
$LN353@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	jns	SHORT $LN139@InputScala
	lea	eax, DWORD PTR [r8+2147483647]
	cmp	ecx, eax
	jle	SHORT $LN139@InputScala
	mov	ecx, 2147483647				; 7fffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [rbx], ecx

; 2056 :             return;

	jmp	$LN99@InputScala
$LN139@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	ecx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [rbx], ecx

; 2056 :             return;

	jmp	$LN99@InputScala
$LN84@InputScala:

; 2059 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	ecx, DWORD PTR [rdx]
	mov	eax, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	ecx, ecx
	je	SHORT $LN146@InputScala
	cmp	eax, ecx
	jb	SHORT $LN145@InputScala
$LN146@InputScala:
	sub	eax, ecx
	mov	esi, eax
$LN145@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2059 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	DWORD PTR [rbx], esi

; 2060 :             return;

	jmp	SHORT $LN99@InputScala
$LN87@InputScala:

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	r8, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r8, r8
	jle	SHORT $LN354@InputScala
	lea	rax, QWORD PTR [r8+r13]
	cmp	rcx, rax
	jge	SHORT $LN155@InputScala
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [rbx], rcx

; 2064 :             return;

	jmp	SHORT $LN99@InputScala
$LN354@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	jns	SHORT $LN155@InputScala
	lea	rax, QWORD PTR [r8+r9]
	cmp	rcx, rax
	jle	SHORT $LN155@InputScala
	mov	rcx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [rbx], rcx

; 2064 :             return;

	jmp	SHORT $LN99@InputScala
$LN155@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [rbx], rcx

; 2064 :             return;

	jmp	SHORT $LN99@InputScala
$LN90@InputScala:

; 2067 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	rax, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	rax, rax
	je	SHORT $LN162@InputScala
	cmp	rcx, rax
	jb	SHORT $LN161@InputScala
$LN162@InputScala:
	mov	rsi, rcx
	sub	rsi, rax
$LN161@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2067 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	QWORD PTR [rbx], rsi

; 2068 :             return;

	jmp	SHORT $LN99@InputScala
$LN93@InputScala:

; 2071 :             if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }

	movss	xmm0, DWORD PTR [rbx]
	subss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rbx], xmm0

; 2072 :             return;

	jmp	SHORT $LN99@InputScala
$LN96@InputScala:

; 2075 :             if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }

	movsd	xmm0, QWORD PTR [rbx]
	subsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rbx], xmm0
$LN99@InputScala:

; 3495 :             value_changed = true;

	mov	bpl, 1
$LN276@InputScala:

; 3496 :         }
; 3497 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r14+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3498 :         if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))

	lea	rcx, OFFSET FLAT:??_C@_01MIFGBAGJ@?$CL@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3498 :         if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))

	mov	r8d, 9216				; 00002400H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3498 :         if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))

	lea	rdx, QWORD PTR $T4[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movaps	xmm6, XMMWORD PTR [rsp+208]
	test	al, al
	je	$LN11@InputScala

; 3499 :         {
; 3500 :             DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast ? p_step_fast : p_step);

	cmp	BYTE PTR [r14+3624], 0
	je	SHORT $LN18@InputScala
	test	rdi, rdi
	jne	SHORT $LN19@InputScala
$LN18@InputScala:
	mov	rdi, QWORD PTR p_step$1$[rsp]
$LN19@InputScala:

; 2035 :     switch (data_type)

	cmp	r15d, 9
	ja	$LN197@InputScala
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN280@InputScala[rdx+r15*4]
	add	rcx, rdx
	jmp	rcx
$LN168@InputScala:

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	movsx	r8d, BYTE PTR [rdi]
	movsx	ecx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r8b, r8b
	jns	SHORT $LN355@InputScala
	mov	eax, -128				; ffffffffffffff80H
	sub	eax, r8d
	cmp	ecx, eax
	jge	SHORT $LN269@InputScala
	mov	cl, -128				; ffffffffffffff80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN197@InputScala
$LN269@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r8b, r8b
$LN355@InputScala:
	jle	SHORT $LN202@InputScala
	mov	eax, 127				; 0000007fH
	sub	eax, r8d
	cmp	ecx, eax
	jle	SHORT $LN202@InputScala
	mov	cl, 127					; 0000007fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN197@InputScala
$LN202@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	add	cl, r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [rbx], cl

; 2040 :             return;

	jmp	$LN197@InputScala
$LN171@InputScala:

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	movzx	r8d, BYTE PTR [rdi]
	movzx	edx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r8b, r8b
	je	SHORT $LN210@InputScala
	mov	ecx, 255				; 000000ffH
	sub	ecx, r8d
	cmp	edx, ecx
	jle	SHORT $LN210@InputScala
	mov	dl, 255					; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [rbx], dl

; 2044 :             return;

	jmp	$LN197@InputScala
$LN210@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	add	dl, r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [rbx], dl

; 2044 :             return;

	jmp	$LN197@InputScala
$LN174@InputScala:

; 2046 :             if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	movsx	r8d, WORD PTR [rdi]
	movsx	ecx, WORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r8w, r8w
	jns	SHORT $LN356@InputScala
	mov	r10d, -32768				; ffffffffffff8000H
	mov	eax, r10d
	sub	eax, r8d
	cmp	ecx, eax
	jl	SHORT $LN216@InputScala
	test	r8w, r8w
$LN356@InputScala:
	jle	SHORT $LN218@InputScala
	mov	r10d, 32767				; 00007fffH
	mov	eax, r10d
	sub	eax, r8d
	cmp	ecx, eax
	jg	SHORT $LN216@InputScala
$LN218@InputScala:
	lea	r10d, DWORD PTR [r8+rcx]
$LN216@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2046 :             if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [rbx], r10w

; 2048 :             return;

	jmp	$LN197@InputScala
$LN177@InputScala:

; 2050 :             if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	movzx	r8d, WORD PTR [rdi]
	movzx	edx, WORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r8w, r8w
	je	SHORT $LN226@InputScala
	mov	r9d, 65535				; 0000ffffH
	mov	ecx, r9d
	sub	ecx, r8d
	cmp	edx, ecx
	jg	SHORT $LN224@InputScala
$LN226@InputScala:
	lea	r9d, DWORD PTR [r8+rdx]
$LN224@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2050 :             if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	mov	WORD PTR [rbx], r9w

; 2052 :             return;

	jmp	$LN197@InputScala
$LN180@InputScala:

; 2054 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	ecx, DWORD PTR [rdi]
	mov	edx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	ecx, ecx
	jns	SHORT $LN357@InputScala
	mov	r8d, -2147483648			; ffffffff80000000H
	mov	eax, r8d
	sub	eax, ecx
	cmp	edx, eax
	jge	SHORT $LN234@InputScala
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2056 :             return;

	mov	DWORD PTR [rbx], r8d
	jmp	$LN197@InputScala
$LN357@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	jle	SHORT $LN234@InputScala
	mov	eax, 2147483647				; 7fffffffH
	mov	r8d, 2147483647				; 7fffffffH
	sub	eax, ecx
	cmp	edx, eax
	jg	SHORT $LN232@InputScala
$LN234@InputScala:
	lea	r8d, DWORD PTR [rdx+rcx]
$LN232@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2054 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [rbx], r8d

; 2056 :             return;

	jmp	$LN197@InputScala
$LN183@InputScala:

; 2058 :             if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	ecx, DWORD PTR [rdi]
	mov	edx, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	ecx, ecx
	je	SHORT $LN242@InputScala
	mov	eax, ecx
	not	eax
	cmp	edx, eax
	mov	eax, -1					; ffffffffH
	ja	SHORT $LN240@InputScala
$LN242@InputScala:
	lea	eax, DWORD PTR [rdx+rcx]
$LN240@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2058 :             if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	DWORD PTR [rbx], eax

; 2060 :             return;

	jmp	SHORT $LN197@InputScala
$LN186@InputScala:

; 2062 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	rcx, rcx
	jns	SHORT $LN358@InputScala
	mov	rax, r13
	sub	rax, rcx
	cmp	rdx, rax
	jge	SHORT $LN250@InputScala
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2064 :             return;

	mov	QWORD PTR [rbx], r13
	jmp	SHORT $LN197@InputScala
$LN358@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	jle	SHORT $LN250@InputScala
	mov	r13, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, r13
	sub	rax, rcx
	cmp	rdx, rax
	jg	SHORT $LN248@InputScala
$LN250@InputScala:
	lea	r13, QWORD PTR [rdx+rcx]
$LN248@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2062 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [rbx], r13

; 2064 :             return;

	jmp	SHORT $LN197@InputScala
$LN189@InputScala:

; 2066 :             if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	rcx, rcx
	je	SHORT $LN258@InputScala
	mov	rax, rcx
	not	rax
	cmp	rdx, rax
	mov	rax, -1
	ja	SHORT $LN256@InputScala
$LN258@InputScala:
	lea	rax, QWORD PTR [rdx+rcx]
$LN256@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2066 :             if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	QWORD PTR [rbx], rax

; 2068 :             return;

	jmp	SHORT $LN197@InputScala
$LN192@InputScala:

; 2069 :         case ImGuiDataType_Float:
; 2070 :             if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }

	movss	xmm0, DWORD PTR [rdi]
	addss	xmm0, DWORD PTR [rbx]
	movss	DWORD PTR [rbx], xmm0

; 2072 :             return;

	jmp	SHORT $LN197@InputScala
$LN195@InputScala:

; 2073 :         case ImGuiDataType_Double:
; 2074 :             if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }

	movsd	xmm0, QWORD PTR [rdi]
	addsd	xmm0, QWORD PTR [rbx]
	movsd	QWORD PTR [rbx], xmm0
$LN197@InputScala:

; 3501 :             value_changed = true;

	mov	bpl, 1
$LN11@InputScala:

; 3502 :         }
; 3503 :         if (flags & ImGuiInputTextFlags_ReadOnly)

	test	r12d, r12d
	je	SHORT $LN12@InputScala

; 3504 :             EndDisabled();

	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled
$LN12@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	r9, QWORD PTR label$GSCopy$1$[rsp]
	mov	rdx, r9

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r9, -1
	jae	SHORT $LN13@InputScala
	npad	7
$LL45@InputScala:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN46@InputScala
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN277@InputScala
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN46@InputScala
$LN277@InputScala:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL45@InputScala
$LN46@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3507 :         if (label != label_end)

	cmp	r9, rdx
	je	SHORT $LN13@InputScala

; 3508 :         {
; 3509 :             SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r14+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3510 :             TextEx(label, label_end);

	mov	rcx, r9
	xor	r8d, r8d
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN13@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3512 :         style.FramePadding = backup_frame_padding;

	movss	DWORD PTR [r14+14612], xmm7
	movss	DWORD PTR [r14+14616], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3515 :         EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	movaps	xmm8, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+192]
$LN6@InputScala:

; 3516 :     }
; 3517 :     if (value_changed)

	test	bpl, bpl
	je	SHORT $LN14@InputScala
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	ecx, DWORD PTR [rax+16504]
	cmp	ecx, DWORD PTR [r14+18616]
	je	SHORT $LN56@InputScala
	test	ecx, ecx
	jne	SHORT $LN55@InputScala
$LN56@InputScala:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rax+16520], 257		; 00000101H
$LN55@InputScala:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rax+18624], 4
$LN14@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3520 :     return value_changed;

	mov	r12, QWORD PTR [rsp+224]
	movzx	eax, bpl
	mov	rbp, QWORD PTR [rsp+312]
$LN1@InputScala:

; 3521 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
	npad	2
$LN281@InputScala:
	DD	$LN69@InputScala
	DD	$LN72@InputScala
	DD	$LN75@InputScala
	DD	$LN78@InputScala
	DD	$LN81@InputScala
	DD	$LN84@InputScala
	DD	$LN87@InputScala
	DD	$LN90@InputScala
	DD	$LN93@InputScala
	DD	$LN96@InputScala
$LN280@InputScala:
	DD	$LN168@InputScala
	DD	$LN171@InputScala
	DD	$LN174@InputScala
	DD	$LN177@InputScala
	DD	$LN180@InputScala
	DD	$LN183@InputScala
	DD	$LN186@InputScala
	DD	$LN189@InputScala
	DD	$LN192@InputScala
	DD	$LN195@InputScala
?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ENDP		; ImGui::InputScalar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CollapsingHeader@ImGui@@YA_NPEBDH@Z
_TEXT	SEGMENT
label$ = 48
flags$ = 56
?CollapsingHeader@ImGui@@YA_NPEBDH@Z PROC		; ImGui::CollapsingHeader, COMDAT

; 6427 : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6427 : {

	mov	rdi, rcx
	mov	ebx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r8+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rcx, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6429 :     if (window->SkipItems)

	cmp	BYTE PTR [rcx+240], 0
	je	SHORT $LN2@Collapsing

; 6430 :         return false;

	xor	al, al

; 6433 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Collapsing:

; 6431 : 
; 6432 :     return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);

	mov	rdx, rdi
	or	ebx, 26
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	ecx, eax
	xor	r9d, r9d
	mov	r8, rdi
	mov	edx, ebx

; 6433 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 6431 : 
; 6432 :     return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);

	jmp	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
?CollapsingHeader@ImGui@@YA_NPEBDH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z
_TEXT	SEGMENT
v_min$GSCopy$ = 64
__$ArrayPad$ = 80
label$ = 112
v$ = 120
v_speed$ = 128
v_min$dead$ = 136
v_max$ = 144
format$ = 152
flags$dead$ = 160
?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z PROC		; ImGui::DragInt, COMDAT

; 2572 : {

$LN4:
	mov	r11, rsp
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, QWORD PTR format$[rsp]

; 2573 :     return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags);

	mov	r8, rdx
	mov	QWORD PTR [r11-56], rax
	movaps	xmm3, xmm2
	lea	rax, QWORD PTR [r11+40]
	mov	DWORD PTR v_min$GSCopy$[rsp], 0
	mov	QWORD PTR [r11-64], rax
	mov	edx, 4
	lea	rax, QWORD PTR [r11-40]
	mov	QWORD PTR [r11-72], rax
	call	?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z ; ImGui::DragScalar

; 2574 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z ENDP		; ImGui::DragInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
_TEXT	SEGMENT
held$ = 48
hovered$ = 49
size$ = 56
bb$ = 64
__$ArrayPad$ = 80
str_id$ = 112
size_arg$ = 120
flags$dead$ = 128
?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z PROC	; ImGui::InvisibleButton, COMDAT

; 740  : {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 743  :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN13@InvisibleB

; 744  :         return false;
; 745  : 
; 746  :     // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
; 747  :     IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);
; 748  : 
; 749  :     const ImGuiID id = window->GetID(str_id);

	mov	rcx, rbx
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 750  :     ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);

	mov	rdx, QWORD PTR [rsi]
	lea	rcx, QWORD PTR size$[rsp]
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	mov	edi, eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rbx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 752  :     ItemSize(size);

	lea	rcx, QWORD PTR size$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm2, DWORD PTR [rbx+312]
	movaps	xmm1, xmm0
	addss	xmm1, DWORD PTR size$[rsp+4]
	movaps	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, DWORD PTR size$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+4], xmm0
	movss	DWORD PTR bb$[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 752  :     ItemSize(size);

	movss	xmm1, DWORD PTR __real@bf800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+8], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 752  :     ItemSize(size);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 753  :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rsp]
	mov	edx, edi
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	SHORT $LN13@InvisibleB

; 755  : 
; 756  :     bool hovered, held;
; 757  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	lea	r9, QWORD PTR held$[rsp]
	mov	DWORD PTR [rsp+32], 0
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, edi
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 758  : 
; 759  :     IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
; 760  :     return pressed;

	jmp	SHORT $LN1@InvisibleB
$LN13@InvisibleB:

; 754  :         return false;

	xor	al, al
$LN1@InvisibleB:

; 761  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ENDP	; ImGui::InvisibleButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z
_TEXT	SEGMENT
$T3 = 32
preview_value$ = 40
item_text$4 = 48
__$ArrayPad$ = 56
label$ = 128
current_item$ = 136
items_getter$dead$ = 144
data$ = 152
items_count$ = 160
popup_max_height_in_items$dead$ = 168
?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z PROC	; ImGui::Combo, COMDAT

; 1906 : {

$LN52:
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1907 :     ImGuiContext& g = *GImGui;

	mov	r13, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 1908 : 
; 1909 :     // Call the getter to obtain the preview string which is a parameter to BeginCombo()
; 1910 :     const char* preview_value = NULL;

	xor	ebx, ebx

; 1911 :     if (*current_item >= 0 && *current_item < items_count)

	mov	r14d, DWORD PTR items_count$[rsp]
	mov	rdi, rdx
	mov	edx, DWORD PTR [rdx]
	mov	r12, r9
	mov	QWORD PTR preview_value$[rsp], rbx
	mov	rsi, rcx
	mov	eax, ebx
	test	edx, edx
	js	SHORT $LN6@Combo
	cmp	edx, r14d
	jge	SHORT $LN6@Combo

; 1912 :         items_getter(data, *current_item, &preview_value);

	lea	r8, QWORD PTR preview_value$[rsp]
	mov	rcx, r9
	call	?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z	; Items_ArrayGetter
	mov	rax, QWORD PTR preview_value$[rsp]
$LN6@Combo:

; 1913 : 
; 1914 :     // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
; 1915 :     if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint))
; 1916 :         SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
; 1917 : 
; 1918 :     if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))

	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, rsi
	call	?BeginCombo@ImGui@@YA_NPEBD0H@Z		; ImGui::BeginCombo
	test	al, al
	je	$LN1@Combo
$LN7@Combo:
	mov	QWORD PTR [rsp+144], rbp

; 1919 :         return false;
; 1920 : 
; 1921 :     // Display items
; 1922 :     // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
; 1923 :     bool value_changed = false;

	xor	bpl, bpl

; 1924 :     for (int i = 0; i < items_count; i++)

	test	r14d, r14d
	jle	$LN3@Combo
	mov	QWORD PTR [rsp+64], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T3[rsp], rbx
	npad	1
$LL4@Combo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1926 :         PushID(i);

	mov	ecx, ebx
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 1927 :         const bool item_selected = (i == *current_item);

	mov	esi, DWORD PTR [rdi]

; 1928 :         const char* item_text;
; 1929 :         if (!items_getter(data, i, &item_text))

	lea	r8, QWORD PTR item_text$4[rsp]
	cmp	ebx, esi
	mov	edx, ebx
	mov	rcx, r12
	sete	r15b
	call	?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z	; Items_ArrayGetter
	test	al, al
	jne	SHORT $LN40@Combo

; 1930 :             item_text = "*Unknown item*";

	lea	rcx, OFFSET FLAT:??_C@_0P@HFPOEILF@?$CKUnknown?5item?$CK@
	mov	QWORD PTR item_text$4[rsp], rcx
	jmp	SHORT $LN8@Combo
$LN40@Combo:

; 1928 :         const char* item_text;
; 1929 :         if (!items_getter(data, i, &item_text))

	mov	rcx, QWORD PTR item_text$4[rsp]
$LN8@Combo:

; 1931 :         if (Selectable(item_text, item_selected) && *current_item != i)

	lea	r9, QWORD PTR $T3[rsp]
	xor	r8d, r8d
	movzx	edx, r15b
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN9@Combo
	cmp	DWORD PTR [rdi], ebx
	je	SHORT $LN9@Combo

; 1932 :         {
; 1933 :             value_changed = true;

	mov	bpl, 1

; 1934 :             *current_item = i;

	mov	DWORD PTR [rdi], ebx
$LN9@Combo:

; 1935 :         }
; 1936 :         if (item_selected)

	cmp	ebx, esi
	jne	SHORT $LN10@Combo

; 1937 :             SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus
$LN10@Combo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1924 :     for (int i = 0; i < items_count; i++)

	inc	ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1924 :     for (int i = 0; i < items_count; i++)

	cmp	ebx, r14d
	jl	SHORT $LL4@Combo
	mov	r15, QWORD PTR [rsp+64]
$LN3@Combo:

; 1818 :     EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup

; 1938 :         PopID();
; 1939 :     }
; 1940 : 
; 1941 :     EndCombo();
; 1942 : 
; 1943 :     if (value_changed)

	test	bpl, bpl
	je	SHORT $LN11@Combo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	edx, DWORD PTR [rcx+16504]
	cmp	edx, DWORD PTR [r13+18616]
	je	SHORT $LN34@Combo
	test	edx, edx
	jne	SHORT $LN33@Combo
$LN34@Combo:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN33@Combo:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
$LN11@Combo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1946 :     return value_changed;

	movzx	eax, bpl
	mov	rbp, QWORD PTR [rsp+144]
$LN1@Combo:

; 1947 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z ENDP	; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z
_TEXT	SEGMENT
label$ = 80
v$ = 88
format$dead$ = 96
flags$dead$ = 104
?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z PROC		; ImGui::InputFloat3, COMDAT

; 3605 : {

$LN4:
	sub	rsp, 72					; 00000048H

; 3606 :     return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);

	mov	r8, rdx
	call	?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ; ImGui::InputScalarN

; 3607 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z ENDP		; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginCombo@ImGui@@YA_NPEBD0H@Z
_TEXT	SEGMENT
$T3 = 64
text_size$4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
hovered$ = 72
held$ = 73
tv1737 = 76
$T9 = 76
id$1$ = 88
$T10 = 88
c$11 = 88
$T12 = 88
flags$1$ = 104
$T13 = 104
backup_next_window_data_flags$1$ = 112
window$1$ = 120
preview_value$GSCopy$1$ = 128
bb$ = 136
c$14 = 152
c$15 = 152
total_bb$ = 152
__$ArrayPad$ = 168
label$ = 384
preview_value$ = 392
flags$ = 400
?BeginCombo@ImGui@@YA_NPEBD0H@Z PROC			; ImGui::BeginCombo, COMDAT

; 1678 : {

$LN255:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-120]
	sub	rsp, 320				; 00000140H
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-168], xmm12
	movaps	XMMWORD PTR [rax-184], xmm13
	movaps	XMMWORD PTR [rax-200], xmm14
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1679 :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 1683 :     g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	xor	r14d, r14d
	mov	esi, r8d
	mov	DWORD PTR flags$1$[rsp], r8d
	mov	QWORD PTR preview_value$GSCopy$1$[rbp-256], rdx
	mov	r12, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r15, QWORD PTR [rdi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1682 :     ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;

	mov	eax, DWORD PTR [rdi+18680]

; 1683 :     g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	mov	DWORD PTR [rdi+18680], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	QWORD PTR window$1$[rsp], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1682 :     ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;

	mov	DWORD PTR backup_next_window_data_flags$1$[rsp], eax

; 1684 :     if (window->SkipItems)

	cmp	BYTE PTR [r15+240], r14b
	jne	$LN221@BeginCombo

; 1685 :         return false;
; 1686 : 
; 1687 :     const ImGuiStyle& style = g.Style;
; 1688 :     const ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	mov	rcx, r15
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 1689 :     IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together
; 1690 : 
; 1691 :     const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ebx, eax
	mov	DWORD PTR id$1$[rsp], eax
	xorps	xmm12, xmm12
	mov	eax, esi
	and	eax, 32					; 00000020H
	mov	DWORD PTR tv1737[rsp], eax
	je	SHORT $LN14@BeginCombo
	xorps	xmm8, xmm8
	jmp	SHORT $LN15@BeginCombo
$LN14@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm8, DWORD PTR [r8+14616]
	addss	xmm8, xmm8
	addss	xmm8, DWORD PTR [r8+15696]
$LN15@BeginCombo:

; 3327 :     const char* text_display_end = text;

	mov	rcx, r12

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r12, -1
	jae	SHORT $LN224@BeginCombo
$LL36@BeginCombo:
	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN224@BeginCombo
	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 35					; 00000023H
	jne	SHORT $LN219@BeginCombo
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN224@BeginCombo
$LN219@BeginCombo:

; 3332 :         text_display_end++;

	mov	rcx, rax
	cmp	rax, -1
	jb	SHORT $LL36@BeginCombo
$LN224@BeginCombo:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm2, DWORD PTR [r8+15696]

; 5418 :     if (text == text_display_end)

	cmp	r12, rcx
	jne	SHORT $LN33@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm13, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN30@BeginCombo
$LN33@BeginCombo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$4[rsp]
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR [r8+15688]
	mov	QWORD PTR [rsp+40], r12
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$4[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm2, DWORD PTR text_size$4[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm13, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm13, xmm13
$LN30@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1693 :     const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();

	mov	r13d, esi
	and	r13d, 64				; 00000040H
	je	SHORT $LN16@BeginCombo
	movaps	xmm14, xmm8
	jmp	SHORT $LN17@BeginCombo
$LN16@BeginCombo:
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movaps	xmm14, xmm0
$LN17@BeginCombo:

; 1695 :     const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm13, xmm12
	movss	xmm5, DWORD PTR [rdi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm3, DWORD PTR [r15+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1694 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	movaps	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm4, DWORD PTR [r15+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1694 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-252], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1694 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-248], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1695 :     const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN18@BeginCombo
	movaps	xmm2, xmm13
	addss	xmm2, DWORD PTR [rdi+14636]
	jmp	SHORT $LN19@BeginCombo
$LN18@BeginCombo:
	movaps	xmm2, xmm12
$LN19@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-252], xmm4

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T5[rsp]

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-248], xmm1
	subss	xmm1, xmm3
	movss	DWORD PTR total_bb$[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm0, xmm4
	movss	DWORD PTR $T5[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movaps	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1697 :     if (!ItemAdd(total_bb, id, &bb))

	lea	r8, QWORD PTR bb$[rbp-256]
	mov	edx, ebx
	lea	rcx, QWORD PTR total_bb$[rbp-256]
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN221@BeginCombo
	movaps	XMMWORD PTR [rsp+304], xmm6

; 1702 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	lea	r9, QWORD PTR held$[rsp]
	movaps	XMMWORD PTR [rsp+288], xmm7
	lea	r8, QWORD PTR hovered$[rsp]
	movaps	XMMWORD PTR [rsp+256], xmm9
	lea	rcx, QWORD PTR bb$[rbp-256]
	movaps	XMMWORD PTR [rsp+240], xmm10
	mov	edx, ebx
	movaps	XMMWORD PTR [rsp+224], xmm11
	mov	DWORD PTR [rsp+32], r14d
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	r9d, ebx

; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_0N@LNBMNBNO@?$CD?$CDComboPopup@+1
	not	r9d
	lea	r11, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	mov	ebx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1702 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	movzx	r10d, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	mov	r8b, 35					; 00000023H
	npad	2
$LL64@BeginCombo:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN69@BeginCombo
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN69@BeginCombo
	cmp	BYTE PTR [rdx+1], r8b
	cmove	ebx, r9d
$LN69@BeginCombo:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, bl
	movzx	eax, r8b
	movzx	r8d, BYTE PTR [rdx]
	xor	rcx, rax
	shr	ebx, 8
	inc	rdx
	xor	ebx, DWORD PTR [r11+rcx*4]
	test	r8b, r8b
	jne	SHORT $LL64@BeginCombo

; 10906:     ImGuiContext& g = *GImGui;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2072 :     return ~crc;

	not	ebx

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	movsxd	rax, DWORD PTR [rdx+18936]
	cmp	DWORD PTR [rdx+18920], eax
	jle	SHORT $LN84@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	mov	rax, QWORD PTR [rdx+18928]
	cmp	DWORD PTR [rcx+rax], ebx
	jne	SHORT $LN84@BeginCombo
	mov	r14b, 1
$LN84@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1705 :     if (pressed && !popup_open)

	test	r10b, r10b
	je	SHORT $LN4@BeginCombo
	test	r14b, r14b
	jne	SHORT $LN4@BeginCombo

; 1706 :     {
; 1707 :         OpenPopupEx(popup_id, ImGuiPopupFlags_None);

	xor	edx, edx
	mov	ecx, ebx
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx

; 1708 :         popup_open = true;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14b, 1
$LN4@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movzx	esi, BYTE PTR hovered$[rsp]
	mov	ecx, 352				; 00000160H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1713 :     const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);

	movss	xmm9, DWORD PTR bb$[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	test	sil, sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm7, DWORD PTR bb$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	mov	eax, 336				; 00000150H
	cmovne	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm10, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1714 :     RenderNavHighlight(bb, id);

	mov	r8d, 1
	lea	rcx, QWORD PTR bb$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+rdx+14552]
	movups	XMMWORD PTR c$15[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rdx+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1714 :     RenderNavHighlight(bb, id);

	mov	edx, DWORD PTR id$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	DWORD PTR c$15[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1713 :     const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);

	movaps	xmm0, xmm9
	subss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm10, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1714 :     RenderNavHighlight(bb, id);

	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 1715 :     if (!(flags & ImGuiComboFlags_NoPreview))

	movss	xmm11, DWORD PTR bb$[rbp-244]
	mov	r9d, 240				; 000000f0H
	test	r13d, r13d
	jne	SHORT $LN220@BeginCombo

; 1716 :         window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);

	cmp	DWORD PTR tv1737[rsp], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$15[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1716 :         window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);

	mov	r8d, 80					; 00000050H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1716 :         window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);

	cmovne	r8d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp+4], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1716 :         window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);

	movss	xmm0, DWORD PTR [rdi+14620]
	lea	rdx, QWORD PTR bb$[rbp-256]
	mov	rcx, QWORD PTR [r15+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1716 :         window->DrawList->AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);

	mov	DWORD PTR [rsp+40], r8d
	lea	r8, QWORD PTR $T8[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	mov	r9d, 240				; 000000f0H
$LN220@BeginCombo:

; 1717 :     if (!(flags & ImGuiComboFlags_NoArrowButton))

	cmp	DWORD PTR tv1737[rsp], 0
	movss	xmm6, DWORD PTR bb$[rbp-252]
	jne	$LN149@BeginCombo

; 1718 :     {
; 1719 :         ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	test	r14b, r14b
	jne	SHORT $LN20@BeginCombo
	mov	ecx, 560				; 00000230H
	test	sil, sil
	je	SHORT $LN21@BeginCombo
$LN20@BeginCombo:
	mov	ecx, 576				; 00000240H
$LN21@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rcx+rax+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$14[rbp-256]

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	xmm1, DWORD PTR [rax+14552]
	movups	XMMWORD PTR c$11[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR c$11[rsp+12], xmm0

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+14776]
	movups	XMMWORD PTR c$14[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR c$14[rbp-244], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1721 :         window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);

	comiss	xmm8, xmm14
	mov	r8d, 160				; 000000a0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$11[rsp]
	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rsp], xmm10
	movss	DWORD PTR $T7[rsp+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1721 :         window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);

	cmovae	r8d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1721 :         window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);

	movss	xmm0, DWORD PTR [rdi+14620]
	lea	rdx, QWORD PTR $T7[rsp]
	mov	rsi, QWORD PTR window$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1721 :         window->DrawList->AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);

	mov	DWORD PTR [rsp+40], r8d
	lea	r8, QWORD PTR bb$[rbp-248]
	movss	DWORD PTR [rsp+32], xmm0
	mov	rcx, QWORD PTR [rsi+728]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1722 :         if (value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x)

	movaps	xmm0, xmm10
	addss	xmm0, xmm8
	subss	xmm0, DWORD PTR [rdi+14612]
	comiss	xmm9, xmm0
	jb	$LN149@BeginCombo

; 1723 :             RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);

	movss	xmm5, DWORD PTR [rdi+14616]
	mov	rsi, QWORD PTR [rsi+728]
	movaps	xmm3, xmm5
	addss	xmm5, xmm6
	addss	xmm3, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3826 :     const float h = draw_list->_Data->FontSize * 1.00f;

	mov	rax, QWORD PTR [rsi+56]
	movss	xmm0, DWORD PTR [rax+16]

; 3827 :     float r = h * 0.40f * scale;

	movaps	xmm4, xmm0

; 3828 :     ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm4, DWORD PTR __real@3ecccccd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm5, xmm0
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f5db22d
	movaps	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3838 :         c = ImVec2(+0.866f, -0.750f) * r;

	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp], xmm0

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f400000

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@bf5db22d
	movss	DWORD PTR $T9[rsp+4], xmm1
	addss	xmm0, xmm3
	movss	DWORD PTR $T10[rsp+4], xmm1
	movaps	xmm1, xmm4
	mulss	xmm4, DWORD PTR __real@3f400000
	mulss	xmm1, xmm12
	movss	DWORD PTR $T10[rsp], xmm0
	addss	xmm4, xmm5
	addss	xmm1, xmm3
	movss	DWORD PTR $T3[rsp+4], xmm4
	movss	DWORD PTR $T3[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r15d, -16777216				; ff000000H
	je	SHORT $LN149@BeginCombo

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rsi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, rsi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1478 :     PathLineTo(p3);

	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, rsi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rsi+120]
	mov	r9d, r15d
	mov	rdx, QWORD PTR [rsi+128]
	mov	rcx, rsi
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rsi+120], 0
$LN149@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1725 :     RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);

	movss	xmm2, DWORD PTR [rdi+14620]
	movaps	xmm0, xmm9
	unpcklps xmm0, xmm11
	movaps	xmm1, xmm7
	unpcklps xmm1, xmm6
	movq	rdx, xmm0
	movq	rcx, xmm1
	movsd	QWORD PTR bb$[rbp-248], xmm0
	movsd	QWORD PTR bb$[rbp-256], xmm1
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder

; 1726 : 
; 1727 :     // Custom preview
; 1728 :     if (flags & ImGuiComboFlags_CustomPreview)

	mov	esi, DWORD PTR flags$1$[rsp]
	bt	esi, 20
	jae	SHORT $LN8@BeginCombo

; 1729 :     {
; 1730 :         g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);

	movss	DWORD PTR [rdi+23868], xmm7
	movss	DWORD PTR [rdi+23872], xmm6
	movss	DWORD PTR [rdi+23876], xmm10
	movss	DWORD PTR [rdi+23880], xmm11

; 1731 :         IM_ASSERT(preview_value == NULL || preview_value[0] == 0);
; 1732 :         preview_value = NULL;
; 1733 :     }
; 1734 : 
; 1735 :     // Render preview and label
; 1736 :     if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))

	jmp	$LN9@BeginCombo
$LN8@BeginCombo:
	mov	r8, QWORD PTR preview_value$GSCopy$1$[rbp-256]
	test	r8, r8
	je	$LN9@BeginCombo
	test	r13d, r13d
	jne	$LN9@BeginCombo

; 1737 :     {
; 1738 :         if (g.LogEnabled)

	cmp	BYTE PTR [rdi+24256], r13b
	je	SHORT $LN10@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_01HCONENDN@?$HL@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	lea	rcx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@
	mov	QWORD PTR [rax+24296], rcx
$LN10@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm7, DWORD PTR [rdi+14612]
	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1740 :         RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);

	mov	QWORD PTR [rsp+48], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR [rdi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1740 :         RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);

	lea	rax, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rsp], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1740 :         RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);

	mov	QWORD PTR [rsp+40], rax
	lea	rdx, QWORD PTR $T13[rsp]
	xor	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rsp+4], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1740 :         RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);

	lea	rcx, QWORD PTR $T12[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rsp], xmm7
	movss	DWORD PTR $T12[rsp+4], xmm0
	mov	QWORD PTR $T6[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1740 :         RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);

	mov	QWORD PTR [rsp+32], 0
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped
$LN9@BeginCombo:

; 1741 :     }
; 1742 :     if (label_size.x > 0)

	comiss	xmm13, xmm12
	movaps	xmm11, XMMWORD PTR [rsp+224]
	movaps	xmm10, XMMWORD PTR [rsp+240]
	movaps	xmm7, XMMWORD PTR [rsp+288]
	jbe	SHORT $LN11@BeginCombo

; 1743 :         RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);

	addss	xmm9, DWORD PTR [rdi+14636]
	addss	xmm6, DWORD PTR [rdi+14616]
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, r12
	movaps	xmm0, xmm9
	unpcklps xmm0, xmm6
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN11@BeginCombo:

; 1744 : 
; 1745 :     if (!popup_open)

	movaps	xmm9, XMMWORD PTR [rsp+256]
	movaps	xmm6, XMMWORD PTR [rsp+304]
	test	r14b, r14b
	je	SHORT $LN221@BeginCombo

; 1747 : 
; 1748 :     g.NextWindowData.Flags = backup_next_window_data_flags;

	mov	eax, DWORD PTR backup_next_window_data_flags$1$[rsp]

; 1749 :     return BeginComboPopup(popup_id, bb, flags);

	lea	rdx, QWORD PTR bb$[rbp-256]
	mov	r8d, esi
	mov	DWORD PTR [rdi+18680], eax
	mov	ecx, ebx
	call	?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z ; ImGui::BeginComboPopup
	jmp	SHORT $LN1@BeginCombo
$LN221@BeginCombo:

; 1746 :         return false;

	xor	al, al
$LN1@BeginCombo:

; 1750 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+320]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?BeginCombo@ImGui@@YA_NPEBD0H@Z ENDP			; ImGui::BeginCombo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
_TEXT	SEGMENT
label$ = 80
hint$ = 88
buf$ = 96
buf_size$ = 104
flags$dead$ = 112
callback$dead$ = 120
$T1 = 120
user_data$ = 128
?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputTextWithHint, COMDAT

; 3667 : {

$LN6:
	sub	rsp, 72					; 00000048H

; 3669 :     return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	mov	rax, QWORD PTR user_data$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:?InputTextCallback@@YAHPEAUImGuiInputTextCallbackData@@@Z ; InputTextCallback
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	DWORD PTR [rsp+40], 262144		; 00040000H
	mov	QWORD PTR [rsp+32], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T1[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3669 :     return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);

	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3670 : }

	add	rsp, 72					; 00000048H
	ret	0
?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputTextWithHint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndMenu@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndMenu@ImGui@@YAXXZ PROC				; ImGui::EndMenu, COMDAT

; 7381 : {

$LN19:
	sub	rsp, 40					; 00000028H

; 7382 :     // Nav: When a left move request our menu failed, close ourselves.
; 7383 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 7384 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rdx, QWORD PTR [rcx+16408]

; 7385 :     IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginMenu()/EndMenu() calls
; 7386 :     ImGuiWindow* parent_window = window->ParentWindow;  // Should always be != NULL is we passed assert.
; 7387 :     if (window->BeginCount == window->BeginCountPreviousFrame)

	movzx	eax, WORD PTR [rdx+250]
	mov	r8, QWORD PTR [rdx+936]
	cmp	WORD PTR [rdx+248], ax
	jne	SHORT $LN13@EndMenu

; 7388 :         if (g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet())

	cmp	DWORD PTR [rcx+19232], 0
	jne	SHORT $LN13@EndMenu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11830:     return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;

	cmp	BYTE PTR [rcx+19217], 0
	je	SHORT $LN13@EndMenu
	cmp	DWORD PTR [rcx+19296], 0
	jne	SHORT $LN13@EndMenu
	cmp	DWORD PTR [rcx+19392], 0
	jne	SHORT $LN13@EndMenu
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7389 :             if (g.NavWindow && (g.NavWindow->RootWindowForNav == window) && parent_window->DC.LayoutType == ImGuiLayoutType_Vertical)

	mov	rax, QWORD PTR [rcx+19096]
	test	rax, rax
	je	SHORT $LN13@EndMenu
	cmp	QWORD PTR [rax+984], rdx
	jne	SHORT $LN13@EndMenu
	cmp	DWORD PTR [r8+492], 1
	jne	SHORT $LN13@EndMenu

; 7390 :             {
; 7391 :                 ClosePopupToLevel(g.BeginPopupStack.Size - 1, true);

	mov	ecx, DWORD PTR [rcx+18936]
	mov	dl, 1
	dec	ecx
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11881:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [rcx+19161], 0

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [rcx+19216], 0

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al
	mov	BYTE PTR [rcx+19160], al
$LN13@EndMenu:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7396 : }

	add	rsp, 40					; 00000028H

; 7392 :                 NavMoveRequestCancel();
; 7393 :             }
; 7394 : 
; 7395 :     EndPopup();

	jmp	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
?EndMenu@ImGui@@YAXXZ ENDP				; ImGui::EndMenu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z
_TEXT	SEGMENT
pressed$1$ = 64
held$ = 64
hovered$ = 65
$T4 = 68
$T5 = 68
$T6 = 68
$T7 = 68
bb_inner$ = 80
tv1064 = 96
tv1062 = 112
c$8 = 128
c$9 = 128
col_rgb$ = 128
c$10 = 144
c$11 = 144
col_rgb_without_alpha$ = 144
bb$ = 160
__$ArrayPad$ = 176
desc_id$ = 416
col$ = 424
flags$ = 432
size_arg$ = 440
?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z PROC ; ImGui::ColorButton, COMDAT

; 5783 : {

$LN132:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-136], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5783 : {

	mov	rdi, r9
	mov	r15d, r8d
	mov	r13, rdx
	mov	r12, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5785 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN105@ColorButto

; 5786 :         return false;
; 5787 : 
; 5788 :     ImGuiContext& g = *GImGui;
; 5789 :     const ImGuiID id = window->GetID(desc_id);

	mov	rdx, rcx
	mov	rcx, rbx
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10420:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xorps	xmm10, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5791 :     const ImVec2 size(size_arg.x == 0.0f ? default_size : size_arg.x, size_arg.y == 0.0f ? default_size : size_arg.y);

	movss	xmm6, DWORD PTR [rdi+4]
	mov	r14d, eax
	ucomiss	xmm6, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rcx+14616]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [rcx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5791 :     const ImVec2 size(size_arg.x == 0.0f ? default_size : size_arg.x, size_arg.y == 0.0f ? default_size : size_arg.y);

	jp	SHORT $LN19@ColorButto
	jne	SHORT $LN19@ColorButto
	movaps	xmm6, xmm0
$LN19@ColorButto:
	movss	xmm9, DWORD PTR [rdi]
	ucomiss	xmm9, xmm10
	jp	SHORT $LN21@ColorButto
	jne	SHORT $LN21@ColorButto
	movaps	xmm9, xmm0
$LN21@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	comiss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm3, DWORD PTR [rbx+312]
	movss	xmm4, DWORD PTR [rbx+316]
	movaps	xmm1, xmm3
	movaps	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-256], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-252], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-248], xmm1
	movss	DWORD PTR bb$[rbp-244], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5793 :     ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);

	jb	SHORT $LN23@ColorButto
	movss	xmm0, DWORD PTR [rsi+14616]
	jmp	SHORT $LN24@ColorButto
$LN23@ColorButto:
	xorps	xmm0, xmm0
$LN24@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5794 :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	edx, r14d
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN105@ColorButto
	movaps	XMMWORD PTR [rsp+304], xmm8

; 5796 : 
; 5797 :     bool hovered, held;
; 5798 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	lea	r9, QWORD PTR held$[rsp]
	movaps	XMMWORD PTR [rsp+256], xmm11
	lea	r8, QWORD PTR hovered$[rsp]
	movaps	XMMWORD PTR [rsp+240], xmm12
	lea	rcx, QWORD PTR bb$[rbp-256]
	movaps	XMMWORD PTR [rsp+224], xmm13
	mov	edx, r14d
	movaps	XMMWORD PTR [rsp+208], xmm14
	movaps	XMMWORD PTR [rsp+192], xmm15
	mov	DWORD PTR [rsp+32], 0
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 5799 : 
; 5800 :     if (flags & ImGuiColorEditFlags_NoAlpha)
; 5801 :         flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);
; 5802 : 
; 5803 :     ImVec4 col_rgb = col;

	movups	xmm8, XMMWORD PTR [r13]
	mov	edi, r15d
	mov	BYTE PTR pressed$1$[rsp], al
	and	edi, -393217				; fffffffffff9ffffH
	test	r15b, 2
	movups	XMMWORD PTR col_rgb$[rbp-256], xmm8
	cmove	edi, r15d

; 5804 :     if (flags & ImGuiColorEditFlags_InputHSV)

	bt	edi, 28
	jae	SHORT $LN5@ColorButto

; 5805 :         ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);

	movss	xmm2, DWORD PTR col_rgb$[rbp-248]
	lea	rax, QWORD PTR col_rgb$[rbp-248]
	movss	xmm1, DWORD PTR col_rgb$[rbp-252]
	lea	r9, QWORD PTR col_rgb$[rbp-256]
	movss	xmm0, DWORD PTR col_rgb$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR col_rgb$[rbp-252]
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	movups	xmm8, XMMWORD PTR col_rgb$[rbp-256]
$LN5@ColorButto:

; 5810 :     ImRect bb_inner = bb;

	movss	xmm3, DWORD PTR bb$[rbp-252]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	minss	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movss	xmm4, DWORD PTR bb$[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movss	xmm5, DWORD PTR bb$[rbp-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm12, DWORD PTR [rsi+14620]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5812 :     if ((flags & ImGuiColorEditFlags_NoBorder) == 0)

	mov	r15d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	shufps	xmm1, xmm8, 85				; 00000055H
	xorps	xmm6, xmm6
	shufps	xmm2, xmm8, 170				; 000000aaH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movaps	xmm15, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR col_rgb_without_alpha$[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movaps	xmm11, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR col_rgb_without_alpha$[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movaps	xmm14, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR col_rgb_without_alpha$[rbp-248], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movss	DWORD PTR bb_inner$[rsp+4], xmm3
	movss	DWORD PTR bb_inner$[rsp+8], xmm4
	movss	DWORD PTR bb_inner$[rsp+12], xmm5

; 5811 :     float off = 0.0f;

	movss	DWORD PTR $T4[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	XMMWORD PTR tv1064[rsp], xmm1
	movaps	XMMWORD PTR tv1062[rsp], xmm2
	mov	DWORD PTR col_rgb_without_alpha$[rbp-244], 1065353216 ; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5808 :     float grid_step = ImMin(size.x, size.y) / 2.99f;

	divss	xmm9, DWORD PTR __real@403f5c29

; 5809 :     float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);

	movaps	xmm0, xmm9
	mulss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm12, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5810 :     ImRect bb_inner = bb;

	movss	xmm0, DWORD PTR bb$[rbp-256]
	movss	DWORD PTR bb_inner$[rsp], xmm0
	movaps	xmm13, xmm0

; 5812 :     if ((flags & ImGuiColorEditFlags_NoBorder) == 0)

	and	r15d, 1024				; 00000400H
	jne	SHORT $LN6@ColorButto

; 5814 :         off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.

	movss	xmm6, DWORD PTR __real@bf400000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 541  :     void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	subss	xmm11, DWORD PTR __real@3f400000
	subss	xmm14, DWORD PTR __real@3f400000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5814 :         off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.

	subss	xmm13, xmm6
	movss	DWORD PTR $T4[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 541  :     void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	subss	xmm15, xmm6
	movss	DWORD PTR bb_inner$[rsp+8], xmm11
	movss	DWORD PTR bb_inner$[rsp+12], xmm14
	movss	DWORD PTR bb_inner$[rsp], xmm13
	movss	DWORD PTR bb_inner$[rsp+4], xmm15
$LN6@ColorButto:
	movaps	XMMWORD PTR [rsp+320], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5817 :     if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)

	movss	xmm7, DWORD PTR __real@3f800000
	bt	edi, 18
	jae	$LN7@ColorButto
	movaps	xmm0, xmm8
	shufps	xmm0, xmm8, 255				; 000000ffH
	comiss	xmm7, xmm0
	jbe	$LN7@ColorButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$9[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	movaps	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movss	DWORD PTR c$9[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	movaps	xmm6, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movss	DWORD PTR c$9[rbp-252], xmm1
	movss	DWORD PTR c$9[rbp-248], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	subss	xmm7, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	mulss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	addss	xmm6, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	movss	DWORD PTR c$9[rbp-244], xmm0

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	movss	xmm1, DWORD PTR $T4[rsp]
	movaps	xmm0, xmm7
	mov	rcx, QWORD PTR [rbx+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5820 :         RenderColorRectWithAlphaCheckerboard(window->DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);

	unpcklps xmm0, xmm1
	movaps	xmm1, xmm11
	mov	DWORD PTR [rsp+56], 160			; 000000a0H
	movss	DWORD PTR [rsp+48], xmm12
	movsd	QWORD PTR [rsp+40], xmm0
	movaps	xmm0, xmm6
	unpcklps xmm1, xmm14
	unpcklps xmm0, xmm15
	movq	r8, xmm1
	movq	rdx, xmm0
	movss	DWORD PTR [rsp+32], xmm9
	movsd	QWORD PTR bb_inner$[rsp+8], xmm1
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5819 :         float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);

	addss	xmm11, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movaps	xmm0, XMMWORD PTR tv1064[rsp]

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$8[rbp-256]
	movaps	xmm1, XMMWORD PTR tv1062[rsp]
	movss	DWORD PTR c$8[rbp-252], xmm0
	movss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5819 :         float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);

	mulss	xmm11, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	movss	DWORD PTR c$8[rbp-244], xmm0
	movss	DWORD PTR c$8[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5819 :         float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);

	addss	xmm11, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movss	DWORD PTR c$8[rbp-248], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T7[rsp+4], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5819 :         float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);

	cvttss2si eax, xmm11
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR $T7[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5821 :         window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);

	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb_inner$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5821 :         window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);

	mov	DWORD PTR [rsp+40], 80			; 00000050H
	lea	r8, QWORD PTR $T7[rsp]
	movss	DWORD PTR [rsp+32], xmm12
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 5822 :     }

	movss	xmm7, DWORD PTR __real@3f800000
	jmp	$LN10@ColorButto
$LN7@ColorButto:

; 5823 :     else
; 5824 :     {
; 5825 :         // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
; 5826 :         ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;

	bt	edi, 17
	lea	rcx, QWORD PTR col_rgb_without_alpha$[rbp-256]
	lea	rax, QWORD PTR col_rgb$[rbp-256]
	cmovae	rax, rcx

; 5827 :         if (col_source.w < 1.0f)

	lea	rcx, QWORD PTR c$11[rbp-256]
	movups	xmm1, XMMWORD PTR [rax]
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	xmm2, xmm1
	movss	DWORD PTR c$11[rbp-256], xmm1
	shufps	xmm2, xmm1, 255				; 000000ffH
	movaps	xmm0, xmm1
	shufps	xmm0, xmm1, 85				; 00000055H
	comiss	xmm7, xmm2
	mulss	xmm2, DWORD PTR [rax+14552]
	shufps	xmm1, xmm1, 170				; 000000aaH
	movss	DWORD PTR c$11[rbp-252], xmm0
	movss	DWORD PTR c$11[rbp-244], xmm2
	movss	DWORD PTR c$11[rbp-248], xmm1
	jbe	SHORT $LN9@ColorButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5828 :             RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);

	mov	rcx, QWORD PTR [rbx+728]
	movaps	xmm0, xmm6
	unpcklps xmm0, xmm6
	movaps	xmm1, xmm11
	mov	DWORD PTR [rsp+56], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5828 :             RenderColorRectWithAlphaCheckerboard(window->DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);

	movss	DWORD PTR [rsp+48], xmm12
	movsd	QWORD PTR [rsp+40], xmm0
	movaps	xmm0, xmm13
	unpcklps xmm0, xmm15
	unpcklps xmm1, xmm14
	movq	rdx, xmm0
	movq	r8, xmm1
	movss	DWORD PTR [rsp+32], xmm9
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard
	jmp	SHORT $LN10@ColorButto
$LN9@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5830 :             window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);

	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb_inner$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5830 :             window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);

	mov	DWORD PTR [rsp+40], 0
	lea	r8, QWORD PTR bb_inner$[rsp+8]
	movss	DWORD PTR [rsp+32], xmm12
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN10@ColorButto:

; 5831 :     }
; 5832 :     RenderNavHighlight(bb, id);

	mov	r8d, 1
	lea	rcx, QWORD PTR bb$[rbp-256]
	mov	edx, r14d
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
	movaps	xmm15, XMMWORD PTR [rsp+192]
	movaps	xmm14, XMMWORD PTR [rsp+208]
	movaps	xmm13, XMMWORD PTR [rsp+224]
	movaps	xmm11, XMMWORD PTR [rsp+256]

; 5833 :     if ((flags & ImGuiColorEditFlags_NoBorder) == 0)

	test	r15d, r15d
	jne	$LN13@ColorButto

; 5834 :     {
; 5835 :         if (g.Style.FrameBorderSize > 0.0f)

	movss	xmm0, DWORD PTR [rsi+14624]
	comiss	xmm0, xmm10
	jbe	SHORT $LN12@ColorButto

; 5836 :             RenderFrameBorder(bb.Min, bb.Max, rounding);

	movss	xmm1, DWORD PTR bb$[rbp-244]
	movaps	xmm2, xmm12
	movss	xmm0, DWORD PTR bb$[rbp-248]
	movss	xmm3, DWORD PTR bb$[rbp-252]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR bb$[rbp-256]
	movq	rdx, xmm0
	unpcklps xmm1, xmm3
	movq	rcx, xmm1
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
	jmp	SHORT $LN13@ColorButto
$LN12@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$10[rbp-256]
	movups	xmm0, XMMWORD PTR [rax+14888]
	movups	XMMWORD PTR c$10[rbp-256], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$10[rbp-244], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5838 :             window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb$[rbp-256]
	movss	DWORD PTR [rsp+48], xmm7
	lea	r8, QWORD PTR bb$[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5838 :             window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

	mov	DWORD PTR [rsp+40], 0
	movss	DWORD PTR [rsp+32], xmm12
	call	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN13@ColorButto:

; 5839 :     }
; 5840 : 
; 5841 :     // Drag and Drop Source
; 5842 :     // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
; 5843 :     if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())

	movaps	xmm12, XMMWORD PTR [rsp+240]
	movaps	xmm7, XMMWORD PTR [rsp+320]
	cmp	DWORD PTR [rsi+16504], r14d
	jne	$LN14@ColorButto
	bt	edi, 9
	jb	$LN14@ColorButto
	xor	ecx, ecx
	call	?BeginDragDropSource@ImGui@@YA_NH@Z	; ImGui::BeginDragDropSource
	test	al, al
	je	$LN14@ColorButto

; 5844 :     {
; 5845 :         if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	dil, 2
	je	SHORT $LN15@ColorButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13168:     if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)

	cmp	DWORD PTR [rsi+19580], -1
	jne	$LN77@ColorButto

; 1812 :         strncpy(dst, src, count - 1);

	mov	r8d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:??_C@_06LFKNFKEK@_COL3F@
	lea	rcx, QWORD PTR [rsi+19584]
	call	QWORD PTR __imp_strncpy

; 13172:         g.DragDropPayloadBufHeap.resize(0);

	lea	rcx, QWORD PTR [rsi+19672]

; 1813 :     dst[count - 1] = 0;

	mov	BYTE PTR [rsi+19616], 0

; 13172:         g.DragDropPayloadBufHeap.resize(0);

	xor	edx, edx
	call	?resize@?$ImVector@E@@QEAAXH@Z		; ImVector<unsigned char>::resize

; 13173:         if (data_size > sizeof(g.DragDropPayloadBufLocal))
; 13174:         {
; 13175:             // Store in heap
; 13176:             g.DragDropPayloadBufHeap.resize((int)data_size);
; 13177:             payload.Data = g.DragDropPayloadBufHeap.Data;
; 13178:             memcpy(payload.Data, data, data_size);
; 13179:         }
; 13180:         else if (data_size > 0)
; 13181:         {
; 13182:             // Store locally
; 13183:             memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));

	mov	DWORD PTR [rsi+19700], 0
	lea	rcx, QWORD PTR [rsi+19688]

; 13184:             payload.Data = g.DragDropPayloadBufLocal;

	mov	QWORD PTR [rsi+19560], rcx

; 13185:             memcpy(payload.Data, data, data_size);

	movsd	QWORD PTR [rcx], xmm8
	psrldq	xmm8, 8
	movd	DWORD PTR [rcx+8], xmm8

; 13186:         }
; 13187:         else
; 13188:         {
; 13189:             payload.Data = NULL;
; 13190:         }
; 13191:         payload.DataSize = (int)data_size;

	mov	DWORD PTR [rsi+19568], 12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5846 :             SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);

	jmp	SHORT $LN77@ColorButto
$LN15@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13168:     if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)

	cmp	DWORD PTR [rsi+19580], -1
	jne	SHORT $LN77@ColorButto

; 1812 :         strncpy(dst, src, count - 1);

	mov	r8d, 32					; 00000020H
	lea	rdx, OFFSET FLAT:??_C@_06LAOCEMMP@_COL4F@
	lea	rcx, QWORD PTR [rsi+19584]
	call	QWORD PTR __imp_strncpy

; 13172:         g.DragDropPayloadBufHeap.resize(0);

	lea	rcx, QWORD PTR [rsi+19672]

; 1813 :     dst[count - 1] = 0;

	mov	BYTE PTR [rsi+19616], 0

; 13172:         g.DragDropPayloadBufHeap.resize(0);

	xor	edx, edx
	call	?resize@?$ImVector@E@@QEAAXH@Z		; ImVector<unsigned char>::resize

; 13173:         if (data_size > sizeof(g.DragDropPayloadBufLocal))
; 13174:         {
; 13175:             // Store in heap
; 13176:             g.DragDropPayloadBufHeap.resize((int)data_size);
; 13177:             payload.Data = g.DragDropPayloadBufHeap.Data;
; 13178:             memcpy(payload.Data, data, data_size);
; 13179:         }
; 13180:         else if (data_size > 0)
; 13181:         {
; 13182:             // Store locally
; 13183:             memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));

	lea	rax, QWORD PTR [rsi+19688]

; 13184:             payload.Data = g.DragDropPayloadBufLocal;

	mov	QWORD PTR [rsi+19560], rax

; 13185:             memcpy(payload.Data, data, data_size);

	movups	XMMWORD PTR [rax], xmm8

; 13186:         }
; 13187:         else
; 13188:         {
; 13189:             payload.Data = NULL;
; 13190:         }
; 13191:         payload.DataSize = (int)data_size;

	mov	DWORD PTR [rsi+19568], 16
$LN77@ColorButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	eax, DWORD PTR [rsi+16240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5849 :         ColorButton(desc_id, col, flags);

	lea	r9, QWORD PTR $T6[rsp]
	mov	r8d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR [rsi+19580], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5849 :         ColorButton(desc_id, col, flags);

	mov	rdx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T6[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5849 :         ColorButton(desc_id, col, flags);

	mov	rcx, r12
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton

; 5850 :         SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 5851 :         TextEx("Color");

	lea	rcx, OFFSET FLAT:??_C@_05PDOBBJNA@Color@
	xor	r8d, r8d
	xor	edx, edx
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx

; 5852 :         EndDragDropSource();

	call	?EndDragDropSource@ImGui@@YAXXZ		; ImGui::EndDragDropSource
$LN14@ColorButto:

; 5853 :     }
; 5854 : 
; 5855 :     // Tooltip
; 5856 :     if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered && IsItemHovered(ImGuiHoveredFlags_ForTooltip))

	movaps	xmm8, XMMWORD PTR [rsp+304]
	test	dil, 64					; 00000040H
	jne	SHORT $LN17@ColorButto
	cmp	BYTE PTR hovered$[rsp], 0
	je	SHORT $LN17@ColorButto
	mov	ecx, 4096				; 00001000H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN17@ColorButto

; 5857 :         ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

	and	edi, 403046402				; 18060002H
	mov	rdx, r13
	mov	r8d, edi
	mov	rcx, r12
	call	?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z	; ImGui::ColorTooltip
$LN17@ColorButto:

; 5858 : 
; 5859 :     return pressed;

	movzx	eax, BYTE PTR pressed$1$[rsp]
	jmp	SHORT $LN1@ColorButto
$LN105@ColorButto:

; 5795 :         return false;

	xor	al, al
$LN1@ColorButto:

; 5860 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ENDP ; ImGui::ColorButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMenu@ImGui@@YA_NPEBD_N@Z
_TEXT	SEGMENT
label$ = 8
enabled$dead$ = 16
?BeginMenu@ImGui@@YA_NPEBD_N@Z PROC			; ImGui::BeginMenu, COMDAT

; 7377 :     return BeginMenuEx(label, NULL, enabled);

	mov	r8b, 1
	xor	edx, edx
	jmp	?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z	; ImGui::BeginMenuEx
?BeginMenu@ImGui@@YA_NPEBD_N@Z ENDP			; ImGui::BeginMenu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z
_TEXT	SEGMENT
step_fast$GSCopy$ = 64
step$GSCopy$ = 72
__$ArrayPad$ = 80
label$ = 112
v$ = 120
step$ = 128
step_fast$ = 136
format$dead$ = 144
flags$dead$ = 152
?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z PROC		; ImGui::InputFloat, COMDAT

; 3594 : {

$LN4:
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3595 :     flags |= ImGuiInputTextFlags_CharsScientific;
; 3596 :     return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), format, flags);

	xor	r8d, r8d
	mov	DWORD PTR [rsp+48], 131072		; 00020000H
	xorps	xmm0, xmm0
	movss	DWORD PTR step$GSCopy$[rsp], xmm2
	comiss	xmm3, xmm0
	lea	rax, QWORD PTR step_fast$GSCopy$[rsp]
	lea	r9, QWORD PTR step$GSCopy$[rsp]
	movss	DWORD PTR step_fast$GSCopy$[rsp], xmm3
	cmovbe	rax, r8
	comiss	xmm2, xmm0
	cmovbe	r9, r8
	lea	r8, OFFSET FLAT:??_C@_04GFJLOHHD@?$CF?43f@
	mov	QWORD PTR [rsp+40], r8
	mov	r8, rdx
	mov	edx, 8
	mov	QWORD PTR [rsp+32], rax
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 3597 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z
_TEXT	SEGMENT
value_changed$1$ = 64
value_changed_sv$1$ = 65
value_changed_h$1$ = 66
col_white$1$ = 68
tv5873 = 68
H$1$ = 72
V$1$ = 76
square_sz$1$ = 80
picker_pos$ = 88
col_midgrey$1$ = 96
B$ = 96
sv_cursor_pos$ = 104
R$ = 104
tv5947 = 112
trc$10 = 112
hue_cursor_pos$11 = 112
S$1$ = 120
current_off_unrotated$12 = 120
mx$1$ = 128
$T13 = 128
sv_picker_size$1$ = 136
user_col32_striped_of_alpha$1$ = 140
G$ = 140
$T14 = 144
trb$15 = 144
$T16 = 144
$T17 = 144
$T18 = 144
$T19 = 144
$T20 = 144
triangle_pb$ = 144
triangle_pc$2$ = 160
triangle_pb$2$ = 164
triangle_pc$1$ = 168
col_hues$6$ = 172
R$1$ = 172
col_hues$5$ = 176
G$1$ = 176
col_hues$4$ = 180
B$1$ = 180
$T21 = 184
tv5885 = 184
col_hues$3$ = 188
tv5862 = 188
tv5793 = 188
col$GSCopy$1$ = 192
$T22 = 200
$T23 = 200
tra$24 = 200
wheel_center$ = 200
tv5905 = 208
tv5872 = 208
$T25 = 208
$T26 = 208
wheel_center$2$ = 224
wheel_center$1$ = 228
$T27 = 232
$T28 = 240
col_black$1$ = 248
tv5788 = 248
tv5884 = 252
hue_color32$1$ = 256
tv5787 = 256
$T29 = 256
$T30 = 256
hue_cursor_rad$1$ = 264
triangle_pa$ = 272
tv5948 = 280
wheel_r_outer$1$ = 288
$T31 = 292
wheel_r_inner$1$ = 296
$T32 = 300
picker_pos$3$ = 304
tv5903 = 312
triangle_pc$ = 320
tv5797 = 328
col_hues$ = 336
ref_col$GSCopy$1$ = 368
$T33 = 368
$T34 = 368
hue_color_f$ = 368
$T35 = 368
ref_col_v4$36 = 368
label$GSCopy$1$ = 384
col_v4$37 = 384
g$1$ = 400
bar1_bb$38 = 400
backup_initial_col$ = 416
__$ArrayPad$ = 432
label$ = 688
col$ = 696
flags$ = 704
ref_col$ = 712
?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z PROC		; ImGui::ColorPicker4, COMDAT

; 5411 : {

$LN1197:
	push	rbp
	push	rbx
	push	rsi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-384]
	sub	rsp, 640				; 00000280H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 5412 :     ImGuiContext& g = *GImGui;

	mov	r15, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14, rdx
	mov	QWORD PTR col$GSCopy$1$[rbp-256], rdx
	mov	ebx, r8d
	mov	QWORD PTR ref_col$GSCopy$1$[rbp-256], r9
	mov	rdx, rcx
	mov	QWORD PTR label$GSCopy$1$[rbp-256], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r15+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5412 :     ImGuiContext& g = *GImGui;

	mov	QWORD PTR g$1$[rbp-256], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [r15+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5414 :     if (window->SkipItems)

	cmp	BYTE PTR [rsi+240], 0
	je	SHORT $LN8@ColorPicke

; 5415 :         return false;

	xor	al, al
	jmp	$LN1@ColorPicke
$LN8@ColorPicke:
	mov	QWORD PTR [rsp+632], rdi
	mov	QWORD PTR [rsp+624], r12
	mov	QWORD PTR [rsp+616], r13

; 5416 : 
; 5417 :     ImDrawList* draw_list = window->DrawList;

	mov	r13, QWORD PTR [rsi+728]
	movaps	XMMWORD PTR [rsp+592], xmm6
	movaps	XMMWORD PTR [rsp+576], xmm7
	movaps	XMMWORD PTR [rsp+560], xmm8
	movaps	XMMWORD PTR [rsp+544], xmm9
	movaps	XMMWORD PTR [rsp+528], xmm10
	movaps	XMMWORD PTR [rsp+512], xmm11
	movaps	XMMWORD PTR [rsp+496], xmm12
	movaps	XMMWORD PTR [rsp+480], xmm13
	movaps	XMMWORD PTR [rsp+464], xmm14
	movaps	XMMWORD PTR [rsp+448], xmm15

; 5421 :     const float width = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1207 :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!

	xor	r12d, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5424 :     PushID(label);

	mov	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1207 :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!

	mov	QWORD PTR [r15+18592], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5421 :     const float width = CalcItemWidth();

	movaps	xmm6, xmm0

; 5424 :     PushID(label);

	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 5425 :     const bool set_current_color_edit_id = (g.ColorEditCurrentID == 0);

	mov	eax, DWORD PTR [r15+23832]
	mov	DWORD PTR tv5903[rbp-256], eax

; 5426 :     if (set_current_color_edit_id)

	test	eax, eax
	jne	SHORT $LN9@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [rsi+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5427 :         g.ColorEditCurrentID = window->IDStack.back();

	mov	rax, QWORD PTR [rsi+304]
	mov	ecx, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR [r15+23832], ecx
$LN9@ColorPicke:

; 5428 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 5429 : 
; 5430 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))
; 5431 :         flags |= ImGuiColorEditFlags_NoSmallPreview;
; 5432 : 
; 5433 :     // Context menu: display and store options.
; 5434 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

	mov	edi, ebx
	or	edi, 16
	bt	ebx, 8
	cmovb	edi, ebx
	test	dil, 8
	jne	SHORT $LN11@ColorPicke

; 5435 :         ColorPickerOptionsPopup(col, flags);

	mov	edx, edi
	mov	rcx, r14
	call	?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z ; ImGui::ColorPickerOptionsPopup
$LN11@ColorPicke:

; 5436 : 
; 5437 :     // Read stored options
; 5438 :     if (!(flags & ImGuiColorEditFlags_PickerMask_))

	mov	ecx, 177209344				; 0a900000H
	test	edi, 100663296				; 06000000H
	jne	SHORT $LN1022@ColorPicke

; 5439 :         flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_PickerMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_PickerMask_;

	mov	eax, DWORD PTR [r15+23828]
	mov	ebx, ecx
	test	eax, 100663296				; 06000000H
	cmovne	ebx, eax
	and	ebx, 100663296				; 06000000H
	or	ebx, edi
	jmp	SHORT $LN12@ColorPicke
$LN1022@ColorPicke:
	mov	ebx, edi
$LN12@ColorPicke:

; 5440 :     if (!(flags & ImGuiColorEditFlags_InputMask_))

	test	ebx, 402653184				; 18000000H
	jne	SHORT $LN1032@ColorPicke

; 5441 :         flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_InputMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_InputMask_;

	mov	eax, DWORD PTR [r15+23828]
	test	eax, 402653184				; 18000000H
	cmovne	ecx, eax
	and	ecx, 402653184				; 18000000H
	or	ebx, ecx
$LN1032@ColorPicke:

; 5442 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_PickerMask_)); // Check that only 1 is selected
; 5443 :     IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags_InputMask_));  // Check that only 1 is selected
; 5444 :     if (!(flags & ImGuiColorEditFlags_NoOptions))

	test	bl, 8
	jne	SHORT $LN14@ColorPicke

; 5445 :         flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

	mov	eax, DWORD PTR [r15+23828]
	and	eax, 65536				; 00010000H
	or	ebx, eax
$LN14@ColorPicke:

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	movss	xmm2, DWORD PTR [r15+14636]
	mov	eax, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10420:     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	movaps	xmm0, xmm2
	movsd	xmm7, QWORD PTR [rsi+312]
	mov	ecx, ebx
	and	ecx, 2
	movsd	QWORD PTR picker_pos$3$[rbp-256], xmm7
	mov	edx, ebx
	mov	DWORD PTR tv5885[rbp-256], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm8, DWORD PTR [rdi+14616]
	and	edx, 65538				; 00010002H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	cmp	edx, 65536				; 00010000H
	mov	DWORD PTR tv5884[rbp-256], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm8, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5450 :     ImVec2 picker_pos = window->DC.CursorPos;

	movsd	QWORD PTR picker_pos$[rsp], xmm7

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	sete	al

; 5457 : 
; 5458 :     float backup_initial_col[4];
; 5459 :     memcpy(backup_initial_col, col, components * sizeof(float));

	mov	edx, 12
	inc	eax
	test	ecx, ecx
	lea	rcx, QWORD PTR backup_initial_col$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm8, DWORD PTR [rdi+15696]
	movd	xmm1, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	cvtdq2ps xmm1, xmm1
	addss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	DWORD PTR square_sz$1$[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm14, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5453 :     float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box

	mulss	xmm1, xmm0

; 5454 :     float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;

	movaps	xmm0, xmm7
	subss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm14, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5454 :     float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;

	addss	xmm0, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR sv_picker_size$1$[rbp-256], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5454 :     float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;

	movss	DWORD PTR mx$1$[rbp-256], xmm0
	addss	xmm0, xmm2
	movss	DWORD PTR $T27[rbp-256], xmm0

; 5455 :     float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;

	addss	xmm0, xmm8
	addss	xmm2, xmm0
	movss	DWORD PTR $T32[rbp-256], xmm0

; 5456 :     float bars_triangles_half_sz = IM_FLOOR(bars_width * 0.20f);

	movaps	xmm0, xmm8
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR $T28[rbp-256], xmm2
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 5457 : 
; 5458 :     float backup_initial_col[4];
; 5459 :     memcpy(backup_initial_col, col, components * sizeof(float));

	mov	eax, 16
	cmovne	eax, edx
	mov	rdx, r14
	cvtdq2ps xmm0, xmm0
	mov	r8d, eax
	mov	QWORD PTR tv5797[rbp-256], rax
	movss	DWORD PTR $T31[rbp-256], xmm0
	call	memcpy

; 5462 :     float wheel_r_outer = sv_picker_size * 0.50f;

	movaps	xmm3, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR triangle_pa$[rbp-252], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5462 :     float wheel_r_outer = sv_picker_size * 0.50f;

	mulss	xmm3, DWORD PTR __real@3f000000
	movaps	xmm0, xmm14
	mulss	xmm0, DWORD PTR __real@3da3d70a
	xorps	xmm11, xmm11

; 5463 :     float wheel_r_inner = wheel_r_outer - wheel_thickness;

	movaps	xmm2, xmm3
	movss	DWORD PTR wheel_r_outer$1$[rbp-256], xmm3
	subss	xmm2, xmm0
	movss	DWORD PTR hue_cursor_rad$1$[rbp-256], xmm0

; 5464 :     ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size * 0.5f);

	movaps	xmm0, xmm14
	addss	xmm0, xmm8

; 5467 :     float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);

	movaps	xmm1, xmm2
	movss	DWORD PTR wheel_r_inner$1$[rbp-256], xmm2
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, xmm7
	movss	DWORD PTR wheel_center$2$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR wheel_center$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5464 :     ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size * 0.5f);

	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR picker_pos$[rsp+4]
	movss	DWORD PTR wheel_center$1$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR wheel_center$[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5467 :     float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);

	movaps	xmm0, xmm14
	mulss	xmm0, DWORD PTR __real@3cdd2f1b
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR triangle_pa$[rbp-256], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5472 :     float H = col[0], S = col[1], V = col[2];

	movss	xmm7, DWORD PTR [r14+4]
	lea	rax, QWORD PTR [r14+4]
	movss	xmm6, DWORD PTR [r14]
	lea	rsi, QWORD PTR [r14+8]
	movss	xmm8, DWORD PTR [rsi]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@bf000000
	movaps	xmm2, xmm1
	mov	QWORD PTR tv5947[rsp], rax

; 5474 :     if (flags & ImGuiColorEditFlags_InputRGB)

	mov	eax, ebx
	mulss	xmm2, DWORD PTR __real@bf5db3d0
	movaps	xmm10, xmm6
	and	eax, 134217728				; 08000000H
	mov	QWORD PTR tv5948[rbp-256], rsi
	movss	xmm9, DWORD PTR __real@40c00000
	movaps	xmm13, xmm7
	movss	xmm3, DWORD PTR __real@1e3ce508
	movaps	xmm15, xmm8
	movss	xmm12, DWORD PTR __real@3f800000
	movss	DWORD PTR triangle_pc$2$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR triangle_pb$[rbp-256], xmm0
	movss	DWORD PTR triangle_pc$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5470 :     ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f5db3d0

; 5474 :     if (flags & ImGuiColorEditFlags_InputRGB)

	mov	DWORD PTR tv5873[rsp], eax
	movss	DWORD PTR triangle_pb$2$[rbp-256], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR triangle_pb$[rbp-252], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5470 :     ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

	movss	DWORD PTR triangle_pc$1$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR triangle_pc$[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5472 :     float H = col[0], S = col[1], V = col[2];

	movss	DWORD PTR R$1$[rbp-256], xmm6
	movss	DWORD PTR H$1$[rsp], xmm6
	movss	DWORD PTR G$1$[rbp-256], xmm7
	movss	DWORD PTR S$1$[rsp], xmm7
	movss	DWORD PTR B$1$[rbp-256], xmm8
	movss	DWORD PTR V$1$[rsp], xmm8

; 5473 :     float R = col[0], G = col[1], B = col[2];

	movss	DWORD PTR R$[rsp], xmm6
	movss	DWORD PTR G$[rbp-256], xmm7
	movss	DWORD PTR B$[rsp], xmm8

; 5474 :     if (flags & ImGuiColorEditFlags_InputRGB)

	je	$LN15@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2366 :     if (g < b)

	comiss	xmm8, xmm7
	xorps	xmm1, xmm1

; 2365 :     float K = 0.f;

	movaps	xmm2, xmm8
	movaps	xmm10, xmm7

; 2366 :     if (g < b)

	jbe	SHORT $LN306@ColorPicke

; 2369 :         K = -1.f;

	movss	xmm1, DWORD PTR __real@bf800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm10, xmm8
	movaps	xmm2, xmm7
$LN306@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2371 :     if (r < g)

	comiss	xmm10, xmm6
	movss	DWORD PTR V$1$[rsp], xmm6
	movaps	xmm15, xmm6
	jbe	SHORT $LN307@ColorPicke

; 2374 :         K = -2.f / 6.f - K;

	movss	xmm0, DWORD PTR __real@beaaaaab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm15, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movss	DWORD PTR V$1$[rsp], xmm10
	movaps	xmm10, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	movaps	xmm1, xmm0
$LN307@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	mov	eax, DWORD PTR [rdi+23832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2377 :     const float chroma = r - (g < b ? g : b);

	movaps	xmm0, xmm10
	minss	xmm0, xmm2
	movaps	xmm13, xmm15

; 2378 :     out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));

	subss	xmm10, xmm2
	subss	xmm13, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, xmm9
	addss	xmm0, xmm3
	divss	xmm10, xmm0

; 2379 :     out_s = chroma / (r + 1e-20f);

	movaps	xmm0, xmm15
	addss	xmm0, xmm3
	addss	xmm10, xmm1
	divss	xmm13, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm10, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2379 :     out_s = chroma / (r + 1e-20f);

	movss	DWORD PTR S$1$[rsp], xmm13
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	DWORD PTR H$1$[rsp], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	cmp	DWORD PTR [rdi+23836], eax
	jne	$LN17@ColorPicke
	lea	rcx, QWORD PTR $T25[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR $T25[rbp-256], xmm6
	movss	DWORD PTR $T25[rbp-252], xmm7
	movss	DWORD PTR $T25[rbp-248], xmm8
	mov	DWORD PTR $T25[rbp-244], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	cmp	DWORD PTR [rdi+23848], eax
	jne	$LN17@ColorPicke

; 5127 :         return;
; 5128 : 
; 5129 :     // When S == 0, H is undefined.
; 5130 :     // When H == 1 it wraps around to 0.
; 5131 :     if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))

	ucomiss	xmm13, xmm11
	jp	SHORT $LN1040@ColorPicke
	je	SHORT $LN1024@ColorPicke
$LN1040@ColorPicke:
	ucomiss	xmm10, xmm11
	jp	SHORT $LN320@ColorPicke
	jne	SHORT $LN320@ColorPicke
	movss	xmm0, DWORD PTR [rdi+23840]
	ucomiss	xmm0, xmm12
	jp	SHORT $LN320@ColorPicke
	jne	SHORT $LN320@ColorPicke
$LN1024@ColorPicke:

; 5132 :         *H = g.ColorEditSavedHue;

	movss	xmm10, DWORD PTR [rdi+23840]
	movss	DWORD PTR H$1$[rsp], xmm10
$LN320@ColorPicke:

; 5133 : 
; 5134 :     // When V == 0, S is undefined.
; 5135 :     if (*V == 0.0f)

	ucomiss	xmm15, xmm11
	jp	SHORT $LN17@ColorPicke
	jne	SHORT $LN17@ColorPicke

; 5136 :         *S = g.ColorEditSavedSat;

	movss	xmm13, DWORD PTR [rdi+23844]
	movss	DWORD PTR S$1$[rsp], xmm13

; 5475 :     {
; 5476 :         // Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
; 5477 :         ColorConvertRGBtoHSV(R, G, B, H, S, V);
; 5478 :         ColorEditRestoreHS(col, &H, &S, &V);
; 5479 :     }

	jmp	SHORT $LN17@ColorPicke
$LN15@ColorPicke:

; 5480 :     else if (flags & ImGuiColorEditFlags_InputHSV)

	bt	ebx, 28
	jae	SHORT $LN17@ColorPicke

; 5481 :     {
; 5482 :         ColorConvertHSVtoRGB(H, S, V, R, G, B);

	lea	rax, QWORD PTR B$[rsp]
	movaps	xmm2, xmm8
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR R$[rsp]
	lea	rax, QWORD PTR G$[rbp-256]
	movaps	xmm1, xmm7
	movaps	xmm0, xmm6
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	movss	xmm0, DWORD PTR R$[rsp]
	movss	xmm1, DWORD PTR G$[rbp-256]
	movss	xmm2, DWORD PTR B$[rsp]
	movss	DWORD PTR R$1$[rbp-256], xmm0
	movss	DWORD PTR G$1$[rbp-256], xmm1
	movss	DWORD PTR B$1$[rbp-256], xmm2
$LN17@ColorPicke:

; 5483 :     }
; 5484 : 
; 5485 :     bool value_changed = false, value_changed_h = false, value_changed_sv = false;
; 5486 : 
; 5487 :     PushItemFlag(ImGuiItemFlags_NoNav, true);

	mov	ecx, 8
	mov	BYTE PTR value_changed$1$[rsp], r12b
	mov	BYTE PTR value_changed_h$1$[rsp], r12b
	mov	BYTE PTR value_changed_sv$1$[rsp], r12b
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag

; 5488 :     if (flags & ImGuiColorEditFlags_PickerHueWheel)

	mov	eax, ebx
	and	eax, 67108864				; 04000000H
	mov	DWORD PTR tv5872[rbp-256], eax
	je	$LN18@ColorPicke

; 5491 :         InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));

	movaps	xmm0, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T30[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5491 :         InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));

	addss	xmm0, DWORD PTR [r15+14636]
	lea	rdx, QWORD PTR $T30[rbp-256]
	lea	rcx, OFFSET FLAT:??_C@_03PPLPHHG@hsv@
	addss	xmm0, DWORD PTR square_sz$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T30[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5491 :         InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));

	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::InvisibleButton
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5501 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5502 :     if (g.ActiveId)

	mov	ecx, DWORD PTR [rax+16504]
	test	ecx, ecx
	je	$LN23@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5492 :         if (IsItemActive())

	cmp	ecx, DWORD PTR [rax+18616]
	jne	$LN23@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm8, DWORD PTR [r15+14076]
	movss	xmm14, DWORD PTR [r15+14080]
	subss	xmm8, DWORD PTR wheel_center$2$[rbp-256]
	subss	xmm14, DWORD PTR wheel_center$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5497 :             if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))

	movss	xmm1, DWORD PTR wheel_r_inner$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm7, DWORD PTR [r15+3592]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5497 :             if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))

	subss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm9, DWORD PTR [r15+3596]
	subss	xmm7, DWORD PTR wheel_center$2$[rbp-256]
	subss	xmm9, DWORD PTR wheel_center$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movaps	xmm2, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	mulss	xmm2, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5497 :             if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))

	mulss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	addss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5497 :             if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))

	comiss	xmm2, xmm1
	jb	SHORT $LN21@ColorPicke
	movss	xmm0, DWORD PTR wheel_r_outer$1$[rbp-256]
	addss	xmm0, xmm12
	mulss	xmm0, xmm0
	comiss	xmm0, xmm2
	jb	SHORT $LN21@ColorPicke

; 5498 :             {
; 5499 :                 // Interactive with Hue wheel
; 5500 :                 H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;

	movaps	xmm1, xmm7
	movaps	xmm0, xmm9
	call	atan2f
	movaps	xmm10, xmm0
	divss	xmm10, DWORD PTR __real@40490fdb
	mulss	xmm10, DWORD PTR __real@3f000000

; 5501 :                 if (H < 0.0f)

	comiss	xmm11, xmm10
	movss	DWORD PTR H$1$[rsp], xmm10
	jbe	SHORT $LN22@ColorPicke

; 5502 :                     H += 1.0f;

	addss	xmm10, xmm12
	movss	DWORD PTR H$1$[rsp], xmm10
$LN22@ColorPicke:

; 5503 :                 value_changed = value_changed_h = true;

	mov	r12b, 1
	mov	BYTE PTR value_changed$1$[rsp], r12b
$LN21@ColorPicke:

; 5504 :             }
; 5505 :             float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);

	movaps	xmm6, xmm10
	mov	BYTE PTR value_changed_h$1$[rsp], r12b
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm6, xmm6
	mulss	xmm6, DWORD PTR __real@40490fdb
	movaps	xmm0, xmm6
	call	cosf
	movss	DWORD PTR tv5793[rbp-256], xmm0

; 5506 :             float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);

	movaps	xmm0, xmm6
	call	sinf
	movss	xmm4, DWORD PTR tv5793[rbp-256]
	movaps	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movss	xmm0, DWORD PTR triangle_pc$2$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movaps	xmm1, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movaps	xmm5, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	mulss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	subss	xmm5, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	mulss	xmm14, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5506 :             float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);

	movaps	xmm3, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5506 :             float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);

	mulss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	addss	xmm8, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movss	DWORD PTR tv5862[rbp-256], xmm5
	movss	xmm14, DWORD PTR triangle_pb$2$[rbp-256]
	subss	xmm14, DWORD PTR triangle_pc$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	subss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movaps	xmm1, xmm14
	movaps	xmm2, xmm3
	subss	xmm2, xmm0
	movaps	xmm0, xmm8
	subss	xmm0, DWORD PTR triangle_pc$1$[rbp-256]
	mulss	xmm1, xmm2
	mulss	xmm0, xmm5
	movss	xmm5, DWORD PTR triangle_pa$[rbp-256]
	subss	xmm5, DWORD PTR triangle_pc$2$[rbp-256]
	subss	xmm1, xmm0
	xorps	xmm0, xmm0

; 1755 :     bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;

	subss	xmm0, DWORD PTR triangle_pb$2$[rbp-256]
	movss	DWORD PTR tv5787[rbp-256], xmm5

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	comiss	xmm11, xmm1
	movaps	xmm1, xmm0
	movss	DWORD PTR tv5788[rbp-256], xmm0
	movaps	xmm0, xmm8
	mulss	xmm1, xmm2
	seta	cl
	subss	xmm0, DWORD PTR triangle_pb$2$[rbp-256]
	mulss	xmm0, xmm5
	subss	xmm1, xmm0
	comiss	xmm11, xmm1
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	al, cl
	jne	$LN892@ColorPicke

; 1757 :     bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;

	subss	xmm3, DWORD PTR triangle_pa$[rbp-256]
	movss	xmm0, DWORD PTR triangle_pc$1$[rbp-256]
	subss	xmm8, xmm11
	movss	xmm1, DWORD PTR triangle_pc$2$[rbp-256]
	subss	xmm0, xmm11
	subss	xmm1, DWORD PTR triangle_pa$[rbp-256]
	mulss	xmm3, xmm0
	mulss	xmm1, xmm8
	subss	xmm3, xmm1
	comiss	xmm11, xmm3
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	cl, al
	jne	$LN892@ColorPicke

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movss	xmm8, DWORD PTR triangle_pc$2$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movaps	xmm5, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1755 :     bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;

	movss	xmm13, DWORD PTR triangle_pb$2$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movaps	xmm0, xmm9
	mulss	xmm0, xmm6
	mulss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1758 :     return ((b1 == b2) && (b2 == b3));

	movss	xmm6, DWORD PTR triangle_pa$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	mulss	xmm5, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mulss	xmm9, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	subss	xmm5, xmm0
	addss	xmm7, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movss	xmm9, DWORD PTR triangle_pc$1$[rbp-256]
	movaps	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR current_off_unrotated$12[rsp], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	subss	xmm1, xmm8
	movaps	xmm2, xmm5
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR current_off_unrotated$12[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	subss	xmm0, xmm9
	subss	xmm2, xmm8
	mulss	xmm1, xmm14
	mulss	xmm0, DWORD PTR tv5862[rbp-256]
	mulss	xmm2, DWORD PTR tv5788[rbp-256]
	subss	xmm1, xmm0
	movaps	xmm0, xmm7
	subss	xmm0, xmm13
	comiss	xmm11, xmm1
	mulss	xmm0, DWORD PTR tv5787[rbp-256]
	seta	cl
	subss	xmm2, xmm0
	comiss	xmm11, xmm2
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	al, cl
	jne	SHORT $LN1036@ColorPicke

; 1757 :     bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;

	movaps	xmm0, xmm9
	movaps	xmm2, xmm5
	subss	xmm0, xmm11
	movaps	xmm1, xmm8
	subss	xmm2, xmm6
	subss	xmm1, xmm6
	mulss	xmm2, xmm0
	movaps	xmm0, xmm7
	subss	xmm0, xmm11
	mulss	xmm1, xmm0
	subss	xmm2, xmm1
	comiss	xmm11, xmm2
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	cl, al
	je	SHORT $LN24@ColorPicke
$LN1036@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5512 :                     current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);

	lea	rax, QWORD PTR current_off_unrotated$12[rsp]
	lea	r9, QWORD PTR triangle_pc$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	r8, QWORD PTR triangle_pb$[rbp-256]
	lea	rdx, QWORD PTR triangle_pa$[rbp-256]
	lea	rcx, QWORD PTR $T29[rbp-256]
	call	?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z ; ImTriangleClosestPoint
	movsd	xmm1, QWORD PTR [rax]
	movaps	xmm0, xmm1
	movsd	QWORD PTR current_off_unrotated$12[rsp], xmm1
	movss	xmm5, DWORD PTR current_off_unrotated$12[rsp]
	shufps	xmm0, xmm0, 85				; 00000055H
	movaps	xmm7, xmm0
$LN24@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm4, xmm13
	subss	xmm7, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm13, DWORD PTR __real@38d1b717
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm4, xmm11
	movaps	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	DWORD PTR S$1$[rsp], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm2, xmm6
	movaps	xmm1, xmm9
	subss	xmm1, xmm11
	subss	xmm5, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1766 :     const float denom = v0.x * v1.y - v1.x * v0.y;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm3, xmm2
	mulss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1767 :     out_v = (v2.x * v1.y - v1.x * v2.y) / denom;

	mulss	xmm7, xmm2
	subss	xmm3, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1

; 1769 :     out_u = 1.0f - out_v - out_w;

	movaps	xmm1, xmm12
	mulss	xmm5, xmm4
	subss	xmm0, xmm7
	subss	xmm7, xmm5
	divss	xmm0, xmm3
	divss	xmm7, xmm3
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm13, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1769 :     out_u = 1.0f - out_v - out_w;

	movaps	xmm0, xmm1
	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN966@ColorPicke
	movaps	xmm15, xmm13
	jmp	SHORT $LN1187@ColorPicke
$LN966@ColorPicke:
	movaps	xmm15, xmm12
	minss	xmm15, xmm1
$LN1187@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5516 :                 S = ImClamp(uu / V, 0.0001f, 1.0f);

	divss	xmm0, xmm15
	movss	DWORD PTR V$1$[rsp], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm13, xmm0
	ja	SHORT $LN973@ColorPicke
	movaps	xmm13, xmm12
	minss	xmm13, xmm0
	movss	DWORD PTR S$1$[rsp], xmm13
$LN973@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5517 :                 value_changed = value_changed_sv = true;

	mov	r12b, 1
	mov	BYTE PTR value_changed_sv$1$[rsp], 1
	mov	BYTE PTR value_changed$1$[rsp], r12b
	jmp	SHORT $LN1188@ColorPicke
$LN892@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1758 :     return ((b1 == b2) && (b2 == b3));

	mov	BYTE PTR value_changed_h$1$[rsp], r12b
$LN1188@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5520 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

	movss	xmm14, DWORD PTR sv_picker_size$1$[rbp-256]
	movss	xmm9, DWORD PTR __real@40c00000
$LN23@ColorPicke:
	test	bl, 8
	jne	SHORT $LN1052@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11238:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	mov	rdi, QWORD PTR [rax+16408]
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN1052@ColorPicke
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN1052@ColorPicke

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, rdi
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN1052@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5548 :     if (alpha_bar)

	movss	xmm7, DWORD PTR picker_pos$[rsp+4]
	movss	xmm8, DWORD PTR square_sz$1$[rsp]
$LN1042@ColorPicke:
	cmp	DWORD PTR tv5884[rbp-256], 65536	; 00010000H
	jne	$LN31@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5551 :         InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));

	lea	rdx, QWORD PTR $T18[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10249:     window->DC.CursorPos = pos;

	movss	xmm0, DWORD PTR $T28[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T18[rbp-256], xmm8
	movss	DWORD PTR $T18[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5551 :         InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));

	lea	rcx, OFFSET FLAT:??_C@_05IAEKHIAN@alpha@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10249:     window->DC.CursorPos = pos;

	movss	DWORD PTR [rax+312], xmm0
	movss	DWORD PTR [rax+316], xmm7

; 10250:     //window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
; 10251:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5551 :         InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));

	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::InvisibleButton
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5501 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5502 :     if (g.ActiveId)

	mov	ecx, DWORD PTR [rax+16504]
	test	ecx, ecx
	je	$LN31@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5552 :         if (IsItemActive())

	cmp	ecx, DWORD PTR [rax+18616]
	jne	$LN31@ColorPicke

; 5554 :             col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	movss	xmm1, DWORD PTR [r15+3596]
	movaps	xmm0, xmm14
	subss	xmm0, xmm12
	subss	xmm1, xmm7
	divss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm1
	jbe	$LN836@ColorPicke
	xorps	xmm2, xmm2
	jmp	$LN837@ColorPicke
$LN18@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5523 :     else if (flags & ImGuiColorEditFlags_PickerHueBar)

	bt	ebx, 25
	jae	$LN1052@ColorPicke

; 5526 :         InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));

	lea	rdx, QWORD PTR $T20[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T20[rbp-256], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5526 :         InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));

	lea	rcx, OFFSET FLAT:??_C@_02CPGMCOJE@sv@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T20[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5526 :         InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));

	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::InvisibleButton
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5501 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5502 :     if (g.ActiveId)

	movaps	xmm6, xmm14
	subss	xmm6, xmm12
	mov	eax, DWORD PTR [r8+16504]
	test	eax, eax
	je	$LN1053@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5527 :         if (IsItemActive())

	cmp	eax, DWORD PTR [r8+18616]
	jne	$LN1053@ColorPicke

; 5528 :         {
; 5529 :             S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));

	movss	xmm0, DWORD PTR [r15+3592]
	subss	xmm0, DWORD PTR picker_pos$3$[rbp-256]
	divss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm0
	jbe	SHORT $LN978@ColorPicke
	xorps	xmm13, xmm13
	jmp	SHORT $LN1189@ColorPicke
$LN978@ColorPicke:
	movaps	xmm13, xmm12
	minss	xmm13, xmm0
$LN1189@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5530 :             V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	movss	xmm0, DWORD PTR [r15+3596]
	movss	xmm7, DWORD PTR picker_pos$[rsp+4]
	subss	xmm0, xmm7
	movss	DWORD PTR S$1$[rsp], xmm13
	divss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm0
	jbe	SHORT $LN960@ColorPicke
	xorps	xmm1, xmm1
	jmp	SHORT $LN961@ColorPicke
$LN960@ColorPicke:
	movaps	xmm1, xmm12
	minss	xmm1, xmm0
$LN961@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	mov	eax, DWORD PTR [r8+23832]

; 5530 :             V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	movaps	xmm15, xmm12
	subss	xmm15, xmm1
	movss	DWORD PTR V$1$[rsp], xmm15

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	cmp	DWORD PTR [r8+23836], eax
	jne	SHORT $LN982@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	lea	rcx, QWORD PTR $T14[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm1, DWORD PTR [r14+4]
	movss	DWORD PTR $T14[rbp-256], xmm0
	movss	xmm0, DWORD PTR [rsi]
	movss	DWORD PTR $T14[rbp-248], xmm0
	movss	DWORD PTR $T14[rbp-252], xmm1
	mov	DWORD PTR $T14[rbp-244], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	cmp	DWORD PTR [r8+23848], eax
	jne	SHORT $LN982@ColorPicke

; 5116 :         return;
; 5117 :     *H = g.ColorEditSavedHue;

	movss	xmm10, DWORD PTR [r8+23840]
	movss	DWORD PTR H$1$[rsp], xmm10
$LN982@ColorPicke:

; 5531 :             ColorEditRestoreH(col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.
; 5532 :             value_changed = value_changed_sv = true;

	mov	r12b, 1
	mov	BYTE PTR value_changed$1$[rsp], r12b
	jmp	SHORT $LN1025@ColorPicke
$LN1053@ColorPicke:

; 5533 :         }
; 5534 :         if (!(flags & ImGuiColorEditFlags_NoOptions))

	movss	xmm7, DWORD PTR picker_pos$[rsp+4]
$LN1025@ColorPicke:
	mov	BYTE PTR value_changed_sv$1$[rsp], r12b
	movzx	esi, r12b
	test	bl, 8
	jne	SHORT $LN1041@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11239:     ImGuiWindow* window = g.CurrentWindow;

	mov	rdi, QWORD PTR [r8+16408]

; 11240:     int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
; 11241:     if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	mov	ecx, 1
	call	?IsMouseReleased@ImGui@@YA_NH@Z		; ImGui::IsMouseReleased
	test	al, al
	je	SHORT $LN1041@ColorPicke
	mov	ecx, 32					; 00000020H
	call	?IsItemHovered@ImGui@@YA_NH@Z		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN1041@ColorPicke

; 11242:     {
; 11243:         ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	rcx, rdi
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID

; 11244:         IM_ASSERT(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
; 11245:         OpenPopupEx(id, popup_flags);

	mov	edx, 1
	mov	ecx, eax
	call	?OpenPopupEx@ImGui@@YAXIH@Z		; ImGui::OpenPopupEx
$LN1041@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5539 :         InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));

	lea	rdx, QWORD PTR $T19[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10249:     window->DC.CursorPos = pos;

	movss	xmm0, DWORD PTR $T27[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm8, DWORD PTR square_sz$1$[rsp]
	movss	DWORD PTR $T19[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T19[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5539 :         InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));

	lea	rcx, OFFSET FLAT:??_C@_03GKJJMKFG@hue@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10249:     window->DC.CursorPos = pos;

	movss	DWORD PTR [rax+312], xmm0
	movss	DWORD PTR [rax+316], xmm7

; 10250:     //window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
; 10251:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5539 :         InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));

	call	?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::InvisibleButton
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5501 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5502 :     if (g.ActiveId)

	mov	ecx, DWORD PTR [rax+16504]
	test	ecx, ecx
	je	$LN1042@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5540 :         if (IsItemActive())

	mov	BYTE PTR value_changed_sv$1$[rsp], r12b
	cmp	ecx, DWORD PTR [rax+18616]
	jne	$LN1042@ColorPicke

; 5541 :         {
; 5542 :             H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	movss	xmm0, DWORD PTR [r15+3596]
	subss	xmm0, xmm7
	divss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm0
	jbe	SHORT $LN949@ColorPicke
	xorps	xmm10, xmm10
	jmp	SHORT $LN1190@ColorPicke
$LN949@ColorPicke:
	movaps	xmm10, xmm12
	minss	xmm10, xmm0
$LN1190@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5543 :             value_changed = value_changed_h = true;

	mov	r12b, 1
	movss	DWORD PTR H$1$[rsp], xmm10
	mov	BYTE PTR value_changed$1$[rsp], r12b
	mov	BYTE PTR value_changed_h$1$[rsp], 1
	mov	BYTE PTR value_changed_sv$1$[rsp], sil
	jmp	$LN1042@ColorPicke
$LN836@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movaps	xmm2, xmm12
	minss	xmm2, xmm1
$LN837@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5554 :             col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));

	movaps	xmm0, xmm12

; 5555 :             value_changed = true;

	mov	r12b, 1
	subss	xmm0, xmm2
	mov	BYTE PTR value_changed$1$[rsp], r12b
	movss	DWORD PTR [r14+12], xmm0
$LN31@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7722 :     ImGuiContext& g = *GImGui;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5560 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	mov	edi, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rdx+18888]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdx+18888], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7725 :     g.CurrentItemFlags = g.ItemFlagsStack.back();

	mov	rax, QWORD PTR [rdx+18896]
	mov	ecx, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR [rdx+18584], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5560 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	and	edi, 256				; 00000100H
	jne	SHORT $LN32@ColorPicke

; 5561 :     {
; 5562 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r15+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 5563 :         BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
$LN32@ColorPicke:

; 5564 :     }
; 5565 : 
; 5566 :     if (!(flags & ImGuiColorEditFlags_NoLabel))

	mov	esi, ebx
	and	esi, 128				; 00000080H
	jne	SHORT $LN34@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	r9, QWORD PTR label$GSCopy$1$[rbp-256]
	mov	rdx, r9

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r9, -1
	jae	SHORT $LN34@ColorPicke
	npad	5
$LL340@ColorPicke:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN341@ColorPicke
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN1034@ColorPicke
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN341@ColorPicke
$LN1034@ColorPicke:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL340@ColorPicke
$LN341@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5569 :         if (label != label_display_end)

	cmp	r9, rdx
	je	SHORT $LN34@ColorPicke

; 5570 :         {
; 5571 :             if ((flags & ImGuiColorEditFlags_NoSidePreview))

	test	edi, edi
	je	SHORT $LN35@ColorPicke

; 5572 :                 SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [r15+14636]
	movaps	xmm0, xmm11
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
$LN35@ColorPicke:

; 5573 :             TextEx(label, label_display_end);

	xor	r8d, r8d
	mov	rcx, r9
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN34@ColorPicke:

; 5574 :         }
; 5575 :     }
; 5576 : 
; 5577 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	movss	xmm8, DWORD PTR __real@40400000
	test	edi, edi
	jne	$LN1055@ColorPicke

; 5578 :     {
; 5579 :         PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);

	lea	ecx, QWORD PTR [rdi+16]
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag

; 5580 :         ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	cmp	DWORD PTR tv5885[rbp-256], edi
	je	SHORT $LN76@ColorPicke
	movaps	xmm2, xmm12
	jmp	SHORT $LN77@ColorPicke
$LN76@ColorPicke:
	movss	xmm2, DWORD PTR [r14+12]
$LN77@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [r14]
	movss	xmm1, DWORD PTR [r14+4]
	movss	DWORD PTR col_v4$37[rbp-256], xmm0
	movss	xmm0, DWORD PTR [r14+8]
	movss	DWORD PTR col_v4$37[rbp-248], xmm0
	movss	DWORD PTR col_v4$37[rbp-252], xmm1
	movss	DWORD PTR col_v4$37[rbp-244], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5581 :         if ((flags & ImGuiColorEditFlags_NoLabel))

	test	esi, esi
	je	SHORT $LN37@ColorPicke

; 5582 :             Text("Current");

	lea	rcx, OFFSET FLAT:??_C@_07EDIFFIJI@Current@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
$LN37@ColorPicke:

; 5585 :         ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));

	movss	xmm14, DWORD PTR square_sz$1$[rsp]
	lea	r9, QWORD PTR $T17[rbp-256]
	movaps	xmm7, xmm14
	lea	rdx, QWORD PTR col_v4$37[rbp-256]
	movaps	xmm6, xmm14
	addss	xmm7, xmm14
	mulss	xmm6, xmm8
	lea	rcx, OFFSET FLAT:??_C@_09CDENILGE@?$CD?$CDcurrent@
	mov	edi, ebx
	and	edi, 403570752				; 180e0040H
	mov	r8d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T17[rbp-252], xmm7
	movss	DWORD PTR $T17[rbp-256], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5585 :         ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));

	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton

; 5586 :         if (ref_col != NULL)

	mov	rsi, QWORD PTR ref_col$GSCopy$1$[rbp-256]
	test	rsi, rsi
	je	SHORT $LN39@ColorPicke

; 5587 :         {
; 5588 :             Text("Original");

	lea	rcx, OFFSET FLAT:??_C@_08DCPBJHAO@Original@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 5589 :             ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);

	cmp	DWORD PTR tv5885[rbp-256], 0
	je	SHORT $LN78@ColorPicke
	movaps	xmm2, xmm12
	jmp	SHORT $LN79@ColorPicke
$LN78@ColorPicke:
	movss	xmm2, DWORD PTR [rsi+12]
$LN79@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5590 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

	lea	r9, QWORD PTR $T16[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm1, DWORD PTR [rsi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5590 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

	lea	rdx, QWORD PTR ref_col_v4$36[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR ref_col_v4$36[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5590 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

	lea	rcx, OFFSET FLAT:??_C@_0L@IGJKOBOK@?$CD?$CDoriginal@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5590 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

	mov	r8d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR ref_col_v4$36[rbp-248], xmm0
	movss	DWORD PTR ref_col_v4$36[rbp-252], xmm1
	movss	DWORD PTR ref_col_v4$36[rbp-244], xmm2

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T16[rbp-256], xmm6
	movss	DWORD PTR $T16[rbp-252], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5590 :             if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))

	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton
	test	al, al
	je	SHORT $LN39@ColorPicke

; 5591 :             {
; 5592 :                 memcpy(col, ref_col, components * sizeof(float));

	mov	r8, QWORD PTR tv5797[rbp-256]
	mov	rdx, rsi
	mov	rcx, r14
	call	memcpy

; 5593 :                 value_changed = true;

	mov	r12b, 1
	mov	BYTE PTR value_changed$1$[rsp], r12b
$LN39@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7722 :     ImGuiContext& g = *GImGui;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rdx+18888]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdx+18888], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7725 :     g.CurrentItemFlags = g.ItemFlagsStack.back();

	mov	rax, QWORD PTR [rdx+18896]
	mov	ecx, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR [rdx+18584], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5597 :         EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	jmp	SHORT $LN36@ColorPicke
$LN1055@ColorPicke:

; 5574 :         }
; 5575 :     }
; 5576 : 
; 5577 :     if (!(flags & ImGuiColorEditFlags_NoSidePreview))

	movss	xmm14, DWORD PTR square_sz$1$[rsp]
$LN36@ColorPicke:

; 5598 :     }
; 5599 : 
; 5600 :     // Convert back color to RGB
; 5601 :     if (value_changed_h || value_changed_sv)

	cmp	BYTE PTR value_changed_h$1$[rsp], 0
	jne	SHORT $LN41@ColorPicke
	cmp	BYTE PTR value_changed_sv$1$[rsp], 0
	je	$LN44@ColorPicke
$LN41@ColorPicke:

; 5602 :     {
; 5603 :         if (flags & ImGuiColorEditFlags_InputRGB)

	cmp	DWORD PTR tv5873[rsp], 0
	je	SHORT $LN42@ColorPicke

; 5604 :         {
; 5605 :             ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);

	lea	rdi, QWORD PTR [r14+8]
	mov	r9, r14
	lea	rsi, QWORD PTR [r14+4]
	mov	QWORD PTR [rsp+40], rdi
	movaps	xmm2, xmm15
	mov	QWORD PTR [rsp+32], rsi
	movaps	xmm1, xmm13
	movaps	xmm0, xmm10
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 5606 :             g.ColorEditSavedHue = H;
; 5607 :             g.ColorEditSavedSat = S;
; 5608 :             g.ColorEditSavedID = g.ColorEditCurrentID;

	mov	eax, DWORD PTR [r15+23832]

; 5609 :             g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));

	lea	rcx, QWORD PTR $T35[rbp-256]
	mov	DWORD PTR [r15+23836], eax
	movss	DWORD PTR [r15+23840], xmm10
	movss	DWORD PTR [r15+23844], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [r14]
	movss	xmm1, DWORD PTR [rsi]
	movss	DWORD PTR $T35[rbp-256], xmm0
	movss	xmm0, DWORD PTR [rdi]
	movss	DWORD PTR $T35[rbp-248], xmm0
	movss	DWORD PTR $T35[rbp-252], xmm1
	mov	DWORD PTR $T35[rbp-244], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5609 :             g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	DWORD PTR [r15+23848], eax

; 5610 :         }

	jmp	SHORT $LN44@ColorPicke
$LN42@ColorPicke:

; 5611 :         else if (flags & ImGuiColorEditFlags_InputHSV)

	bt	ebx, 28
	jae	SHORT $LN44@ColorPicke

; 5612 :         {
; 5613 :             col[0] = H;

	movss	DWORD PTR [r14], xmm10

; 5614 :             col[1] = S;

	movss	DWORD PTR [r14+4], xmm13

; 5615 :             col[2] = V;

	movss	DWORD PTR [r14+8], xmm15
$LN44@ColorPicke:

; 5616 :         }
; 5617 :     }
; 5618 : 
; 5619 :     // R,G,B and H,S,V slider color editor
; 5620 :     bool value_changed_fix_hue_wrap = false;

	xor	r14b, r14b

; 5621 :     if ((flags & ImGuiColorEditFlags_NoInputs) == 0)

	test	bl, 32					; 00000020H
	jne	$LN1046@ColorPicke

; 5622 :     {
; 5623 :         PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);

	cmp	DWORD PTR tv5884[rbp-256], 65536	; 00010000H
	jne	SHORT $LN80@ColorPicke
	movss	xmm0, DWORD PTR $T28[rbp-256]
	jmp	SHORT $LN81@ColorPicke
$LN80@ColorPicke:
	movss	xmm0, DWORD PTR $T27[rbp-256]
$LN81@ColorPicke:
	addss	xmm0, xmm14
	subss	xmm0, DWORD PTR picker_pos$3$[rbp-256]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 5624 :         ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
; 5625 :         ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;

	mov	esi, ebx

; 5626 :         if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)

	mov	edi, ebx
	and	esi, 428736538				; 198e001aH
	bt	ebx, 20
	jb	SHORT $LN1026@ColorPicke
	and	edi, 7340032				; 00700000H
	jne	SHORT $LN48@ColorPicke
	jmp	SHORT $LN47@ColorPicke
$LN1026@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	and	edi, 7340032				; 00700000H
$LN47@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5627 :             if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))

	mov	rdx, QWORD PTR col$GSCopy$1$[rbp-256]
	lea	rcx, OFFSET FLAT:??_C@_05JCABMAIH@?$CD?$CDrgb@
	mov	r8d, esi
	or	r8d, 1048580				; 00100004H
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	test	al, al
	je	SHORT $LN48@ColorPicke

; 5628 :             {
; 5629 :                 // FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
; 5630 :                 // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
; 5631 :                 value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);

	cmp	DWORD PTR [r15+16504], 0
	je	SHORT $LN83@ColorPicke
	cmp	BYTE PTR [r15+16517], r14b
	jne	SHORT $LN83@ColorPicke
	mov	r14b, 1
$LN83@ColorPicke:

; 5632 :                 value_changed = true;

	mov	r12b, 1
	mov	BYTE PTR value_changed$1$[rsp], r12b
$LN48@ColorPicke:

; 5633 :             }
; 5634 :         if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)

	bt	ebx, 21
	jb	SHORT $LN50@ColorPicke
	test	edi, edi
	jne	SHORT $LN49@ColorPicke
$LN50@ColorPicke:

; 5635 :             value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);

	mov	rdx, QWORD PTR col$GSCopy$1$[rbp-256]
	lea	rcx, OFFSET FLAT:??_C@_05JICEKLIF@?$CD?$CDhsv@
	mov	r8d, esi
	or	r8d, 2097156				; 00200004H
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	or	r12b, al
	mov	BYTE PTR value_changed$1$[rsp], r12b
$LN49@ColorPicke:

; 5636 :         if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags_DisplayMask_) == 0)

	bt	ebx, 22
	jb	SHORT $LN52@ColorPicke
	test	edi, edi
	jne	SHORT $LN51@ColorPicke
$LN52@ColorPicke:

; 5637 :             value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);

	mov	rdx, QWORD PTR col$GSCopy$1$[rbp-256]
	lea	rcx, OFFSET FLAT:??_C@_05BOAMFJMJ@?$CD?$CDhex@
	or	esi, 4194308				; 00400004H
	mov	r8d, esi
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	or	r12b, al
	mov	BYTE PTR value_changed$1$[rsp], r12b
$LN51@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5642 :     if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))

	mov	rdx, QWORD PTR tv5947[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5642 :     if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))

	mov	rax, QWORD PTR col$GSCopy$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5642 :     if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))

	mov	r8d, DWORD PTR tv5873[rsp]
	mov	rcx, QWORD PTR tv5948[rbp-256]
	test	r14b, r14b
	je	$LN1048@ColorPicke
	test	r8d, r8d
	je	$LN1048@ColorPicke

; 5645 :         ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);

	movss	xmm5, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2365 :     float K = 0.f;

	movaps	xmm6, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5645 :         ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);

	movss	xmm3, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2366 :     if (g < b)

	comiss	xmm5, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5645 :         ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);

	movss	xmm4, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2366 :     if (g < b)

	movss	xmm7, DWORD PTR __real@bf800000
	jbe	SHORT $LN918@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2369 :         K = -1.f;

	movaps	xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm3, xmm5
	movaps	xmm5, xmm0
$LN918@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2371 :     if (r < g)

	comiss	xmm3, xmm4
	jbe	SHORT $LN919@ColorPicke

; 2374 :         K = -2.f / 6.f - K;

	movss	xmm1, DWORD PTR __real@beaaaaab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	subss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm4, xmm3
	movaps	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	movaps	xmm6, xmm1
$LN919@ColorPicke:

; 2377 :     const float chroma = r - (g < b ? g : b);

	movaps	xmm0, xmm3
	movaps	xmm2, xmm4
	minss	xmm0, xmm5

; 2379 :     out_s = chroma / (r + 1e-20f);

	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR __real@1e3ce508
	subss	xmm3, xmm5
	movss	xmm5, DWORD PTR __real@1e3ce508
	subss	xmm2, xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, xmm9
	divss	xmm0, xmm1
	addss	xmm2, xmm5
	divss	xmm3, xmm2
	addss	xmm3, xmm6
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	xmm6, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	andps	xmm3, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5646 :         if (new_H <= 0 && H > 0)

	comiss	xmm11, xmm3
	jb	$LN57@ColorPicke
	comiss	xmm10, xmm11
	jbe	$LN57@ColorPicke

; 5647 :         {
; 5648 :             if (new_V <= 0 && V != new_V)

	comiss	xmm11, xmm4
	jb	SHORT $LN55@ColorPicke
	ucomiss	xmm15, xmm4
	jp	SHORT $LN1039@ColorPicke
	je	SHORT $LN55@ColorPicke
$LN1039@ColorPicke:

; 5649 :                 ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);

	movaps	xmm2, xmm15
	movaps	xmm1, xmm13
	mulss	xmm2, DWORD PTR __real@3f000000
$LN1195@ColorPicke:

; 5652 :         }
; 5653 :     }
; 5654 : 
; 5655 :     if (value_changed)

	mov	QWORD PTR [rsp+40], rcx
	mov	r9, rax
	movaps	xmm0, xmm10
	mov	QWORD PTR [rsp+32], rdx
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	mov	rax, QWORD PTR col$GSCopy$1$[rbp-256]
	mov	rcx, QWORD PTR tv5948[rbp-256]
	mov	rdx, QWORD PTR tv5947[rsp]
	mov	r8d, DWORD PTR tv5873[rsp]
	jmp	SHORT $LN1192@ColorPicke
$LN55@ColorPicke:

; 5650 :             else if (new_S <= 0)

	comiss	xmm11, xmm0
	jb	SHORT $LN57@ColorPicke

; 5651 :                 ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);

	movaps	xmm1, xmm13
	movaps	xmm2, xmm4
	mulss	xmm1, DWORD PTR __real@3f000000
	jmp	SHORT $LN1195@ColorPicke
$LN1046@ColorPicke:

; 5621 :     if ((flags & ImGuiColorEditFlags_NoInputs) == 0)

	mov	rax, QWORD PTR col$GSCopy$1$[rbp-256]
	mov	rcx, QWORD PTR tv5948[rbp-256]
	mov	rdx, QWORD PTR tv5947[rsp]
	mov	r8d, DWORD PTR tv5873[rsp]
$LN1048@ColorPicke:

; 5652 :         }
; 5653 :     }
; 5654 : 
; 5655 :     if (value_changed)

	movss	xmm7, DWORD PTR __real@bf800000
	movss	xmm6, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
$LN1192@ColorPicke:
	movss	xmm5, DWORD PTR __real@1e3ce508
$LN57@ColorPicke:
	test	r12b, r12b
	je	$LN1044@ColorPicke

; 5656 :     {
; 5657 :         if (flags & ImGuiColorEditFlags_InputRGB)

	test	r8d, r8d
	je	$LN59@ColorPicke

; 5660 :             G = col[1];

	movss	xmm14, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2365 :     float K = 0.f;

	movaps	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5661 :             B = col[2];

	movss	xmm15, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2365 :     float K = 0.f;

	movaps	xmm10, xmm14

; 2366 :     if (g < b)

	comiss	xmm15, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5659 :             R = col[0];

	movss	xmm9, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2365 :     float K = 0.f;

	movaps	xmm2, xmm15

; 2366 :     if (g < b)

	jbe	SHORT $LN930@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm10, xmm15
	movaps	xmm2, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2369 :         K = -1.f;

	movaps	xmm1, xmm7
$LN930@ColorPicke:

; 2371 :     if (r < g)

	comiss	xmm10, xmm9
	movaps	xmm7, xmm9
	movss	DWORD PTR V$1$[rsp], xmm7
	jbe	SHORT $LN931@ColorPicke

; 2374 :         K = -2.f / 6.f - K;

	movss	xmm0, DWORD PTR __real@beaaaaab
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movaps	xmm7, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movss	DWORD PTR V$1$[rsp], xmm7
	movaps	xmm10, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2374 :         K = -2.f / 6.f - K;

	movaps	xmm1, xmm0
$LN931@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5124 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2377 :     const float chroma = r - (g < b ? g : b);

	movaps	xmm0, xmm10
	minss	xmm0, xmm2
	movaps	xmm13, xmm7

; 2378 :     out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));

	subss	xmm10, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	mov	eax, DWORD PTR [r8+23832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2377 :     const float chroma = r - (g < b ? g : b);

	subss	xmm13, xmm0

; 2378 :     out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));

	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR __real@40c00000
	addss	xmm0, xmm5
	divss	xmm10, xmm0

; 2379 :     out_s = chroma / (r + 1e-20f);

	movaps	xmm0, xmm7
	addss	xmm0, xmm5
	addss	xmm10, xmm1
	divss	xmm13, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm10, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2379 :     out_s = chroma / (r + 1e-20f);

	movss	DWORD PTR S$1$[rsp], xmm13
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	movss	DWORD PTR H$1$[rsp], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	cmp	DWORD PTR [r8+23836], eax
	jne	$LN61@ColorPicke
	lea	rcx, QWORD PTR $T33[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR $T33[rbp-256], xmm9
	movss	DWORD PTR $T33[rbp-252], xmm14
	movss	DWORD PTR $T33[rbp-248], xmm15
	mov	DWORD PTR $T33[rbp-244], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	cmp	DWORD PTR [r8+23848], eax
	jne	$LN61@ColorPicke

; 5127 :         return;
; 5128 : 
; 5129 :     // When S == 0, H is undefined.
; 5130 :     // When H == 1 it wraps around to 0.
; 5131 :     if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))

	ucomiss	xmm13, xmm11
	jp	SHORT $LN1038@ColorPicke
	je	SHORT $LN1027@ColorPicke
$LN1038@ColorPicke:
	ucomiss	xmm10, xmm11
	jp	SHORT $LN911@ColorPicke
	jne	SHORT $LN911@ColorPicke
	movss	xmm0, DWORD PTR [r8+23840]
	ucomiss	xmm0, xmm12
	jp	SHORT $LN911@ColorPicke
	jne	SHORT $LN911@ColorPicke
$LN1027@ColorPicke:

; 5132 :         *H = g.ColorEditSavedHue;

	movss	xmm10, DWORD PTR [r8+23840]
	movss	DWORD PTR H$1$[rsp], xmm10
$LN911@ColorPicke:

; 5133 : 
; 5134 :     // When V == 0, S is undefined.
; 5135 :     if (*V == 0.0f)

	ucomiss	xmm7, xmm11
	jp	$LN61@ColorPicke
	jne	$LN61@ColorPicke

; 5136 :         *S = g.ColorEditSavedSat;

	movss	xmm13, DWORD PTR [r8+23844]
	movss	DWORD PTR S$1$[rsp], xmm13

; 5662 :             ColorConvertRGBtoHSV(R, G, B, H, S, V);
; 5663 :             ColorEditRestoreHS(col, &H, &S, &V);   // Fix local Hue as display below will use it immediately.
; 5664 :         }

	jmp	SHORT $LN61@ColorPicke
$LN59@ColorPicke:

; 5665 :         else if (flags & ImGuiColorEditFlags_InputHSV)

	bt	ebx, 28
	jae	SHORT $LN1044@ColorPicke

; 5666 :         {
; 5667 :             H = col[0];

	movss	xmm10, DWORD PTR [rax]

; 5668 :             S = col[1];
; 5669 :             V = col[2];
; 5670 :             ColorConvertHSVtoRGB(H, S, V, R, G, B);

	lea	r9, QWORD PTR R$[rsp]
	movss	xmm13, DWORD PTR [rdx]
	lea	rax, QWORD PTR B$[rsp]
	movss	xmm7, DWORD PTR [rcx]
	movaps	xmm1, xmm13
	mov	QWORD PTR [rsp+40], rax
	movaps	xmm2, xmm7
	lea	rax, QWORD PTR G$[rbp-256]
	movss	DWORD PTR H$1$[rsp], xmm10
	movaps	xmm0, xmm10
	mov	QWORD PTR [rsp+32], rax
	movss	DWORD PTR S$1$[rsp], xmm13
	movss	DWORD PTR V$1$[rsp], xmm7
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB
	movss	xmm9, DWORD PTR R$[rsp]
	movss	xmm14, DWORD PTR G$[rbp-256]
	movss	xmm15, DWORD PTR B$[rsp]
	jmp	SHORT $LN61@ColorPicke
$LN1044@ColorPicke:

; 5674 :     const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);

	movss	xmm15, DWORD PTR B$1$[rbp-256]
	movss	xmm14, DWORD PTR G$1$[rbp-256]
	movss	xmm9, DWORD PTR R$1$[rbp-256]
	movss	xmm7, DWORD PTR V$1$[rsp]
$LN61@ColorPicke:
	movss	xmm6, DWORD PTR [r15+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm6
	jbe	SHORT $LN270@ColorPicke
	movaps	xmm0, xmm11
	jmp	SHORT $LN271@ColorPicke
$LN270@ColorPicke:
	movaps	xmm0, xmm12
	minss	xmm0, xmm6
$LN271@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5674 :     const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);

	mulss	xmm0, DWORD PTR __real@437f0000

; 5680 :     ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

	lea	r9, QWORD PTR hue_color_f$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR hue_color_f$[rbp-256], 1065353216 ; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5680 :     ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

	movaps	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR hue_color_f$[rbp-244], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5680 :     ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

	movaps	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR hue_color_f$[rbp-252], 1065353216 ; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5674 :     const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);

	addss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	mov	DWORD PTR hue_color_f$[rbp-248], 1065353216 ; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5674 :     const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);

	cvttss2si r12d, xmm0

; 5680 :     ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);

	movaps	xmm0, xmm10
	shl	r12d, 24
	mov	eax, r12d
	mov	DWORD PTR col_black$1$[rbp-256], r12d
	or	eax, 16777215				; 00ffffffH
	mov	edi, r12d
	mov	DWORD PTR col_white$1$[rsp], eax
	or	edi, 255				; 000000ffH
	mov	eax, r12d
	mov	DWORD PTR $T21[rbp-256], edi
	or	eax, 8421504				; 00808080H
	mov	DWORD PTR col_hues$[rbp-256], edi
	mov	DWORD PTR col_midgrey$1$[rsp], eax
	mov	esi, r12d
	mov	eax, r12d
	mov	DWORD PTR col_hues$[rbp-232], edi
	or	eax, 65280				; 0000ff00H
	or	esi, 65535				; 0000ffffH
	mov	DWORD PTR col_hues$3$[rbp-256], eax
	mov	DWORD PTR col_hues$[rbp-248], eax
	mov	eax, r12d
	or	eax, 16776960				; 00ffff00H
	mov	DWORD PTR col_hues$[rbp-252], esi
	mov	DWORD PTR col_hues$4$[rbp-256], eax
	mov	DWORD PTR col_hues$[rbp-244], eax
	mov	eax, r12d
	or	eax, 16711680				; 00ff0000H
	mov	DWORD PTR col_hues$5$[rbp-256], eax
	mov	DWORD PTR col_hues$[rbp-240], eax
	mov	eax, r12d
	or	eax, 16711935				; 00ff00ffH
	mov	DWORD PTR col_hues$6$[rbp-256], eax
	mov	DWORD PTR col_hues$[rbp-236], eax
	lea	rax, QWORD PTR hue_color_f$[rbp-248]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR hue_color_f$[rbp-252]
	mov	QWORD PTR [rsp+32], rax
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 5681 :     ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);

	lea	rcx, QWORD PTR hue_color_f$[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 5682 :     ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!

	lea	rcx, QWORD PTR $T34[rbp-256]
	mov	DWORD PTR hue_color32$1$[rbp-256], eax
	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR $T34[rbp-256], xmm9
	movss	DWORD PTR $T34[rbp-252], xmm14
	movss	DWORD PTR $T34[rbp-248], xmm15
	movss	DWORD PTR $T34[rbp-244], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5682 :     ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 5686 :     if (flags & ImGuiColorEditFlags_PickerHueWheel)

	cmp	DWORD PTR tv5872[rbp-256], 0
	mov	r14d, 3
	movss	xmm15, DWORD PTR __real@40000000
	mov	DWORD PTR user_col32_striped_of_alpha$1$[rbp-256], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	QWORD PTR sv_cursor_pos$[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5686 :     if (flags & ImGuiColorEditFlags_PickerHueWheel)

	je	$LN62@ColorPicke

; 5689 :         const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).

	movss	xmm1, DWORD PTR wheel_r_outer$1$[rbp-256]
	lea	r12, QWORD PTR col_hues$[rbp-256]
	movss	xmm0, DWORD PTR __real@3f000000

; 5690 :         const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);

	mov	eax, 715827883				; 2aaaaaabH
	movss	xmm10, DWORD PTR wheel_r_inner$1$[rbp-256]
	movaps	xmm14, xmm0
	movss	xmm13, DWORD PTR hue_cursor_rad$1$[rbp-256]
	movaps	xmm15, xmm10
	addss	xmm15, xmm1
	cvttss2si ecx, xmm1
	movaps	xmm11, xmm15
	movss	DWORD PTR tv5905[rbp-256], xmm15
	movss	xmm15, DWORD PTR __real@40c00000
	imul	ecx
	divss	xmm14, xmm1
	mov	r14d, edx
	sar	r14d, 1
	mov	eax, r14d
	shr	eax, 31
	add	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	mov	eax, 4
	cmp	r14d, eax
	cmovle	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5689 :         const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).

	xor	ebx, ebx
	mov	r15d, ebx
	mulss	xmm11, xmm0
	npad	4
$LL4@ColorPicke:

; 5691 :         for (int n = 0; n < 6; n++)
; 5692 :         {
; 5693 :             const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
; 5694 :             const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
; 5695 :             const int vert_start_idx = draw_list->VtxBuffer.Size;

	mov	edi, DWORD PTR [r13+32]

; 5696 :             draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);

	lea	rdx, QWORD PTR wheel_center$[rbp-256]
	movd	xmm9, r15d
	movaps	xmm2, xmm11
	cvtdq2ps xmm9, xmm9
	mov	DWORD PTR [rsp+40], r14d
	mov	rcx, r13
	movaps	xmm6, xmm9
	addss	xmm9, xmm12
	divss	xmm6, xmm15
	divss	xmm9, xmm15
	addss	xmm6, xmm6
	addss	xmm9, xmm9
	mulss	xmm6, DWORD PTR __real@40490fdb
	mulss	xmm9, DWORD PTR __real@40490fdb
	subss	xmm6, xmm14
	addss	xmm9, xmm14
	movaps	xmm3, xmm6
	movss	DWORD PTR [rsp+32], xmm9
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, DWORD PTR col_white$1$[rsp]
	mov	rcx, r13
	mov	r8d, DWORD PTR [r13+120]
	mov	rdx, QWORD PTR [r13+128]
	movss	DWORD PTR [rsp+40], xmm13
	mov	DWORD PTR [rsp+32], ebx
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5701 :             ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	DWORD PTR [r13+120], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5701 :             ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);

	call	cosf
	movaps	xmm8, xmm0
	movaps	xmm0, xmm6
	mulss	xmm8, xmm10
	addss	xmm8, DWORD PTR wheel_center$2$[rbp-256]
	call	sinf
	movaps	xmm7, xmm0

; 5702 :             ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);

	movaps	xmm0, xmm9
	mulss	xmm7, xmm10
	addss	xmm7, DWORD PTR wheel_center$1$[rbp-256]
	call	cosf
	movaps	xmm6, xmm0
	movaps	xmm0, xmm9
	mulss	xmm6, xmm10
	addss	xmm6, DWORD PTR wheel_center$2$[rbp-256]
	call	sinf

; 5703 :             ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1]);

	mov	eax, DWORD PTR $T21[rbp-256]
	movaps	xmm1, xmm6
	movss	xmm9, DWORD PTR wheel_center$1$[rbp-256]
	add	r12, 4
	mov	r8d, DWORD PTR [r13+32]
	mov	edx, edi
	mulss	xmm0, xmm10
	mov	rcx, r13
	mov	ebx, DWORD PTR [r12]
	mov	DWORD PTR [rsp+48], ebx
	addss	xmm0, xmm9
	mov	DWORD PTR [rsp+40], eax
	unpcklps xmm1, xmm0
	movaps	xmm0, xmm8
	unpcklps xmm0, xmm7
	movq	r9, xmm0
	movsd	QWORD PTR [rsp+32], xmm1
	call	?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z ; ImGui::ShadeVertsLinearColorGradientKeepAlpha
	inc	r15d
	mov	DWORD PTR $T21[rbp-256], ebx
	mov	ebx, 0
	cmp	r15d, 6
	jl	$LL4@ColorPicke

; 5704 :         }
; 5705 : 
; 5706 :         // Render Cursor + preview on Hue Wheel
; 5707 :         float cos_hue_angle = ImCos(H * 2.0f * IM_PI);

	movss	xmm10, DWORD PTR H$1$[rsp]
	addss	xmm10, xmm10
	mulss	xmm10, DWORD PTR __real@40490fdb
	movaps	xmm0, xmm10
	call	cosf
	movaps	xmm6, xmm0

; 5708 :         float sin_hue_angle = ImSin(H * 2.0f * IM_PI);

	movaps	xmm0, xmm10
	call	sinf

; 5709 :         ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);

	movaps	xmm1, xmm6
	movss	xmm13, DWORD PTR wheel_center$2$[rbp-256]
	movaps	xmm2, xmm0
	mulss	xmm1, DWORD PTR tv5905[rbp-256]
	movaps	xmm7, xmm0
	mulss	xmm2, DWORD PTR tv5905[rbp-256]
	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm1, xmm13

; 5710 :         float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;

	movss	xmm8, DWORD PTR hue_cursor_rad$1$[rbp-256]
	addss	xmm2, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR hue_cursor_pos$11[rsp], xmm1
	movss	DWORD PTR hue_cursor_pos$11[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5710 :         float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;

	cmp	BYTE PTR value_changed_h$1$[rsp], bl
	je	SHORT $LN88@ColorPicke
	mulss	xmm8, DWORD PTR __real@3f266666
	jmp	SHORT $LN89@ColorPicke
$LN88@ColorPicke:
	mulss	xmm8, DWORD PTR __real@3f0ccccd
$LN89@ColorPicke:

; 5711 :         int hue_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(hue_cursor_rad); // Lock segment count so the +1 one matches others.

	movaps	xmm1, xmm8
	mov	rcx, r13
	call	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount

; 5712 :         draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);

	mov	r15d, DWORD PTR hue_color32$1$[rbp-256]
	lea	rdx, QWORD PTR hue_cursor_pos$11[rsp]
	mov	r9d, r15d
	mov	DWORD PTR [rsp+32], eax
	movaps	xmm2, xmm8
	mov	rcx, r13
	mov	ebx, eax
	call	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 5713 :         draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments);

	mov	r9d, DWORD PTR col_midgrey$1$[rsp]
	lea	rdx, QWORD PTR hue_cursor_pos$11[rsp]
	movaps	xmm2, xmm8
	movss	DWORD PTR [rsp+40], xmm12
	addss	xmm2, xmm12
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, r13
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 5714 :         draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);

	mov	edi, DWORD PTR col_white$1$[rsp]
	lea	rdx, QWORD PTR hue_cursor_pos$11[rsp]
	movss	DWORD PTR [rsp+40], xmm12
	mov	r9d, edi
	movaps	xmm2, xmm8
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, r13
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm2, DWORD PTR wheel_center$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movaps	xmm15, xmm6
	mulss	xmm15, DWORD PTR triangle_pc$2$[rbp-256]
	movaps	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8232 :     return GImGui->DrawListSharedData.TexUvWhitePixel;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5721 :         draw_list->PrimReserve(3, 3);

	mov	r14d, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	mulss	xmm8, DWORD PTR triangle_pa$[rbp-256]
	movaps	xmm10, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5721 :         draw_list->PrimReserve(3, 3);

	mov	r8d, r14d
	mov	edx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	mulss	xmm10, DWORD PTR triangle_pb$2$[rbp-256]
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5721 :         draw_list->PrimReserve(3, 3);

	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movaps	xmm9, xmm7
	movaps	xmm1, xmm7
	mulss	xmm9, DWORD PTR triangle_pa$[rbp-256]
	movaps	xmm14, xmm15
	mulss	xmm1, DWORD PTR triangle_pc$2$[rbp-256]
	xorps	xmm11, xmm11
	mulss	xmm0, xmm11
	addss	xmm10, xmm1
	subss	xmm8, xmm0
	movaps	xmm0, xmm6
	mulss	xmm6, DWORD PTR triangle_pc$1$[rbp-256]
	mulss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	addss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm8, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	addss	xmm9, xmm0
	movaps	xmm0, xmm7
	mulss	xmm7, DWORD PTR triangle_pc$1$[rbp-256]
	mulss	xmm0, DWORD PTR triangle_pb$2$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm6, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	subss	xmm15, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tra$24[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8232 :     return GImGui->DrawListSharedData.TexUvWhitePixel;

	movss	xmm7, DWORD PTR [rax+15708]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm9, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	subss	xmm14, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR trb$15[rbp-252], xmm10
	movss	DWORD PTR trc$10[rsp+4], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8232 :     return GImGui->DrawListSharedData.TexUvWhitePixel;

	movss	xmm6, DWORD PTR [rax+15704]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm15, xmm13

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR tra$24[rbp-252], xmm9
	addss	xmm14, xmm13
	movss	DWORD PTR trc$10[rsp], xmm15
	movss	DWORD PTR trb$15[rbp-256], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5721 :         draw_list->PrimReserve(3, 3);

	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rcx, QWORD PTR [r13+80]
	movzx	eax, WORD PTR [r13+52]
	mov	WORD PTR [rcx], ax

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	rax, QWORD PTR [r13+72]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	add	QWORD PTR [r13+80], 2

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax], xmm8
	movss	DWORD PTR [rax+4], xmm9
	mov	rax, QWORD PTR [r13+72]
	mov	r12d, DWORD PTR col_black$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

	movss	xmm13, DWORD PTR S$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [r13+72]
	mov	DWORD PTR [rax+16], r15d
	add	QWORD PTR [r13+72], 20
	inc	DWORD PTR [r13+52]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rax, QWORD PTR [r13+80]

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	ecx, DWORD PTR [r13+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	r15, QWORD PTR g$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rax], cx

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	rax, QWORD PTR [r13+72]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	add	QWORD PTR [r13+80], 2

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax], xmm14
	movss	DWORD PTR [rax+4], xmm10
	mov	rax, QWORD PTR [r13+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [r13+72]
	mov	DWORD PTR [rax+16], r12d
	add	QWORD PTR [r13+72], 20
	inc	DWORD PTR [r13+52]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	rax, QWORD PTR [r13+80]

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	ecx, DWORD PTR [r13+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	r12d, DWORD PTR col_midgrey$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [rax], cx

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	rax, QWORD PTR [r13+72]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	add	QWORD PTR [r13+80], 2

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movss	DWORD PTR [rax], xmm15
	movss	xmm15, DWORD PTR trc$10[rsp+4]
	movss	DWORD PTR [rax+4], xmm15
	mov	rax, QWORD PTR [r13+72]
	movss	DWORD PTR [rax+8], xmm6
	movss	DWORD PTR [rax+12], xmm7
	mov	rax, QWORD PTR [r13+72]
	mov	DWORD PTR [rax+16], edi
	add	QWORD PTR [r13+72], 20
	inc	DWORD PTR [r13+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r12d, -16777216				; ff000000H
	je	$LN170@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [r13+124]
	mov	r8d, DWORD PTR [r13+120]
	cmp	r8d, ecx
	jne	SHORT $LN176@ColorPicke
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN180@ColorPicke
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN181@ColorPicke
$LN180@ColorPicke:
	mov	eax, 8
$LN181@ColorPicke:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [r13+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN176@ColorPicke:
	movsxd	rdx, DWORD PTR [r13+120]
	mov	rcx, QWORD PTR [r13+128]
	mov	rax, QWORD PTR tra$24[rbp-256]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [r13+120]
	inc	r8d
	mov	DWORD PTR [r13+120], r8d
	mov	ecx, DWORD PTR [r13+124]
	cmp	r8d, ecx
	jne	SHORT $LN185@ColorPicke
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN189@ColorPicke
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN190@ColorPicke
$LN189@ColorPicke:
	mov	eax, 8
$LN190@ColorPicke:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [r13+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN185@ColorPicke:
	movsxd	rdx, DWORD PTR [r13+120]
	mov	rcx, QWORD PTR [r13+128]
	mov	rax, QWORD PTR trb$15[rbp-256]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	r8d, DWORD PTR [r13+120]
	inc	r8d
	mov	DWORD PTR [r13+120], r8d
	mov	ecx, DWORD PTR [r13+124]
	cmp	r8d, ecx
	jne	SHORT $LN194@ColorPicke
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN198@ColorPicke
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN199@ColorPicke
$LN198@ColorPicke:
	mov	eax, 8
$LN199@ColorPicke:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [r13+120]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN194@ColorPicke:
	movsxd	rdx, DWORD PTR [r13+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r9d, r12d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r13+128]
	mov	rax, QWORD PTR trc$10[rsp]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [rsp+40], xmm0

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	QWORD PTR [rcx+rdx*8], rax

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	rcx, r13

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [r13+120]

; 2808 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

	mov	r8d, DWORD PTR [r13+120]
	mov	rdx, QWORD PTR [r13+128]
	mov	DWORD PTR [rsp+32], 1
	call	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
	mov	DWORD PTR [r13+120], 0
$LN170@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5726 :         sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));

	movaps	xmm0, xmm12
	subss	xmm0, DWORD PTR V$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm0
	jbe	SHORT $LN132@ColorPicke
	xorps	xmm1, xmm1
	jmp	SHORT $LN133@ColorPicke
$LN132@ColorPicke:
	movaps	xmm1, xmm12
	minss	xmm1, xmm0
$LN133@ColorPicke:
	comiss	xmm11, xmm13
	jbe	SHORT $LN126@ColorPicke
	xorps	xmm0, xmm0
	jmp	SHORT $LN127@ColorPicke
$LN126@ColorPicke:
	movaps	xmm0, xmm12
	minss	xmm0, xmm13
$LN127@ColorPicke:

; 465  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

	subss	xmm8, DWORD PTR trc$10[rsp]
	subss	xmm9, xmm15
	mulss	xmm8, xmm0
	mulss	xmm9, xmm0
	addss	xmm8, DWORD PTR trc$10[rsp]
	addss	xmm9, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5727 :     }

	movss	xmm15, DWORD PTR __real@40000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 465  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

	subss	xmm14, xmm8
	subss	xmm10, xmm9
	mulss	xmm14, xmm1
	mulss	xmm10, xmm1
	addss	xmm14, xmm8
	addss	xmm10, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5726 :         sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));

	movss	DWORD PTR sv_cursor_pos$[rsp], xmm14
	movss	DWORD PTR sv_cursor_pos$[rsp+4], xmm10

; 5727 :     }

	jmp	$LN1194@ColorPicke
$LN62@ColorPicke:

; 5728 :     else if (flags & ImGuiColorEditFlags_PickerHueBar)

	bt	ebx, 25
	jae	$LN1045@ColorPicke

; 5731 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

	mov	eax, DWORD PTR col_white$1$[rsp]
	lea	rdx, QWORD PTR picker_pos$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm14, DWORD PTR picker_pos$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5731 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR sv_picker_size$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5731 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm9, DWORD PTR mx$1$[rbp-256]
	addss	xmm14, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5731 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], r8d
	mov	DWORD PTR [rsp+32], r8d
	lea	r8, QWORD PTR $T23[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T23[rbp-256], xmm9
	movss	DWORD PTR $T23[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5731 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 5732 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);

	mov	DWORD PTR [rsp+48], r12d
	lea	r8, QWORD PTR $T22[rbp-256]
	mov	DWORD PTR [rsp+40], r12d
	lea	rdx, QWORD PTR picker_pos$[rsp]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 0
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T22[rbp-256], xmm9
	movss	DWORD PTR $T22[rbp-252], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5732 :         draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 5733 :         RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);

	mov	rcx, QWORD PTR picker_pos$3$[rbp-256]
	movaps	xmm0, xmm9
	unpcklps xmm0, xmm14
	movaps	xmm2, xmm11
	movq	rdx, xmm0
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5734 :         sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much

	movsd	xmm2, QWORD PTR picker_pos$3$[rbp-256]
	subss	xmm9, xmm15
	movaps	xmm1, xmm2
	addss	xmm1, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN876@ColorPicke
	movaps	xmm0, xmm11
	jmp	SHORT $LN877@ColorPicke
$LN876@ColorPicke:
	movaps	xmm0, xmm12
	minss	xmm0, xmm13
$LN877@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5734 :         sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much

	movss	xmm3, DWORD PTR __real@3f000000
	mulss	xmm0, xmm6
	addss	xmm0, xmm2
	addss	xmm0, xmm3
	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm2
	jbe	SHORT $LN842@ColorPicke
	movss	DWORD PTR sv_cursor_pos$[rsp], xmm1
	jmp	SHORT $LN841@ColorPicke
$LN842@ColorPicke:
	comiss	xmm2, xmm9
	jbe	SHORT $LN840@ColorPicke
	movss	DWORD PTR sv_cursor_pos$[rsp], xmm9
	jmp	SHORT $LN841@ColorPicke
$LN840@ColorPicke:
	movss	DWORD PTR sv_cursor_pos$[rsp], xmm2
$LN841@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5735 :         sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

	movaps	xmm1, xmm12
	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm1
	jbe	SHORT $LN882@ColorPicke
	movaps	xmm0, xmm11
	jmp	SHORT $LN883@ColorPicke
$LN882@ColorPicke:
	movaps	xmm0, xmm12
	minss	xmm0, xmm1
$LN883@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5735 :         sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

	movss	xmm4, DWORD PTR picker_pos$[rsp+4]
	movaps	xmm1, xmm14
	mulss	xmm0, xmm6
	subss	xmm1, xmm15
	movaps	xmm2, xmm4
	addss	xmm2, xmm15
	addss	xmm0, xmm4
	addss	xmm0, xmm3
	cvttss2si eax, xmm0
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm3
	jbe	SHORT $LN888@ColorPicke
	movss	DWORD PTR sv_cursor_pos$[rsp+4], xmm2
	jmp	SHORT $LN887@ColorPicke
$LN888@ColorPicke:
	comiss	xmm3, xmm1
	jbe	SHORT $LN886@ColorPicke
	movss	DWORD PTR sv_cursor_pos$[rsp+4], xmm1
	jmp	SHORT $LN887@ColorPicke
$LN886@ColorPicke:
	movss	DWORD PTR sv_cursor_pos$[rsp+4], xmm3
$LN887@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR $T32[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	lea	r8, QWORD PTR $T13[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm13, DWORD PTR __real@40c00000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	lea	rdx, QWORD PTR $T26[rbp-256]
	movaps	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-256], xmm0
	movss	xmm0, DWORD PTR $T27[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	mov	r9d, edi
	divss	xmm9, xmm13
	mov	rcx, r13
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T26[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	movaps	xmm0, xmm9
	movaps	xmm7, xmm9
	mulss	xmm0, xmm11
	addss	xmm7, xmm4
	addss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm7
	movss	DWORD PTR $T26[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	mov	ebx, DWORD PTR col_hues$3$[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	movaps	xmm6, xmm9
	mov	DWORD PTR [rsp+48], ebx
	addss	xmm6, xmm9
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T26[rbp-252], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	lea	rdx, QWORD PTR $T26[rbp-256]
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, r13
	addss	xmm6, DWORD PTR picker_pos$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	mov	esi, DWORD PTR col_hues$4$[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	movaps	xmm7, xmm9
	mov	DWORD PTR [rsp+48], esi
	mulss	xmm7, xmm8
	lea	rdx, QWORD PTR $T26[rbp-256]
	mov	DWORD PTR [rsp+40], esi
	mov	r9d, ebx
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T26[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	mov	DWORD PTR [rsp+32], ebx
	addss	xmm7, DWORD PTR picker_pos$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	mov	ebx, DWORD PTR col_hues$5$[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	movaps	xmm8, xmm9
	mov	DWORD PTR [rsp+48], ebx
	mulss	xmm8, DWORD PTR __real@40800000
	lea	rdx, QWORD PTR $T26[rbp-256]
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, esi
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T26[rbp-252], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	mov	DWORD PTR [rsp+32], esi
	addss	xmm8, DWORD PTR picker_pos$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	mov	esi, DWORD PTR col_hues$6$[rbp-256]
	lea	r8, QWORD PTR $T13[rbp-256]
	movss	xmm7, DWORD PTR picker_pos$[rsp+4]
	lea	rdx, QWORD PTR $T26[rbp-256]
	movaps	xmm6, xmm9
	mov	DWORD PTR [rsp+48], esi
	mulss	xmm6, DWORD PTR __real@40a00000
	mov	r9d, ebx
	mov	DWORD PTR [rsp+40], esi
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T26[rbp-252], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	mov	DWORD PTR [rsp+32], ebx
	addss	xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
	mulss	xmm9, xmm13
	addss	xmm9, xmm7
	mov	DWORD PTR [rsp+48], edi
	lea	r8, QWORD PTR $T13[rbp-256]
	mov	DWORD PTR [rsp+40], edi
	lea	rdx, QWORD PTR $T26[rbp-256]
	mov	r9d, esi
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rbp-252], xmm9
	movss	DWORD PTR $T26[rbp-252], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5739 :             draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);

	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 5740 :         float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);
; 5741 :         RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);

	movss	xmm0, DWORD PTR $T32[rbp-256]
	movaps	xmm2, xmm11
	movss	xmm6, DWORD PTR $T27[rbp-256]
	movaps	xmm1, xmm6
	unpcklps xmm0, xmm14
	unpcklps xmm1, xmm7
	movq	rdx, xmm0
	movq	rcx, xmm1
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder

; 5742 :         RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);

	movss	xmm4, DWORD PTR $T31[rbp-256]
	subss	xmm6, xmm12
	movss	xmm0, DWORD PTR [r15+14552]
	movaps	xmm1, xmm4
	movss	xmm9, DWORD PTR sv_picker_size$1$[rbp-256]
	addss	xmm1, xmm12
	movss	xmm3, DWORD PTR square_sz$1$[rsp]
	mov	rcx, r13
	movss	xmm14, DWORD PTR __real@3f000000
	addss	xmm3, xmm15
	mulss	xmm10, xmm9
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm0, xmm6
	unpcklps xmm1, xmm4
	addss	xmm10, xmm7
	movq	r8, xmm1
	addss	xmm10, xmm14
	cvttss2si eax, xmm10
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	unpcklps xmm0, xmm2
	movq	rdx, xmm0
	call	?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z ; RenderArrowsForVerticalBar
	mov	edi, DWORD PTR col_white$1$[rsp]
	mov	r12d, DWORD PTR col_midgrey$1$[rsp]
	jmp	SHORT $LN64@ColorPicke
$LN1045@ColorPicke:

; 5728 :     else if (flags & ImGuiColorEditFlags_PickerHueBar)

	mov	edi, DWORD PTR col_white$1$[rsp]
	mov	r12d, DWORD PTR col_midgrey$1$[rsp]
$LN1194@ColorPicke:

; 5743 :     }
; 5744 : 
; 5745 :     // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
; 5746 :     float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;

	movss	xmm7, DWORD PTR picker_pos$[rsp+4]
	movss	xmm14, DWORD PTR __real@3f000000
	movss	xmm9, DWORD PTR sv_picker_size$1$[rbp-256]
	movss	xmm13, DWORD PTR __real@40c00000
$LN64@ColorPicke:
	cmp	BYTE PTR value_changed_sv$1$[rsp], 0
	je	SHORT $LN90@ColorPicke
	movss	xmm13, DWORD PTR __real@41200000
$LN90@ColorPicke:

; 5747 :     int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(sv_cursor_rad); // Lock segment count so the +1 one matches others.

	movaps	xmm1, xmm13
	mov	rcx, r13
	call	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	mov	esi, DWORD PTR user_col32_striped_of_alpha$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5747 :     int sv_cursor_segments = draw_list->_CalcCircleAutoSegmentCount(sv_cursor_rad); // Lock segment count so the +1 one matches others.

	mov	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)

	test	esi, -16777216				; ff000000H
	je	$LN94@ColorPicke
	comiss	xmm14, xmm13
	ja	$LN94@ColorPicke

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)

	test	eax, eax
	jg	SHORT $LN95@ColorPicke

; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], 48			; 00000030H
	movaps	xmm2, xmm13
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, r13
	call	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

	dec	DWORD PTR [r13+120]

; 1516 :     }

	jmp	SHORT $LN96@ColorPicke
$LN95@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	ebx, 3
	jl	SHORT $LN101@ColorPicke
	mov	eax, 512				; 00000200H
	mov	r14d, ebx
	cmp	ebx, eax
	cmovg	r14d, eax
$LN101@ColorPicke:
	movd	xmm0, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1524 :         PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);

	lea	eax, DWORD PTR [r14-1]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [rsp+40], eax
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, r13
	movaps	xmm3, xmm11
	movaps	xmm2, xmm13
	movaps	xmm1, xmm0
	subss	xmm1, xmm12
	mulss	xmm1, DWORD PTR __real@40c90fdb
	divss	xmm1, xmm0
	movss	DWORD PTR [rsp+32], xmm1
	call	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN96@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [r13+120]
	mov	r9d, esi
	mov	rdx, QWORD PTR [r13+128]
	mov	rcx, r13
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [r13+120], 0
$LN94@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5749 :     draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, sv_cursor_segments);

	movaps	xmm2, xmm13
	movss	DWORD PTR [rsp+40], xmm12
	addss	xmm2, xmm12
	mov	DWORD PTR [rsp+32], ebx
	mov	r9d, r12d
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	rcx, r13
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 5750 :     draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, sv_cursor_segments);

	movss	DWORD PTR [rsp+40], xmm12
	lea	rdx, QWORD PTR sv_cursor_pos$[rsp]
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], ebx
	movaps	xmm2, xmm13
	mov	rcx, r13
	call	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 5751 : 
; 5752 :     // Render alpha bar
; 5753 :     if (alpha_bar)

	cmp	DWORD PTR tv5884[rbp-256], 65536	; 00010000H
	mov	r12, QWORD PTR [rsp+624]
	mov	r14, QWORD PTR col$GSCopy$1$[rbp-256]
	jne	$LN65@ColorPicke

; 5754 :     {
; 5755 :         float alpha = ImSaturate(col[3]);

	movss	xmm0, DWORD PTR [r14+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm11, xmm0
	jbe	SHORT $LN220@ColorPicke
	movaps	xmm8, xmm11
	jmp	SHORT $LN221@ColorPicke
$LN220@ColorPicke:
	movaps	xmm8, xmm12
	minss	xmm8, xmm0
$LN221@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5756 :         ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);

	movss	xmm4, DWORD PTR $T28[rbp-256]
	movaps	xmm2, xmm7
	movss	xmm13, DWORD PTR square_sz$1$[rsp]
	addss	xmm2, xmm9

; 5757 :         RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));

	movss	xmm10, DWORD PTR picker_pos$[rsp+4]
	movaps	xmm3, xmm4
	addss	xmm3, xmm13
	mov	DWORD PTR [rsp+56], 0
	movss	DWORD PTR [rsp+48], xmm11
	movaps	xmm0, xmm11
	movaps	xmm6, xmm4
	unpcklps xmm0, xmm11
	unpcklps xmm6, xmm10
	xor	r9d, r9d
	movsd	QWORD PTR [rsp+40], xmm0
	movq	rdx, xmm6
	movaps	xmm1, xmm3
	movsd	QWORD PTR bar1_bb$38[rbp-256], xmm6
	subss	xmm1, xmm4
	movaps	xmm7, xmm3
	unpcklps xmm7, xmm2
	mov	rcx, r13
	movq	r8, xmm7
	movsd	QWORD PTR bar1_bb$38[rbp-248], xmm7
	mulss	xmm1, xmm14
	movss	DWORD PTR [rsp+32], xmm1
	call	?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z ; ImGui::RenderColorRectWithAlphaCheckerboard

; 5758 :         draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);

	mov	eax, esi
	lea	r8, QWORD PTR bar1_bb$38[rbp-248]
	and	eax, 16777215				; 00ffffffH
	lea	rdx, QWORD PTR bar1_bb$38[rbp-256]
	mov	DWORD PTR [rsp+48], eax
	mov	r9d, esi
	mov	DWORD PTR [rsp+40], eax
	mov	rcx, r13
	mov	DWORD PTR [rsp+32], esi
	call	?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor

; 5759 :         float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);
; 5760 :         RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);

	movaps	xmm2, xmm11
	movq	rdx, xmm7
	movq	rcx, xmm6
	call	?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z ; ImGui::RenderFrameBorder

; 5761 :         RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);

	movss	xmm5, DWORD PTR $T31[rbp-256]
	addss	xmm13, xmm15
	movss	xmm4, DWORD PTR $T28[rbp-256]
	movaps	xmm1, xmm5
	movss	xmm0, DWORD PTR [r15+14552]
	addss	xmm1, xmm12
	subss	xmm4, xmm12
	movss	DWORD PTR [rsp+32], xmm0
	subss	xmm12, xmm8
	mov	rcx, r13
	movaps	xmm3, xmm13
	unpcklps xmm1, xmm5
	movaps	xmm0, xmm4
	movq	r8, xmm1
	mulss	xmm12, xmm9
	addss	xmm12, xmm10
	addss	xmm12, xmm14
	cvttss2si eax, xmm12
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	unpcklps xmm0, xmm2
	movq	rdx, xmm0
	call	?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z ; RenderArrowsForVerticalBar
$LN65@ColorPicke:

; 5762 :     }
; 5763 : 
; 5764 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 5765 : 
; 5766 :     if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)

	movzx	edi, BYTE PTR value_changed$1$[rsp]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	xmm15, XMMWORD PTR [rsp+448]
	movaps	xmm14, XMMWORD PTR [rsp+464]
	movaps	xmm13, XMMWORD PTR [rsp+480]
	movaps	xmm12, XMMWORD PTR [rsp+496]
	movaps	xmm11, XMMWORD PTR [rsp+512]
	movaps	xmm10, XMMWORD PTR [rsp+528]
	movaps	xmm9, XMMWORD PTR [rsp+544]
	movaps	xmm8, XMMWORD PTR [rsp+560]
	movaps	xmm7, XMMWORD PTR [rsp+576]
	movaps	xmm6, XMMWORD PTR [rsp+592]
	mov	r13, QWORD PTR [rsp+616]
	test	dil, dil
	je	SHORT $LN67@ColorPicke
	mov	r8, QWORD PTR tv5797[rbp-256]
	lea	rcx, QWORD PTR backup_initial_col$[rbp-256]
	mov	rdx, r14
	call	memcmp
	test	eax, eax
	jne	SHORT $LN66@ColorPicke

; 5767 :         value_changed = false;

	xor	dil, dil

; 5768 :     if (value_changed && g.LastItemData.ID != 0) // In case of ID collision, the second EndGroup() won't catch g.ActiveId

	jmp	SHORT $LN67@ColorPicke
$LN66@ColorPicke:
	mov	eax, DWORD PTR [r15+18616]
	test	eax, eax
	je	SHORT $LN67@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	ecx, DWORD PTR [rbx+16504]
	cmp	ecx, eax
	je	SHORT $LN282@ColorPicke
	test	ecx, ecx
	jne	SHORT $LN281@ColorPicke
$LN282@ColorPicke:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rbx+16520], 257		; 00000101H
$LN281@ColorPicke:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rbx+18624], 4
$LN67@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5771 :     if (set_current_color_edit_id)

	cmp	DWORD PTR tv5903[rbp-256], 0
	jne	SHORT $LN68@ColorPicke

; 5772 :         g.ColorEditCurrentID = 0;

	mov	DWORD PTR [r15+23832], 0
$LN68@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5775 :     return value_changed;

	movzx	eax, dil
	mov	rdi, QWORD PTR [rsp+632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
$LN1@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5776 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 640				; 00000280H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ENDP		; ImGui::ColorPicker4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?NewLine@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
?NewLine@ImGui@@YAXXZ PROC				; ImGui::NewLine, COMDAT

; 1361 : {

$LN14:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r9, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1363 :     if (window->SkipItems)

	cmp	BYTE PTR [r9+240], 0
	jne	SHORT $LN1@NewLine

; 1364 :         return;
; 1365 : 
; 1366 :     ImGuiContext& g = *GImGui;
; 1367 :     const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
; 1368 :     window->DC.LayoutType = ImGuiLayoutType_Vertical;
; 1369 :     window->DC.IsSameLine = false;
; 1370 :     if (window->DC.CurrLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.

	movss	xmm1, DWORD PTR [r9+356]
	xorps	xmm0, xmm0
	mov	r10d, DWORD PTR [r9+492]
	comiss	xmm1, xmm0
	mov	DWORD PTR [r9+492], 1
	mov	BYTE PTR [r9+376], 0
	movss	xmm1, DWORD PTR __real@bf800000
	jbe	SHORT $LN3@NewLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T2[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1371 :         ItemSize(ImVec2(0, 0));

	jmp	SHORT $LN12@NewLine
$LN3@NewLine:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rcx+15696]
	movss	DWORD PTR $T1[rsp+4], xmm0
	mov	DWORD PTR $T1[rsp], 0
$LN12@NewLine:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1374 :     window->DC.LayoutType = backup_layout_type;

	lea	rcx, QWORD PTR $T1[rsp]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	mov	DWORD PTR [r9+492], r10d
$LN1@NewLine:

; 1375 : }

	add	rsp, 40					; 00000028H
	ret	0
?NewLine@ImGui@@YAXXZ ENDP				; ImGui::NewLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMainMenuBar@ImGui@@YA_NXZ
_TEXT	SEGMENT
$T8 = 32
?BeginMainMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMainMenuBar, COMDAT

; 7118 : {

$LN140:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 7119 :     ImGuiContext& g = *GImGui;

	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rdi, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r11+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	rbx, QWORD PTR [rax]

; 14026:     if (viewport)

	test	rbx, rbx
	je	SHORT $LN10@BeginMainM

; 14027:         viewport->LastFrameActive = g.FrameCount;

	mov	eax, DWORD PTR [r11+16240]
	mov	DWORD PTR [rbx+108], eax
$LN10@BeginMainM:

; 14028:     if (g.CurrentViewport == viewport)

	cmp	QWORD PTR [r11+19000], rbx
	je	SHORT $LN12@BeginMainM

; 14029:         return;
; 14030:     g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;

	test	rbx, rbx
	je	SHORT $LN14@BeginMainM
	mov	eax, DWORD PTR [rbx+40]
	mov	DWORD PTR [r11+18992], eax

; 14031:     g.CurrentViewport = viewport;
; 14032:     //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
; 14033: 
; 14034:     // Notify platform layer of viewport changes
; 14035:     // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
; 14036:     if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)

	mov	rax, QWORD PTR [r11+14464]
	mov	QWORD PTR [r11+19000], rbx
	test	rax, rax
	je	SHORT $LN12@BeginMainM

; 14037:         g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);

	mov	rcx, rbx
	call	rax
	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN12@BeginMainM
$LN14@BeginMainM:

; 14029:         return;
; 14030:     g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;

	mov	DWORD PTR [r11+18992], 1065353216	; 3f800000H
	mov	QWORD PTR [r11+19000], rbx
$LN12@BeginMainM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7128 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

	movss	xmm1, DWORD PTR [rdi+14752]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	lea	r8, OFFSET FLAT:??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@+1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7128 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

	subss	xmm1, DWORD PTR [rdi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rdi+14748]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	lea	rsi, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7128 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

	movss	DWORD PTR [rdi+18816], xmm0
	xorps	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2050 :     ImU32 crc = seed;

	mov	r10d, -1				; ffffffffH

; 2065 :         while (unsigned char c = *data++)

	mov	r9b, 35					; 00000023H
	mov	edx, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7128 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));

	movss	DWORD PTR [rdi+18820], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm5, DWORD PTR [r11+14616]
	addss	xmm5, xmm5
	addss	xmm5, DWORD PTR [r11+15696]
$LL44@BeginMainM:

; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r9b, 35					; 00000023H
	jne	SHORT $LN49@BeginMainM
	cmp	BYTE PTR [r8], r9b
	jne	SHORT $LN49@BeginMainM
	cmp	BYTE PTR [r8+1], r9b
	cmove	edx, r10d
$LN49@BeginMainM:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, dl
	movzx	eax, r9b
	movzx	r9d, BYTE PTR [r8]
	xor	rcx, rax
	shr	edx, 8
	inc	r8
	xor	edx, DWORD PTR [rsi+rcx*4]
	test	r9b, r9b
	jne	SHORT $LL44@BeginMainM

; 2070 :         }
; 2071 :     }
; 2072 :     return ~crc;

	not	edx

; 5800 :     return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);

	lea	rcx, QWORD PTR [r11+16376]
	call	?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z	; ImGuiStorage::GetVoidPtr
	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7086 :     ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)(viewport_p ? viewport_p : GetMainViewport());

	test	rbx, rbx
	jne	SHORT $LN36@BeginMainM
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r11+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	rbx, QWORD PTR [rax]
$LN36@BeginMainM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7087 :     if (bar_window == NULL || bar_window->BeginCount == 0)

	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN26@BeginMainM
	cmp	WORD PTR [rcx+248], si
	jne	$LN126@BeginMainM
$LN26@BeginMainM:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movss	xmm1, DWORD PTR [rbx+304]

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm3, xmm6

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	movss	xmm0, DWORD PTR [rbx+16]

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movaps	xmm4, xmm1
	addss	xmm4, DWORD PTR [rbx+8]
	movss	xmm2, DWORD PTR [rbx+308]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	subss	xmm0, xmm1

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	addss	xmm2, DWORD PTR [rbx+12]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	addss	xmm0, DWORD PTR [rbx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	or	DWORD PTR [r11+18680], 3

; 8116 :     g.NextWindowData.PosVal = pos;

	movss	DWORD PTR [r11+18700], xmm4
	movss	DWORD PTR [r11+18704], xmm2

; 8127 :     g.NextWindowData.SizeVal = size;

	movss	DWORD PTR [r11+18720], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	mov	QWORD PTR [r11+18708], rsi

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [r11+18684], 1

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [r11+18740], 1

; 8128 :     g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [r11+18688], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7092 :         ImVec2 pos = avail_rect.Min;

	subss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8127 :     g.NextWindowData.SizeVal = size;

	movss	DWORD PTR [r11+18716], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7102 :             viewport->BuildWorkOffsetMin[axis] += axis_size;

	addss	xmm5, DWORD PTR [rbx+308]
	movss	DWORD PTR [rbx+308], xmm5
$LN126@BeginMainM:

; 7103 :         else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)
; 7104 :             viewport->BuildWorkOffsetMax[axis] -= axis_size;
; 7105 :     }
; 7106 : 
; 7107 :     window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
; 7108 :     SetNextWindowViewport(viewport->ID); // Enforce viewport so we don't create our own viewport when ImGuiConfigFlags_ViewportsNoMerge is set.

	mov	eax, DWORD PTR [rbx]

; 7109 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	movaps	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8181 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;

	or	DWORD PTR [r11+18680], 256		; 00000100H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7109 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	mov	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8182 :     g.NextWindowData.ViewportId = id;

	mov	DWORD PTR [r11+18780], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7109 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3219 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T8[rsp], 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm1, DWORD PTR [rbx+14576]
	lea	rcx, QWORD PTR [rbx+18840]
	movss	xmm0, DWORD PTR [rbx+14580]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T8[rsp+4], xmm1
	movss	DWORD PTR $T8[rsp+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7111 :     bool is_open = Begin(name, NULL, window_flags);

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	mov	QWORD PTR [rbx+14576], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7111 :     bool is_open = Begin(name, NULL, window_flags);

	mov	r8d, 2098447				; 0020050fH
	lea	rcx, OFFSET FLAT:??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 7112 :     PopStyleVar(2);

	mov	ecx, 2
	movzx	ebx, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 7129 :     ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
; 7130 :     float height = GetFrameHeight();
; 7131 :     bool is_open = BeginViewportSideBar("##MainMenuBar", viewport, ImGuiDir_Up, height, window_flags);
; 7132 :     g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);

	mov	QWORD PTR [rdi+18816], rsi

; 7133 : 
; 7134 :     if (is_open)

	test	bl, bl
	je	SHORT $LN2@BeginMainM

; 7135 :         BeginMenuBar();

	call	?BeginMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMenuBar
	jmp	SHORT $LN138@BeginMainM
$LN2@BeginMainM:

; 7136 :     else
; 7137 :         End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
$LN138@BeginMainM:

; 7138 :     return is_open;
; 7139 : }

	mov	rsi, QWORD PTR [rsp+88]
	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+80]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?BeginMainMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMainMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z
_TEXT	SEGMENT
data_type$GSCopy$1$ = 64
v32$3 = 64
v32$4 = 64
v32$5 = 64
v32$6 = 64
hovered$1$ = 68
text_size$7 = 72
$T8 = 72
$T9 = 72
label$GSCopy$1$ = 88
window$1$ = 96
frame_bb$ = 104
c$10 = 120
total_bb$ = 120
value_buf$ = 144
__$ArrayPad$ = 208
label$ = 368
data_type$ = 376
p_data$ = 384
v_speed$ = 392
p_min$ = 400
p_max$ = 408
format$ = 416
flags$dead$ = 424
?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z PROC		; ImGui::DragScalar, COMDAT

; 2395 : {

$LN306:
	mov	r11, rsp
	mov	QWORD PTR [r11+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-104]
	sub	rsp, 304				; 00000130H
	movaps	XMMWORD PTR [r11-88], xmm7
	movaps	XMMWORD PTR [r11-104], xmm8
	movaps	XMMWORD PTR [r11-120], xmm9
	movaps	XMMWORD PTR [r11-136], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2395 : {

	movaps	xmm7, xmm3
	mov	rbx, QWORD PTR p_min$[rbp-256]
	mov	r15, r8
	mov	r13, QWORD PTR format$[rbp-256]
	mov	r12, rcx
	mov	DWORD PTR data_type$GSCopy$1$[rsp], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2395 : {

	mov	QWORD PTR label$GSCopy$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rdi, QWORD PTR [rsi+16408]
	mov	QWORD PTR window$1$[rsp], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2397 :     if (window->SkipItems)

	cmp	BYTE PTR [rdi+240], 0
	jne	$LN222@DragScalar

; 2398 :         return false;
; 2399 : 
; 2400 :     ImGuiContext& g = *GImGui;
; 2401 :     const ImGuiStyle& style = g.Style;
; 2402 :     const ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	movaps	XMMWORD PTR [r11-72], xmm6
	mov	rcx, rdi
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	r14d, eax

; 2403 :     const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2403 :     const float w = CalcItemWidth();

	movaps	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rcx, r12

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r12, -1
	jae	SHORT $LN226@DragScalar
	npad	5
$LL45@DragScalar:
	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN226@DragScalar
	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 35					; 00000023H
	jne	SHORT $LN217@DragScalar
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN226@DragScalar
$LN217@DragScalar:

; 3332 :         text_display_end++;

	mov	rcx, rax
	cmp	rax, -1
	jb	SHORT $LL45@DragScalar
$LN226@DragScalar:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm2, DWORD PTR [r8+15696]
	xorps	xmm9, xmm9

; 5418 :     if (text == text_display_end)

	movss	xmm8, DWORD PTR __real@7f7fffff
	cmp	r12, rcx
	jne	SHORT $LN42@DragScalar
	xorps	xmm10, xmm10

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN39@DragScalar
$LN42@DragScalar:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$7[rsp]
	mov	QWORD PTR [rsp+56], 0
	movaps	xmm3, xmm8
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR [r8+15688]
	mov	QWORD PTR [rsp+40], r12
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$7[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm2, DWORD PTR text_size$7[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm10, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm10, xmm10
$LN39@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2407 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm10, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm3, DWORD PTR [rdi+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2406 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	movss	xmm4, DWORD PTR [rsi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm6, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2406 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));

	movaps	xmm1, xmm4
	addss	xmm1, xmm4
	addss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, DWORD PTR [rdi+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR frame_bb$[rsp], xmm3
	movss	xmm2, DWORD PTR [rdi+316]
	movss	DWORD PTR frame_bb$[rsp+4], xmm2
	movss	DWORD PTR frame_bb$[rsp+8], xmm6
	movss	DWORD PTR frame_bb$[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2407 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN20@DragScalar
	movaps	xmm0, xmm10
	addss	xmm0, DWORD PTR [rsi+14636]
	jmp	SHORT $LN21@DragScalar
$LN20@DragScalar:
	xorps	xmm0, xmm0
$LN21@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rsp+4], xmm2

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T8[rsp]

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-244], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-248], xmm6
	subss	xmm6, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movaps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2411 :     if (!ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))

	lea	r8, QWORD PTR frame_bb$[rsp]
	mov	edx, r14d
	lea	rcx, QWORD PTR total_bb$[rsp]
	mov	r9d, 1024				; 00000400H
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	movaps	xmm6, XMMWORD PTR [rsp+288]
	test	al, al
	je	$LN222@DragScalar

; 2413 : 
; 2414 :     // Default format string when passing NULL
; 2415 :     if (format == NULL)

	lea	rcx, OFFSET FLAT:__ImageBase
	test	r13, r13
	jne	SHORT $LN4@DragScalar

; 2006 :     return &GDataTypeInfo[data_type];

	movsxd	rax, DWORD PTR data_type$GSCopy$1$[rsp]
	shl	rax, 5

; 2416 :         format = DataTypeGetInfo(data_type)->PrintFmt;

	mov	r13, QWORD PTR ?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B[rax+rcx+16]
$LN4@DragScalar:

; 2418 :     const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);

	mov	r8d, DWORD PTR [rsi+18620]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	mov	edx, r14d
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@IH@Z ; ImGui::ItemHoverable
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3525 :     inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }

	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2418 :     const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);

	movzx	r8d, al
	mov	BYTE PTR hovered$1$[rsp], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3525 :     inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }

	cmp	DWORD PTR [r11+16504], r14d
	jne	SHORT $LN22@DragScalar
	cmp	DWORD PTR [r11+23824], r14d
	je	$LN208@DragScalar
$LN22@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2423 :         const bool input_requested_by_tabbing = temp_input_allowed && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_FocusedByTabbing) != 0;

	mov	edi, DWORD PTR [rsi+18624]
	xor	r12b, r12b
	and	edi, 256				; 00000100H

; 2424 :         const bool clicked = hovered && IsMouseClicked(0, id);

	test	al, al
	je	SHORT $LN26@DragScalar
	xor	r8d, r8d
	mov	edx, r14d
	xor	ecx, ecx
	call	?IsMouseClicked@ImGui@@YA_NHIH@Z	; ImGui::IsMouseClicked
	movzx	r8d, BYTE PTR hovered$1$[rsp]
	test	al, al
	je	SHORT $LN26@DragScalar
	mov	cl, 1
	jmp	SHORT $LN218@DragScalar
$LN26@DragScalar:
	xor	cl, cl

; 2425 :         const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));

	test	r8b, r8b
	je	SHORT $LN28@DragScalar
$LN218@DragScalar:
	cmp	WORD PTR [rsi+14170], 2
	jne	SHORT $LN28@DragScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9640 :     if (owner_id == ImGuiKeyOwner_Any)

	test	r14d, r14d
	jne	SHORT $LN181@DragScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2425 :         const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));

	cmp	BYTE PTR [r11+18132], r12b
	jmp	SHORT $LN299@DragScalar
$LN181@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9646 :     if (owner_data->OwnerCurr != owner_id)

	mov	eax, DWORD PTR [r11+18124]
	cmp	eax, r14d
	je	SHORT $LN211@DragScalar

; 9647 :     {
; 9648 :         if (owner_data->LockThisFrame)

	cmp	BYTE PTR [r11+18132], r12b
	jne	SHORT $LN28@DragScalar

; 9649 :             return false;
; 9650 :         if (owner_data->OwnerCurr != ImGuiKeyOwner_None)

	cmp	eax, -1					; ffffffffH
$LN299@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2425 :         const bool double_clicked = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey_MouseLeft, id));

	jne	SHORT $LN28@DragScalar
$LN211@DragScalar:
	mov	al, 1
	jmp	SHORT $LN29@DragScalar
$LN28@DragScalar:
	xor	al, al
$LN29@DragScalar:

; 2426 :         const bool make_active = (input_requested_by_tabbing || clicked || double_clicked || g.NavActivateId == id);

	test	edi, edi
	jne	SHORT $LN30@DragScalar
	test	cl, cl
	jne	SHORT $LN30@DragScalar
	test	al, al
	jne	SHORT $LN30@DragScalar
	cmp	DWORD PTR [rsi+19112], r14d
	je	SHORT $LN30@DragScalar
	xor	dl, dl
	jmp	SHORT $LN9@DragScalar
$LN30@DragScalar:
	mov	dl, 1

; 2427 :         if (make_active && (clicked || double_clicked))

	test	cl, cl
	jne	SHORT $LN7@DragScalar
	test	al, al
	je	SHORT $LN214@DragScalar
$LN7@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [r11+18128], r14d
	mov	DWORD PTR [r11+18124], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [r11+18132], 0
$LN214@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2430 :             if (input_requested_by_tabbing || (clicked && g.IO.KeyCtrl) || double_clicked || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput)))

	test	edi, edi
	jne	SHORT $LN10@DragScalar
	test	cl, cl
	je	SHORT $LN11@DragScalar
	cmp	BYTE PTR [rsi+3624], r12b
	jne	SHORT $LN10@DragScalar
$LN11@DragScalar:
	test	al, al
	jne	SHORT $LN10@DragScalar
	cmp	DWORD PTR [rsi+19112], r14d
	jne	SHORT $LN9@DragScalar
	test	BYTE PTR [rsi+19124], dl
	je	SHORT $LN9@DragScalar
$LN10@DragScalar:

; 2431 :                 temp_input_is_active = true;

	movzx	r12d, dl
$LN9@DragScalar:

; 2432 : 
; 2433 :         // (Optional) simple click (without moving) turns Drag into an InputText
; 2434 :         if (g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active)

	cmp	BYTE PTR [rsi+101], 0
	je	SHORT $LN13@DragScalar
	test	r12b, r12b
	jne	SHORT $LN13@DragScalar

; 2435 :             if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	cmp	DWORD PTR [rsi+16504], r14d
	jne	SHORT $LN13@DragScalar
	test	r8b, r8b
	je	SHORT $LN13@DragScalar
	cmp	BYTE PTR [rsi+14190], r12b
	je	SHORT $LN13@DragScalar
	movss	xmm1, DWORD PTR [rsi+116]
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm9, xmm1
	jbe	SHORT $LN202@DragScalar

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movss	xmm1, DWORD PTR [r11+116]
$LN202@DragScalar:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [r11+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2435 :             if (g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jae	SHORT $LN13@DragScalar

; 2436 :             {
; 2437 :                 g.NavActivateId = id;

	mov	DWORD PTR [rsi+19112], r14d

; 2438 :                 g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
; 2439 :                 temp_input_is_active = true;

	mov	r12b, 1
	mov	DWORD PTR [rsi+19124], 1
$LN13@DragScalar:

; 2440 :             }
; 2441 : 
; 2442 :         if (make_active && !temp_input_is_active)

	test	dl, dl
	je	SHORT $LN14@DragScalar
	test	r12b, r12b
	jne	SHORT $LN228@DragScalar

; 2443 :         {
; 2444 :             SetActiveID(id, window);

	mov	rdi, QWORD PTR window$1$[rsp]
	mov	ecx, r14d
	mov	rdx, rdi
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 2445 :             SetFocusID(id, window);

	mov	rdx, rdi
	mov	ecx, r14d
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 2446 :             FocusWindow(window);

	xor	edx, edx
	mov	rcx, rdi
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow

; 2447 :             g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
; 2448 :         }
; 2449 :     }
; 2450 : 
; 2451 :     if (temp_input_is_active)

	mov	r11, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [rsi+18568], 3
$LN15@DragScalar:

; 2456 :     }
; 2457 : 
; 2458 :     // Draw frame
; 2459 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	cmp	DWORD PTR [rsi+16504], r14d
	jne	SHORT $LN35@DragScalar
	mov	eax, 368				; 00000170H
	jmp	SHORT $LN36@DragScalar
$LN14@DragScalar:

; 2447 :             g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
; 2448 :         }
; 2449 :     }
; 2450 : 
; 2451 :     if (temp_input_is_active)

	test	r12b, r12b
	je	SHORT $LN15@DragScalar
$LN228@DragScalar:

; 2452 :     {
; 2453 :         // Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
; 2454 :         const bool is_clamp_input = (flags & ImGuiSliderFlags_AlwaysClamp) != 0 && (p_min == NULL || p_max == NULL || DataTypeCompare(data_type, p_min, p_max) < 0);
; 2455 :         return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);

	mov	r12, QWORD PTR label$GSCopy$1$[rsp]
$LN208@DragScalar:
	mov	r9d, DWORD PTR data_type$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rsp]
	xor	eax, eax
	mov	r8, r12
	mov	QWORD PTR [rsp+56], rax
	mov	edx, r14d
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], r15
	call	?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z ; ImGui::TempInputScalar
	jmp	$LN1@DragScalar
$LN35@DragScalar:

; 2456 :     }
; 2457 : 
; 2458 :     // Draw frame
; 2459 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	movzx	eax, BYTE PTR hovered$1$[rsp]
	add	rax, 21
	shl	rax, 4
$LN36@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r11+rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2460 :     RenderNavHighlight(frame_bb, id);

	mov	r8d, 1
	lea	rcx, QWORD PTR frame_bb$[rsp]
	mov	edx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$10[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r11+14552]
	movss	DWORD PTR c$10[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2460 :     RenderNavHighlight(frame_bb, id);

	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$10[rsp]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2461 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	movss	xmm0, DWORD PTR [rsi+14620]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2461 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	mov	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	r9b, 1
	mov	rcx, QWORD PTR frame_bb$[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 2360 :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2361 :     if (g.ActiveId == id)

	cmp	DWORD PTR [rdi+16504], r14d
	jne	$LN92@DragScalar

; 2362 :     {
; 2363 :         // Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.
; 2364 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])

	mov	eax, DWORD PTR [rdi+16544]
	cmp	eax, 1
	jne	SHORT $LN86@DragScalar
	cmp	BYTE PTR [rdi+3600], 0
	je	SHORT $LN220@DragScalar
	jmp	SHORT $LN88@DragScalar
$LN86@DragScalar:

; 2365 :             ClearActiveID();
; 2366 :         else if ((g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN88@DragScalar
	cmp	DWORD PTR [rdi+19120], r14d
	jne	SHORT $LN88@DragScalar
	cmp	BYTE PTR [rdi+16516], 0
	jne	SHORT $LN88@DragScalar
$LN220@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN88@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2369 :     if (g.ActiveId != id)

	cmp	DWORD PTR [rdi+16504], r14d
	jne	$LN92@DragScalar

; 2370 :         return false;
; 2371 :     if ((g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))

	test	BYTE PTR [rdi+18620], 128		; 00000080H
	jne	$LN92@DragScalar

; 2372 :         return false;
; 2373 : 
; 2374 :     switch (data_type)

	movsxd	rdi, DWORD PTR data_type$GSCopy$1$[rsp]
	cmp	edi, 9
	ja	$LN107@DragScalar
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN225@DragScalar[rdx+rdi*4]
	add	rcx, rdx
	jmp	rcx
$LN93@DragScalar:

; 2375 :     {
; 2376 :     case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }

	movsx	eax, BYTE PTR [r15]
	mov	DWORD PTR v32$6[rsp], eax
	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN109@DragScalar
	movzx	eax, BYTE PTR [rax]
	jmp	SHORT $LN110@DragScalar
$LN109@DragScalar:
	mov	al, 127					; 0000007fH
$LN110@DragScalar:
	movsx	ecx, al
	test	rbx, rbx
	je	SHORT $LN111@DragScalar
	movzx	eax, BYTE PTR [rbx]
	jmp	SHORT $LN112@DragScalar
$LN111@DragScalar:
	mov	al, -128				; ffffffffffffff80H
$LN112@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	lea	rdx, QWORD PTR v32$6[rsp]
	mov	DWORD PTR [rsp+32], ecx
	movaps	xmm2, xmm7
	mov	ecx, 4
	movsx	r9d, al
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
$LN303@DragScalar:

; 2462 : 
; 2463 :     // Drag behavior
; 2464 :     const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
; 2465 :     if (value_changed)

	movzx	ebx, al
	test	al, al
	je	$LN82@DragScalar
	movzx	eax, BYTE PTR v32$6[rsp]
	mov	BYTE PTR [r15], al
	jmp	$LN82@DragScalar
$LN95@DragScalar:

; 2377 :     case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }

	movzx	eax, BYTE PTR [r15]
	mov	DWORD PTR v32$5[rsp], eax
	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN113@DragScalar
	movzx	eax, BYTE PTR [rax]
	jmp	SHORT $LN114@DragScalar
$LN113@DragScalar:
	mov	al, 255					; 000000ffH
$LN114@DragScalar:
	movzx	ecx, al
	test	rbx, rbx
	je	SHORT $LN115@DragScalar
	movzx	eax, BYTE PTR [rbx]
	jmp	SHORT $LN116@DragScalar
$LN115@DragScalar:
	xor	eax, eax
$LN116@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	lea	rdx, QWORD PTR v32$5[rsp]
	mov	DWORD PTR [rsp+32], ecx
	movaps	xmm2, xmm7
	mov	ecx, 5
	movzx	r9d, al
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	jmp	SHORT $LN303@DragScalar
$LN97@DragScalar:

; 2378 :     case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }

	movsx	eax, WORD PTR [r15]
	mov	DWORD PTR v32$4[rsp], eax
	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN117@DragScalar
	movzx	eax, WORD PTR [rax]
	jmp	SHORT $LN118@DragScalar
$LN117@DragScalar:
	mov	eax, 32767				; 00007fffH
$LN118@DragScalar:
	movsx	ecx, ax
	test	rbx, rbx
	je	SHORT $LN119@DragScalar
	movzx	eax, WORD PTR [rbx]
	jmp	SHORT $LN120@DragScalar
$LN119@DragScalar:
	mov	eax, -32768				; ffffffffffff8000H
$LN120@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	lea	rdx, QWORD PTR v32$4[rsp]
	mov	DWORD PTR [rsp+32], ecx
	movaps	xmm2, xmm7
	mov	ecx, 4
	movsx	r9d, ax
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
$LN304@DragScalar:

; 2462 : 
; 2463 :     // Drag behavior
; 2464 :     const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
; 2465 :     if (value_changed)

	movzx	ebx, al
	test	al, al
	je	$LN82@DragScalar
	movzx	eax, WORD PTR v32$4[rsp]
	mov	WORD PTR [r15], ax
	jmp	$LN82@DragScalar
$LN99@DragScalar:

; 2379 :     case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }

	movzx	eax, WORD PTR [r15]
	mov	DWORD PTR v32$3[rsp], eax
	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN121@DragScalar
	movzx	eax, WORD PTR [rax]
	jmp	SHORT $LN122@DragScalar
$LN121@DragScalar:
	mov	eax, 65535				; 0000ffffH
$LN122@DragScalar:
	movzx	ecx, ax
	test	rbx, rbx
	je	SHORT $LN123@DragScalar
	movzx	eax, WORD PTR [rbx]
	jmp	SHORT $LN124@DragScalar
$LN123@DragScalar:
	xor	eax, eax
$LN124@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	lea	rdx, QWORD PTR v32$3[rsp]
	mov	DWORD PTR [rsp+32], ecx
	movaps	xmm2, xmm7
	mov	ecx, 5
	movzx	r9d, ax
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	jmp	SHORT $LN304@DragScalar
$LN101@DragScalar:

; 2380 :     case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN125@DragScalar
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN126@DragScalar
$LN125@DragScalar:
	mov	ecx, 2147483647				; 7fffffffH
$LN126@DragScalar:
	test	rbx, rbx
	je	SHORT $LN127@DragScalar
	mov	r9d, DWORD PTR [rbx]
	jmp	SHORT $LN128@DragScalar
$LN127@DragScalar:
	mov	r9d, -2147483648			; ffffffff80000000H
$LN128@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	DWORD PTR [rsp+32], ecx
	mov	rdx, r15
	mov	ecx, edi
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
	jmp	$LN302@DragScalar
$LN102@DragScalar:

; 2381 :     case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN129@DragScalar
	mov	eax, DWORD PTR [rax]
	jmp	SHORT $LN130@DragScalar
$LN129@DragScalar:
	mov	eax, -1					; ffffffffH
$LN130@DragScalar:
	test	rbx, rbx
	je	SHORT $LN131@DragScalar
	mov	r9d, DWORD PTR [rbx]
	jmp	SHORT $LN132@DragScalar
$LN131@DragScalar:
	xor	r9d, r9d
$LN132@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	rdx, r15
	mov	DWORD PTR [rsp+32], eax
	mov	ecx, edi
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	jmp	$LN302@DragScalar
$LN103@DragScalar:

; 2382 :     case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN133@DragScalar
	mov	rcx, QWORD PTR [rax]
	jmp	SHORT $LN134@DragScalar
$LN133@DragScalar:
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN134@DragScalar:
	test	rbx, rbx
	je	SHORT $LN135@DragScalar
	mov	r9, QWORD PTR [rbx]
	jmp	SHORT $LN136@DragScalar
$LN135@DragScalar:
	mov	r9, -9223372036854775808		; 8000000000000000H
$LN136@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	QWORD PTR [rsp+32], rcx
	mov	rdx, r15
	mov	ecx, edi
	call	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
	jmp	$LN302@DragScalar
$LN104@DragScalar:

; 2383 :     case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN137@DragScalar
	mov	rcx, QWORD PTR [rax]
	jmp	SHORT $LN138@DragScalar
$LN137@DragScalar:
	mov	rcx, -1
$LN138@DragScalar:
	test	rbx, rbx
	je	SHORT $LN139@DragScalar
	mov	r9, QWORD PTR [rbx]
	jmp	SHORT $LN140@DragScalar
$LN139@DragScalar:
	xor	r9d, r9d
$LN140@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	QWORD PTR [rsp+32], rcx
	mov	rdx, r15
	mov	ecx, edi
	call	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
	jmp	$LN302@DragScalar
$LN105@DragScalar:

; 2384 :     case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN141@DragScalar
	movss	xmm8, DWORD PTR [rax]
$LN141@DragScalar:
	test	rbx, rbx
	je	SHORT $LN143@DragScalar
	movss	xmm3, DWORD PTR [rbx]
	jmp	SHORT $LN144@DragScalar
$LN143@DragScalar:
	movss	xmm3, DWORD PTR __real@ff7fffff
$LN144@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	rdx, r15
	movss	DWORD PTR [rsp+32], xmm8
	mov	ecx, edi
	call	??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z ; ImGui::DragBehaviorT<float,float,float>
	jmp	SHORT $LN302@DragScalar
$LN106@DragScalar:

; 2385 :     case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, flags);

	mov	rax, QWORD PTR p_max$[rbp-256]
	test	rax, rax
	je	SHORT $LN145@DragScalar
	movsd	xmm0, QWORD PTR [rax]
	jmp	SHORT $LN146@DragScalar
$LN145@DragScalar:
	movsd	xmm0, QWORD PTR __real@7fefffffffffffff
$LN146@DragScalar:
	test	rbx, rbx
	je	SHORT $LN147@DragScalar
	movsd	xmm3, QWORD PTR [rbx]
	jmp	SHORT $LN148@DragScalar
$LN147@DragScalar:
	movsd	xmm3, QWORD PTR __real@ffefffffffffffff
$LN148@DragScalar:
	mov	QWORD PTR [rsp+40], r13
	movaps	xmm2, xmm7
	mov	rdx, r15
	movsd	QWORD PTR [rsp+32], xmm0
	mov	ecx, edi
	call	??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z ; ImGui::DragBehaviorT<double,double,double>
$LN302@DragScalar:

; 2462 : 
; 2463 :     // Drag behavior
; 2464 :     const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
; 2465 :     if (value_changed)

	movzx	ebx, al
$LN82@DragScalar:
	test	bl, bl
	je	SHORT $LN16@DragScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	ecx, DWORD PTR [rax+16504]
	cmp	ecx, r14d
	je	SHORT $LN159@DragScalar
	test	ecx, ecx
	jne	SHORT $LN158@DragScalar
$LN159@DragScalar:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rax+16520], 257		; 00000101H
$LN158@DragScalar:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rax+18624], 4
	jmp	SHORT $LN16@DragScalar
$LN92@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2470 :     const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);

	mov	edi, DWORD PTR data_type$GSCopy$1$[rsp]
$LN107@DragScalar:
	xor	bl, bl
$LN16@DragScalar:
	mov	r9, r15
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, edi
	lea	rcx, QWORD PTR value_buf$[rbp-256]
	mov	edx, 64					; 00000040H
	call	?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z ; ImGui::DataTypeFormatString
	movsxd	rcx, eax
	lea	r9, QWORD PTR value_buf$[rbp-256]
	add	r9, rcx

; 2471 :     if (g.LogEnabled)

	cmp	BYTE PTR [rsi+24256], 0
	je	SHORT $LN17@DragScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_01HCONENDN@?$HL@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	lea	rcx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@
	mov	QWORD PTR [rax+24296], rcx
$LN17@DragScalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2473 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	lea	rax, QWORD PTR $T9[rsp]
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR value_buf$[rbp-256]
	lea	rdx, QWORD PTR frame_bb$[rsp+8]
	mov	QWORD PTR [rsp+32], 0
	lea	rcx, QWORD PTR frame_bb$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T9[rsp], 1056964608		; 3f000000H
	mov	DWORD PTR $T9[rsp+4], 1056964608	; 3f000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2473 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped

; 2474 : 
; 2475 :     if (label_size.x > 0.0f)

	comiss	xmm10, xmm9
	jbe	SHORT $LN18@DragScalar

; 2476 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR frame_bb$[rsp+8]
	mov	r9b, 1
	movss	xmm1, DWORD PTR frame_bb$[rsp+4]
	xor	r8d, r8d
	addss	xmm0, DWORD PTR [rsi+14636]
	addss	xmm1, DWORD PTR [rsi+14616]
	mov	rdx, QWORD PTR label$GSCopy$1$[rsp]
	unpcklps xmm0, xmm1
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN18@DragScalar:

; 2477 : 
; 2478 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_Inputable : 0));
; 2479 :     return value_changed;

	movzx	eax, bl
	jmp	SHORT $LN1@DragScalar
$LN222@DragScalar:

; 2412 :         return false;

	xor	al, al
$LN1@DragScalar:

; 2480 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN225@DragScalar:
	DD	$LN93@DragScalar
	DD	$LN95@DragScalar
	DD	$LN97@DragScalar
	DD	$LN99@DragScalar
	DD	$LN101@DragScalar
	DD	$LN102@DragScalar
	DD	$LN103@DragScalar
	DD	$LN104@DragScalar
	DD	$LN105@DragScalar
	DD	$LN106@DragScalar
?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z ENDP		; ImGui::DragScalar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMenuBar@ImGui@@YA_NXZ
_TEXT	SEGMENT
cr$2 = 32
bar_rect$ = 32
__$ArrayPad$ = 48
?BeginMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMenuBar, COMDAT

; 7008 : {

$LN86:
	mov	r11, rsp
	push	rbx
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7010 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN77@BeginMenuB

; 7011 :         return false;
; 7012 :     if (!(window->Flags & ImGuiWindowFlags_MenuBar))

	test	DWORD PTR [rbx+20], 1024		; 00000400H
	je	$LN77@BeginMenuB
	mov	QWORD PTR [r11+8], rbp
	mov	QWORD PTR [r11+16], rsi
	mov	QWORD PTR [r11+24], rdi
	movaps	XMMWORD PTR [rsp+96], xmm6
	movaps	XMMWORD PTR [rsp+80], xmm7
	movaps	XMMWORD PTR [r11-56], xmm8

; 7014 : 
; 7015 :     IM_ASSERT(!window->DC.MenuBarAppending);
; 7016 :     BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 7017 :     PushID("##menubar");

	lea	rcx, OFFSET FLAT:??_C@_09FHPMMDGK@?$CD?$CDmenubar@
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 7018 : 
; 7019 :     // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
; 7020 :     // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
; 7021 :     ImRect bar_rect = window->MenuBarRect();

	lea	rdx, QWORD PTR bar_rect$[rsp]
	mov	rcx, rbx
	call	?MenuBarRect@ImGuiWindow@@QEBA?AUImRect@@XZ ; ImGuiWindow::MenuBarRect

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	movss	xmm5, DWORD PTR [rbx+140]
	movss	xmm3, DWORD PTR __real@3f000000
	movaps	xmm4, xmm5
	movss	xmm6, DWORD PTR bar_rect$[rsp]
	movaps	xmm0, xmm5
	movss	xmm1, DWORD PTR bar_rect$[rsp+8]
	addss	xmm4, xmm6
	movss	xmm7, DWORD PTR bar_rect$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm6

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	addss	xmm0, xmm7
	addss	xmm4, xmm3
	addss	xmm0, xmm3
	cvttss2si eax, xmm4
	movd	xmm8, eax
	cvttss2si eax, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rbx+136]
	maxss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	cvtdq2ps xmm8, xmm8
	subss	xmm1, xmm0
	movd	xmm4, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm8, DWORD PTR [rbx+544]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	movss	xmm0, DWORD PTR bar_rect$[rsp+12]
	addss	xmm0, xmm3
	cvtdq2ps xmm4, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR cr$2[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm4, DWORD PTR [rbx+548]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	addss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR cr$2[rsp+4], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	cvttss2si eax, xmm2
	movd	xmm1, eax
	cvttss2si eax, xmm0
	cvtdq2ps xmm1, xmm1
	movd	xmm2, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm1, DWORD PTR [rbx+552]

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7022 :     ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window->WindowBorderSize), IM_ROUND(bar_rect.Min.y + window->WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window->WindowRounding, window->WindowBorderSize))), IM_ROUND(bar_rect.Max.y));

	cvtdq2ps xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	comiss	xmm8, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm2, DWORD PTR [rbx+556]

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR cr$2[rsp+8], xmm1
	movss	DWORD PTR cr$2[rsp+12], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5088 :     window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);

	mov	rbp, QWORD PTR [rsi+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	jb	SHORT $LN54@BeginMenuB
	movss	DWORD PTR cr$2[rsp+8], xmm8
$LN54@BeginMenuB:
	comiss	xmm4, xmm2
	movaps	xmm8, XMMWORD PTR [rsp+64]
	jb	SHORT $LN58@BeginMenuB
	movss	DWORD PTR cr$2[rsp+12], xmm4
$LN58@BeginMenuB:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbp+88]
	mov	ecx, DWORD PTR [rbp+92]
	cmp	r8d, ecx
	jne	SHORT $LN61@BeginMenuB
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN65@BeginMenuB
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN66@BeginMenuB
$LN65@BeginMenuB:
	mov	eax, 8
$LN66@BeginMenuB:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [rbp+88]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z	; ImVector<ImVec4>::reserve
$LN61@BeginMenuB:
	movsxd	rdx, DWORD PTR [rbp+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 593  :     _OnChangedClipRect();

	mov	rcx, rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR [rbp+96]
	add	rdx, rdx
	movups	xmm0, XMMWORD PTR cr$2[rsp]
	movups	XMMWORD PTR [rax+rdx*8], xmm0
	inc	DWORD PTR [rbp+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 592  :     _CmdHeader.ClipRect = cr;

	movups	XMMWORD PTR [rbp+136], xmm0

; 593  :     _OnChangedClipRect();

	call	?_OnChangedClipRect@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedClipRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5089 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	rax, QWORD PTR [rsi+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [rax+88]
	mov	rax, QWORD PTR [rax+96]
	add	rcx, rcx

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rax+rcx*8-12]
	movss	xmm1, DWORD PTR [rax+rcx*8-8]
	movss	xmm2, DWORD PTR [rax+rcx*8-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5089 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	eax, DWORD PTR [rax+rcx*8-16]
	mov	DWORD PTR [rsi+624], eax
	movss	DWORD PTR [rsi+628], xmm0
	movss	DWORD PTR [rsi+632], xmm1
	movss	DWORD PTR [rsi+636], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7027 :     window->DC.CursorPos = window->DC.CursorMaxPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);

	addss	xmm6, DWORD PTR [rbx+412]
	addss	xmm7, DWORD PTR [rbx+416]

; 7028 :     window->DC.LayoutType = ImGuiLayoutType_Horizontal;

	mov	DWORD PTR [rbx+492], 0

; 7029 :     window->DC.IsSameLine = false;

	mov	BYTE PTR [rbx+376], 0

; 7030 :     window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;

	mov	DWORD PTR [rbx+400], 1
	movss	DWORD PTR [rbx+336], xmm6
	movss	DWORD PTR [rbx+340], xmm7
	movss	DWORD PTR [rbx+312], xmm6
	movss	DWORD PTR [rbx+316], xmm7

; 7031 :     window->DC.MenuBarAppending = true;

	mov	BYTE PTR [rbx+411], 1

; 7032 :     AlignTextToFramePadding();

	call	?AlignTextToFramePadding@ImGui@@YAXXZ	; ImGui::AlignTextToFramePadding

; 7033 :     return true;

	movaps	xmm7, XMMWORD PTR [rsp+80]
	mov	al, 1
	movaps	xmm6, XMMWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+144]
	mov	rsi, QWORD PTR [rsp+136]
	mov	rbp, QWORD PTR [rsp+128]

; 7034 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
$LN77@BeginMenuB:

; 7013 :         return false;

	xor	al, al

; 7034 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rbx
	ret	0
?BeginMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Spacing@ImGui@@YAXXZ
_TEXT	SEGMENT
$T1 = 48
?Spacing@ImGui@@YAXXZ PROC				; ImGui::Spacing, COMDAT

; 1342 : {

$LN9:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1344 :     if (window->SkipItems)

	mov	rax, QWORD PTR [rcx+16408]
	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN1@Spacing

; 1346 :     ItemSize(ImVec2(0, 0));

	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T1[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1346 :     ItemSize(ImVec2(0, 0));

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
$LN1@Spacing:

; 1347 : }

	add	rsp, 40					; 00000028H
	ret	0
?Spacing@ImGui@@YAXXZ ENDP				; ImGui::Spacing
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?AlignTextToFramePadding@ImGui@@YAXXZ
_TEXT	SEGMENT
?AlignTextToFramePadding@ImGui@@YAXXZ PROC		; ImGui::AlignTextToFramePadding, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1380 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN1@AlignTextT

; 1384 :     window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);

	movss	xmm1, DWORD PTR [rcx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rax+356]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1384 :     window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);

	addss	xmm1, xmm1
	addss	xmm1, DWORD PTR [rcx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
	movss	xmm1, DWORD PTR [rax+368]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1384 :     window->DC.CurrLineSize.y = ImMax(window->DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);

	movss	DWORD PTR [rax+356], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, DWORD PTR [rcx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1385 :     window->DC.CurrLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);

	movss	DWORD PTR [rax+368], xmm1
$LN1@AlignTextT:

; 1386 : }

	ret	0
?AlignTextToFramePadding@ImGui@@YAXXZ ENDP		; ImGui::AlignTextToFramePadding
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?EndCombo@ImGui@@YAXXZ
_TEXT	SEGMENT
?EndCombo@ImGui@@YAXXZ PROC				; ImGui::EndCombo, COMDAT

; 1818 :     EndPopup();

	jmp	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
?EndCombo@ImGui@@YAXXZ ENDP				; ImGui::EndCombo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??D@YA?AUImVec2@@AEBU0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*, COMDAT

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm2
	mov	rax, rcx
	mulss	xmm0, DWORD PTR [rdx]
	mulss	xmm2, DWORD PTR [rdx+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm2

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	ret	0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??H@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+, COMDAT

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm0, DWORD PTR [r8]
	addss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	ret	0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??G@YA?AUImVec2@@AEBU0@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-, COMDAT

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [r8]
	subss	xmm1, DWORD PTR [r8+4]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	ret	0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator+=, COMDAT

; 2545 : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [rcx]
	mov	rax, rcx
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	addss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??Y@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator-=, COMDAT

; 2546 : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [rcx]
	mov	rax, rcx
	subss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx], xmm0
	subss	xmm1, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
uv$ = 24
col$ = 32
?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC		; ImDrawList::PrimVtx, COMDAT

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	movzx	eax, WORD PTR [rcx+52]
	mov	r10, QWORD PTR [rcx+80]

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movsd	xmm1, QWORD PTR [r8]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [r10], ax

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	rax, QWORD PTR [rcx+72]

; 2839 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }

	add	QWORD PTR [rcx+80], 2

; 2838 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rax], xmm0
	mov	rax, QWORD PTR [rcx+72]
	movsd	QWORD PTR [rax+8], xmm1
	mov	rax, QWORD PTR [rcx+72]
	mov	DWORD PTR [rax+16], r9d
	add	QWORD PTR [rcx+72], 20
	inc	DWORD PTR [rcx+52]

; 2840 :     inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)         { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); } // Write vertex with unique index

	ret	0
?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP		; ImDrawList::PrimVtx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?GetCharAdvance@ImFont@@QEBAMG@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
?GetCharAdvance@ImFont@@QEBAMG@Z PROC			; ImFont::GetCharAdvance, COMDAT

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	movzx	eax, dx
	cmp	eax, DWORD PTR [rcx]
	jge	SHORT $LN3@GetCharAdv
	mov	rax, QWORD PTR [rcx+8]

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movzx	edx, dx

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	movss	xmm0, DWORD PTR [rax+rdx*4]
	ret	0
$LN3@GetCharAdv:
	movss	xmm0, DWORD PTR [rcx+16]
	ret	0
?GetCharAdvance@ImFont@@QEBAMG@Z ENDP			; ImFont::GetCharAdvance
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z
_TEXT	SEGMENT
base$ = 8
count$ = 16
size_of_element$ = 24
compare_func$ = 32
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z PROC			; ImQsort, COMDAT

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	rdx, 1
	jbe	SHORT $LN2@ImQsort
	rex_jmp	QWORD PTR __imp_qsort
$LN2@ImQsort:
	ret	0
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z ENDP			; ImQsort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankA@@YA_ND@Z
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA, COMDAT

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	cl, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	cl, 9
	je	SHORT $LN3@ImCharIsBl
	xor	al, al
	ret	0
$LN3@ImCharIsBl:
	mov	al, 1
	ret	0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImCharIsBlankW@@YA_NI@Z
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW, COMDAT

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN3@ImCharIsBl
	cmp	ecx, 9
	je	SHORT $LN3@ImCharIsBl
	cmp	ecx, 12288				; 00003000H
	je	SHORT $LN3@ImCharIsBl
	xor	al, al
	ret	0
$LN3@ImCharIsBl:
	mov	al, 1
	ret	0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImPow@@YAMMM@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?ImPow@@YAMMM@Z PROC					; ImPow, COMDAT

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	jmp	powf
?ImPow@@YAMMM@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImPow@@YANNN@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?ImPow@@YANNN@Z PROC					; ImPow, COMDAT

; 437  : static inline double ImPow(double x, double y)  { return pow(x, y); }

	jmp	pow
?ImPow@@YANNN@Z ENDP					; ImPow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLog@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?ImLog@@YAMM@Z PROC					; ImLog, COMDAT

; 438  : static inline float  ImLog(float x)             { return logf(x); }             // DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision

	jmp	logf
?ImLog@@YAMM@Z ENDP					; ImLog
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLog@@YANN@Z
_TEXT	SEGMENT
x$ = 8
?ImLog@@YANN@Z PROC					; ImLog, COMDAT

; 439  : static inline double ImLog(double x)            { return log(x); }

	jmp	log
?ImLog@@YANN@Z ENDP					; ImLog
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImAbs@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAMM@Z PROC					; ImAbs, COMDAT
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 441  : static inline float  ImAbs(float x)             { return fabsf(x); }

	ret	0
?ImAbs@@YAMM@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImAbs@@YANN@Z
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YANN@Z PROC					; ImAbs, COMDAT

; 442  : static inline double ImAbs(double x)            { return fabs(x); }

	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	ret	0
?ImAbs@@YANN@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImMax@@YA?AUImVec2@@AEBU1@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
?ImMax@@YA?AUImVec2@@AEBU1@0@Z PROC			; ImMax, COMDAT

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm1, DWORD PTR [rdx+4]
	maxss	xmm0, DWORD PTR [r8]
	maxss	xmm1, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	ret	0
?ImMax@@YA?AUImVec2@@AEBU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
b$ = 24
t$ = 32
?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z PROC			; ImLerp, COMDAT

; 465  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

	movss	xmm1, DWORD PTR [r8]
	mov	rax, rcx
	subss	xmm1, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8+4]
	subss	xmm0, DWORD PTR [rdx+4]
	mulss	xmm1, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, DWORD PTR [rdx]
	addss	xmm0, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 465  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }

	ret	0
?ImLerp@@YA?AUImVec2@@AEBU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImSaturate@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?ImSaturate@@YAMM@Z PROC				; ImSaturate, COMDAT

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movaps	xmm1, xmm0
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	ja	SHORT $LN6@ImSaturate
	movss	xmm0, DWORD PTR __real@3f800000
	minss	xmm0, xmm1
$LN6@ImSaturate:
	ret	0
?ImSaturate@@YAMM@Z ENDP				; ImSaturate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLengthSqr@@YAMAEBUImVec2@@@Z
_TEXT	SEGMENT
lhs$ = 8
?ImLengthSqr@@YAMAEBUImVec2@@@Z PROC			; ImLengthSqr, COMDAT

; 469  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }

	movss	xmm1, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rcx]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
	ret	0
?ImLengthSqr@@YAMAEBUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YA?AUImVec2@@AEBU1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
v$ = 16
?ImFloor@@YA?AUImVec2@@AEBU1@@Z PROC			; ImFloor, COMDAT

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvttss2si eax, DWORD PTR [rdx]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [rdx+4]
	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	mov	rax, rcx
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	ret	0
?ImFloor@@YA?AUImVec2@@AEBU1@@Z ENDP			; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
v$ = 16
cos_a$ = 24
sin_a$ = 32
?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z PROC			; ImRotate, COMDAT

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	movss	xmm4, DWORD PTR [rdx]
	mov	rax, rcx
	movss	xmm5, DWORD PTR [rdx+4]
	movaps	xmm1, xmm4
	movaps	xmm0, xmm5
	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
	mulss	xmm5, xmm2
	mulss	xmm4, xmm3
	subss	xmm1, xmm0
	addss	xmm5, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 478  : static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }

	ret	0
?ImRotate@@YA?AUImVec2@@AEBU1@MM@Z ENDP			; ImRotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImLinearSweep@@YAMMMM@Z
_TEXT	SEGMENT
current$ = 8
target$ = 16
speed$ = 24
?ImLinearSweep@@YAMMMM@Z PROC				; ImLinearSweep, COMDAT

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN2@ImLinearSw
	addss	xmm0, xmm2

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm1

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	ret	0
$LN2@ImLinearSw:
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@ImLinearSw
	subss	xmm0, xmm2

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
$LN3@ImLinearSw:

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	ret	0
?ImLinearSweep@@YAMMMM@Z ENDP				; ImLinearSweep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetArea@ImRect@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?GetArea@ImRect@@QEBAMXZ PROC				; ImRect::GetArea, COMDAT

; 531  :     float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }

	movss	xmm0, DWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR [rcx+8]
	subss	xmm0, DWORD PTR [rcx+4]
	subss	xmm1, DWORD PTR [rcx]
	mulss	xmm0, xmm1
	ret	0
?GetArea@ImRect@@QEBAMXZ ENDP				; ImRect::GetArea
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetTL@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetTL@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetTL, COMDAT

; 532  :     ImVec2      GetTL() const                       { return Min; }                   // Top-left

	movsd	xmm0, QWORD PTR [rcx]
	mov	rax, rdx
	movsd	QWORD PTR [rdx], xmm0
	ret	0
?GetTL@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetTL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QEBA?AUImVec2@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetTR@ImRect@@QEBA?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 533  :     ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right

	mov	rax, rdx
	ret	0
?GetTR@ImRect@@QEBA?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ PROC	; ImGuiInputTextState::CursorAnimReset, COMDAT

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rcx+3712], -1097229926	; be99999aH
	ret	0
?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ ENDP	; ImGuiInputTextState::CursorAnimReset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?CursorClamp@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?CursorClamp@ImGuiInputTextState@@QEAAXXZ PROC		; ImGuiInputTextState::CursorClamp, COMDAT

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	r8d, DWORD PTR [rcx+12]

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edx, r8d
	cmp	DWORD PTR [rcx+84], r8d
	cmovl	edx, DWORD PTR [rcx+84]
	cmp	DWORD PTR [rcx+88], r8d

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rcx+84], edx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edx, r8d
	cmovl	edx, DWORD PTR [rcx+88]
	cmp	DWORD PTR [rcx+92], r8d

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rcx+88], edx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmovl	r8d, DWORD PTR [rcx+92]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rcx+92], r8d
	ret	0
?CursorClamp@ImGuiInputTextState@@QEAAXXZ ENDP		; ImGuiInputTextState::CursorClamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?HasSelection@ImGuiInputTextState@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?HasSelection@ImGuiInputTextState@@QEBA_NXZ PROC	; ImGuiInputTextState::HasSelection, COMDAT

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rcx+92]
	cmp	DWORD PTR [rcx+88], eax
	setne	al
	ret	0
?HasSelection@ImGuiInputTextState@@QEBA_NXZ ENDP	; ImGuiInputTextState::HasSelection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ClearSelection@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?ClearSelection@ImGuiInputTextState@@QEAAXXZ PROC	; ImGuiInputTextState::ClearSelection, COMDAT

; 1124 :     void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }

	mov	eax, DWORD PTR [rcx+84]
	mov	DWORD PTR [rcx+92], eax
	mov	DWORD PTR [rcx+88], eax
	ret	0
?ClearSelection@ImGuiInputTextState@@QEAAXXZ ENDP	; ImGuiInputTextState::ClearSelection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?SelectAll@ImGuiInputTextState@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?SelectAll@ImGuiInputTextState@@QEAAXXZ PROC		; ImGuiInputTextState::SelectAll, COMDAT

; 1128 :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+92], eax
	mov	DWORD PTR [rcx+84], eax
	mov	DWORD PTR [rcx+88], 0
	mov	BYTE PTR [rcx+106], 0
	ret	0
?SelectAll@ImGuiInputTextState@@QEAAXXZ ENDP		; ImGuiInputTextState::SelectAll
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ClearFlags@ImGuiNextItemData@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?ClearFlags@ImGuiNextItemData@@QEAAXXZ PROC		; ImGuiNextItemData::ClearFlags, COMDAT

; 1207 :     inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; ItemFlags = ImGuiItemFlags_None; } // Also cleared manually by ItemAdd()!

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?ClearFlags@ImGuiNextItemData@@QEAAXXZ ENDP		; ImGuiNextItemData::ClearFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiPtrOrIndex@@QEAA@PEAX@Z
_TEXT	SEGMENT
this$ = 8
ptr$ = 16
??0ImGuiPtrOrIndex@@QEAA@PEAX@Z PROC			; ImGuiPtrOrIndex::ImGuiPtrOrIndex, COMDAT

; 1270 :     ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	DWORD PTR [rcx+8], -1
	ret	0
??0ImGuiPtrOrIndex@@QEAA@PEAX@Z ENDP			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiPtrOrIndex@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??0ImGuiPtrOrIndex@@QEAA@H@Z PROC			; ImGuiPtrOrIndex::ImGuiPtrOrIndex, COMDAT

; 1271 :     ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }

	mov	QWORD PTR [rcx], 0
	mov	rax, rcx
	mov	DWORD PTR [rcx+8], edx
	ret	0
??0ImGuiPtrOrIndex@@QEAA@H@Z ENDP			; ImGuiPtrOrIndex::ImGuiPtrOrIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ PROC ; ImGuiViewportP::GetBuildWorkRect, COMDAT

; 1806 :     ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }

$LN26:
	sub	rsp, 40					; 00000028H

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movss	xmm2, DWORD PTR [rcx+304]

; 1806 :     ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }

	mov	rax, rdx

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movss	xmm5, DWORD PTR [rcx+308]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	movss	xmm0, DWORD PTR [rcx+312]
	movss	xmm4, DWORD PTR [rcx+20]
	movss	xmm1, DWORD PTR [rcx+16]
	subss	xmm4, xmm5
	movss	xmm3, DWORD PTR [rcx+316]
	subss	xmm1, xmm2
	movaps	XMMWORD PTR [rsp+16], xmm6

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movaps	xmm6, xmm2
	addss	xmm6, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp], xmm7
	xorps	xmm2, xmm2
	movaps	xmm7, xmm5

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	addss	xmm4, xmm3

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	addss	xmm7, DWORD PTR [rcx+12]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rdx], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rdx+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1806 :     ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }

	movaps	xmm7, XMMWORD PTR [rsp]

; 525  :     constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}

	addss	xmm0, xmm6

; 1806 :     ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }

	movaps	xmm6, XMMWORD PTR [rsp+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rdx+12], xmm2
	movss	DWORD PTR [rdx+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1806 :     ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }

	add	rsp, 40					; 00000028H
	ret	0
?GetBuildWorkRect@ImGuiViewportP@@QEBA?AUImRect@@XZ ENDP ; ImGuiViewportP::GetBuildWorkRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTabItem@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTabItem@@QEAA@XZ PROC				; ImGuiTabItem::ImGuiTabItem, COMDAT

; 2700 :     ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+24], rax
	mov	DWORD PTR [rcx+32], eax
	mov	QWORD PTR [rcx+48], rax
	mov	rax, rcx
	mov	QWORD PTR [rcx+16], -1
	mov	QWORD PTR [rcx+36], -1082130432		; ffffffffbf800000H
	mov	DWORD PTR [rcx+44], -1			; ffffffffH
	ret	0
??0ImGuiTabItem@@QEAA@XZ ENDP				; ImGuiTabItem::ImGuiTabItem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?TempInputIsActive@ImGui@@YA_NI@Z
_TEXT	SEGMENT
id$ = 8
?TempInputIsActive@ImGui@@YA_NI@Z PROC			; ImGui::TempInputIsActive, COMDAT

; 3525 :     inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	DWORD PTR [rax+16504], ecx
	jne	SHORT $LN3@TempInputI
	cmp	DWORD PTR [rax+23824], ecx
	jne	SHORT $LN3@TempInputI
	mov	al, 1
	ret	0
$LN3@TempInputI:
	xor	al, al
	ret	0
?TempInputIsActive@ImGui@@YA_NI@Z ENDP			; ImGui::TempInputIsActive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetInputTextState@ImGui@@YAPEAUImGuiInputTextState@@I@Z
_TEXT	SEGMENT
id$ = 8
?GetInputTextState@ImGui@@YAPEAUImGuiInputTextState@@I@Z PROC ; ImGui::GetInputTextState, COMDAT

; 3526 :     inline ImGuiInputTextState* GetInputTextState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL; } // Get input text state if active

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	ecx, ecx
	je	SHORT $LN3@GetInputTe
	cmp	DWORD PTR [rax+19960], ecx
	jne	SHORT $LN3@GetInputTe
	add	rax, 19952				; 00004df0H
	ret	0
$LN3@GetInputTe:
	xor	eax, eax
	ret	0
?GetInputTextState@ImGui@@YAPEAUImGuiInputTextState@@I@Z ENDP ; ImGui::GetInputTextState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextEx@ImGui@@YAXPEBD0H@Z
_TEXT	SEGMENT
text_size$7 = 64
text_size$8 = 64
flags$1$ = 72
pos$9 = 80
text_pos$$sroa$148$1$ = 88
text_size$10 = 96
text_size$11 = 96
text_size$12 = 96
text_size$13 = 96
bb$14 = 96
bb$15 = 96
__$ArrayPad$ = 112
text$ = 352
text_end$ = 360
flags$ = 368
?TextEx@ImGui@@YAXPEBD0H@Z PROC				; ImGui::TextEx, COMDAT

; 147  : {

$LN285:
	mov	r11, rsp
	push	rbp
	push	rsi
	push	r12
	lea	rbp, QWORD PTR [r11-88]
	sub	rsp, 320				; 00000140H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 147  : {

	mov	r9, rcx
	mov	r12d, r8d
	mov	DWORD PTR flags$1$[rsp], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rcx, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 149  :     if (window->SkipItems)

	cmp	BYTE PTR [rcx+240], 0
	jne	$LN171@TextEx
	mov	QWORD PTR [r11+24], rbx

; 150  :         return;
; 151  :     ImGuiContext& g = *GImGui;
; 152  : 
; 153  :     // Accept null ranges
; 154  :     if (text == text_end)
; 155  :         text = text_end = "";
; 156  : 
; 157  :     // Calculate length
; 158  :     const char* text_begin = text;

	cmp	r9, rdx
	mov	QWORD PTR [r11-32], rdi
	lea	rbx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	movaps	XMMWORD PTR [r11-72], xmm6
	mov	rdi, rbx
	movaps	XMMWORD PTR [r11-104], xmm8
	cmovne	rdi, rdx
	cmovne	rbx, r9
	movaps	XMMWORD PTR [r11-184], xmm13
	movaps	XMMWORD PTR [r11-216], xmm15

; 159  :     if (text_end == NULL)

	test	rdi, rdi
	jne	SHORT $LN10@TextEx

; 160  :         text_end = text + strlen(text); // FIXME-OPT

	mov	rdi, -1
	npad	8
$LL227@TextEx:
	inc	rdi
	cmp	BYTE PTR [rbx+rdi], 0
	jne	SHORT $LL227@TextEx
	add	rdi, rbx
$LN10@TextEx:

; 161  : 
; 162  :     const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
; 163  :     const float wrap_pos_x = window->DC.TextWrapPos;

	movss	xmm6, DWORD PTR [rcx+504]
	xorps	xmm8, xmm8
	movss	xmm15, DWORD PTR [rcx+368]

; 165  :     if (text_end - text <= 2000 || wrap_enabled)

	mov	rax, rdi
	addss	xmm15, DWORD PTR [rcx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm13, DWORD PTR [rcx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 164  :     const bool wrap_enabled = (wrap_pos_x >= 0.0f);

	comiss	xmm6, xmm8
	mov	QWORD PTR [rsp+304], r13
	movaps	XMMWORD PTR [rsp+256], xmm7
	movss	DWORD PTR text_pos$$sroa$148$1$[rsp], xmm15
	setae	dl
	movaps	XMMWORD PTR [rsp+224], xmm9

; 165  :     if (text_end - text <= 2000 || wrap_enabled)

	sub	rax, rbx
	cmp	rax, 2000				; 000007d0H
	jle	$LN13@TextEx
	test	dl, dl
	jne	$LN220@TextEx

; 192  :         if (!g.LogEnabled)

	movss	xmm9, DWORD PTR __real@3f7fff58
	xor	r13d, r13d
	xorps	xmm6, xmm6
	movaps	XMMWORD PTR [rsp+176], xmm12
	movaps	xmm7, xmm15
	movss	xmm12, DWORD PTR [rsi+15696]
	movaps	XMMWORD PTR [rsp+144], xmm14
	movss	xmm14, DWORD PTR __real@7f7fffff
	mov	QWORD PTR [rsp+296], r14
	mov	QWORD PTR [rsp+288], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR text_size$7[rsp], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 191  :         ImVec2 pos = text_pos;

	movss	DWORD PTR pos$9[rsp], xmm13

; 192  :         if (!g.LogEnabled)

	movss	DWORD PTR pos$9[rsp+4], xmm7
	cmp	BYTE PTR [rsi+24256], r13b
	jne	$LN16@TextEx

; 193  :         {
; 194  :             int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);

	movss	xmm0, DWORD PTR [rcx+628]
	subss	xmm0, xmm15
	movss	DWORD PTR pos$9[rsp+4], xmm7
	divss	xmm0, xmm12
	cvttss2si r12d, xmm0

; 195  :             if (lines_skippable > 0)

	test	r12d, r12d
	jle	$LN234@TextEx

; 196  :             {
; 197  :                 int lines_skipped = 0;

	mov	r15d, r13d

; 198  :                 while (line < text_end && lines_skipped < lines_skippable)

	cmp	rbx, rdi
	jae	$LN3@TextEx
	movss	xmm7, DWORD PTR __real@bf800000
$LL2@TextEx:
	cmp	r15d, r12d
	jge	$LN233@TextEx

; 199  :                 {
; 200  :                     const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, rbx
	mov	rcx, rbx
	call	memchr

; 201  :                     if (!line_end)

	test	rax, rax
	mov	r14, rax
	cmove	r14, rdi

; 202  :                         line_end = text_end;
; 203  :                     if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)

	test	BYTE PTR flags$1$[rsp], 1
	jne	SHORT $LN144@TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	cmp	rbx, r14
	jne	SHORT $LN131@TextEx

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm0, xmm8
	jmp	SHORT $LN128@TextEx
$LN131@TextEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$10[rsp]
	mov	rcx, QWORD PTR [rsi+15688]
	movaps	xmm3, xmm14
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rbx
	movss	DWORD PTR [rsp+32], xmm7
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$10[rsp]
	addss	xmm0, xmm9
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR text_size$10[rsp], xmm0
$LN128@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm6, xmm0
	jae	SHORT $LN144@TextEx
	movaps	xmm6, xmm0
$LN144@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 205  :                     line = line_end + 1;

	lea	rbx, QWORD PTR [r14+1]

; 206  :                     lines_skipped++;

	inc	r15d
	cmp	rbx, rdi
	jb	$LL2@TextEx
$LN233@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR text_size$7[rsp], xmm6
$LN3@TextEx:
	movd	xmm7, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 208  :                 pos.y += lines_skipped * line_height;

	cvtdq2ps xmm7, xmm7
	mulss	xmm7, xmm12
	addss	xmm7, xmm15
	movss	DWORD PTR pos$9[rsp+4], xmm7
$LN234@TextEx:

; 213  :         if (line < text_end)

	mov	r12d, DWORD PTR flags$1$[rsp]
$LN16@TextEx:
	cmp	rbx, rdi
	jae	$LN19@TextEx
	movaps	XMMWORD PTR [rsp+208], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm9, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 213  :         if (line < text_end)

	movaps	XMMWORD PTR [rsp+192], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm9, xmm12
	movaps	xmm11, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movaps	xmm10, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm11, xmm14
	npad	9
$LL4@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4258 :     if (!bb.Overlaps(window->ClipRect))

	mov	rax, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm9, DWORD PTR [rax+628]
	jbe	SHORT $LN226@TextEx
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm10
	jbe	SHORT $LN226@TextEx
	comiss	xmm11, DWORD PTR [rax+624]
	jbe	SHORT $LN226@TextEx
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm13
	ja	SHORT $LN33@TextEx
$LN226@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4260 :             if (!g.LogEnabled)

	cmp	BYTE PTR [rsi+24256], r13b
	je	$LN225@TextEx
$LN33@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 221  :                 const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, rbx
	mov	rcx, rbx
	call	memchr

; 222  :                 if (!line_end)

	test	rax, rax
	mov	r14, rax
	cmove	r14, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	cmp	rbx, r14
	jne	SHORT $LN42@TextEx

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm0, xmm8
	jmp	SHORT $LN39@TextEx
$LN42@TextEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$13[rsp]
	movss	xmm2, DWORD PTR [rsi+15696]
	movaps	xmm3, xmm14
	mov	rcx, QWORD PTR [rsi+15688]
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rbx
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$13[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR text_size$13[rsp], xmm0
$LN39@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm6, xmm0
	jae	SHORT $LN55@TextEx
	movss	DWORD PTR text_size$7[rsp], xmm0
	movaps	xmm6, xmm0
$LN55@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 225  :                 RenderText(pos, line, line_end, false);

	mov	rcx, QWORD PTR pos$9[rsp]
	xor	r9d, r9d
	mov	r8, r14
	mov	rdx, rbx
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 226  :                 line = line_end + 1;
; 227  :                 line_rect.Min.y += line_height;
; 228  :                 line_rect.Max.y += line_height;
; 229  :                 pos.y += line_height;

	addss	xmm7, xmm12
	lea	rbx, QWORD PTR [r14+1]
	addss	xmm10, xmm12
	addss	xmm9, xmm12
	movss	DWORD PTR pos$9[rsp+4], xmm7
	cmp	rbx, rdi
	jb	$LL4@TextEx
$LN225@TextEx:

; 230  :             }
; 231  : 
; 232  :             // Count remaining lines
; 233  :             int lines_skipped = 0;

	movaps	xmm11, XMMWORD PTR [rsp+192]
	mov	r15d, r13d
	movaps	xmm10, XMMWORD PTR [rsp+208]

; 234  :             while (line < text_end)

	cmp	rbx, rdi
	jae	$LN7@TextEx
	movss	xmm15, DWORD PTR __real@bf800000
	and	r12d, 1
	npad	6
$LL6@TextEx:

; 235  :             {
; 236  :                 const char* line_end = (const char*)memchr(line, '\n', text_end - line);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, rbx
	mov	rcx, rbx
	call	memchr

; 237  :                 if (!line_end)

	test	rax, rax
	mov	r14, rax
	cmove	r14, rdi

; 238  :                     line_end = text_end;
; 239  :                 if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)

	test	r12d, r12d
	jne	SHORT $LN117@TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	cmp	rbx, r14
	jne	SHORT $LN104@TextEx

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm0, xmm8
	jmp	SHORT $LN101@TextEx
$LN104@TextEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$11[rsp]
	mov	rcx, QWORD PTR [rsi+15688]
	movaps	xmm3, xmm14
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rbx
	movss	DWORD PTR [rsp+32], xmm15
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$11[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR text_size$11[rsp], xmm0
$LN101@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm6, xmm0
	jae	SHORT $LN117@TextEx
	movaps	xmm6, xmm0
$LN117@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 241  :                 line = line_end + 1;

	lea	rbx, QWORD PTR [r14+1]

; 242  :                 lines_skipped++;

	inc	r15d
	cmp	rbx, rdi
	jb	$LL6@TextEx
	movss	xmm15, DWORD PTR text_pos$$sroa$148$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR text_size$7[rsp], xmm6
$LN7@TextEx:
	movd	xmm0, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 244  :             pos.y += lines_skipped * line_height;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm12
	addss	xmm7, xmm0
$LN19@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm7, xmm15

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm9, xmm13
	addss	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 249  :         ItemSize(text_size, 0.0f);

	movaps	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm6, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 249  :         ItemSize(text_size, 0.0f);

	lea	rcx, QWORD PTR text_size$7[rsp]
	movss	DWORD PTR text_size$7[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 249  :         ItemSize(text_size, 0.0f);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10137:     g.LastItemData.Rect = bb;

	movaps	xmm0, xmm13

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	movaps	xmm14, XMMWORD PTR [rsp+144]
	movaps	xmm12, XMMWORD PTR [rsp+176]
	mov	r15, QWORD PTR [rsp+288]
	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	mov	r14, QWORD PTR [rsp+296]
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm15
	mov	DWORD PTR [r10+18620], eax
	mov	rax, QWORD PTR [r10+16408]
	shufps	xmm0, xmm0, 198				; 000000c6H
	movss	xmm0, xmm9
	mov	DWORD PTR [r10+18616], r13d
	shufps	xmm0, xmm0, 39				; 00000027H
	movss	xmm0, xmm6
	mov	DWORD PTR [r10+18624], r13d
	shufps	xmm0, xmm0, 57				; 00000039H
	movups	XMMWORD PTR [r10+18628], xmm0
	mov	QWORD PTR [r10+18592], r13
	movups	XMMWORD PTR [r10+18644], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm6, DWORD PTR [rax+628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10137:     g.LastItemData.Rect = bb;

	movups	XMMWORD PTR bb$14[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN179@TextEx
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm15
	jbe	SHORT $LN179@TextEx
	comiss	xmm9, DWORD PTR [rax+624]
	jbe	SHORT $LN179@TextEx
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm13
	jbe	SHORT $LN179@TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN170@TextEx
$LN179@TextEx:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], r13b
	je	$LN282@TextEx
$LN170@TextEx:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$14[rsp+8]
	lea	rcx, QWORD PTR bb$14[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	$LN282@TextEx

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
	jmp	$LN282@TextEx
$LN13@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 168  :         const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;

	test	dl, dl
	je	SHORT $LN25@TextEx
$LN220@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4278 :     if (wrap_pos_x < 0.0f)

	comiss	xmm8, xmm6
	ja	SHORT $LN25@TextEx

; 4279 :         return 0.0f;
; 4280 : 
; 4281 :     ImGuiContext& g = *GImGui;
; 4282 :     ImGuiWindow* window = g.CurrentWindow;
; 4283 :     if (wrap_pos_x == 0.0f)

	ucomiss	xmm6, xmm8
	jp	SHORT $LN120@TextEx
	jne	SHORT $LN120@TextEx

; 4284 :     {
; 4285 :         // We could decide to setup a default wrapping max point for auto-resizing windows,
; 4286 :         // or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
; 4287 :         //if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
; 4288 :         //    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
; 4289 :         //else
; 4290 :         wrap_pos_x = window->WorkRect.Max.x;

	movss	xmm6, DWORD PTR [rcx+600]

; 4295 :     }
; 4296 : 
; 4297 :     return ImMax(wrap_pos_x - pos.x, 1.0f);

	subss	xmm6, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm6, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4298 : }

	jmp	SHORT $LN26@TextEx
$LN120@TextEx:

; 4291 :     }
; 4292 :     else if (wrap_pos_x > 0.0f)

	comiss	xmm6, xmm8
	jbe	SHORT $LN122@TextEx

; 4293 :     {
; 4294 :         wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

	movss	xmm0, DWORD PTR [rcx+80]
	subss	xmm0, DWORD PTR [rcx+184]
	addss	xmm0, xmm6
	movaps	xmm6, xmm0
$LN122@TextEx:

; 4295 :     }
; 4296 : 
; 4297 :     return ImMax(wrap_pos_x - pos.x, 1.0f);

	subss	xmm6, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm6, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4298 : }

	jmp	SHORT $LN26@TextEx
$LN25@TextEx:

; 5417 :     const float font_size = g.FontSize;

	xorps	xmm6, xmm6
$LN26@TextEx:
	movss	xmm9, DWORD PTR [rsi+15696]

; 5418 :     if (text == text_display_end)

	xor	r13d, r13d
	cmp	rbx, rdi
	jne	SHORT $LN61@TextEx
	xorps	xmm7, xmm7

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN283@TextEx
$LN61@TextEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm3, DWORD PTR __real@7f7fffff
	lea	rdx, QWORD PTR text_size$12[rsp]
	mov	rcx, QWORD PTR [rsi+15688]
	movaps	xmm2, xmm9
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rbx
	movss	DWORD PTR [rsp+32], xmm6
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$12[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm9, DWORD PTR text_size$12[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm7, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm7, xmm7
$LN283@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	DWORD PTR text_size$8[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 172  :         ItemSize(text_size, 0.0f);

	lea	rcx, QWORD PTR text_size$8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	DWORD PTR text_size$8[rsp], xmm7
	addss	xmm9, xmm15
	xorps	xmm1, xmm1
	addss	xmm7, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 172  :         ItemSize(text_size, 0.0f);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10137:     g.LastItemData.Rect = bb;

	movaps	xmm8, xmm13
	shufps	xmm8, xmm8, 225				; 000000e1H
	movss	xmm8, xmm15
	shufps	xmm8, xmm8, 198				; 000000c6H

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	movss	xmm8, xmm7
	or	eax, DWORD PTR [r10+18596]
	shufps	xmm8, xmm8, 39				; 00000027H
	mov	DWORD PTR [r10+18620], eax
	movss	xmm8, xmm9

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	shufps	xmm8, xmm8, 57				; 00000039H
	movups	XMMWORD PTR [r10+18628], xmm8
	mov	DWORD PTR [r10+18616], r13d
	movups	XMMWORD PTR [r10+18644], xmm8
	mov	DWORD PTR [r10+18624], r13d
	mov	QWORD PTR [r10+18592], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm9, DWORD PTR [rax+628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10137:     g.LastItemData.Rect = bb;

	movups	XMMWORD PTR bb$15[rsp], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN99@TextEx
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm15
	jbe	SHORT $LN99@TextEx
	comiss	xmm7, DWORD PTR [rax+624]
	jbe	SHORT $LN99@TextEx
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm13
	jbe	SHORT $LN99@TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN90@TextEx
$LN99@TextEx:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], r13b
	je	SHORT $LN282@TextEx
$LN90@TextEx:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$15[rsp+8]
	lea	rcx, QWORD PTR bb$15[rsp]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN91@TextEx

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN91@TextEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 177  :         RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);

	movaps	xmm3, xmm6
	mov	r8, rdi
	mov	rdx, rbx
	movq	rcx, xmm8
	call	?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z ; ImGui::RenderTextWrapped
$LN282@TextEx:
	movaps	xmm7, XMMWORD PTR [rsp+256]
	movaps	xmm9, XMMWORD PTR [rsp+224]
	mov	r13, QWORD PTR [rsp+304]
	movaps	xmm8, XMMWORD PTR [rsp+240]
	movaps	xmm6, XMMWORD PTR [rsp+272]
	movaps	xmm13, XMMWORD PTR [rsp+160]
	mov	rdi, QWORD PTR [rsp+312]
	mov	rbx, QWORD PTR [rsp+368]
	movaps	xmm15, XMMWORD PTR [rsp+128]
$LN171@TextEx:

; 250  :         ItemAdd(bb, 0);
; 251  :     }
; 252  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 320				; 00000140H
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
?TextEx@ImGui@@YAXPEBD0H@Z ENDP				; ImGui::TextEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z
_TEXT	SEGMENT
backup$1 = 32
col$ = 80
fmt$ = 88
args$ = 96
?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z PROC	; ImGui::TextColoredV, COMDAT

; 287  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 287  : {

	mov	rbp, rdx
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$1[rsp], 0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 287  : {

	mov	rsi, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+14776]

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR backup$1[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 289  :     TextV(fmt, args);

	mov	rdx, rsi
	mov	rcx, rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	movups	XMMWORD PTR [rbx+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 289  :     TextV(fmt, args);

	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [r8+18824]
	cmp	eax, 1
	jl	SHORT $LN11@TextColore
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3153 :         g.ColorStack.pop_back();

	lea	rdx, QWORD PTR [rax+rax*4]
	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
$LN11@TextColore:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 291  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z ENDP	; ImGui::TextColoredV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TextWrappedV@ImGui@@YAXPEBDPEAD@Z
_TEXT	SEGMENT
fmt$ = 48
args$ = 56
?TextWrappedV@ImGui@@YAXPEBDPEAD@Z PROC			; ImGui::TextWrappedV, COMDAT

; 318  : {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 319  :     ImGuiContext& g = *GImGui;
; 320  :     const bool need_backup = (g.CurrentWindow->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xorps	xmm0, xmm0
	mov	rbx, rdx
	mov	rdi, rcx
	mov	r8, QWORD PTR [rax+16408]
	comiss	xmm0, DWORD PTR [r8+504]
	seta	al

; 321  :     if (need_backup)

	test	al, al
	je	SHORT $LN2@TextWrappe

; 322  :         PushTextWrapPos(0.0f);

	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos
	mov	rdx, rbx
	mov	rcx, rdi
	call	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+528]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7792 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();

	mov	rax, QWORD PTR [r8+536]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+528], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7792 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();

	mov	DWORD PTR [r8+504], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 326  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@TextWrappe:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 323  :     TextV(fmt, args);

	jmp	?TextV@ImGui@@YAXPEBDPEAD@Z		; ImGui::TextV
?TextWrappedV@ImGui@@YAXPEBDPEAD@Z ENDP			; ImGui::TextWrappedV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z
_TEXT	SEGMENT
hovered$ = 64
held$ = 65
text_size$2 = 72
$T3 = 72
size$ = 72
label_size$ = 80
c$4 = 88
$T5 = 88
bb$ = 104
__$ArrayPad$ = 120
label$ = 208
size_arg$ = 216
flags$ = 224
?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z PROC		; ImGui::ButtonEx, COMDAT

; 681  : {

$LN64:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 681  : {

	mov	r15d, r8d
	mov	r13, rdx
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r14, QWORD PTR [rdi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 683  :     if (window->SkipItems)

	cmp	BYTE PTR [r14+240], 0
	jne	$LN47@ButtonEx

; 688  :     const ImGuiID id = window->GetID(label);

	mov	rdx, rcx
	movaps	XMMWORD PTR [r11-56], xmm7
	mov	rcx, r14
	movaps	XMMWORD PTR [r11-72], xmm8
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 688  :     const ImGuiID id = window->GetID(label);

	mov	r12d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rsi

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rsi, -1
	jae	SHORT $LN49@ButtonEx
	npad	4
$LL17@ButtonEx:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN49@ButtonEx
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN46@ButtonEx
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN49@ButtonEx
$LN46@ButtonEx:

; 3332 :         text_display_end++;

	mov	rdx, rcx
	cmp	rcx, -1
	jb	SHORT $LL17@ButtonEx
$LN49@ButtonEx:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm1, DWORD PTR [r9+15696]

; 5418 :     if (text == text_display_end)

	xor	ebx, ebx
	cmp	rsi, rdx
	jne	SHORT $LN14@ButtonEx
	xorps	xmm4, xmm4

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN61@ButtonEx
$LN14@ButtonEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movaps	xmm2, xmm1
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [r9+15688]
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR text_size$2[rbp-105]
	mov	QWORD PTR [rsp+40], rsi
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$2[rbp-105]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm1, DWORD PTR text_size$2[rbp-101]
	cvttss2si eax, xmm0
	movd	xmm4, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm4, xmm4
$LN61@ButtonEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 691  :     ImVec2 pos = window->DC.CursorPos;

	movss	xmm8, DWORD PTR [r14+312]
	movss	xmm7, DWORD PTR [r14+316]
	movss	DWORD PTR label_size$[rbp-101], xmm1
	movss	DWORD PTR label_size$[rbp-105], xmm4

; 692  :     if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)

	bt	r15d, 15
	jae	SHORT $LN3@ButtonEx
	movss	xmm2, DWORD PTR [rdi+14616]
	movss	xmm0, DWORD PTR [r14+368]
	comiss	xmm0, xmm2
	jbe	SHORT $LN3@ButtonEx

; 693  :         pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;

	subss	xmm0, xmm2
	addss	xmm7, xmm0
$LN3@ButtonEx:

; 694  :     ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	movss	xmm2, DWORD PTR [rdi+14612]
	lea	rcx, QWORD PTR size$[rbp-105]
	movss	xmm3, DWORD PTR [rdi+14616]
	addss	xmm2, xmm2
	mov	rdx, QWORD PTR [r13]
	addss	xmm3, xmm3
	addss	xmm2, xmm4
	addss	xmm3, xmm1
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize

; 697  :     ItemSize(size, style.FramePadding.y);

	movss	xmm1, DWORD PTR [rdi+14616]
	lea	rcx, QWORD PTR size$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-105], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR size$[rbp-105]
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-101], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm0, DWORD PTR size$[rbp-101]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-97], xmm2
	movss	DWORD PTR bb$[rbp-93], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 697  :     ItemSize(size, style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 698  :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rbp-105]
	mov	edx, r12d
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	movaps	xmm8, XMMWORD PTR [rsp+128]
	movaps	xmm7, XMMWORD PTR [rsp+144]
	test	al, al
	je	$LN47@ButtonEx

; 700  : 
; 701  :     bool hovered, held;
; 702  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	lea	r9, QWORD PTR held$[rbp-105]
	mov	DWORD PTR [rsp+32], r15d
	lea	r8, QWORD PTR hovered$[rbp-105]
	mov	edx, r12d
	lea	rcx, QWORD PTR bb$[rbp-105]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior
	movzx	r14d, al

; 703  : 
; 704  :     // Render
; 705  :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	movzx	ecx, BYTE PTR hovered$[rbp-105]
	cmp	BYTE PTR held$[rbp-105], bl
	je	SHORT $LN7@ButtonEx
	test	cl, cl
	je	SHORT $LN62@ButtonEx
	mov	ebx, 23
	jmp	SHORT $LN8@ButtonEx
$LN7@ButtonEx:
	test	cl, cl
$LN62@ButtonEx:
	setne	bl
	add	rbx, 21
$LN8@ButtonEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	lea	rax, QWORD PTR [rbx+14]
	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 706  :     RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$4[rbp-105], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 706  :     RenderNavHighlight(bb, id);

	lea	rcx, QWORD PTR bb$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	DWORD PTR c$4[rbp-93], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 706  :     RenderNavHighlight(bb, id);

	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rbp-105]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 707  :     RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	movss	xmm0, DWORD PTR [rdi+14620]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 707  :     RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	mov	rdx, QWORD PTR bb$[rbp-97]
	mov	r9b, 1
	mov	rcx, QWORD PTR bb$[rbp-105]
	movss	DWORD PTR [rsp+32], xmm0
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 708  : 
; 709  :     if (g.LogEnabled)

	cmp	BYTE PTR [rdi+24256], 0
	je	SHORT $LN5@ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	lea	rcx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN@
	mov	QWORD PTR [rax+24296], rcx
$LN5@ButtonEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm3, DWORD PTR [rdi+14612]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	lea	rcx, QWORD PTR bb$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm2, DWORD PTR [rdi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	lea	rax, QWORD PTR [rdi+14704]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR bb$[rbp-97]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	lea	rdx, QWORD PTR $T3[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm1, DWORD PTR bb$[rbp-93]
	subss	xmm0, xmm3

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, DWORD PTR bb$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	mov	QWORD PTR [rsp+48], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm2

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, DWORD PTR bb$[rbp-101]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR $T5[rbp-105]
	lea	rax, QWORD PTR label_size$[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rbp-105], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	xor	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-105], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	mov	r8, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rbp-101], xmm1
	movss	DWORD PTR $T5[rbp-101], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 711  :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	mov	QWORD PTR [rsp+32], rax
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped

; 712  : 
; 713  :     // Automatically close popups
; 714  :     //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
; 715  :     //    CloseCurrentPopup();
; 716  : 
; 717  :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
; 718  :     return pressed;

	movzx	eax, r14b
	jmp	SHORT $LN1@ButtonEx
$LN47@ButtonEx:

; 699  :         return false;

	xor	al, al
$LN1@ButtonEx:

; 719  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ENDP		; ImGui::ButtonEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z
_TEXT	SEGMENT
hovered$ = 48
held$ = 49
c$3 = 56
c$4 = 72
size$ = 88
bb$ = 96
__$ArrayPad$ = 112
str_id$ = 240
dir$ = 248
flags$dead$ = 264
?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z PROC	; ImGui::ArrowButtonEx, COMDAT

; 764  : {

$LN45:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 192				; 000000c0H
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax

; 765  :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r15d, edx
	mov	QWORD PTR size$[rbp-137], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rdi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 767  :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN37@ArrowButto

; 770  :     const ImGuiID id = window->GetID(str_id);

	mov	rdx, rcx
	mov	rcx, rbx
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR [rbx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 770  :     const ImGuiID id = window->GetID(str_id);

	mov	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10420:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm1, xmm0
	movss	xmm2, DWORD PTR [rbx+312]
	movss	xmm8, DWORD PTR size$[rbp-133]
	movaps	xmm3, xmm2
	movss	xmm9, DWORD PTR size$[rbp-137]
	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-133], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm3, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm0, DWORD PTR [rax+14616]
	addss	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-137], xmm2
	movss	DWORD PTR bb$[rbp-125], xmm1
	movss	DWORD PTR bb$[rbp-129], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm0, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 773  :     ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0f);

	comiss	xmm8, xmm0
	jb	SHORT $LN5@ArrowButto
	movss	xmm1, DWORD PTR [rdi+14616]
	jmp	SHORT $LN6@ArrowButto
$LN5@ArrowButto:
	movss	xmm1, DWORD PTR __real@bf800000
$LN6@ArrowButto:
	lea	rcx, QWORD PTR size$[rbp-137]
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 774  :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rbp-137]
	mov	edx, esi
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN37@ArrowButto
	mov	QWORD PTR [rsp+248], r14

; 776  : 
; 777  :     bool hovered, held;
; 778  :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	lea	r9, QWORD PTR held$[rbp-137]
	movaps	XMMWORD PTR [rsp+176], xmm6
	lea	r8, QWORD PTR hovered$[rbp-137]
	mov	edx, esi
	movaps	XMMWORD PTR [rsp+160], xmm7
	lea	rcx, QWORD PTR bb$[rbp-137]
	mov	DWORD PTR [rsp+32], 1040		; 00000410H
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 779  : 
; 780  :     // Render
; 781  :     const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	cmp	BYTE PTR held$[rbp-137], 0
	movzx	r14d, al
	movzx	ecx, BYTE PTR hovered$[rbp-137]
	je	SHORT $LN7@ArrowButto
	test	cl, cl
	je	SHORT $LN7@ArrowButto
	mov	eax, 23
	jmp	SHORT $LN8@ArrowButto
$LN7@ArrowButto:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	rax, 21
$LN8@ArrowButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 14
	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 783  :     RenderNavHighlight(bb, id);

	mov	r8d, 1
	mov	edx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	xmm1, DWORD PTR [rcx+14552]
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$3[rbp-137], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR c$3[rbp-125], xmm0

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rcx+14776]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 783  :     RenderNavHighlight(bb, id);

	lea	rcx, QWORD PTR bb$[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$4[rbp-137], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR c$4[rbp-125], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 783  :     RenderNavHighlight(bb, id);

	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$3[rbp-137]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 784  :     RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);

	movss	xmm0, DWORD PTR [rdi+14620]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 784  :     RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);

	mov	rdx, QWORD PTR bb$[rbp-129]
	mov	r9b, 1
	mov	rcx, QWORD PTR bb$[rbp-137]
	movss	DWORD PTR [rsp+32], xmm0
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 785  :     RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

	movss	xmm1, DWORD PTR [rdi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 785  :     RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

	subss	xmm9, xmm1
	xorps	xmm7, xmm7
	subss	xmm8, xmm1
	xorps	xmm6, xmm6
	mulss	xmm9, DWORD PTR __real@3f000000
	mulss	xmm8, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm6, xmm9
	maxss	xmm7, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, DWORD PTR bb$[rbp-137]
	addss	xmm7, DWORD PTR bb$[rbp-133]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 785  :     RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

	movss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm6
	mov	rcx, QWORD PTR [rbx+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 785  :     RenderArrow(window->DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);

	unpcklps xmm1, xmm7
	mov	r9d, r15d
	movq	rdx, xmm1
	movss	DWORD PTR [rsp+32], xmm0
	call	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow

; 786  : 
; 787  :     IMGUI_TEST_ENGINE_ITEM_INFO(id, str_id, g.LastItemData.StatusFlags);
; 788  :     return pressed;

	movaps	xmm7, XMMWORD PTR [rsp+160]
	movzx	eax, r14b
	mov	r14, QWORD PTR [rsp+248]
	movaps	xmm6, XMMWORD PTR [rsp+176]
	jmp	SHORT $LN1@ArrowButto
$LN37@ArrowButto:

; 775  :         return false;

	xor	al, al
$LN1@ArrowButto:

; 789  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ENDP	; ImGui::ArrowButtonEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z
_TEXT	SEGMENT
window$ = 48
axis$ = 56
?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z PROC ; ImGui::GetWindowScrollbarID, COMDAT

; 867  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	r8, QWORD PTR [rcx+304]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 868  :     return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");

	lea	rax, OFFSET FLAT:??_C@_08ENAFOMOP@?$CDSCROLLX@
	test	edx, edx
	lea	rsi, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	mov	rbx, rcx
	cmove	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	xor	edx, edx
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r8+rax*4-4]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr

; 3854 :     ImGuiContext& g = *Ctx;
; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rcx, QWORD PTR [rbx]
	mov	edi, eax
	cmp	DWORD PTR [rcx+16480], eax
	jne	SHORT $LN4@GetWindowS

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	mov	r8, rsi
	mov	edx, 11
	mov	ecx, eax
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 868  :     return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");

	mov	eax, edi
$LN4@GetWindowS:

; 869  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z ENDP ; ImGui::GetWindowScrollbarID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
window$ = 56
axis$ = 64
?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z PROC ; ImGui::GetWindowScrollbarRect, COMDAT

; 873  : {

$LN37:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm5, DWORD PTR [rdx+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 875  :     const ImRect inner_rect = window->InnerRect;

	movups	xmm2, XMMWORD PTR [rdx+560]

; 877  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)

	movsxd	rax, r8d
	movss	xmm4, DWORD PTR [rdx+140]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	movaps	xmm1, xmm5
	addss	xmm1, DWORD PTR [rdx+92]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 877  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)

	xor	rax, 1
	movaps	XMMWORD PTR [rsp+16], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR [rdx+80]
	movaps	XMMWORD PTR [rsp], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	movaps	xmm3, xmm6
	addss	xmm3, DWORD PTR [rdx+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 877  :     const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)

	movss	xmm7, DWORD PTR [rdx+rax*4+224]

; 878  :     IM_ASSERT(scrollbar_size > 0.0f);
; 879  :     if (axis == ImGuiAxis_X)

	mov	rax, rcx
	test	r8d, r8d
	jne	SHORT $LN2@GetWindowS

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	subss	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	shufps	xmm2, xmm2, 170				; 000000aaH
	subss	xmm2, xmm4
	movaps	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 880  :         return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);

	maxss	xmm5, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+4], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 883  : }

	movaps	xmm6, XMMWORD PTR [rsp+16]
	movaps	xmm7, XMMWORD PTR [rsp]
	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetWindowS:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	subss	xmm3, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	shufps	xmm1, xmm2, 85				; 00000055H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	shufps	xmm2, xmm2, 255				; 000000ffH
	subss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+8], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	subss	xmm0, xmm7

; 883  : }

	movaps	xmm7, XMMWORD PTR [rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+12], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 882  :         return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);

	maxss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 883  : }

	movaps	xmm6, XMMWORD PTR [rsp+16]
	add	rsp, 40					; 00000028H
	ret	0
?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z ENDP ; ImGui::GetWindowScrollbarRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z
_TEXT	SEGMENT
held$ = 48
hovered$ = 49
axis$1$ = 52
bb$ = 56
p_scroll_v$GSCopy$1$ = 72
c$1 = 72
c$2 = 72
grab_rect$ = 72
__$ArrayPad$ = 88
bb_frame$ = 304
id$ = 312
axis$ = 320
p_scroll_v$ = 328
size_avail_v$ = 336
size_contents_v$ = 344
flags$ = 352
?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z PROC ; ImGui::ScrollbarEx, COMDAT

; 921  : {

$LN157:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-71]
	sub	rsp, 256				; 00000100H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rax-168], xmm12
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 922  :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r15d, edx
	mov	QWORD PTR p_scroll_v$GSCopy$1$[rsp], r9
	mov	r14, rcx
	mov	DWORD PTR axis$1$[rsp], r8d

; 923  :     ImGuiWindow* window = g.CurrentWindow;

	mov	r13, QWORD PTR [rbx+16408]

; 924  :     if (window->SkipItems)

	cmp	BYTE PTR [r13+240], 0
	jne	$LN4@ScrollbarE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm2, DWORD PTR [rcx+8]
	xorps	xmm6, xmm6
	subss	xmm2, DWORD PTR [rcx]

; 530  :     float       GetHeight() const                   { return Max.y - Min.y; }

	movss	xmm1, DWORD PTR [rcx+12]
	subss	xmm1, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 929  :     if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)

	comiss	xmm6, xmm2
	jae	$LN4@ScrollbarE
	comiss	xmm6, xmm1
	jae	$LN4@ScrollbarE

; 931  : 
; 932  :     // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
; 933  :     float alpha = 1.0f;

	movss	xmm9, DWORD PTR __real@3f800000
	movaps	xmm12, xmm9

; 934  :     if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)

	cmp	r8d, 1
	jne	SHORT $LN6@ScrollbarE
	movss	xmm3, DWORD PTR [rbx+14616]
	movss	xmm4, DWORD PTR [rbx+15696]
	addss	xmm3, xmm3
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	comiss	xmm0, xmm1
	jbe	SHORT $LN6@ScrollbarE

; 935  :         alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));

	movaps	xmm0, xmm1
	subss	xmm0, xmm4
	divss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm0
	ja	$LN4@ScrollbarE
	minss	xmm12, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 936  :     if (alpha <= 0.0f)

	comiss	xmm6, xmm12
	jae	$LN4@ScrollbarE
$LN6@ScrollbarE:

; 943  :     bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm4, DWORD PTR __real@40000000
	movups	xmm0, XMMWORD PTR [rcx]
	mov	QWORD PTR [rsp+320], rsi
	mov	QWORD PTR [rsp+248], rdi
	subss	xmm1, xmm4
	mov	QWORD PTR [rsp+240], r12
	movaps	XMMWORD PTR [rsp+208], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm7, DWORD PTR __real@40400000
	movaps	XMMWORD PTR [rsp+192], xmm8
	movaps	XMMWORD PTR [rsp+160], xmm10
	movaps	XMMWORD PTR [rsp+144], xmm11
	movaps	XMMWORD PTR [rsp+112], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 943  :     bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm13, DWORD PTR __real@3f000000
	comiss	xmm12, xmm9
	mulss	xmm1, xmm13
	setae	r12b
	movaps	XMMWORD PTR [rsp+96], xmm14
	movups	XMMWORD PTR bb$[rsp], xmm0
	cvttss2si eax, xmm1
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm6, xmm3
	jbe	SHORT $LN31@ScrollbarE
	xorps	xmm0, xmm0
	jmp	SHORT $LN32@ScrollbarE
$LN31@ScrollbarE:
	movaps	xmm0, xmm7
	minss	xmm0, xmm3
$LN32@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 943  :     bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm2, xmm4
	xorps	xmm0, xmm3
	mulss	xmm2, xmm13
	cvttss2si eax, xmm2
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm6, xmm1
	jbe	SHORT $LN37@ScrollbarE
	xorps	xmm7, xmm7
	jmp	SHORT $LN38@ScrollbarE
$LN37@ScrollbarE:
	minss	xmm7, xmm1
$LN38@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR bb$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 943  :     bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));

	xorps	xmm7, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm2, DWORD PTR bb$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 542  :     void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	subss	xmm2, xmm0
	addss	xmm7, DWORD PTR bb$[rsp+8]
	addss	xmm0, DWORD PTR bb$[rsp+12]
	movss	DWORD PTR bb$[rsp], xmm1
	movss	DWORD PTR bb$[rsp+4], xmm2
	movss	DWORD PTR bb$[rsp+8], xmm7
	movss	DWORD PTR bb$[rsp+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 946  :     const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();

	test	r8d, r8d
	jne	SHORT $LN15@ScrollbarE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm7, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 946  :     const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();

	jmp	SHORT $LN16@ScrollbarE
$LN15@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 530  :     float       GetHeight() const                   { return Max.y - Min.y; }

	movaps	xmm7, xmm0
	subss	xmm7, xmm2
$LN16@ScrollbarE:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	mov	rsi, QWORD PTR size_avail_v$[rbp-225]
	xorps	xmm1, xmm1
	mov	rdi, QWORD PTR size_contents_v$[rbp-225]
	mov	eax, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 952  :     const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);

	movss	xmm10, DWORD PTR [rbx+14676]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	rdi, rsi
	mov	rcx, rsi
	xorps	xmm0, xmm0
	cmovge	rcx, rdi
	cmp	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 952  :     const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);

	cvtsi2ss xmm1, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmovge	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 952  :     const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);

	cvtsi2ss xmm0, rax
	divss	xmm1, xmm0
	mulss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm10, xmm1
	ja	SHORT $LN58@ScrollbarE
	movaps	xmm10, xmm7
	minss	xmm10, xmm1
$LN58@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 953  :     const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	movaps	xmm11, xmm10

; 954  : 
; 955  :     // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
; 956  :     bool held = false;

	mov	BYTE PTR held$[rsp], 0

; 957  :     bool hovered = false;
; 958  :     ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);

	mov	r9d, 8
	mov	BYTE PTR hovered$[rsp], 0
	xor	r8d, r8d
	mov	rcx, r14
	divss	xmm11, xmm7
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 959  :     ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

	lea	r9, QWORD PTR held$[rsp]
	mov	DWORD PTR [rsp+32], 262144		; 00040000H
	lea	r8, QWORD PTR hovered$[rsp]
	mov	edx, r15d
	lea	rcx, QWORD PTR bb$[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 962  :     float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);

	mov	rdx, QWORD PTR p_scroll_v$GSCopy$1$[rsp]
	sub	rdi, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	rdi, 1
	mov	eax, 1
	cmovle	rdi, rax
	xorps	xmm1, xmm1
	xorps	xmm14, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 962  :     float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);

	cvtsi2ss xmm1, QWORD PTR [rdx]
	cvtsi2ss xmm14, rdi
	divss	xmm1, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm1
	jbe	SHORT $LN65@ScrollbarE
	xorps	xmm0, xmm0
	jmp	SHORT $LN66@ScrollbarE
$LN65@ScrollbarE:
	movaps	xmm0, xmm9
	minss	xmm0, xmm1
$LN66@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 964  :     if (held && allow_interaction && grab_h_norm < 1.0f)

	movzx	esi, BYTE PTR held$[rsp]
	movaps	xmm5, xmm7
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	subss	xmm5, xmm10
	xor	r10d, r10d
	movaps	xmm8, xmm5
	mulss	xmm8, xmm0
	divss	xmm8, xmm7
	test	sil, sil
	je	$LN128@ScrollbarE
	test	r12b, r12b
	je	$LN128@ScrollbarE
	comiss	xmm9, xmm11
	jbe	$LN128@ScrollbarE

; 965  :     {
; 966  :         const float scrollbar_pos_v = bb.Min[axis];
; 967  :         const float mouse_pos_v = g.IO.MousePos[axis];

	movsxd	r12, DWORD PTR axis$1$[rsp]

; 968  : 
; 969  :         // Click position in scrollbar normalized space (0.0f->1.0f)
; 970  :         const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);

	movss	xmm0, DWORD PTR [rbx+r12*4+3592]
	subss	xmm0, DWORD PTR bb$[rsp+r12*4]
	divss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm0
	jbe	SHORT $LN111@ScrollbarE
	xorps	xmm2, xmm2
	jmp	SHORT $LN112@ScrollbarE
$LN111@ScrollbarE:
	movaps	xmm2, xmm9
	minss	xmm2, xmm0
$LN112@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4002 :     g.HoveredId = id;

	mov	DWORD PTR [r8+16484], r15d

; 4003 :     g.HoveredIdAllowOverlap = false;

	mov	BYTE PTR [r8+16492], r10b

; 4004 :     if (id != 0 && g.HoveredIdPreviousFrame != id)

	test	r15d, r15d
	je	SHORT $LN114@ScrollbarE
	cmp	DWORD PTR [r8+16488], r15d
	je	SHORT $LN114@ScrollbarE

; 4005 :         g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;

	mov	QWORD PTR [r8+16496], r10
$LN114@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 973  :         bool seek_absolute = false;

	xor	cl, cl

; 974  :         if (g.ActiveIdIsJustActivated)

	cmp	BYTE PTR [rbx+16516], cl
	je	SHORT $LN10@ScrollbarE

; 975  :         {
; 976  :             // On initial click calculate the distance between mouse and the center of the grab
; 977  :             seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);

	comiss	xmm8, xmm2
	ja	SHORT $LN17@ScrollbarE
	movaps	xmm0, xmm8
	addss	xmm0, xmm11
	comiss	xmm2, xmm0
	ja	SHORT $LN17@ScrollbarE

; 980  :             else
; 981  :                 g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

	movaps	xmm1, xmm2
	movaps	xmm0, xmm11
	subss	xmm1, xmm8
	mulss	xmm0, xmm13
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+23936], xmm1
	jmp	SHORT $LN10@ScrollbarE
$LN17@ScrollbarE:

; 975  :         {
; 976  :             // On initial click calculate the distance between mouse and the center of the grab
; 977  :             seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);

	movzx	ecx, al

; 978  :             if (seek_absolute)
; 979  :                 g.ScrollbarClickDeltaToGrabCenter = 0.0f;

	mov	DWORD PTR [rbx+23936], r10d
$LN10@ScrollbarE:

; 982  :         }
; 983  : 
; 984  :         // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
; 985  :         // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
; 986  :         const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));

	movaps	xmm1, xmm2
	movaps	xmm4, xmm11
	subss	xmm1, DWORD PTR [rbx+23936]
	mulss	xmm4, xmm13
	movaps	xmm0, xmm9
	subss	xmm0, xmm11
	subss	xmm1, xmm4
	divss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm1
	jbe	SHORT $LN120@ScrollbarE
	xorps	xmm3, xmm3
	jmp	SHORT $LN121@ScrollbarE
$LN120@ScrollbarE:
	movaps	xmm3, xmm9
	minss	xmm3, xmm1
$LN121@ScrollbarE:
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 987  :         *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);

	movaps	xmm0, xmm14
	mulss	xmm0, xmm3
	cvttss2si rax, xmm0
	mov	QWORD PTR [rdx], rax

; 988  : 
; 989  :         // Update values for rendering
; 990  :         scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);

	cvtsi2ss xmm1, rax
	divss	xmm1, xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm1
	ja	SHORT $LN104@ScrollbarE
	movaps	xmm6, xmm9
	minss	xmm6, xmm1
$LN104@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 991  :         grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

	movaps	xmm8, xmm5
	mulss	xmm8, xmm6
	divss	xmm8, xmm7

; 992  : 
; 993  :         // Update distance to grab now that we have seeked and saturated
; 994  :         if (seek_absolute)

	test	cl, cl
	je	SHORT $LN11@ScrollbarE

; 995  :             g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;

	subss	xmm2, xmm8
	subss	xmm2, xmm4
	movss	DWORD PTR [rbx+23936], xmm2
	jmp	SHORT $LN11@ScrollbarE
$LN128@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	mov	r12d, DWORD PTR axis$1$[rsp]
$LN11@ScrollbarE:
	movups	xmm0, XMMWORD PTR [r8+15000]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$1[rsp]
	movss	xmm6, DWORD PTR [r8+14552]
	movups	XMMWORD PTR c$1[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$1[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	movaps	xmm14, XMMWORD PTR [rsp+96]
	mov	r9d, eax
	movaps	xmm13, XMMWORD PTR [rsp+112]
	movaps	xmm11, XMMWORD PTR [rsp+144]
	movaps	xmm7, XMMWORD PTR [rsp+208]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1000 :     const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);

	test	sil, sil
	je	SHORT $LN19@ScrollbarE
	mov	eax, 17
	jmp	SHORT $LN20@ScrollbarE
$LN19@ScrollbarE:
	cmp	BYTE PTR hovered$[rsp], r10b
	mov	rax, r10
	setne	al
	add	rax, 15
$LN20@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	add	rax, rax

; 3092 :     c.w *= style.Alpha * alpha_mul;

	mulss	xmm6, xmm12

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$2[rsp]
	movups	xmm0, XMMWORD PTR [r8+rax*8+14776]
	movups	XMMWORD PTR c$2[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$2[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1001 :     window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);

	movss	xmm0, DWORD PTR [r13+136]
	lea	r8, QWORD PTR [r14+8]
	mov	rcx, QWORD PTR [r13+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	edi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1001 :     window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);

	mov	eax, DWORD PTR flags$[rbp-225]
	mov	rdx, r14
	mov	DWORD PTR [rsp+40], eax
	movss	DWORD PTR [rsp+32], xmm0
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1002 :     ImRect grab_rect;
; 1003 :     if (axis == ImGuiAxis_X)

	movss	xmm1, DWORD PTR bb$[rsp+8]
	test	r12d, r12d
	mov	r12, QWORD PTR [rsp+240]
	jne	SHORT $LN12@ScrollbarE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm1, DWORD PTR bb$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1004 :         grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);

	movss	xmm0, DWORD PTR bb$[rsp+4]
	movss	DWORD PTR grab_rect$[rsp+4], xmm0
	movss	xmm0, DWORD PTR bb$[rsp+12]
	movss	DWORD PTR grab_rect$[rsp+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mulss	xmm1, xmm8
	addss	xmm1, DWORD PTR bb$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1004 :         grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);

	movss	DWORD PTR grab_rect$[rsp], xmm1
	addss	xmm1, xmm10
	jmp	SHORT $LN155@ScrollbarE
$LN12@ScrollbarE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm2, DWORD PTR bb$[rsp+12]
	subss	xmm2, DWORD PTR bb$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1006 :         grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);

	movss	xmm0, DWORD PTR bb$[rsp]
	movss	DWORD PTR grab_rect$[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mulss	xmm2, xmm8
	addss	xmm2, DWORD PTR bb$[rsp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1006 :         grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);

	movss	DWORD PTR grab_rect$[rsp+4], xmm2
	addss	xmm2, xmm10
	movss	DWORD PTR grab_rect$[rsp+12], xmm2
$LN155@ScrollbarE:

; 1007 :     window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);

	movss	xmm0, DWORD PTR [rbx+14672]
	lea	r8, QWORD PTR grab_rect$[rsp+8]
	mov	rcx, QWORD PTR [r13+728]
	lea	rdx, QWORD PTR grab_rect$[rsp]
	mov	DWORD PTR [rsp+40], 0
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm0
	movss	DWORD PTR grab_rect$[rsp+8], xmm1
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1008 : 
; 1009 :     return held;

	movaps	xmm10, XMMWORD PTR [rsp+160]
	movzx	eax, sil
	mov	rsi, QWORD PTR [rsp+320]
	movaps	xmm8, XMMWORD PTR [rsp+192]
	mov	rdi, QWORD PTR [rsp+248]
	jmp	SHORT $LN1@ScrollbarE
$LN4@ScrollbarE:

; 930  :         return false;

	xor	al, al
$LN1@ScrollbarE:

; 1010 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+256]
	movaps	xmm6, XMMWORD PTR [r11-32]
	movaps	xmm9, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	rbx
	pop	rbp
	ret	0
?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z ENDP ; ImGui::ScrollbarEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z
_TEXT	SEGMENT
hovered$ = 64
held$ = 65
c$2 = 72
$T3 = 72
$T4 = 72
$T5 = 72
c$6 = 88
c$7 = 88
$T8 = 104
$T9 = 104
bb$ = 104
__$ArrayPad$ = 120
id$ = 288
texture_id$ = 296
size$ = 304
uv0$ = 312
uv1$ = 320
bg_col$ = 328
tint_col$ = 336
flags$dead$ = 344
?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z PROC ; ImGui::ImageButtonEx, COMDAT

; 1039 : {

$LN72:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	lea	rbp, QWORD PTR [rsp-23]
	sub	rsp, 240				; 000000f0H
	movaps	XMMWORD PTR [rsp+144], xmm11
	movaps	XMMWORD PTR [rsp+128], xmm12
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-217], rax

; 1040 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r12, r9
	mov	r13, rdx
	mov	esi, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rdi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1042 :     if (window->SkipItems)

	cmp	BYTE PTR [rdi+240], 0
	jne	$LN63@ImageButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm3, DWORD PTR [rdi+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm4, DWORD PTR [rdi+316]
	movaps	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1045 :     const ImVec2 padding = g.Style.FramePadding;

	movss	xmm11, DWORD PTR [rbx+14612]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR [r8+4]
	addss	xmm2, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1045 :     const ImVec2 padding = g.Style.FramePadding;

	movss	xmm12, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm11
	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-217], xmm3
	movss	DWORD PTR bb$[rbp-213], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm2, xmm0

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm12
	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-209], xmm2
	subss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm0

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rbp-205], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm1, xmm4
	movss	DWORD PTR $T3[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	movss	xmm1, DWORD PTR __real@bf800000
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1048 :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rbp-217]
	mov	edx, esi
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN63@ImageButto
	mov	QWORD PTR [rsp+296], r14

; 1050 : 
; 1051 :     bool hovered, held;
; 1052 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	lea	r9, QWORD PTR held$[rsp]
	mov	QWORD PTR [rsp+304], r15
	lea	r8, QWORD PTR hovered$[rsp]
	movaps	XMMWORD PTR [rsp+224], xmm6
	lea	rcx, QWORD PTR bb$[rbp-217]
	movaps	XMMWORD PTR [rsp+208], xmm7
	mov	edx, esi
	movaps	XMMWORD PTR [rsp+192], xmm8
	movaps	XMMWORD PTR [rsp+176], xmm9
	movaps	XMMWORD PTR [rsp+160], xmm10
	mov	DWORD PTR [rsp+32], 0
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 1053 : 
; 1054 :     // Render
; 1055 :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	cmp	BYTE PTR held$[rsp], 0
	movzx	r15d, al
	movzx	ecx, BYTE PTR hovered$[rsp]
	je	SHORT $LN6@ImageButto
	test	cl, cl
	je	SHORT $LN6@ImageButto
	mov	eax, 23
	jmp	SHORT $LN7@ImageButto
$LN6@ImageButto:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	rax, 21
$LN7@ImageButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 14
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$2[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$2[rsp]
	movss	DWORD PTR c$2[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1056 :     RenderNavHighlight(bb, id);

	mov	edx, esi
	lea	rcx, QWORD PTR bb$[rbp-217]
	mov	r8d, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1056 :     RenderNavHighlight(bb, id);

	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movaps	xmm1, xmm11
	xorps	xmm6, xmm6
	minss	xmm1, xmm12

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm6, xmm1
	jbe	SHORT $LN40@ImageButto
	xorps	xmm0, xmm0
	jmp	SHORT $LN41@ImageButto
$LN40@ImageButto:
	movss	xmm0, DWORD PTR [rbx+14620]
	minss	xmm0, xmm1
$LN41@ImageButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1057 :     RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, g.Style.FrameRounding));

	mov	rdx, QWORD PTR bb$[rbp-209]
	mov	r9b, 1
	mov	rcx, QWORD PTR bb$[rbp-217]
	mov	r8d, r14d
	movss	DWORD PTR [rsp+32], xmm0
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 1058 :     if (bg_col.w > 0.0f)

	mov	rax, QWORD PTR bg_col$[rbp-217]
	movss	xmm7, DWORD PTR bb$[rbp-205]
	movss	xmm8, DWORD PTR bb$[rbp-209]
	movss	xmm9, DWORD PTR bb$[rbp-213]
	movss	xmm0, DWORD PTR [rax+12]
	comiss	xmm0, xmm6
	mov	r14, QWORD PTR [rsp+296]
	movss	xmm10, DWORD PTR bb$[rbp-217]
	jbe	$LN62@ImageButto
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	xmm0, XMMWORD PTR [rax]

; 3100 :     c.w *= style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	XMMWORD PTR c$6[rsp], xmm0

; 3100 :     c.w *= style.Alpha;

	shufps	xmm0, xmm0, 255				; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$6[rbp-205], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm0, xmm8
	subss	xmm0, xmm11

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm1

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm1, xmm9
	addss	xmm1, xmm12

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm10
	addss	xmm0, xmm11

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-213], xmm1
	movss	DWORD PTR $T9[rbp-217], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1059 :         window->DrawList->AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));

	mov	rcx, QWORD PTR [rdi+728]
	lea	rdx, QWORD PTR $T9[rbp-217]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1059 :         window->DrawList->AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));

	mov	DWORD PTR [rsp+40], 0
	lea	r8, QWORD PTR $T5[rsp]
	movss	DWORD PTR [rsp+32], xmm6
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN62@ImageButto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	mov	rax, QWORD PTR tint_col$[rbp-217]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm8, xmm11
	subss	xmm7, xmm12

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm10, xmm11
	addss	xmm9, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	xmm0, XMMWORD PTR [rax]

; 3100 :     c.w *= style.Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3101 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp-217], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3099 :     ImVec4 c = col;

	movups	XMMWORD PTR c$7[rsp], xmm0

; 3100 :     c.w *= style.Alpha;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rbp-213], xmm7
	movss	DWORD PTR $T4[rsp], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3100 :     c.w *= style.Alpha;

	movss	DWORD PTR c$7[rbp-205], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3101 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1060 :     window->DrawList->AddImage(texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));

	mov	rcx, QWORD PTR [rdi+728]
	lea	r9, QWORD PTR $T8[rbp-217]
	mov	DWORD PTR [rsp+48], eax
	lea	r8, QWORD PTR $T4[rsp]
	mov	rax, QWORD PTR uv1$[rbp-217]
	mov	rdx, r13
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r12
	call	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage

; 1061 : 
; 1062 :     return pressed;

	movaps	xmm10, XMMWORD PTR [rsp+160]
	movzx	eax, r15b
	mov	r15, QWORD PTR [rsp+304]
	movaps	xmm9, XMMWORD PTR [rsp+176]
	movaps	xmm8, XMMWORD PTR [rsp+192]
	movaps	xmm7, XMMWORD PTR [rsp+208]
	movaps	xmm6, XMMWORD PTR [rsp+224]
	jmp	SHORT $LN1@ImageButto
$LN63@ImageButto:

; 1049 :         return false;

	xor	al, al
$LN1@ImageButto:

; 1063 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-217]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+72]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	mov	rsp, r11
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z ENDP ; ImGui::ImageButtonEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z
_TEXT	SEGMENT
$T2 = 64
user_texture_id$ = 112
size$ = 120
uv0$ = 128
uv1$ = 136
frame_padding$dead$ = 144
bg_col$ = 152
tint_col$ = 160
?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z PROC ; ImGui::ImageButton, COMDAT

; 1081 : {

$LN54:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1082 :     ImGuiContext& g = *GImGui;
; 1083 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx
	mov	rbx, QWORD PTR [rax+16408]

; 1084 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	je	SHORT $LN2@ImageButto

; 1085 :         return false;

	xor	al, al
	jmp	$LN1@ImageButto
$LN2@ImageButto:
	mov	QWORD PTR [rsp+112], rdi

; 1086 : 
; 1087 :     // Default to using texture ID as ID. User can still push string/integer prefixes.
; 1088 :     PushID((void*)(intptr_t)user_texture_id);

	call	?PushID@ImGui@@YAXPEBX@Z		; ImGui::PushID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [rbx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_06EBHDMMP@?$CDimage@+1
	mov	rax, QWORD PTR [rbx+304]
	lea	r10, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	mov	r8b, 35					; 00000023H
	mov	r9d, DWORD PTR [rax+rcx*4-4]
	not	r9d
	mov	edi, r9d
$LL16@ImageButto:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN21@ImageButto
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN21@ImageButto
	cmp	BYTE PTR [rdx+1], r8b
	cmove	edi, r9d
$LN21@ImageButto:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, dil
	movzx	eax, r8b
	movzx	r8d, BYTE PTR [rdx]
	xor	rcx, rax
	shr	edi, 8
	inc	rdx
	xor	edi, DWORD PTR [r10+rcx*4]
	test	r8b, r8b
	jne	SHORT $LL16@ImageButto

; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rax, QWORD PTR [rbx]

; 2072 :     return ~crc;

	not	edi

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], edi
	jne	SHORT $LN7@ImageButto

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_06EBHDMMP@?$CDimage@
	mov	edx, 11
	mov	ecx, edi
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN7@ImageButto:

; 8417 :     window->IDStack.pop_back();

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T2[rsp], 11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [rbx+16408]

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rcx, QWORD PTR [rbx+18840]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm1, DWORD PTR [rbx+14612]
	movss	xmm0, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T2[rsp+4], xmm1
	movss	DWORD PTR $T2[rsp+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1094 :     bool ret = ImageButtonEx(id, user_texture_id, size, uv0, uv1, bg_col, tint_col);

	mov	rax, QWORD PTR tint_col$[rsp]
	mov	r9, r14
	mov	QWORD PTR [rsp+48], rax
	mov	r8, r15
	mov	rax, QWORD PTR bg_col$[rsp]
	mov	rdx, rsi
	mov	QWORD PTR [rsp+40], rax
	mov	ecx, edi
	mov	QWORD PTR [rsp+32], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	mov	DWORD PTR [rbx+14612], 1073741824	; 40000000H
	mov	DWORD PTR [rbx+14616], 1073741824	; 40000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1094 :     bool ret = ImageButtonEx(id, user_texture_id, size, uv0, uv1, bg_col, tint_col);

	call	?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@11AEBUImVec4@@2H@Z ; ImGui::ImageButtonEx

; 1095 :     if (frame_padding >= 0)
; 1096 :         PopStyleVar();

	mov	ecx, 1
	movzx	ebx, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 1097 :     return ret;

	mov	rdi, QWORD PTR [rsp+112]
	movzx	eax, bl
$LN1@ImageButto:

; 1098 : }

	mov	rbx, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z ENDP ; ImGui::ImageButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?SeparatorEx@ImGui@@YAXHM@Z
_TEXT	SEGMENT
c$3 = 48
c$4 = 48
$T5 = 48
$T6 = 48
bb$7 = 64
bb$8 = 64
__$ArrayPad$ = 80
flags$ = 208
thickness$ = 216
?SeparatorEx@ImGui@@YAXHM@Z PROC			; ImGui::SeparatorEx, COMDAT

; 1392 : {

$LN132:
	mov	r11, rsp
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11+32], rdi
	push	rbp
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 192				; 000000c0H
	movaps	XMMWORD PTR [r11-56], xmm8
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1392 : {

	movaps	xmm8, xmm1
	mov	r8d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rdi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rdi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1394 :     if (window->SkipItems)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN13@SeparatorE

; 1395 :         return;
; 1396 : 
; 1397 :     ImGuiContext& g = *GImGui;
; 1398 :     IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected
; 1399 :     IM_ASSERT(thickness > 0.0f);
; 1400 : 
; 1401 :     if (flags & ImGuiSeparatorFlags_Vertical)

	mov	QWORD PTR [r11+16], r14
	movaps	XMMWORD PTR [r11-24], xmm6
	movaps	XMMWORD PTR [r11-40], xmm7
	movaps	XMMWORD PTR [r11-72], xmm9
	test	r8b, 2
	je	$LN3@SeparatorE

; 1407 :         ItemSize(ImVec2(thickness, 0.0f));

	movss	xmm1, DWORD PTR __real@bf800000
	lea	rcx, QWORD PTR $T6[rbp-105]
	movaps	XMMWORD PTR [r11-88], xmm10
	movss	xmm10, DWORD PTR [rbx+312]
	movaps	xmm9, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rbp-105], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1406 :         const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness, y2));

	addss	xmm9, xmm8
	movaps	XMMWORD PTR [r11-104], xmm11
	movss	xmm11, DWORD PTR [rbx+316]
	xorps	xmm8, xmm8
	movaps	xmm7, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T6[rbp-101], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1405 :         float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;

	addss	xmm7, DWORD PTR [rbx+356]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movaps	xmm6, xmm9
	unpcklps xmm6, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1407 :         ItemSize(ImVec2(thickness, 0.0f));

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10132:     ImGuiWindow* window = g.CurrentWindow;
; 10133: 
; 10134:     // Set item data
; 10135:     // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
; 10136:     g.LastItemData.ID = id;

	xor	r14d, r14d

; 10137:     g.LastItemData.Rect = bb;

	movaps	xmm0, xmm10
	shufps	xmm0, xmm0, 225				; 000000e1H
	movss	xmm0, xmm11

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	mov	DWORD PTR [r10+18620], eax

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	shufps	xmm0, xmm0, 225				; 000000e1H
	unpcklpd xmm0, xmm6
	mov	DWORD PTR [r10+18616], r14d
	movups	XMMWORD PTR [r10+18628], xmm0
	mov	DWORD PTR [r10+18624], r14d
	movups	XMMWORD PTR [r10+18644], xmm0
	mov	QWORD PTR [r10+18592], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	comiss	xmm7, DWORD PTR [rax+628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10137:     g.LastItemData.Rect = bb;

	movups	XMMWORD PTR bb$8[rbp-105], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN51@SeparatorE
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, xmm11
	jbe	SHORT $LN51@SeparatorE
	comiss	xmm9, DWORD PTR [rax+624]
	jbe	SHORT $LN51@SeparatorE
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, xmm10
	jbe	SHORT $LN51@SeparatorE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN42@SeparatorE
$LN51@SeparatorE:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], r14b
	je	SHORT $LN130@SeparatorE
$LN42@SeparatorE:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$8[rbp-97]
	lea	rcx, QWORD PTR bb$8[rbp-105]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN43@SeparatorE

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN43@SeparatorE:

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r10+15208]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rbp-105]
	movups	XMMWORD PTR c$4[rbp-105], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r10+14552]
	movss	DWORD PTR c$4[rbp-93], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1412 :         window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));

	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb$8[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1412 :         window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));

	mov	DWORD PTR [rsp+40], r14d
	lea	r8, QWORD PTR bb$8[rbp-97]
	movss	DWORD PTR [rsp+32], xmm8
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1413 :         if (g.LogEnabled)

	cmp	BYTE PTR [rdi+24256], r14b
	je	SHORT $LN130@SeparatorE

; 1414 :             LogText(" |");

	lea	rcx, OFFSET FLAT:??_C@_02LLHJFGPH@?5?$HM@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText
$LN130@SeparatorE:
	movaps	xmm10, XMMWORD PTR [rsp+112]
	movaps	xmm11, XMMWORD PTR [rsp+96]
$LN127@SeparatorE:
	movaps	xmm6, XMMWORD PTR [rsp+176]
	mov	r14, QWORD PTR [rsp+216]
	movaps	xmm7, XMMWORD PTR [rsp+160]
	movaps	xmm9, XMMWORD PTR [rsp+128]
$LN13@SeparatorE:

; 1458 :         }
; 1459 :     }
; 1460 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN3@SeparatorE:

; 1415 :     }
; 1416 :     else if (flags & ImGuiSeparatorFlags_Horizontal)

	test	r8b, 1
	je	SHORT $LN127@SeparatorE

; 1417 :     {
; 1418 :         // Horizontal Separator
; 1419 :         float x1 = window->Pos.x;

	movss	xmm6, DWORD PTR [rbx+80]

; 1420 :         float x2 = window->Pos.x + window->Size.x;
; 1421 : 
; 1422 :         // FIXME-WORKRECT: old hack (#205) until we decide of consistent behavior with WorkRect/Indent and Separator
; 1423 :         if (g.GroupStack.Size > 0 && g.GroupStack.back().WindowID == window->ID)

	movsxd	rax, DWORD PTR [rdi+18904]
	movaps	xmm7, xmm6
	mov	QWORD PTR [rsp+208], rsi
	addss	xmm7, DWORD PTR [rbx+88]
	test	eax, eax
	jle	SHORT $LN8@SeparatorE
	mov	rcx, QWORD PTR [rdi+18912]
	lea	rdx, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [rbx+16]
	add	rdx, rdx
	cmp	DWORD PTR [rcx+rdx*8-48], eax
	jne	SHORT $LN8@SeparatorE

; 1424 :             x1 += window->DC.Indent.x;

	addss	xmm6, DWORD PTR [rbx+380]
$LN8@SeparatorE:

; 1425 : 
; 1426 :         // FIXME-WORKRECT: In theory we should simply be using WorkRect.Min.x/Max.x everywhere but it isn't aesthetically what we want,
; 1427 :         // need to introduce a variant of WorkRect for that purpose. (#4787)
; 1428 :         if (ImGuiTable* table = g.CurrentTable)

	mov	rdx, QWORD PTR [rdi+19728]
	test	rdx, rdx
	je	SHORT $LN9@SeparatorE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, DWORD PTR [rdx+116]
	imul	rcx, rax, 112				; 00000070H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1430 :             x1 = table->Columns[table->CurrentColumn].MinX;

	mov	rax, QWORD PTR [rdx+24]
	movss	xmm6, DWORD PTR [rcx+rax+8]

; 1431 :             x2 = table->Columns[table->CurrentColumn].MaxX;

	movss	xmm7, DWORD PTR [rcx+rax+12]
$LN9@SeparatorE:

; 1432 :         }
; 1433 : 
; 1434 :         // Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
; 1435 :         // We currently don't need to provide the same feature for tables because tables naturally have border features.
; 1436 :         ImGuiOldColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;

	xor	r14d, r14d
	test	r8b, 4
	je	SHORT $LN15@SeparatorE
	mov	rsi, QWORD PTR [rbx+480]

; 1437 :         if (columns)

	test	rsi, rsi
	je	SHORT $LN10@SeparatorE

; 1438 :             PushColumnsBackground();

	call	?PushColumnsBackground@ImGui@@YAXXZ	; ImGui::PushColumnsBackground
	jmp	SHORT $LN10@SeparatorE
$LN15@SeparatorE:

; 1432 :         }
; 1433 : 
; 1434 :         // Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
; 1435 :         // We currently don't need to provide the same feature for tables because tables naturally have border features.
; 1436 :         ImGuiOldColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;

	mov	rsi, r14
$LN10@SeparatorE:

; 1439 : 
; 1440 :         // We don't provide our width to the layout so that it doesn't get feed back into AutoFit
; 1441 :         // FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)
; 1442 :         const float thickness_for_layout = (thickness == 1.0f) ? 0.0f : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.

	ucomiss	xmm8, DWORD PTR __real@3f800000
	xorps	xmm9, xmm9
	jp	SHORT $LN17@SeparatorE
	jne	SHORT $LN17@SeparatorE
	xorps	xmm2, xmm2
	jmp	SHORT $LN18@SeparatorE
$LN17@SeparatorE:
	movaps	xmm2, xmm8
$LN18@SeparatorE:

; 1443 :         const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));

	movss	xmm0, DWORD PTR [rbx+316]

; 1444 :         ItemSize(ImVec2(0.0f, thickness_for_layout));

	lea	rcx, QWORD PTR $T5[rbp-105]
	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$7[rbp-101], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1443 :         const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$7[rbp-105], xmm6
	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-101], xmm2
	mov	DWORD PTR $T5[rbp-105], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	unpcklps xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1444 :         ItemSize(ImVec2(0.0f, thickness_for_layout));

	movss	xmm1, DWORD PTR __real@bf800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movsd	QWORD PTR bb$7[rbp-97], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1444 :         ItemSize(ImVec2(0.0f, thickness_for_layout));

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10131:     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 10138:     g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
; 10139:     g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;

	mov	eax, DWORD PTR [r10+18584]
	or	eax, DWORD PTR [r10+18596]
	mov	DWORD PTR [r10+18616], r14d
	movups	xmm0, XMMWORD PTR bb$7[rbp-105]
	movups	XMMWORD PTR [r10+18628], xmm0
	movups	xmm1, XMMWORD PTR bb$7[rbp-105]
	mov	DWORD PTR [r10+18620], eax

; 10140:     g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
; 10141: 
; 10142:     // Directional navigation processing
; 10143:     if (id != 0)
; 10144:     {
; 10145:         KeepAliveID(id);
; 10146: 
; 10147:         // Runs prior to clipping early-out
; 10148:         //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
; 10149:         //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
; 10150:         //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
; 10151:         //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
; 10152:         //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
; 10153:         //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
; 10154:         // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
; 10155:         // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
; 10156:         if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
; 10157:         {
; 10158:             window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
; 10159:             if (g.NavId == id || g.NavAnyRequest)
; 10160:                 if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
; 10161:                     if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
; 10162:                         NavProcessItem();
; 10163:         }
; 10164: 
; 10165:         // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
; 10166:         // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
; 10167:         // READ THE FAQ: https://dearimgui.com/faq
; 10168:         IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
; 10169:     }
; 10170:     g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
; 10171:     g.NextItemData.ItemFlags = ImGuiItemFlags_None;
; 10172: 
; 10173: #ifdef IMGUI_ENABLE_TEST_ENGINE
; 10174:     if (id != 0)
; 10175:         IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
; 10176: #endif
; 10177: 
; 10178:     // Clipping test
; 10179:     // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
; 10180:     //const bool is_clipped = IsClippedEx(bb, id);
; 10181:     //if (is_clipped)
; 10182:     //    return false;
; 10183:     const bool is_rect_visible = bb.Overlaps(window->ClipRect);

	mov	rax, QWORD PTR [r10+16408]
	movups	XMMWORD PTR [r10+18644], xmm1
	mov	DWORD PTR [r10+18624], r14d
	mov	QWORD PTR [r10+18592], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	movss	xmm0, DWORD PTR bb$7[rbp-93]
	comiss	xmm0, DWORD PTR [rax+628]
	jbe	SHORT $LN85@SeparatorE
	movss	xmm0, DWORD PTR [rax+636]
	comiss	xmm0, DWORD PTR bb$7[rbp-101]
	jbe	SHORT $LN85@SeparatorE
	movss	xmm0, DWORD PTR bb$7[rbp-97]
	comiss	xmm0, DWORD PTR [rax+624]
	jbe	SHORT $LN85@SeparatorE
	movss	xmm0, DWORD PTR [rax+632]
	comiss	xmm0, DWORD PTR bb$7[rbp-105]
	jbe	SHORT $LN85@SeparatorE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10200:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;

	mov	DWORD PTR [r10+18624], 512		; 00000200H
	jmp	SHORT $LN76@SeparatorE
$LN85@SeparatorE:

; 10184:     if (!is_rect_visible)
; 10185:         if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
; 10186:             if (!g.LogEnabled)

	cmp	BYTE PTR [r10+24256], r14b
	je	$LN12@SeparatorE
$LN76@SeparatorE:

; 10201:     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	r8b, 1
	lea	rdx, QWORD PTR bb$7[rbp-97]
	lea	rcx, QWORD PTR bb$7[rbp-105]
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	SHORT $LN77@SeparatorE

; 10202:         g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;

	or	DWORD PTR [r10+18624], 1
$LN77@SeparatorE:

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r10+15208]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$3[rbp-105]
	movups	XMMWORD PTR c$3[rbp-105], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r10+14552]
	movss	DWORD PTR c$3[rbp-93], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1449 :             window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));

	mov	rcx, QWORD PTR [rbx+728]
	lea	rdx, QWORD PTR bb$7[rbp-105]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1449 :             window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));

	mov	DWORD PTR [rsp+40], r14d
	lea	r8, QWORD PTR bb$7[rbp-97]
	movss	DWORD PTR [rsp+32], xmm9
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 1450 :             if (g.LogEnabled)

	cmp	BYTE PTR [rdi+24256], r14b
	je	SHORT $LN12@SeparatorE

; 1451 :                 LogRenderedText(&bb.Min, "--------------------------------\n");

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0CC@IODDEFBI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
	lea	rcx, QWORD PTR bb$7[rbp-105]
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN12@SeparatorE:

; 1452 : 
; 1453 :         }
; 1454 :         if (columns)

	test	rsi, rsi
	je	SHORT $LN128@SeparatorE

; 1455 :         {
; 1456 :             PopColumnsBackground();

	call	?PopColumnsBackground@ImGui@@YAXXZ	; ImGui::PopColumnsBackground

; 1457 :             columns->LineMinY = window->DC.CursorPos.y;

	mov	eax, DWORD PTR [rbx+316]
	mov	DWORD PTR [rsi+28], eax
$LN128@SeparatorE:
	mov	rsi, QWORD PTR [rsp+208]
	jmp	$LN127@SeparatorE
?SeparatorEx@ImGui@@YAXHM@Z ENDP			; ImGui::SeparatorEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z
_TEXT	SEGMENT
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
min_size$ = 64
text_baseline_y$1$ = 72
text_size$6 = 72
$T7 = 72
$T8 = 72
$T9 = 80
label_size$ = 80
tv786 = 88
padding$$sroa$467$1$ = 92
c$10 = 96
bb$ = 96
label_pos$ = 112
__$ArrayPad$ = 120
id$dead$ = 336
label$ = 344
label_end$ = 352
extra_w$ = 360
?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z PROC		; ImGui::SeparatorTextEx, COMDAT

; 1477 : {

$LN88:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rax-72]
	sub	rsp, 288				; 00000120H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-184], xmm14
	movaps	XMMWORD PTR [rax-200], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1478 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	xmm14, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	movss	xmm6, DWORD PTR __real@3f7fff58
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1477 : {

	mov	r14, r8
	mov	rsi, rdx
	xorps	xmm10, xmm10

; 1479 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rdi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5417 :     const float font_size = g.FontSize;

	movss	xmm4, DWORD PTR [rbx+15696]

; 5418 :     if (text == text_display_end)

	cmp	rdx, r8
	jne	SHORT $LN14@SeparatorT
	xorps	xmm11, xmm11

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN86@SeparatorT
$LN14@SeparatorT:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$6[rsp]
	movss	xmm3, DWORD PTR __real@7f7fffff
	movaps	xmm2, xmm4
	mov	rcx, QWORD PTR [rbx+15688]
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rsi
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$6[rsp]

; 5428 : 
; 5429 :     return text_size;

	movss	xmm4, DWORD PTR text_size$6[rsp+4]
	addss	xmm0, xmm6
	cvttss2si eax, xmm0
	movd	xmm11, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm11, xmm11
$LN86@SeparatorT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1484 :     const ImVec2 padding = style.SeparatorTextPadding;

	movss	xmm0, DWORD PTR [rbx+14732]

; 1490 :     ItemSize(min_size, text_baseline_y);

	lea	rcx, QWORD PTR min_size$[rsp]
	movss	xmm15, DWORD PTR [rdi+316]
	movaps	xmm1, xmm0
	movss	xmm2, DWORD PTR [rbx+14736]
	addss	xmm1, xmm0
	movss	xmm8, DWORD PTR [rbx+14720]
	addss	xmm2, xmm2
	movss	xmm12, DWORD PTR [rdi+312]
	movss	DWORD PTR padding$$sroa$467$1$[rsp], xmm0
	movaps	xmm0, xmm11
	addss	xmm0, xmm14
	movss	DWORD PTR label_size$[rsp+4], xmm4
	movss	DWORD PTR tv786[rsp], xmm1
	addss	xmm2, xmm4
	movss	DWORD PTR label_size$[rsp], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp], xmm12
	movss	DWORD PTR bb$[rsp+4], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1487 :     const ImVec2 min_size(label_size.x + extra_w + padding.x * 2.0f, ImMax(label_size.y + padding.y * 2.0f, separator_thickness));

	addss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rdi+600]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+8], xmm1

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR min_size$[rsp], xmm0
	movaps	xmm0, xmm15
	addss	xmm0, xmm2
	movss	DWORD PTR min_size$[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR bb$[rsp+12], xmm0
	subss	xmm0, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1489 :     const float text_baseline_y = ImFloor((bb.GetHeight() - label_size.y) * style.SeparatorTextAlign.y + 0.99999f); //ImMax(padding.y, ImFloor((style.SeparatorTextSize - label_size.y) * 0.5f));

	subss	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rbx+14728]
	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1490 :     ItemSize(min_size, text_baseline_y);

	movaps	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	movss	DWORD PTR text_baseline_y$1$[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1490 :     ItemSize(min_size, text_baseline_y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 1491 :     if (!ItemAdd(bb, id))

	xor	r8d, r8d
	lea	rcx, QWORD PTR bb$[rsp]
	xor	edx, edx
	xor	r9d, r9d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN9@SeparatorT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR padding$$sroa$467$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$10[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1499 :     const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN

	addss	xmm15, DWORD PTR text_baseline_y$1$[rsp]
	xorps	xmm1, xmm1
	mov	QWORD PTR [rsp+336], r15
	movaps	XMMWORD PTR [rsp+256], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	addss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1498 :     const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);

	movss	xmm7, DWORD PTR bb$[rsp+8]
	movaps	XMMWORD PTR [rsp+224], xmm9
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+160], xmm13
	movss	xmm13, DWORD PTR bb$[rsp+12]
	movaps	xmm0, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR label_pos$[rsp+4], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1496 :     const float seps_y = ImFloor((bb.Min.y + bb.Max.y) * 0.5f + 0.99999f);

	addss	xmm0, DWORD PTR bb$[rsp+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1498 :     const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);

	movaps	xmm0, xmm7
	subss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvtsi2ss xmm9, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1498 :     const float label_avail_w = ImMax(0.0f, sep2_x2 - sep1_x1 - padding.x * 2.0f);

	subss	xmm0, DWORD PTR tv786[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1499 :     const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN

	subss	xmm1, xmm11
	subss	xmm1, xmm14
	mulss	xmm1, DWORD PTR [rbx+14724]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1499 :     const ImVec2 label_pos(pos.x + padding.x + ImMax(0.0f, (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y); // FIXME-ALIGN

	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR label_pos$[rsp], xmm0
	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1502 :     window->DC.CursorPosPrevLine.x = label_pos.x + label_size.x;

	movss	DWORD PTR [rdi+320], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+15208]
	movups	XMMWORD PTR c$10[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$10[rsp+12], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1505 :     if (label_size.x > 0.0f)

	comiss	xmm11, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1505 :     if (label_size.x > 0.0f)

	jbe	$LN3@SeparatorT

; 1506 :     {
; 1507 :         const float sep1_x2 = label_pos.x - style.ItemSpacing.x;

	movss	xmm6, DWORD PTR label_pos$[rsp]
	movss	xmm0, DWORD PTR [rbx+14628]
	movaps	xmm1, xmm6

; 1508 :         const float sep2_x1 = label_pos.x + label_size.x + extra_w + style.ItemSpacing.x;

	addss	xmm6, xmm11
	subss	xmm1, xmm0
	addss	xmm6, xmm14

; 1509 :         if (sep1_x2 > sep1_x1 && separator_thickness > 0.0f)

	comiss	xmm1, xmm12
	addss	xmm6, xmm0
	jbe	SHORT $LN5@SeparatorT
	comiss	xmm8, xmm10
	jbe	SHORT $LN5@SeparatorT

; 1510 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);

	mov	rcx, QWORD PTR [rdi+728]
	lea	r8, QWORD PTR $T5[rsp]
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1510 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);

	lea	rdx, QWORD PTR $T8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm9
	movss	DWORD PTR $T8[rsp], xmm12
	movss	DWORD PTR $T8[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1510 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep1_x2, seps_y), separator_col, separator_thickness);

	movss	DWORD PTR [rsp+32], xmm8
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN5@SeparatorT:

; 1511 :         if (sep2_x2 > sep2_x1 && separator_thickness > 0.0f)

	comiss	xmm7, xmm6
	jbe	SHORT $LN6@SeparatorT
	comiss	xmm8, xmm10
	jbe	SHORT $LN6@SeparatorT

; 1512 :             window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	mov	rcx, QWORD PTR [rdi+728]
	lea	r8, QWORD PTR $T4[rsp]
	mov	r9d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1512 :             window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	lea	rdx, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T4[rsp+4], xmm9
	movss	DWORD PTR $T7[rsp], xmm6
	movss	DWORD PTR $T7[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1512 :             window->DrawList->AddLine(ImVec2(sep2_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	movss	DWORD PTR [rsp+32], xmm8
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN6@SeparatorT:

; 1513 :         if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	je	SHORT $LN7@SeparatorT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_03JMFMNIFM@?9?9?9@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	mov	QWORD PTR [rax+24296], 0
$LN7@SeparatorT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1515 :         RenderTextEllipsis(window->DrawList, label_pos, ImVec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x, bb.Max.x, label, label_end, &label_size);

	addss	xmm13, DWORD PTR [rbx+14632]
	mov	rcx, QWORD PTR [rdi+728]
	lea	rax, QWORD PTR label_size$[rsp]
	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+48], r14
	lea	rdx, QWORD PTR label_pos$[rsp]
	mov	QWORD PTR [rsp+40], rsi
	movaps	xmm3, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T3[rsp+4], xmm13
	movss	DWORD PTR $T3[rsp], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1515 :         RenderTextEllipsis(window->DrawList, label_pos, ImVec2(bb.Max.x, bb.Max.y + style.ItemSpacing.y), bb.Max.x, bb.Max.x, label, label_end, &label_size);

	movss	DWORD PTR [rsp+32], xmm7
	call	?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z ; ImGui::RenderTextEllipsis

; 1516 :     }

	jmp	SHORT $LN85@SeparatorT
$LN3@SeparatorT:

; 1517 :     else
; 1518 :     {
; 1519 :         if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	je	SHORT $LN8@SeparatorT

; 1520 :             LogText("---");

	lea	rcx, OFFSET FLAT:??_C@_03JMFMNIFM@?9?9?9@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText
$LN8@SeparatorT:

; 1521 :         if (separator_thickness > 0.0f)

	comiss	xmm8, xmm10
	jbe	SHORT $LN85@SeparatorT

; 1522 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	mov	rcx, QWORD PTR [rdi+728]
	lea	r8, QWORD PTR $T2[rsp]
	mov	r9d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1522 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	lea	rdx, QWORD PTR $T9[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T2[rsp+4], xmm9
	movss	DWORD PTR $T9[rsp], xmm12
	movss	DWORD PTR $T9[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1522 :             window->DrawList->AddLine(ImVec2(sep1_x1, seps_y), ImVec2(sep2_x2, seps_y), separator_col, separator_thickness);

	movss	DWORD PTR [rsp+32], xmm8
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN85@SeparatorT:
	movaps	xmm9, XMMWORD PTR [rsp+224]
	movaps	xmm7, XMMWORD PTR [rsp+256]
	mov	r15, QWORD PTR [rsp+336]
	movaps	xmm13, XMMWORD PTR [rsp+160]
$LN9@SeparatorT:

; 1523 :     }
; 1524 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+288]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?SeparatorTextEx@ImGui@@YAXIPEBD0M@Z ENDP		; ImGui::SeparatorTextEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ShrinkWidthItemComparer@@YAHPEBX0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?ShrinkWidthItemComparer@@YAHPEBX0@Z PROC		; ShrinkWidthItemComparer, COMDAT

; 1607 :     const ImGuiShrinkWidthItem* a = (const ImGuiShrinkWidthItem*)lhs;
; 1608 :     const ImGuiShrinkWidthItem* b = (const ImGuiShrinkWidthItem*)rhs;
; 1609 :     if (int d = (int)(b->Width - a->Width))

	movss	xmm0, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [rcx+4]
	cvttss2si eax, xmm0
	test	eax, eax
	jne	SHORT $LN1@ShrinkWidt

; 1610 :         return d;
; 1611 :     return (b->Index - a->Index);

	mov	eax, DWORD PTR [rdx]
	sub	eax, DWORD PTR [rcx]
$LN1@ShrinkWidt:

; 1612 : }

	ret	0
?ShrinkWidthItemComparer@@YAHPEBX0@Z ENDP		; ShrinkWidthItemComparer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z
_TEXT	SEGMENT
items$ = 64
count$ = 72
width_excess$ = 80
?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z PROC ; ImGui::ShrinkWidths, COMDAT

; 1617 : {

$LN110:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	movsxd	rsi, edx
	mov	rdi, rcx
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	xmm6, xmm2

; 1618 :     if (count == 1)

	cmp	esi, 1
	jne	SHORT $LN17@ShrinkWidt

; 1619 :     {
; 1620 :         if (items[0].Width >= 0.0f)

	movss	xmm1, DWORD PTR [rcx+4]
	xorps	xmm0, xmm0
	comiss	xmm1, xmm0
	jb	$LN84@ShrinkWidt

; 1621 :             items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);

	subss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1621 :             items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);

	movss	DWORD PTR [rcx+4], xmm1

; 1654 :         }
; 1655 : }

	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN17@ShrinkWidt:
	mov	QWORD PTR [rsp+64], rbx

; 1622 :         return;
; 1623 :     }
; 1624 :     ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);

	mov	rbx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	rsi, 1
	jbe	SHORT $LN28@ShrinkWidt
	lea	r9, OFFSET FLAT:?ShrinkWidthItemComparer@@YAHPEBX0@Z ; ShrinkWidthItemComparer
	mov	r8d, 12
	mov	rdx, rbx
	call	QWORD PTR __imp_qsort
$LN28@ShrinkWidt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1626 :     while (width_excess > 0.0f && count_same_width < count)

	movss	xmm5, DWORD PTR __real@3f800000
	xorps	xmm4, xmm4
	comiss	xmm6, xmm4
	mov	r8d, 1
	jbe	$LN83@ShrinkWidt

; 1627 :     {
; 1628 :         while (count_same_width < count && items[0].Width <= items[count_same_width].Width)

	mov	ecx, r8d
$LL2@ShrinkWidt:

; 1626 :     while (width_excess > 0.0f && count_same_width < count)

	cmp	r8d, esi
	jge	$LN83@ShrinkWidt

; 1627 :     {
; 1628 :         while (count_same_width < count && items[0].Width <= items[count_same_width].Width)

	movss	xmm1, DWORD PTR [rdi+4]
	lea	rdx, QWORD PTR [rcx*2+1]
	add	rdx, rcx
	lea	rdx, QWORD PTR [rdi+rdx*4]
	npad	3
$LL4@ShrinkWidt:
	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@ShrinkWidt

; 1629 :             count_same_width++;

	inc	r8d
	inc	rcx
	add	rdx, 12
	cmp	rcx, rbx
	jl	SHORT $LL4@ShrinkWidt
$LN5@ShrinkWidt:

; 1630 :         float max_width_to_remove_per_item = (count_same_width < count && items[count_same_width].Width >= 0.0f) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);

	cmp	r8d, esi
	jge	SHORT $LN21@ShrinkWidt
	lea	rax, QWORD PTR [rcx+rcx*2]
	movss	xmm1, DWORD PTR [rdi+rax*4+4]
	comiss	xmm1, xmm4
	jb	SHORT $LN21@ShrinkWidt
	movss	xmm0, DWORD PTR [rdi+4]
	subss	xmm0, xmm1
	jmp	SHORT $LN22@ShrinkWidt
$LN21@ShrinkWidt:
	movss	xmm0, DWORD PTR [rdi+4]
	subss	xmm0, xmm5
$LN22@ShrinkWidt:

; 1631 :         if (max_width_to_remove_per_item <= 0.0f)

	comiss	xmm4, xmm0
	jae	$LN83@ShrinkWidt

; 1632 :             break;
; 1633 :         float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);

	movd	xmm3, r8d
	movaps	xmm2, xmm6
	cvtdq2ps xmm3, xmm3

; 1634 :         for (int item_n = 0; item_n < count_same_width; item_n++)

	xor	r9d, r9d
	divss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1634 :         for (int item_n = 0; item_n < count_same_width; item_n++)

	cmp	rcx, 4
	jl	SHORT $LC61@ShrinkWidt

; 1632 :             break;
; 1633 :         float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);

	lea	rdx, QWORD PTR [rcx-4]
	shr	rdx, 2
	lea	rax, QWORD PTR [rdi+16]
	inc	rdx
	lea	r9, QWORD PTR [rdx*4]
	npad	4

; 1634 :         for (int item_n = 0; item_n < count_same_width; item_n++)

$LL62@ShrinkWidt:

; 1635 :             items[item_n].Width -= width_to_remove_per_item;

	movss	xmm0, DWORD PTR [rax-12]
	movss	xmm1, DWORD PTR [rax]
	subss	xmm0, xmm2
	subss	xmm1, xmm2
	movss	DWORD PTR [rax-12], xmm0
	movss	xmm0, DWORD PTR [rax+12]
	movss	DWORD PTR [rax], xmm1
	subss	xmm0, xmm2
	movss	xmm1, DWORD PTR [rax+24]
	subss	xmm1, xmm2
	movss	DWORD PTR [rax+12], xmm0
	movss	DWORD PTR [rax+24], xmm1
	add	rax, 48					; 00000030H
	sub	rdx, 1
	jne	SHORT $LL62@ShrinkWidt
$LC61@ShrinkWidt:

; 1634 :         for (int item_n = 0; item_n < count_same_width; item_n++)

	cmp	r9, rcx
	jge	SHORT $LN60@ShrinkWidt
	lea	rax, QWORD PTR [r9*2+1]
	add	rax, r9
	lea	rdx, QWORD PTR [rdi+rax*4]
	mov	rax, rcx
	sub	rax, r9
$LC8@ShrinkWidt:

; 1635 :             items[item_n].Width -= width_to_remove_per_item;

	movss	xmm0, DWORD PTR [rdx]
	subss	xmm0, xmm2
	movss	DWORD PTR [rdx], xmm0
	add	rdx, 12
	sub	rax, 1
	jne	SHORT $LC8@ShrinkWidt
$LN60@ShrinkWidt:

; 1636 :         width_excess -= width_to_remove_per_item * count_same_width;

	mulss	xmm3, xmm2
	subss	xmm6, xmm3
	comiss	xmm6, xmm4
	ja	$LL2@ShrinkWidt
$LN83@ShrinkWidt:

; 1637 :     }
; 1638 : 
; 1639 :     // Round width and redistribute remainder
; 1640 :     // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
; 1641 :     width_excess = 0.0f;

	xor	r8d, r8d
	movaps	xmm3, xmm4

; 1642 :     for (int n = 0; n < count; n++)

	cmp	rbx, 4
	jl	$LC64@ShrinkWidt
	lea	rdx, QWORD PTR [rsi-4]
	shr	rdx, 2
	lea	rcx, QWORD PTR [rdi+16]
	inc	rdx
	lea	r8, QWORD PTR [rdx*4]
	npad	8
$LL65@ShrinkWidt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	movss	xmm1, DWORD PTR [rcx-12]
	movss	xmm2, DWORD PTR [rcx]
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1645 :         width_excess += items[n].Width - width_rounded;

	subss	xmm1, xmm0

; 1646 :         items[n].Width = width_rounded;

	movss	DWORD PTR [rcx-12], xmm0
	movd	xmm0, eax
	addss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	movss	xmm1, DWORD PTR [rcx+12]
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1646 :         items[n].Width = width_rounded;

	movss	DWORD PTR [rcx], xmm0
	subss	xmm2, xmm0
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1645 :         width_excess += items[n].Width - width_rounded;

	addss	xmm3, xmm2
	subss	xmm1, xmm0

; 1646 :         items[n].Width = width_rounded;

	movss	DWORD PTR [rcx+12], xmm0
	addss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	movss	xmm1, DWORD PTR [rcx+24]
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1645 :         width_excess += items[n].Width - width_rounded;

	subss	xmm1, xmm0

; 1646 :         items[n].Width = width_rounded;

	movss	DWORD PTR [rcx+24], xmm0
	add	rcx, 48					; 00000030H
	addss	xmm3, xmm1
	sub	rdx, 1
	jne	SHORT $LL65@ShrinkWidt
$LC64@ShrinkWidt:

; 1642 :     for (int n = 0; n < count; n++)

	cmp	r8, rbx
	jge	SHORT $LN63@ShrinkWidt
	lea	rcx, QWORD PTR [r8*2+1]
	mov	rdx, rbx
	add	rcx, r8
	sub	rdx, r8
	lea	rcx, QWORD PTR [rdi+rcx*4]
$LC52@ShrinkWidt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	movss	xmm1, DWORD PTR [rcx]
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1645 :         width_excess += items[n].Width - width_rounded;

	subss	xmm1, xmm0

; 1646 :         items[n].Width = width_rounded;

	movss	DWORD PTR [rcx], xmm0
	add	rcx, 12
	addss	xmm3, xmm1
	sub	rdx, 1
	jne	SHORT $LC52@ShrinkWidt
$LN63@ShrinkWidt:

; 1647 :     }
; 1648 :     while (width_excess > 0.0f)

	comiss	xmm3, xmm4
	jbe	$LN108@ShrinkWidt
$LL12@ShrinkWidt:

; 1649 :         for (int n = 0; n < count && width_excess > 0.0f; n++)

	xor	edx, edx
	cmp	rbx, 4
	jl	$LC66@ShrinkWidt
	lea	rcx, QWORD PTR [rdi+4]
$LL71@ShrinkWidt:
	comiss	xmm3, xmm4
	jbe	$LN108@ShrinkWidt

; 1650 :         {
; 1651 :             float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);

	movss	xmm1, DWORD PTR [rcx]
	movss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1653 :             width_excess -= width_to_add;

	subss	xmm3, xmm0
	addss	xmm1, xmm0
	comiss	xmm3, xmm4
	movss	DWORD PTR [rcx], xmm1
	jbe	$LN108@ShrinkWidt

; 1650 :         {
; 1651 :             float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);

	movss	xmm1, DWORD PTR [rcx+12]
	movss	xmm0, DWORD PTR [rcx+16]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1653 :             width_excess -= width_to_add;

	subss	xmm3, xmm0
	addss	xmm1, xmm0
	comiss	xmm3, xmm4
	movss	DWORD PTR [rcx+12], xmm1
	jbe	$LN108@ShrinkWidt

; 1650 :         {
; 1651 :             float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);

	movss	xmm1, DWORD PTR [rcx+24]
	movss	xmm0, DWORD PTR [rcx+28]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1653 :             width_excess -= width_to_add;

	subss	xmm3, xmm0
	addss	xmm1, xmm0
	comiss	xmm3, xmm4
	movss	DWORD PTR [rcx+24], xmm1
	jbe	SHORT $LN108@ShrinkWidt
	movss	xmm1, DWORD PTR [rcx+36]
	lea	rax, QWORD PTR [rsi-3]
	movss	xmm0, DWORD PTR [rcx+40]
	add	rdx, 4
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1652 :             items[n].Width += width_to_add;

	addss	xmm1, xmm0

; 1653 :             width_excess -= width_to_add;

	subss	xmm3, xmm0
	movss	DWORD PTR [rcx+36], xmm1
	add	rcx, 48					; 00000030H
	cmp	rdx, rax
	jl	$LL71@ShrinkWidt
$LC66@ShrinkWidt:

; 1649 :         for (int n = 0; n < count && width_excess > 0.0f; n++)

	cmp	rdx, rbx
	jge	SHORT $LN68@ShrinkWidt
	lea	rcx, QWORD PTR [rdx*2+1]
	add	rcx, rdx
	lea	rcx, QWORD PTR [rdi+rcx*4]
$LC16@ShrinkWidt:
	comiss	xmm3, xmm4
	jbe	SHORT $LN108@ShrinkWidt

; 1650 :         {
; 1651 :             float width_to_add = ImMin(items[n].InitialWidth - items[n].Width, 1.0f);

	movss	xmm1, DWORD PTR [rcx]
	inc	rdx
	movss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1652 :             items[n].Width += width_to_add;

	addss	xmm1, xmm0

; 1653 :             width_excess -= width_to_add;

	subss	xmm3, xmm0
	movss	DWORD PTR [rcx], xmm1
	add	rcx, 12
	cmp	rdx, rbx
	jl	SHORT $LC16@ShrinkWidt
$LN68@ShrinkWidt:

; 1647 :     }
; 1648 :     while (width_excess > 0.0f)

	comiss	xmm3, xmm4
	ja	$LL12@ShrinkWidt
$LN108@ShrinkWidt:
	mov	rbx, QWORD PTR [rsp+64]
$LN84@ShrinkWidt:

; 1654 :         }
; 1655 : }

	mov	rsi, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z ENDP ; ImGui::ShrinkWidths
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CalcMaxPopupHeightFromItemCount@@YAMH@Z
_TEXT	SEGMENT
items_count$ = 8
?CalcMaxPopupHeightFromItemCount@@YAMH@Z PROC		; CalcMaxPopupHeightFromItemCount, COMDAT

; 1671 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 1672 :     if (items_count <= 0)

	test	ecx, ecx
	jg	SHORT $LN2@CalcMaxPop

; 1673 :         return FLT_MAX;

	movss	xmm0, DWORD PTR __real@7f7fffff

; 1675 : }

	ret	0
$LN2@CalcMaxPop:

; 1674 :     return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);

	movss	xmm2, DWORD PTR [rax+14632]
	movss	xmm3, DWORD PTR [rax+14564]
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [rax+15696]
	movd	xmm1, ecx
	addss	xmm3, xmm3
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	addss	xmm0, xmm3

; 1675 : }

	ret	0
?CalcMaxPopupHeightFromItemCount@@YAMH@Z ENDP		; CalcMaxPopupHeightFromItemCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z
_TEXT	SEGMENT
tv522 = 64
size_contents_ideal$4 = 64
$T5 = 64
size_contents_current$6 = 72
$T7 = 72
size_expected$8 = 72
constraint_min$9 = 72
size_auto_fit$10 = 88
pos$11 = 88
r_outer$12 = 96
name$ = 112
__$ArrayPad$ = 128
popup_id$ = 224
bb$ = 232
flags$ = 240
?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z PROC	; ImGui::BeginComboPopup, COMDAT

; 1753 : {

$LN120:
	mov	r11, rsp
	push	rbp
	push	rbx
	push	rdi
	push	r12
	push	r15
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax

; 1754 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	edi, r8d
	mov	r12, rdx
	mov	r9d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	movsxd	rax, DWORD PTR [rbx+18936]
	cmp	DWORD PTR [rbx+18920], eax
	jle	$LN31@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	mov	rax, QWORD PTR [rbx+18928]
	cmp	DWORD PTR [rcx+rax], r9d
	jne	$LN31@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm1, DWORD PTR [rdx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1763 :     if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)

	xor	r15d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm1, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1763 :     if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)

	mov	edx, DWORD PTR [rbx+18680]
	xorps	xmm4, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	mov	QWORD PTR [r11+8], rsi
	mov	QWORD PTR [r11+24], r14
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1763 :     if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)

	test	dl, 16
	je	SHORT $LN3@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rbx+18744]
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1765 :         g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);

	movss	DWORD PTR [rbx+18744], xmm0

; 1766 :     }

	jmp	$LN4@BeginCombo
$LN3@BeginCombo:

; 1767 :     else
; 1768 :     {
; 1769 :         if ((flags & ImGuiComboFlags_HeightMask_) == 0)
; 1770 :             flags |= ImGuiComboFlags_HeightRegular;
; 1771 :         IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)); // Only one
; 1772 :         int popup_max_height_in_items = -1;

	or	edi, 4
	mov	ecx, -1
	test	r8b, 30
	cmovne	edi, r8d

; 1773 :         if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;

	test	dil, 4
	je	SHORT $LN6@BeginCombo
	mov	ecx, 8
	jmp	SHORT $LN10@BeginCombo
$LN6@BeginCombo:

; 1774 :         else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;

	test	dil, 2
	je	SHORT $LN8@BeginCombo
	mov	ecx, 4
	jmp	SHORT $LN10@BeginCombo
$LN8@BeginCombo:

; 1775 :         else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;

	test	dil, 8
	mov	eax, 20
	cmovne	ecx, eax
$LN10@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR __real@7f7fffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1777 :         if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.x <= 0.0f) // Don't apply constraints if user specified a size

	mov	eax, edx
	xorps	xmm5, xmm5
	and	eax, 2
	je	SHORT $LN12@BeginCombo
	comiss	xmm4, DWORD PTR [rbx+18716]
	jb	SHORT $LN105@BeginCombo
$LN12@BeginCombo:

; 1778 :             constraint_min.x = w;

	movss	DWORD PTR constraint_min$9[rbp-121], xmm1
	movaps	xmm5, xmm1

; 1779 :         if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize) == 0 || g.NextWindowData.SizeVal.y <= 0.0f)

	test	eax, eax
	je	SHORT $LN14@BeginCombo
$LN105@BeginCombo:
	comiss	xmm4, DWORD PTR [rbx+18720]
	jb	SHORT $LN13@BeginCombo
$LN14@BeginCombo:

; 1780 :             constraint_max.y = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);

	call	?CalcMaxPopupHeightFromItemCount@@YAMH@Z ; CalcMaxPopupHeightFromItemCount
$LN13@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movaps	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8134 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;

	or	edx, 16
	mov	DWORD PTR [rbx+18680], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	unpcklps xmm1, xmm4
	movsd	QWORD PTR tv522[rbp-121], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8135 :     g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);

	movss	DWORD PTR [rbx+18744], xmm5
	movss	xmm1, DWORD PTR tv522[rbp-117]
	movss	DWORD PTR [rbx+18748], xmm1
	mov	DWORD PTR [rbx+18752], 2139095039	; 7f7fffffH
	movss	DWORD PTR [rbx+18756], xmm0

; 8136 :     g.NextWindowData.SizeCallback = custom_callback;

	mov	QWORD PTR [rbx+18760], r15

; 8137 :     g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;

	mov	QWORD PTR [rbx+18768], r15
$LN4@BeginCombo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1786 :     ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth

	mov	r9d, DWORD PTR [rbx+18936]
	lea	r8, OFFSET FLAT:??_C@_0N@JOGGDHMO@?$CD?$CDCombo_?$CF02d@
	mov	edx, 16
	lea	rcx, QWORD PTR name$[rbp-121]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	movzx	r9d, BYTE PTR name$[rbp-121]
	lea	r8, QWORD PTR name$[rbp-120]
	mov	r10d, -1				; ffffffffH
	mov	edx, r10d
	test	r9b, r9b
	je	SHORT $LN45@BeginCombo
	lea	r11, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	npad	2
$LL44@BeginCombo:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r9b, 35					; 00000023H
	jne	SHORT $LN49@BeginCombo
	cmp	BYTE PTR [r8], r9b
	jne	SHORT $LN49@BeginCombo
	cmp	BYTE PTR [r8+1], r9b
	cmove	edx, r10d
$LN49@BeginCombo:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, dl
	movzx	eax, r9b
	movzx	r9d, BYTE PTR [r8]
	xor	rcx, rax
	shr	edx, 8
	inc	r8
	xor	edx, DWORD PTR [r11+rcx*4]
	test	r9b, r9b
	jne	SHORT $LL44@BeginCombo
$LN45@BeginCombo:

; 5800 :     return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2072 :     return ~crc;

	not	edx

; 5800 :     return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);

	lea	rcx, QWORD PTR [rsi+16376]
	call	?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z	; ImGuiStorage::GetVoidPtr
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1791 :     if (ImGuiWindow* popup_window = FindWindowByName(name))

	test	rax, rax
	je	$LN16@BeginCombo

; 1792 :         if (popup_window->WasActive)

	cmp	BYTE PTR [rax+236], r15b
	je	$LN16@BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 6016 :     CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);

	lea	r8, QWORD PTR size_contents_ideal$4[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	mov	QWORD PTR size_contents_ideal$4[rbp-121], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 6016 :     CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);

	lea	rdx, QWORD PTR size_contents_current$6[rbp-121]
	mov	rcx, rax
	call	?CalcWindowContentSizes@@YAXPEAUImGuiWindow@@PEAUImVec2@@1@Z ; CalcWindowContentSizes

; 6017 :     ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);

	mov	rdx, rcx
	lea	r8, QWORD PTR size_contents_ideal$4[rbp-121]
	lea	rcx, QWORD PTR size_auto_fit$10[rbp-121]
	call	?CalcWindowAutoFitSize@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z ; CalcWindowAutoFitSize

; 6018 :     ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);

	lea	r8, QWORD PTR size_auto_fit$10[rbp-121]
	mov	rdx, r14
	lea	rcx, QWORD PTR size_expected$8[rbp-121]
	call	?CalcWindowSizeAfterConstraint@@YA?AUImVec2@@PEAUImGuiWindow@@AEBU1@@Z ; CalcWindowSizeAfterConstraint
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1796 :             popup_window->AutoPosLastDirection = (flags & ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"

	mov	eax, 3

; 1797 :             ImRect r_outer = GetPopupAllowedExtentRect(popup_window);

	lea	rcx, QWORD PTR r_outer$12[rbp-121]
	test	dil, 1
	mov	rdx, r14
	cmovne	eax, r15d
	mov	DWORD PTR [r14+268], eax
	call	?GetPopupAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z ; ImGui::GetPopupAllowedExtentRect
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1798 :             ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);

	lea	rax, QWORD PTR r_outer$12[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [r12+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1798 :             ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);

	lea	r9, QWORD PTR [r14+268]
	mov	DWORD PTR [rsp+48], 1
	lea	r8, QWORD PTR size_expected$8[rbp-121]
	mov	QWORD PTR [rsp+40], r12
	lea	rdx, QWORD PTR $T5[rbp-121]
	lea	rcx, QWORD PTR pos$11[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rbp-121], xmm0
	movss	DWORD PTR $T5[rbp-117], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1798 :             ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);

	mov	QWORD PTR [rsp+32], rax
	call	?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z ; ImGui::FindBestWindowPosForPopupEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8113 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8114 :     IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 8115 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
; 8116 :     g.NextWindowData.PosVal = pos;

	movsd	xmm0, QWORD PTR pos$11[rbp-121]
	or	DWORD PTR [rsi+18680], 1
	movsd	QWORD PTR [rsi+18700], xmm0

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	mov	QWORD PTR [rsi+18708], r15

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rsi+18684], 1

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [rsi+18740], 1
$LN16@BeginCombo:

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm1, DWORD PTR [rsi+14560]
	lea	rcx, QWORD PTR [rsi+18840]
	movss	xmm0, DWORD PTR [rsi+14564]
	lea	rdx, QWORD PTR $T7[rbp-121]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR [rbx+14612]
	movss	xmm7, DWORD PTR [rbx+14564]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T7[rbp-117], xmm1
	movss	DWORD PTR $T7[rbp-113], xmm0
	mov	DWORD PTR $T7[rbp-121], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1805 :     bool ret = Begin(name, NULL, window_flags);

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	movss	DWORD PTR [rsi+14560], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1805 :     bool ret = Begin(name, NULL, window_flags);

	mov	r8d, 67109191				; 04000147H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	movss	DWORD PTR [rsi+14564], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1805 :     bool ret = Begin(name, NULL, window_flags);

	lea	rcx, QWORD PTR name$[rbp-121]
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 1806 :     PopStyleVar();

	mov	ecx, 1
	movzx	ebx, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	movaps	xmm7, XMMWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+160]
	mov	r14, QWORD PTR [rsp+240]
	mov	rsi, QWORD PTR [rsp+224]

; 1807 :     if (!ret)

	test	bl, bl
	jne	SHORT $LN17@BeginCombo

; 1808 :     {
; 1809 :         EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup

; 1810 :         IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
; 1811 :         return false;

	jmp	SHORT $LN118@BeginCombo
$LN17@BeginCombo:

; 1812 :     }
; 1813 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@BeginCombo
$LN31@BeginCombo:

; 1755 :     if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None))
; 1756 :     {
; 1757 :         g.NextWindowData.ClearFlags();

	xor	r15d, r15d
	mov	DWORD PTR [rbx+18680], r15d
$LN118@BeginCombo:

; 1814 : }

	xor	al, al
$LN1@BeginCombo:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z ENDP	; ImGui::BeginComboPopup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z
_TEXT	SEGMENT
data$ = 8
idx$ = 16
out_text$ = 24
?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z PROC		; Items_ArrayGetter, COMDAT

; 1877 :     const char* const* items = (const char* const*)data;
; 1878 :     if (out_text)

	test	r8, r8
	je	SHORT $LN4@Items_Arra

; 1879 :         *out_text = items[idx];

	movsxd	rax, edx
	mov	rcx, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR [r8], rcx
$LN4@Items_Arra:

; 1880 :     return true;
; 1881 : }

	mov	al, 1
	ret	0
?Items_ArrayGetter@@YA_NPEAXHPEAPEBD@Z ENDP		; Items_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z
_TEXT	SEGMENT
data$ = 8
idx$ = 16
out_text$ = 24
?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z PROC	; Items_SingleStringGetter, COMDAT

; 1886 :     // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
; 1887 :     const char* items_separated_by_zeros = (const char*)data;
; 1888 :     int items_count = 0;

	xor	r9d, r9d

; 1889 :     const char* p = items_separated_by_zeros;
; 1890 :     while (*p)

	cmp	BYTE PTR [rcx], r9b
	je	SHORT $LN9@Items_Sing
$LL2@Items_Sing:

; 1891 :     {
; 1892 :         if (idx == items_count)

	cmp	edx, r9d
	je	SHORT $LN9@Items_Sing

; 1893 :             break;
; 1894 :         p += strlen(p) + 1;

	mov	rax, -1
$LL14@Items_Sing:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL14@Items_Sing
	inc	rcx

; 1895 :         items_count++;

	inc	r9d
	add	rcx, rax
	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LL2@Items_Sing

; 1898 :         return false;

	xor	al, al

; 1902 : }

	ret	0
$LN9@Items_Sing:

; 1896 :     }
; 1897 :     if (!*p)

	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN5@Items_Sing

; 1898 :         return false;

	xor	al, al

; 1902 : }

	ret	0
$LN5@Items_Sing:

; 1899 :     if (out_text)

	test	r8, r8
	je	SHORT $LN6@Items_Sing

; 1900 :         *out_text = p;

	mov	QWORD PTR [r8], rcx
$LN6@Items_Sing:

; 1901 :     return true;

	mov	al, 1

; 1902 : }

	ret	0
?Items_SingleStringGetter@@YA_NPEAXHPEAPEBD@Z ENDP	; Items_SingleStringGetter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z
_TEXT	SEGMENT
data_type$ = 8
?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z PROC ; ImGui::DataTypeGetInfo, COMDAT

; 2005 :     IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
; 2006 :     return &GDataTypeInfo[data_type];

	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	shl	rax, 5
	add	rax, rcx

; 2007 : }

	ret	0
?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z ENDP ; ImGui::DataTypeGetInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z
_TEXT	SEGMENT
buf$ = 8
buf_size$ = 16
data_type$ = 24
p_data$ = 32
format$ = 40
?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z PROC	; ImGui::DataTypeFormatString, COMDAT

; 2011 :     // Signedness doesn't matter when pushing integer arguments
; 2012 :     if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)

	lea	eax, DWORD PTR [r8-4]
	cmp	eax, 1
	jbe	$LN3@DataTypeFo

; 2014 :     if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)

	lea	eax, DWORD PTR [r8-6]
	cmp	eax, 1
	jbe	$LN5@DataTypeFo

; 2016 :     if (data_type == ImGuiDataType_Float)

	cmp	r8d, 8
	jne	SHORT $LN6@DataTypeFo

; 2017 :         return ImFormatString(buf, buf_size, format, *(const float*)p_data);

	movss	xmm3, DWORD PTR [r9]
	mov	r8, QWORD PTR format$[rsp]
	cvtps2pd xmm3, xmm3
	movsxd	rdx, edx
	movq	r9, xmm3
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN6@DataTypeFo:

; 2018 :     if (data_type == ImGuiDataType_Double)

	cmp	r8d, 9
	jne	SHORT $LN7@DataTypeFo

; 2019 :         return ImFormatString(buf, buf_size, format, *(const double*)p_data);

	movsd	xmm3, QWORD PTR [r9]
	mov	r8, QWORD PTR format$[rsp]
	movq	r9, xmm3
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN7@DataTypeFo:

; 2020 :     if (data_type == ImGuiDataType_S8)

	test	r8d, r8d
	jne	SHORT $LN8@DataTypeFo

; 2021 :         return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data);

	movsx	r9d, BYTE PTR [r9]

; 2030 : }

	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN8@DataTypeFo:

; 2022 :     if (data_type == ImGuiDataType_U8)

	cmp	r8d, 1
	jne	SHORT $LN9@DataTypeFo

; 2023 :         return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data);

	movzx	r9d, BYTE PTR [r9]

; 2030 : }

	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN9@DataTypeFo:

; 2024 :     if (data_type == ImGuiDataType_S16)

	cmp	r8d, 2
	jne	SHORT $LN10@DataTypeFo

; 2025 :         return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data);

	movsx	r9d, WORD PTR [r9]

; 2030 : }

	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN10@DataTypeFo:

; 2026 :     if (data_type == ImGuiDataType_U16)

	cmp	r8d, 3
	jne	SHORT $LN11@DataTypeFo

; 2027 :         return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data);

	movzx	r9d, WORD PTR [r9]

; 2030 : }

	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN11@DataTypeFo:

; 2028 :     IM_ASSERT(0);
; 2029 :     return 0;

	xor	eax, eax

; 2030 : }

	ret	0
$LN5@DataTypeFo:

; 2015 :         return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data);

	mov	r9, QWORD PTR [r9]
	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
$LN3@DataTypeFo:

; 2013 :         return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data);

	mov	r9d, DWORD PTR [r9]

; 2030 : }

	mov	r8, QWORD PTR format$[rsp]
	movsxd	rdx, edx
	jmp	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString
?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z ENDP	; ImGui::DataTypeFormatString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z
_TEXT	SEGMENT
data_type$ = 8
op$ = 16
output$ = 24
arg1$ = 32
arg2$ = 40
?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z PROC		; ImGui::DataTypeApplyOp, COMDAT

; 2034 :     IM_ASSERT(op == '+' || op == '-');
; 2035 :     switch (data_type)

	cmp	ecx, 9
	ja	$LN33@DataTypeAp
	movsxd	rax, ecx
	lea	r10, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN106@DataTypeAp[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN4@DataTypeAp:

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN5@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movsx	ecx, BYTE PTR [r9]
	movsx	r10d, BYTE PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r10b, r10b
	jns	SHORT $LN107@DataTypeAp
	mov	eax, -128				; ffffffffffffff80H
	sub	eax, r10d
	cmp	ecx, eax
	jge	SHORT $LN100@DataTypeAp
	mov	cl, -128				; ffffffffffffff80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN100@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r10b, r10b
$LN107@DataTypeAp:
	jle	SHORT $LN38@DataTypeAp
	mov	eax, 127				; 0000007fH
	sub	eax, r10d
	cmp	ecx, eax
	jle	SHORT $LN38@DataTypeAp
	mov	cl, 127					; 0000007fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN38@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	add	cl, r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2038 :             if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN5@DataTypeAp:

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movsx	ecx, BYTE PTR [r9]
	movsx	r10d, BYTE PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r10b, r10b
	jle	SHORT $LN108@DataTypeAp
	lea	eax, DWORD PTR [r10-128]
	cmp	ecx, eax
	jge	SHORT $LN101@DataTypeAp
	mov	cl, -128				; ffffffffffffff80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN101@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r10b, r10b
$LN108@DataTypeAp:
	jns	SHORT $LN42@DataTypeAp
	lea	eax, DWORD PTR [r10+127]
	cmp	ecx, eax
	jle	SHORT $LN42@DataTypeAp
	mov	cl, 127					; 0000007fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN42@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	cl, r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2039 :             if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }

	mov	BYTE PTR [r8], cl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN7@DataTypeAp:

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN8@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movzx	edx, BYTE PTR [r9]
	movzx	r10d, BYTE PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r10b, r10b
	je	SHORT $LN46@DataTypeAp
	mov	ecx, 255				; 000000ffH
	sub	ecx, r10d
	cmp	edx, ecx
	jle	SHORT $LN46@DataTypeAp
	mov	dl, 255					; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [r8], dl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN46@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	add	dl, r10b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2042 :             if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [r8], dl

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN8@DataTypeAp:

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movzx	ecx, BYTE PTR [rax]
	movzx	eax, BYTE PTR [r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	cl, cl
	je	SHORT $LN49@DataTypeAp
	cmp	al, cl
	jae	SHORT $LN49@DataTypeAp
	xor	al, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [r8], al

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN49@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	al, cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2043 :             if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }

	mov	BYTE PTR [r8], al

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN10@DataTypeAp:

; 2046 :             if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN11@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movsx	edx, WORD PTR [r9]
	movsx	r10d, WORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r10w, r10w
	jns	SHORT $LN109@DataTypeAp
	mov	ecx, -32768				; ffffffffffff8000H
	mov	eax, ecx
	sub	eax, r10d
	cmp	edx, eax
	jl	SHORT $LN52@DataTypeAp
	test	r10w, r10w
$LN109@DataTypeAp:
	jle	SHORT $LN54@DataTypeAp
	mov	ecx, 32767				; 00007fffH
	mov	eax, ecx
	sub	eax, r10d
	cmp	edx, eax
	jg	SHORT $LN52@DataTypeAp
$LN54@DataTypeAp:
	lea	ecx, DWORD PTR [r10+rdx]
$LN52@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2046 :             if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [r8], cx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN11@DataTypeAp:

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movsx	ecx, WORD PTR [r9]
	movsx	r10d, WORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r10w, r10w
	jle	SHORT $LN110@DataTypeAp
	lea	eax, DWORD PTR [r10-32768]
	cmp	ecx, eax
	jge	SHORT $LN104@DataTypeAp
	mov	ecx, -32768				; ffffffffffff8000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [r8], cx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN104@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	r10w, r10w
$LN110@DataTypeAp:
	jns	SHORT $LN58@DataTypeAp
	lea	eax, DWORD PTR [r10+32767]
	cmp	ecx, eax
	jle	SHORT $LN58@DataTypeAp
	mov	ecx, 32767				; 00007fffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [r8], cx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN58@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	cx, r10w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2047 :             if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }

	mov	WORD PTR [r8], cx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN13@DataTypeAp:

; 2050 :             if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN14@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movzx	edx, WORD PTR [r9]
	movzx	r10d, WORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	r10w, r10w
	je	SHORT $LN62@DataTypeAp
	mov	r9d, 65535				; 0000ffffH
	mov	ecx, r9d
	sub	ecx, r10d
	cmp	edx, ecx
	jg	SHORT $LN60@DataTypeAp
$LN62@DataTypeAp:
	lea	r9d, DWORD PTR [r10+rdx]
$LN60@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2050 :             if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	mov	WORD PTR [r8], r9w

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN14@DataTypeAp:

; 2051 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	movzx	ecx, WORD PTR [rax]
	movzx	eax, WORD PTR [r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	cx, cx
	je	SHORT $LN65@DataTypeAp
	cmp	ax, cx
	jae	SHORT $LN65@DataTypeAp
	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2051 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	mov	WORD PTR [r8], ax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN65@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	ax, cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2051 :             if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }

	mov	WORD PTR [r8], ax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN16@DataTypeAp:

; 2054 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN17@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	r10d, DWORD PTR [r9]
	mov	edx, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	edx, edx
	jns	SHORT $LN111@DataTypeAp
	mov	ecx, -2147483648			; ffffffff80000000H
	mov	eax, ecx
	sub	eax, edx
	cmp	r10d, eax
	jge	SHORT $LN70@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2054 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [r8], ecx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN111@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	jle	SHORT $LN70@DataTypeAp
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	sub	eax, edx
	cmp	r10d, eax
	jg	SHORT $LN68@DataTypeAp
$LN70@DataTypeAp:
	lea	ecx, DWORD PTR [r10+rdx]
$LN68@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2054 :             if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [r8], ecx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN17@DataTypeAp:

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	ecx, DWORD PTR [r9]
	mov	edx, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	edx, edx
	jle	SHORT $LN112@DataTypeAp
	lea	eax, DWORD PTR [rdx-2147483648]
	cmp	ecx, eax
	jge	SHORT $LN74@DataTypeAp
	mov	ecx, -2147483648			; ffffffff80000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [r8], ecx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN112@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	jns	SHORT $LN74@DataTypeAp
	lea	eax, DWORD PTR [rdx+2147483647]
	cmp	ecx, eax
	jle	SHORT $LN74@DataTypeAp
	mov	ecx, 2147483647				; 7fffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [r8], ecx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN74@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	ecx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2055 :             if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }

	mov	DWORD PTR [r8], ecx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN19@DataTypeAp:

; 2058 :             if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN20@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	edx, DWORD PTR [r9]
	mov	ecx, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	ecx, ecx
	je	SHORT $LN78@DataTypeAp
	mov	eax, ecx
	not	eax
	cmp	edx, eax
	mov	eax, -1					; ffffffffH
	ja	SHORT $LN76@DataTypeAp
$LN78@DataTypeAp:
	lea	eax, DWORD PTR [rdx+rcx]
$LN76@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2058 :             if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	DWORD PTR [r8], eax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN20@DataTypeAp:

; 2059 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	ecx, DWORD PTR [rax]
	mov	eax, DWORD PTR [r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	ecx, ecx
	je	SHORT $LN81@DataTypeAp
	cmp	eax, ecx
	jae	SHORT $LN81@DataTypeAp
	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2059 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	DWORD PTR [r8], eax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN81@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2059 :             if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }

	mov	DWORD PTR [r8], eax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN22@DataTypeAp:

; 2062 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN23@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	r10, QWORD PTR [r9]
	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	rdx, rdx
	jns	SHORT $LN113@DataTypeAp
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
	sub	rax, rdx
	cmp	r10, rax
	jge	SHORT $LN86@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2062 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [r8], rcx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN113@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	jle	SHORT $LN86@DataTypeAp
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rcx
	sub	rax, rdx
	cmp	r10, rax
	jg	SHORT $LN84@DataTypeAp
$LN86@DataTypeAp:
	lea	rcx, QWORD PTR [r10+rdx]
$LN84@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2062 :             if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [r8], rcx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN23@DataTypeAp:

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	r10, QWORD PTR [r9]
	mov	rdx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	rdx, rdx
	jle	SHORT $LN114@DataTypeAp
	mov	rcx, -9223372036854775808		; 8000000000000000H
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	r10, rax
	jge	SHORT $LN90@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [r8], rcx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN114@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	jns	SHORT $LN90@DataTypeAp
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	r10, rax
	jg	SHORT $LN88@DataTypeAp
$LN90@DataTypeAp:
	mov	rcx, r10
	sub	rcx, rdx
$LN88@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2063 :             if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }

	mov	QWORD PTR [r8], rcx

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN25@DataTypeAp:

; 2066 :             if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN26@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	rdx, QWORD PTR [r9]
	mov	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	test	rcx, rcx
	je	SHORT $LN94@DataTypeAp
	mov	rax, rcx
	not	rax
	cmp	rdx, rax
	mov	rax, -1
	ja	SHORT $LN92@DataTypeAp
$LN94@DataTypeAp:
	lea	rax, QWORD PTR [rdx+rcx]
$LN92@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2066 :             if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	QWORD PTR [r8], rax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN26@DataTypeAp:

; 2067 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	cmp	edx, 45					; 0000002dH
	jne	$LN33@DataTypeAp
	mov	rax, QWORD PTR arg2$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r9]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	test	rcx, rcx
	je	SHORT $LN97@DataTypeAp
	cmp	rax, rcx
	jae	SHORT $LN97@DataTypeAp
	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2067 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	QWORD PTR [r8], rax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN97@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2067 :             if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }

	mov	QWORD PTR [r8], rax

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN28@DataTypeAp:

; 2068 :             return;
; 2069 :         case ImGuiDataType_Float:
; 2070 :             if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN29@DataTypeAp
	movss	xmm0, DWORD PTR [r9]
	mov	rax, QWORD PTR arg2$[rsp]
	addss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [r8], xmm0

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN29@DataTypeAp:

; 2071 :             if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }

	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN33@DataTypeAp
	movss	xmm0, DWORD PTR [r9]
	mov	rax, QWORD PTR arg2$[rsp]
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR [r8], xmm0

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	ret	0
$LN31@DataTypeAp:

; 2072 :             return;
; 2073 :         case ImGuiDataType_Double:
; 2074 :             if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }

	cmp	edx, 43					; 0000002bH
	jne	SHORT $LN32@DataTypeAp
	movsd	xmm0, QWORD PTR [r9]
	mov	rax, QWORD PTR arg2$[rsp]
	addsd	xmm0, QWORD PTR [rax]

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	movsd	QWORD PTR [r8], xmm0
	ret	0
$LN32@DataTypeAp:

; 2075 :             if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }

	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN33@DataTypeAp
	movsd	xmm0, QWORD PTR [r9]
	mov	rax, QWORD PTR arg2$[rsp]
	subsd	xmm0, QWORD PTR [rax]

; 2076 :             return;
; 2077 :         case ImGuiDataType_COUNT: break;
; 2078 :     }
; 2079 :     IM_ASSERT(0);
; 2080 : }

	movsd	QWORD PTR [r8], xmm0
$LN33@DataTypeAp:
	ret	0
$LN106@DataTypeAp:
	DD	$LN4@DataTypeAp
	DD	$LN7@DataTypeAp
	DD	$LN10@DataTypeAp
	DD	$LN13@DataTypeAp
	DD	$LN16@DataTypeAp
	DD	$LN19@DataTypeAp
	DD	$LN22@DataTypeAp
	DD	$LN25@DataTypeAp
	DD	$LN28@DataTypeAp
	DD	$LN31@DataTypeAp
?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z ENDP		; ImGui::DataTypeApplyOp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z
_TEXT	SEGMENT
v32$ = 32
data_backup$ = 40
format_sanitized$ = 48
__$ArrayPad$ = 80
buf$ = 144
data_type$ = 152
p_data$ = 160
format$ = 168
?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z PROC	; ImGui::DataTypeApplyFromText, COMDAT

; 2085 : {

$LN94:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r9
	movsxd	rbp, edx
	mov	rsi, r8
	mov	rdi, rcx
$LL2@DataTypeAp:

; 2086 :     while (ImCharIsBlankA(*buf))

	movzx	eax, BYTE PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 375  : static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN62@DataTypeAp
	cmp	al, 9
	jne	SHORT $LN66@DataTypeAp
$LN62@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2087 :         buf++;

	inc	rdi
	jmp	SHORT $LL2@DataTypeAp
$LN66@DataTypeAp:
	mov	QWORD PTR [rsp+96], r14

; 2088 :     if (!buf[0])

	test	al, al
	je	$LN63@DataTypeAp

; 2006 :     return &GDataTypeInfo[data_type];

	lea	rax, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B
	mov	r14, rbp
	shl	r14, 5

; 2089 :         return false;
; 2090 : 
; 2091 :     // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
; 2092 :     const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);
; 2093 :     ImGuiDataTypeTempStorage data_backup;
; 2094 :     memcpy(&data_backup, p_data, type_info->Size);

	lea	rcx, QWORD PTR data_backup$[rsp]

; 2006 :     return &GDataTypeInfo[data_type];

	add	r14, rax

; 2089 :         return false;
; 2090 : 
; 2091 :     // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
; 2092 :     const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);
; 2093 :     ImGuiDataTypeTempStorage data_backup;
; 2094 :     memcpy(&data_backup, p_data, type_info->Size);

	mov	rdx, rsi
	mov	r8, QWORD PTR [r14]
	call	memcpy

; 2095 : 
; 2096 :     // Sanitize format
; 2097 :     // - For float/double we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in, so force them into %f and %lf
; 2098 :     // - In theory could treat empty format as using default, but this would only cover rare/bizarre case of using InputScalar() + integer + format string without %.
; 2099 :     char format_sanitized[32];
; 2100 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	lea	eax, DWORD PTR [rbp-8]
	cmp	eax, 1
	jbe	SHORT $LN7@DataTypeAp

; 3317 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, rbx

; 2102 :     else
; 2103 :         format = ImParseFormatSanitizeForScanning(format, format_sanitized, IM_ARRAYSIZE(format_sanitized));

	lea	r10, QWORD PTR format_sanitized$[rsp]

; 3317 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd

; 3318 :     const char* fmt_out_begin = fmt_out;
; 3319 :     IM_UNUSED(fmt_out_size);
; 3320 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3321 :     bool has_type = false;

	xor	dl, dl
	mov	r11, rax

; 3322 :     while (fmt_in < fmt_end)

	cmp	rbx, rax
	jae	SHORT $LN27@DataTypeAp
	mov	r8, 288028100371939328			; 03ff480800000000H
	mov	r9, 576460752303423497			; 0800000000000009H
$LL26@DataTypeAp:

; 3323 :     {
; 3324 :         char c = *fmt_in++;

	movsx	rcx, BYTE PTR [rbx]
	inc	rbx

; 3325 :         if (!has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))

	test	dl, dl
	jne	SHORT $LN61@DataTypeAp
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN61@DataTypeAp
	bt	r8, rcx
	jb	SHORT $LN31@DataTypeAp
$LN61@DataTypeAp:

; 3326 :             continue;
; 3327 :         has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits

	lea	eax, DWORD PTR [rcx-97]
	cmp	al, 25
	jbe	SHORT $LN35@DataTypeAp
	lea	eax, DWORD PTR [rcx-65]
	cmp	al, 25
	jbe	SHORT $LN35@DataTypeAp
	xor	al, al
	jmp	SHORT $LN36@DataTypeAp
$LN35@DataTypeAp:
	mov	al, 1
$LN36@DataTypeAp:
	or	dl, al

; 3328 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	eax, DWORD PTR [rcx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN70@DataTypeAp
	bt	r9, rax
	jb	SHORT $LN31@DataTypeAp
$LN70@DataTypeAp:

; 3329 :             *(fmt_out++) = c;

	mov	BYTE PTR [r10], cl
	inc	r10
$LN31@DataTypeAp:

; 3322 :     while (fmt_in < fmt_end)

	cmp	rbx, r11
	jb	SHORT $LL26@DataTypeAp
$LN27@DataTypeAp:

; 3330 :     }
; 3331 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r10], 0

; 2102 :     else
; 2103 :         format = ImParseFormatSanitizeForScanning(format, format_sanitized, IM_ARRAYSIZE(format_sanitized));

	lea	rdx, QWORD PTR format_sanitized$[rsp]
	jmp	SHORT $LN6@DataTypeAp
$LN7@DataTypeAp:

; 2101 :         format = type_info->ScanFmt;

	mov	rdx, QWORD PTR [r14+24]
$LN6@DataTypeAp:

; 2104 : 
; 2105 :     // Small types need a 32-bit buffer to receive the result from scanf()
; 2106 :     int v32 = 0;

	xor	ebx, ebx

; 2107 :     if (sscanf(buf, format, type_info->Size >= 4 ? p_data : &v32) < 1)

	lea	r8, QWORD PTR v32$[rsp]
	cmp	QWORD PTR [r14], 4
	mov	rcx, rdi
	mov	DWORD PTR v32$[rsp], ebx
	cmovae	r8, rsi
	call	sscanf
	cmp	eax, 1
	jl	$LN63@DataTypeAp

; 2109 :     if (type_info->Size < 4)

	cmp	QWORD PTR [r14], 4
	jae	$LN16@DataTypeAp

; 2110 :     {
; 2111 :         if (data_type == ImGuiDataType_S8)

	test	ebp, ebp
	jne	SHORT $LN10@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	eax, DWORD PTR v32$[rsp]
	cmp	eax, -128				; ffffffffffffff80H
	jge	SHORT $LN39@DataTypeAp
	mov	eax, -128				; ffffffffffffff80H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2112 :             *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);

	mov	BYTE PTR [rsi], al
	jmp	SHORT $LN16@DataTypeAp
$LN39@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	ecx, 127				; 0000007fH
	cmp	eax, ecx
	cmovg	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2112 :             *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);

	mov	BYTE PTR [rsi], al
	jmp	SHORT $LN16@DataTypeAp
$LN10@DataTypeAp:

; 2113 :         else if (data_type == ImGuiDataType_U8)

	cmp	ebp, 1
	jne	SHORT $LN12@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	eax, DWORD PTR v32$[rsp]
	test	eax, eax
	js	SHORT $LN44@DataTypeAp
	mov	ecx, 255				; 000000ffH
	mov	ebx, eax
	cmp	eax, ecx
	cmovg	ebx, ecx
$LN44@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2114 :             *(ImU8*)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);

	mov	BYTE PTR [rsi], bl
	jmp	SHORT $LN16@DataTypeAp
$LN12@DataTypeAp:

; 2115 :         else if (data_type == ImGuiDataType_S16)

	cmp	ebp, 2
	jne	SHORT $LN14@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	ecx, DWORD PTR v32$[rsp]
	mov	eax, -32768				; ffffffffffff8000H
	cmp	ecx, eax
	jl	SHORT $LN48@DataTypeAp
	mov	edx, 32767				; 00007fffH
	mov	eax, ecx
	cmp	ecx, edx
	cmovg	eax, edx
$LN48@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2116 :             *(ImS16*)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);

	mov	WORD PTR [rsi], ax
	jmp	SHORT $LN16@DataTypeAp
$LN14@DataTypeAp:

; 2117 :         else if (data_type == ImGuiDataType_U16)

	cmp	ebp, 3
	jne	SHORT $LN16@DataTypeAp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	eax, DWORD PTR v32$[rsp]
	test	eax, eax
	js	SHORT $LN52@DataTypeAp
	mov	ecx, 65535				; 0000ffffH
	mov	ebx, eax
	cmp	eax, ecx
	cmovg	ebx, ecx
$LN52@DataTypeAp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2118 :             *(ImU16*)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);

	mov	WORD PTR [rsi], bx
$LN16@DataTypeAp:

; 2119 :         else
; 2120 :             IM_ASSERT(0);
; 2121 :     }
; 2122 : 
; 2123 :     return memcmp(&data_backup, p_data, type_info->Size) != 0;

	mov	r8, QWORD PTR [r14]
	lea	rcx, QWORD PTR data_backup$[rsp]
	mov	rdx, rsi
	call	memcmp
	test	eax, eax
	setne	al
	jmp	SHORT $LN1@DataTypeAp
$LN63@DataTypeAp:

; 2108 :         return false;

	xor	al, al
$LN1@DataTypeAp:
	mov	r14, QWORD PTR [rsp+96]

; 2124 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z ENDP	; ImGui::DataTypeApplyFromText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeCompare@ImGui@@YAHHPEBX0@Z
_TEXT	SEGMENT
data_type$ = 8
arg_1$ = 16
arg_2$ = 24
?DataTypeCompare@ImGui@@YAHHPEBX0@Z PROC		; ImGui::DataTypeCompare, COMDAT

; 2136 :     switch (data_type)

	cmp	ecx, 9
	ja	$LN14@DataTypeCo
	movsxd	rax, ecx
	lea	r9, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN56@DataTypeCo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN4@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	ecx, BYTE PTR [rdx]
	movzx	edx, BYTE PTR [r8]
	cmp	cl, dl
	jge	SHORT $LN17@DataTypeCo
$LN57@DataTypeCo:

; 2152 : }

	mov	eax, -1
	ret	0
$LN17@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	cl, dl
	setg	al

; 2152 : }

	ret	0
$LN5@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	ecx, BYTE PTR [rdx]
	movzx	edx, BYTE PTR [r8]
	cmp	cl, dl
	jb	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	cl, dl
	seta	al

; 2152 : }

	ret	0
$LN6@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	ecx, WORD PTR [rdx]
	movzx	edx, WORD PTR [r8]
	cmp	cx, dx
	jl	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	cx, dx
	setg	al

; 2152 : }

	ret	0
$LN7@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	ecx, WORD PTR [rdx]
	movzx	edx, WORD PTR [r8]
	cmp	cx, dx
	jb	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	cx, dx
	seta	al

; 2152 : }

	ret	0
$LN8@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	mov	ecx, DWORD PTR [rdx]
	mov	edx, DWORD PTR [r8]
	cmp	ecx, edx
	jl	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	ecx, edx
	setg	al

; 2152 : }

	ret	0
$LN9@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	mov	ecx, DWORD PTR [rdx]
	mov	edx, DWORD PTR [r8]
	cmp	ecx, edx
	jb	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	ecx, edx
	seta	al

; 2152 : }

	ret	0
$LN10@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	mov	rcx, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [r8]
	cmp	rcx, rdx
	jl	SHORT $LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	rcx, rdx
	setg	al

; 2152 : }

	ret	0
$LN11@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	mov	rcx, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [r8]
	cmp	rcx, rdx
	jb	$LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	rcx, rdx
	seta	al

; 2152 : }

	ret	0
$LN12@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [r8]
	comiss	xmm1, xmm0
	ja	$LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al

; 2152 : }

	ret	0
$LN13@DataTypeCo:

; 2129 :     if (*lhs < *rhs) return -1;

	movsd	xmm0, QWORD PTR [rdx]
	movsd	xmm1, QWORD PTR [r8]
	comisd	xmm1, xmm0
	ja	$LN57@DataTypeCo

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	comisd	xmm0, xmm1
	seta	al

; 2152 : }

	ret	0
$LN14@DataTypeCo:

; 2137 :     {
; 2138 :     case ImGuiDataType_S8:     return DataTypeCompareT<ImS8  >((const ImS8*  )arg_1, (const ImS8*  )arg_2);
; 2139 :     case ImGuiDataType_U8:     return DataTypeCompareT<ImU8  >((const ImU8*  )arg_1, (const ImU8*  )arg_2);
; 2140 :     case ImGuiDataType_S16:    return DataTypeCompareT<ImS16 >((const ImS16* )arg_1, (const ImS16* )arg_2);
; 2141 :     case ImGuiDataType_U16:    return DataTypeCompareT<ImU16 >((const ImU16* )arg_1, (const ImU16* )arg_2);
; 2142 :     case ImGuiDataType_S32:    return DataTypeCompareT<ImS32 >((const ImS32* )arg_1, (const ImS32* )arg_2);
; 2143 :     case ImGuiDataType_U32:    return DataTypeCompareT<ImU32 >((const ImU32* )arg_1, (const ImU32* )arg_2);
; 2144 :     case ImGuiDataType_S64:    return DataTypeCompareT<ImS64 >((const ImS64* )arg_1, (const ImS64* )arg_2);
; 2145 :     case ImGuiDataType_U64:    return DataTypeCompareT<ImU64 >((const ImU64* )arg_1, (const ImU64* )arg_2);
; 2146 :     case ImGuiDataType_Float:  return DataTypeCompareT<float >((const float* )arg_1, (const float* )arg_2);
; 2147 :     case ImGuiDataType_Double: return DataTypeCompareT<double>((const double*)arg_1, (const double*)arg_2);
; 2148 :     case ImGuiDataType_COUNT:  break;
; 2149 :     }
; 2150 :     IM_ASSERT(0);
; 2151 :     return 0;

	xor	eax, eax

; 2152 : }

	ret	0
	npad	1
$LN56@DataTypeCo:
	DD	$LN4@DataTypeCo
	DD	$LN5@DataTypeCo
	DD	$LN6@DataTypeCo
	DD	$LN7@DataTypeCo
	DD	$LN8@DataTypeCo
	DD	$LN9@DataTypeCo
	DD	$LN10@DataTypeCo
	DD	$LN11@DataTypeCo
	DD	$LN12@DataTypeCo
	DD	$LN13@DataTypeCo
?DataTypeCompare@ImGui@@YAHHPEBX0@Z ENDP		; ImGui::DataTypeCompare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z
_TEXT	SEGMENT
data_type$ = 8
p_data$ = 16
p_min$ = 24
p_max$ = 32
?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z PROC		; ImGui::DataTypeClamp, COMDAT

; 2165 :     switch (data_type)

	cmp	ecx, 9
	ja	$LN14@DataTypeCl
	movsxd	rax, ecx
	lea	r10, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN76@DataTypeCl[r10+rax*4]
	add	rcx, r10
	jmp	rcx
$LN4@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN66@DataTypeCl
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rdx], al
	jl	SHORT $LN77@DataTypeCl
$LN66@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [rdx], al
	jle	$LN14@DataTypeCl
$LN77@DataTypeCl:

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	mov	BYTE PTR [rdx], al
	mov	al, 1
	ret	0
$LN5@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN67@DataTypeCl
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rdx], al
	jb	SHORT $LN77@DataTypeCl
$LN67@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [rdx], al
	jbe	$LN14@DataTypeCl
	mov	BYTE PTR [rdx], al
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN6@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN68@DataTypeCl
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rdx], ax
	jl	SHORT $LN78@DataTypeCl
$LN68@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	movzx	eax, WORD PTR [r9]
	cmp	WORD PTR [rdx], ax
	jle	$LN14@DataTypeCl
$LN78@DataTypeCl:

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	mov	WORD PTR [rdx], ax
	mov	al, 1
	ret	0
$LN7@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN69@DataTypeCl
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rdx], ax
	jb	SHORT $LN78@DataTypeCl
$LN69@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	movzx	eax, WORD PTR [r9]
	cmp	WORD PTR [rdx], ax
	jbe	$LN14@DataTypeCl
	mov	WORD PTR [rdx], ax
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN8@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN70@DataTypeCl
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	jl	SHORT $LN79@DataTypeCl
$LN70@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	mov	eax, DWORD PTR [r9]
	cmp	DWORD PTR [rdx], eax
	jle	$LN14@DataTypeCl
$LN79@DataTypeCl:

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	mov	DWORD PTR [rdx], eax
	mov	al, 1
	ret	0
$LN9@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN71@DataTypeCl
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	jb	SHORT $LN79@DataTypeCl
$LN71@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	mov	eax, DWORD PTR [r9]
	cmp	DWORD PTR [rdx], eax
	jbe	$LN14@DataTypeCl
	mov	DWORD PTR [rdx], eax
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN10@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN72@DataTypeCl
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rdx], rax
	jl	SHORT $LN80@DataTypeCl
$LN72@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	$LN14@DataTypeCl
	mov	rax, QWORD PTR [r9]
	cmp	QWORD PTR [rdx], rax
	jle	$LN14@DataTypeCl
$LN80@DataTypeCl:

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	mov	QWORD PTR [rdx], rax
	mov	al, 1
	ret	0
$LN11@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN73@DataTypeCl
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rdx], rax
	jb	SHORT $LN80@DataTypeCl
$LN73@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	SHORT $LN14@DataTypeCl
	mov	rax, QWORD PTR [r9]
	cmp	QWORD PTR [rdx], rax
	jbe	SHORT $LN14@DataTypeCl
	mov	QWORD PTR [rdx], rax
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN12@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN74@DataTypeCl
	movss	xmm0, DWORD PTR [r8]
	comiss	xmm0, DWORD PTR [rdx]
	jbe	SHORT $LN74@DataTypeCl
	movss	DWORD PTR [rdx], xmm0
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN74@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	SHORT $LN14@DataTypeCl
	movss	xmm1, DWORD PTR [r9]
	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN14@DataTypeCl
	movss	DWORD PTR [rdx], xmm1
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN13@DataTypeCl:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r8, r8
	je	SHORT $LN75@DataTypeCl
	movsd	xmm0, QWORD PTR [r8]
	comisd	xmm0, QWORD PTR [rdx]
	jbe	SHORT $LN75@DataTypeCl
	movsd	QWORD PTR [rdx], xmm0
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN75@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r9, r9
	je	SHORT $LN14@DataTypeCl
	movsd	xmm1, QWORD PTR [r9]
	movsd	xmm0, QWORD PTR [rdx]
	comisd	xmm0, xmm1
	jbe	SHORT $LN14@DataTypeCl
	movsd	QWORD PTR [rdx], xmm1
	mov	al, 1

; 2166 :     {
; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);
; 2176 :     case ImGuiDataType_Double: return DataTypeClampT<double>((double*)p_data, (const double*)p_min, (const double*)p_max);
; 2177 :     case ImGuiDataType_COUNT:  break;
; 2178 :     }
; 2179 :     IM_ASSERT(0);
; 2180 :     return false;
; 2181 : }

	ret	0
$LN14@DataTypeCl:
	xor	al, al
	ret	0
	npad	3
$LN76@DataTypeCl:
	DD	$LN4@DataTypeCl
	DD	$LN5@DataTypeCl
	DD	$LN6@DataTypeCl
	DD	$LN7@DataTypeCl
	DD	$LN8@DataTypeCl
	DD	$LN9@DataTypeCl
	DD	$LN10@DataTypeCl
	DD	$LN11@DataTypeCl
	DD	$LN12@DataTypeCl
	DD	$LN13@DataTypeCl
?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z ENDP		; ImGui::DataTypeClamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?GetMinimumStepAtDecimalPrecision@@YAMH@Z
_TEXT	SEGMENT
decimal_precision$ = 8
?GetMinimumStepAtDecimalPrecision@@YAMH@Z PROC		; GetMinimumStepAtDecimalPrecision, COMDAT

; 2185 :     static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
; 2186 :     if (decimal_precision < 0)

	test	ecx, ecx
	jns	SHORT $LN2@GetMinimum

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000

; 2189 : }

	ret	0
$LN2@GetMinimum:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	ecx, 10
	jge	SHORT $LN4@GetMinimum
	movsxd	rax, ecx
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 2189 : }

	ret	0
$LN4@GetMinimum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	ecx
	movd	xmm1, ecx
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	jmp	powf
?GetMinimumStepAtDecimalPrecision@@YAMH@Z ENDP		; GetMinimumStepAtDecimalPrecision
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z
_TEXT	SEGMENT
v32$1 = 96
v32$2 = 96
v32$3 = 96
v32$4 = 96
id$ = 96
data_type$ = 104
p_v$ = 112
v_speed$ = 120
p_min$ = 128
p_max$ = 136
format$ = 144
flags$dead$ = 152
?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z PROC	; ImGui::DragBehavior, COMDAT

; 2356 : {

$LN110:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 2357 :     // Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
; 2358 :     IM_ASSERT((flags == 1 || (flags & ImGuiSliderFlags_InvalidMask_) == 0) && "Invalid ImGuiSliderFlags flags! Has the 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");
; 2359 : 
; 2360 :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbx, r8
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	esi, ecx
	movaps	xmm6, xmm3
	movsxd	rbp, edx

; 2361 :     if (g.ActiveId == id)

	cmp	DWORD PTR [rdi+16504], ecx
	jne	SHORT $LN7@DragBehavi

; 2362 :     {
; 2363 :         // Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.
; 2364 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])

	mov	eax, DWORD PTR [rdi+16544]
	cmp	eax, 1
	jne	SHORT $LN5@DragBehavi
	cmp	BYTE PTR [rdi+3600], 0
	je	SHORT $LN74@DragBehavi
	jmp	SHORT $LN7@DragBehavi
$LN5@DragBehavi:

; 2365 :             ClearActiveID();
; 2366 :         else if ((g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN7@DragBehavi
	cmp	DWORD PTR [rdi+19120], esi
	jne	SHORT $LN7@DragBehavi
	cmp	BYTE PTR [rdi+16516], 0
	jne	SHORT $LN7@DragBehavi
$LN74@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN7@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2369 :     if (g.ActiveId != id)

	cmp	DWORD PTR [rdi+16504], esi
	jne	$LN11@DragBehavi

; 2370 :         return false;
; 2371 :     if ((g.LastItemData.InFlags & ImGuiItemFlags_ReadOnly) || (flags & ImGuiSliderFlags_ReadOnly))

	test	BYTE PTR [rdi+18620], 128		; 00000080H
	jne	$LN11@DragBehavi

; 2373 : 
; 2374 :     switch (data_type)

	cmp	ebp, 9
	ja	$LN11@DragBehavi
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN77@DragBehavi[rdx+rbp*4]
	add	rcx, rdx
	jmp	rcx
$LN12@DragBehavi:

; 2375 :     {
; 2376 :     case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }

	movsx	eax, BYTE PTR [rbx]
	mov	DWORD PTR v32$4[rsp], eax
	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN28@DragBehavi
	movzx	ecx, BYTE PTR [rax]
	jmp	SHORT $LN29@DragBehavi
$LN28@DragBehavi:
	mov	cl, 127					; 0000007fH
$LN29@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	movsx	edx, cl
	test	rax, rax
	je	SHORT $LN30@DragBehavi
	movzx	ecx, BYTE PTR [rax]
	jmp	SHORT $LN31@DragBehavi
$LN30@DragBehavi:
	mov	cl, -128				; ffffffffffffff80H
$LN31@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR v32$4[rsp]
	movsx	r9d, cl
	mov	ecx, 4
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
	test	al, al
	je	$LN1@DragBehavi
	movzx	ecx, BYTE PTR v32$4[rsp]
	mov	BYTE PTR [rbx], cl
	jmp	$LN1@DragBehavi
$LN14@DragBehavi:

; 2377 :     case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }

	movzx	eax, BYTE PTR [rbx]
	mov	DWORD PTR v32$3[rsp], eax
	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN32@DragBehavi
	movzx	ecx, BYTE PTR [rax]
	jmp	SHORT $LN33@DragBehavi
$LN32@DragBehavi:
	mov	cl, 255					; 000000ffH
$LN33@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	movzx	edx, cl
	test	rax, rax
	je	SHORT $LN34@DragBehavi
	movzx	ecx, BYTE PTR [rax]
	jmp	SHORT $LN35@DragBehavi
$LN34@DragBehavi:
	xor	ecx, ecx
$LN35@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR v32$3[rsp]
	movzx	r9d, cl
	mov	ecx, 5
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	test	al, al
	je	$LN1@DragBehavi
	movzx	ecx, BYTE PTR v32$3[rsp]
	mov	BYTE PTR [rbx], cl
	jmp	$LN1@DragBehavi
$LN16@DragBehavi:

; 2378 :     case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT<ImS32, ImS32, float>(ImGuiDataType_S32, &v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }

	movsx	eax, WORD PTR [rbx]
	mov	DWORD PTR v32$2[rsp], eax
	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN36@DragBehavi
	movzx	ecx, WORD PTR [rax]
	jmp	SHORT $LN37@DragBehavi
$LN36@DragBehavi:
	mov	ecx, 32767				; 00007fffH
$LN37@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	movsx	edx, cx
	test	rax, rax
	je	SHORT $LN38@DragBehavi
	movzx	ecx, WORD PTR [rax]
	jmp	SHORT $LN39@DragBehavi
$LN38@DragBehavi:
	mov	ecx, -32768				; ffffffffffff8000H
$LN39@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR v32$2[rsp]
	movsx	r9d, cx
	mov	ecx, 4
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
	test	al, al
	je	$LN1@DragBehavi
	movzx	ecx, WORD PTR v32$2[rsp]
	mov	WORD PTR [rbx], cx
	jmp	$LN1@DragBehavi
$LN18@DragBehavi:

; 2379 :     case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT<ImU32, ImS32, float>(ImGuiDataType_U32, &v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }

	movzx	eax, WORD PTR [rbx]
	mov	DWORD PTR v32$1[rsp], eax
	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN40@DragBehavi
	movzx	ecx, WORD PTR [rax]
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	mov	ecx, 65535				; 0000ffffH
$LN41@DragBehavi:
	mov	r9, QWORD PTR p_min$[rsp]
	movzx	edx, cx
	test	r9, r9
	je	SHORT $LN43@DragBehavi
	movzx	r9d, WORD PTR [r9]
$LN43@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	ecx, 5
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR v32$1[rsp]
	movzx	r9d, r9w
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	test	al, al
	je	$LN1@DragBehavi
	movzx	ecx, WORD PTR v32$1[rsp]
	mov	WORD PTR [rbx], cx
	jmp	$LN1@DragBehavi
$LN20@DragBehavi:

; 2380 :     case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN44@DragBehavi
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN45@DragBehavi
$LN44@DragBehavi:
	mov	ecx, 2147483647				; 7fffffffH
$LN45@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	test	rax, rax
	je	SHORT $LN46@DragBehavi
	mov	r9d, DWORD PTR [rax]
	jmp	SHORT $LN47@DragBehavi
$LN46@DragBehavi:
	mov	r9d, -2147483648			; ffffffff80000000H
$LN47@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, ebp
	call	??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ; ImGui::DragBehaviorT<int,int,float>
	jmp	$LN1@DragBehavi
$LN21@DragBehavi:

; 2381 :     case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN48@DragBehavi
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN49@DragBehavi
$LN48@DragBehavi:
	mov	ecx, -1					; ffffffffH
$LN49@DragBehavi:
	mov	r9, QWORD PTR p_min$[rsp]
	test	r9, r9
	je	SHORT $LN51@DragBehavi
	mov	r9d, DWORD PTR [r9]
$LN51@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, ebp
	call	??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ; ImGui::DragBehaviorT<unsigned int,int,float>
	jmp	$LN1@DragBehavi
$LN22@DragBehavi:

; 2382 :     case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN52@DragBehavi
	mov	rcx, QWORD PTR [rax]
	jmp	SHORT $LN53@DragBehavi
$LN52@DragBehavi:
	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
$LN53@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	test	rax, rax
	je	SHORT $LN54@DragBehavi
	mov	r9, QWORD PTR [rax]
	jmp	SHORT $LN55@DragBehavi
$LN54@DragBehavi:
	mov	r9, -9223372036854775808		; 8000000000000000H
$LN55@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	QWORD PTR [rsp+32], rcx
	mov	ecx, ebp
	call	??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z ; ImGui::DragBehaviorT<__int64,__int64,double>
	jmp	$LN1@DragBehavi
$LN23@DragBehavi:

; 2383 :     case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN56@DragBehavi
	mov	rcx, QWORD PTR [rax]
	jmp	SHORT $LN57@DragBehavi
$LN56@DragBehavi:
	mov	rcx, -1
$LN57@DragBehavi:
	mov	r9, QWORD PTR p_min$[rsp]
	test	r9, r9
	je	SHORT $LN59@DragBehavi
	mov	r9, QWORD PTR [r9]
$LN59@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	QWORD PTR [rsp+32], rcx
	mov	ecx, ebp
	call	??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
	jmp	$LN1@DragBehavi
$LN24@DragBehavi:

; 2384 :     case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN60@DragBehavi
	movss	xmm0, DWORD PTR [rax]
	jmp	SHORT $LN61@DragBehavi
$LN60@DragBehavi:
	movss	xmm0, DWORD PTR __real@7f7fffff
$LN61@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	test	rax, rax
	je	SHORT $LN62@DragBehavi
	movss	xmm3, DWORD PTR [rax]
	jmp	SHORT $LN63@DragBehavi
$LN62@DragBehavi:
	movss	xmm3, DWORD PTR __real@ff7fffff
$LN63@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	ecx, ebp
	movss	DWORD PTR [rsp+32], xmm0
	call	??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z ; ImGui::DragBehaviorT<float,float,float>
	jmp	SHORT $LN1@DragBehavi
$LN25@DragBehavi:

; 2385 :     case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, flags);

	mov	rax, QWORD PTR p_max$[rsp]
	test	rax, rax
	je	SHORT $LN64@DragBehavi
	movsd	xmm0, QWORD PTR [rax]
	jmp	SHORT $LN65@DragBehavi
$LN64@DragBehavi:
	movsd	xmm0, QWORD PTR __real@7fefffffffffffff
$LN65@DragBehavi:
	mov	rax, QWORD PTR p_min$[rsp]
	test	rax, rax
	je	SHORT $LN66@DragBehavi
	movsd	xmm3, QWORD PTR [rax]
	jmp	SHORT $LN67@DragBehavi
$LN66@DragBehavi:
	movsd	xmm3, QWORD PTR __real@ffefffffffffffff
$LN67@DragBehavi:
	mov	rax, QWORD PTR format$[rsp]
	movaps	xmm2, xmm6
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rbx
	mov	ecx, ebp
	movsd	QWORD PTR [rsp+32], xmm0
	call	??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z ; ImGui::DragBehaviorT<double,double,double>
	jmp	SHORT $LN1@DragBehavi
$LN11@DragBehavi:

; 2372 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2386 :     case ImGuiDataType_COUNT:  break;
; 2387 :     }
; 2388 :     IM_ASSERT(0);
; 2389 :     return false;
; 2390 : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
	npad	1
$LN77@DragBehavi:
	DD	$LN12@DragBehavi
	DD	$LN14@DragBehavi
	DD	$LN16@DragBehavi
	DD	$LN18@DragBehavi
	DD	$LN20@DragBehavi
	DD	$LN21@DragBehavi
	DD	$LN22@DragBehavi
	DD	$LN23@DragBehavi
	DD	$LN24@DragBehavi
	DD	$LN25@DragBehavi
?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z ENDP	; ImGui::DragBehavior
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatFindStart@@YAPEBDPEBD@Z
_TEXT	SEGMENT
fmt$ = 8
?ImParseFormatFindStart@@YAPEBDPEBD@Z PROC		; ImParseFormatFindStart, COMDAT

; 3251 : {

	npad	2
$LN17@ImParseFor:

; 3252 :     while (char c = fmt[0])
; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN14@ImParseFor
	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 37					; 00000025H
	jne	SHORT $LN15@ImParseFor
	cmp	BYTE PTR [rax], dl
	jne	SHORT $LN14@ImParseFor

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	dl, dl
$LN15@ImParseFor:
	cmovne	rax, rcx
	lea	rcx, QWORD PTR [rax+1]
	jmp	SHORT $LN17@ImParseFor
$LN14@ImParseFor:

; 3259 :     }
; 3260 :     return fmt;
; 3261 : }

	mov	rax, rcx
	ret	0
?ImParseFormatFindStart@@YAPEBDPEBD@Z ENDP		; ImParseFormatFindStart
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatFindEnd@@YAPEBDPEBD@Z
_TEXT	SEGMENT
fmt$ = 8
?ImParseFormatFindEnd@@YAPEBDPEBD@Z PROC		; ImParseFormatFindEnd, COMDAT

; 3265 :     // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
; 3266 :     if (fmt[0] != '%')

	cmp	BYTE PTR [rcx], 37			; 00000025H
	mov	r8, rcx
	je	SHORT $LN5@ImParseFor

; 3267 :         return fmt;

	mov	rax, rcx

; 3278 : }

	ret	0
$LN5@ImParseFor:

; 3268 :     const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
; 3269 :     const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
; 3270 :     for (char c; (c = *fmt) != 0; fmt++)

	mov	al, 37					; 00000025H
	npad	2
$LL4@ImParseFor:

; 3271 :     {
; 3272 :         if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)

	lea	ecx, DWORD PTR [rax-65]
	movsx	r9d, al
	cmp	cl, 25
	ja	SHORT $LN16@ImParseFor
	lea	ecx, DWORD PTR [r9-65]
	mov	edx, 1
	shl	edx, cl
	test	edx, 2304				; 00000900H
	je	SHORT $LN11@ImParseFor
$LN16@ImParseFor:

; 3273 :             return fmt + 1;
; 3274 :         if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)

	sub	al, 97					; 00000061H
	cmp	al, 25
	ja	SHORT $LN2@ImParseFor
	lea	ecx, DWORD PTR [r9-97]
	mov	eax, 1
	shl	eax, cl
	test	eax, 38275712				; 02480a80H
	je	SHORT $LN11@ImParseFor
$LN2@ImParseFor:

; 3268 :     const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
; 3269 :     const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
; 3270 :     for (char c; (c = *fmt) != 0; fmt++)

	movzx	eax, BYTE PTR [r8+1]
	inc	r8
	test	al, al
	jne	SHORT $LL4@ImParseFor

; 3276 :     }
; 3277 :     return fmt;

	mov	rax, r8

; 3278 : }

	ret	0
$LN11@ImParseFor:

; 3275 :             return fmt + 1;

	lea	rax, QWORD PTR [r8+1]

; 3278 : }

	ret	0
?ImParseFormatFindEnd@@YAPEBDPEBD@Z ENDP		; ImParseFormatFindEnd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z
_TEXT	SEGMENT
fmt$ = 48
buf$ = 56
buf_size$dead$ = 64
?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z PROC	; ImParseFormatTrimDecorations, COMDAT

; 3286 : {

$LN33:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r10, rcx
	mov	rdi, rdx

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN24@ImParseFor
$LL6@ImParseFor:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN31@ImParseFor
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN24@ImParseFor

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN31@ImParseFor:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL6@ImParseFor
$LN24@ImParseFor:

; 3287 :     const char* fmt_start = ImParseFormatFindStart(fmt);
; 3288 :     if (fmt_start[0] != '%')

	cmp	BYTE PTR [r10], 37			; 00000025H
	je	SHORT $LN2@ImParseFor

; 3289 :         return "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@

; 3295 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@ImParseFor:

; 3290 :     const char* fmt_end = ImParseFormatFindEnd(fmt_start);

	mov	rcx, r10
	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd

; 3291 :     if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.

	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN3@ImParseFor

; 3292 :         return fmt_start;

	mov	rax, r10

; 3295 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@ImParseFor:

; 3293 :     ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));

	sub	rax, r10
	mov	QWORD PTR [rsp+48], rbx
	inc	rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	ebx, 32					; 00000020H
	cmp	rax, rbx
	cmovb	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1809 :     if (count < 1)

	cmp	rbx, 1
	jb	SHORT $LN14@ImParseFor

; 1810 :         return;
; 1811 :     if (count > 1)

	jbe	SHORT $LN16@ImParseFor

; 1812 :         strncpy(dst, src, count - 1);

	lea	r8, QWORD PTR [rbx-1]
	mov	rdx, r10
	mov	rcx, rdi
	call	QWORD PTR __imp_strncpy
$LN16@ImParseFor:

; 1813 :     dst[count - 1] = 0;

	mov	BYTE PTR [rbx+rdi-1], 0
$LN14@ImParseFor:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3294 :     return buf;

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi

; 3295 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z ENDP	; ImParseFormatTrimDecorations
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z
_TEXT	SEGMENT
fmt_in$ = 48
fmt_out$ = 56
fmt_out_size$dead$ = 64
?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z PROC	; ImParseFormatSanitizeForPrinting, COMDAT

; 3301 : {

$LN13:
	sub	rsp, 40					; 00000028H
	mov	r10, rdx
	mov	r11, rcx

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r11, rax
	jae	SHORT $LN11@ImParseFor
	mov	r9, 576460752303423497			; 0800000000000009H
$LL2@ImParseFor:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r11]
	inc	r11

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN9@ImParseFor
	bt	r9, rcx
	jb	SHORT $LN4@ImParseFor
$LN9@ImParseFor:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r10], dl
	inc	r10
$LN4@ImParseFor:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r11, r8
	jb	SHORT $LL2@ImParseFor
$LN11@ImParseFor:

; 3310 :     }
; 3311 :     *fmt_out = 0; // Zero-terminate
; 3312 : }

	mov	BYTE PTR [r10], 0
	add	rsp, 40					; 00000028H
	ret	0
?ImParseFormatSanitizeForPrinting@@YAXPEBDPEAD_K@Z ENDP	; ImParseFormatSanitizeForPrinting
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z
_TEXT	SEGMENT
fmt_in$ = 48
fmt_out$ = 56
fmt_out_size$dead$ = 64
?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z PROC ; ImParseFormatSanitizeForScanning, COMDAT

; 3316 : {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r11, rdx
	mov	r10, rcx

; 3317 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd

; 3318 :     const char* fmt_out_begin = fmt_out;
; 3319 :     IM_UNUSED(fmt_out_size);
; 3320 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3321 :     bool has_type = false;

	xor	r8b, r8b
	mov	r9, rax
	mov	rbx, r11

; 3322 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN23@ImParseFor
	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, 576460752303423497			; 0800000000000009H
	mov	QWORD PTR [rsp+56], rdi
	mov	rdi, 288028100371939328			; 03ff480800000000H
	npad	3
$LL2@ImParseFor:

; 3323 :     {
; 3324 :         char c = *fmt_in++;

	movsx	rdx, BYTE PTR [r10]
	inc	r10

; 3325 :         if (!has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#'))

	test	r8b, r8b
	jne	SHORT $LN18@ImParseFor
	cmp	dl, 57					; 00000039H
	ja	SHORT $LN18@ImParseFor
	bt	rdi, rdx
	jb	SHORT $LN7@ImParseFor
$LN18@ImParseFor:

; 3326 :             continue;
; 3327 :         has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits

	lea	eax, DWORD PTR [rdx-97]
	cmp	al, 25
	jbe	SHORT $LN11@ImParseFor
	lea	eax, DWORD PTR [rdx-65]
	cmp	al, 25
	jbe	SHORT $LN11@ImParseFor
	xor	al, al
	jmp	SHORT $LN12@ImParseFor
$LN11@ImParseFor:
	mov	al, 1
$LN12@ImParseFor:
	or	r8b, al

; 3328 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	eax, DWORD PTR [rdx-36]
	cmp	al, 59					; 0000003bH
	ja	SHORT $LN21@ImParseFor
	bt	rsi, rax
	jb	SHORT $LN7@ImParseFor
$LN21@ImParseFor:

; 3329 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN7@ImParseFor:

; 3322 :     while (fmt_in < fmt_end)

	cmp	r10, r9
	jb	SHORT $LL2@ImParseFor
	mov	rdi, QWORD PTR [rsp+56]

; 3332 :     return fmt_out_begin;
; 3333 : }

	mov	rax, rbx
	mov	rsi, QWORD PTR [rsp+48]
	mov	BYTE PTR [r11], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN23@ImParseFor:

; 3330 :     }
; 3331 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], r8b

; 3332 :     return fmt_out_begin;
; 3333 : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ImParseFormatSanitizeForScanning@@YAPEBDPEBDPEAD_K@Z ENDP ; ImParseFormatSanitizeForScanning
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ImParseFormatPrecision@@YAHPEBDH@Z
_TEXT	SEGMENT
fmt$ = 8
default_precision$dead$ = 16
?ImParseFormatPrecision@@YAHPEBDH@Z PROC		; ImParseFormatPrecision, COMDAT

; 3252 :     while (char c = fmt[0])

	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN15@ImParseFor
$LL14@ImParseFor:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 37					; 00000025H
	jne	SHORT $LN47@ImParseFor
	cmp	BYTE PTR [rax], dl
	jne	SHORT $LN15@ImParseFor

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	dl, dl
$LN47@ImParseFor:
	cmovne	rax, rcx
	movzx	edx, BYTE PTR [rax+1]
	lea	rcx, QWORD PTR [rax+1]
	test	dl, dl
	jne	SHORT $LL14@ImParseFor
$LN15@ImParseFor:

; 3352 :     fmt = ImParseFormatFindStart(fmt);
; 3353 :     if (fmt[0] != '%')

	cmp	BYTE PTR [rcx], 37			; 00000025H
	je	SHORT $LN4@ImParseFor

; 3354 :         return default_precision;

	mov	eax, 3

; 3370 : }

	ret	0
$LN4@ImParseFor:

; 3355 :     fmt++;
; 3356 :     while (*fmt >= '0' && *fmt <= '9')

	movzx	eax, BYTE PTR [rcx+1]
	lea	rdx, QWORD PTR [rcx+1]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN3@ImParseFor

; 3254 :         if (c == '%' && fmt[1] != '%')

	movzx	ecx, al
$LL2@ImParseFor:

; 3355 :     fmt++;
; 3356 :     while (*fmt >= '0' && *fmt <= '9')

	movzx	eax, cl
	cmp	cl, 57					; 00000039H
	ja	SHORT $LN3@ImParseFor
	movzx	eax, BYTE PTR [rdx+1]

; 3357 :         fmt++;

	inc	rdx
	movzx	ecx, al
	cmp	al, 48					; 00000030H
	jge	SHORT $LL2@ImParseFor
$LN3@ImParseFor:

; 3358 :     int precision = INT_MAX;

	mov	r10, rdx
	mov	r8d, 2147483647				; 7fffffffH

; 3359 :     if (*fmt == '.')

	mov	r9d, 3
	cmp	al, 46					; 0000002eH
	jne	SHORT $LN6@ImParseFor

; 3339 :     if (*src == '-') { negative = 1; src++; }

	movzx	eax, BYTE PTR [rdx+1]
	xor	ecx, ecx
	mov	r11d, ecx
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN23@ImParseFor
	movzx	eax, BYTE PTR [rdx+2]
	lea	r11d, QWORD PTR [r9-2]
$LN23@ImParseFor:

; 3340 :     if (*src == '+') { src++; }

	mov	rdx, rcx
	sete	dl
	inc	rdx
	add	rdx, r10
	cmp	al, 43					; 0000002bH
	jne	SHORT $LN24@ImParseFor
	lea	rax, QWORD PTR [rdx+1]
	mov	rdx, rax
	movzx	eax, BYTE PTR [rax]
$LN24@ImParseFor:

; 3341 :     TYPE v = 0;
; 3342 :     while (*src >= '0' && *src <= '9')

	cmp	al, 48					; 00000030H
	jl	SHORT $LN22@ImParseFor
	npad	4
$LL21@ImParseFor:
	cmp	al, 57					; 00000039H
	ja	SHORT $LN22@ImParseFor

; 3343 :         v = (v * 10) + (*src++ - '0');

	movzx	eax, al
	lea	ecx, DWORD PTR [rcx+rcx*4]
	inc	rdx
	lea	ecx, DWORD PTR [rcx-24]
	lea	ecx, DWORD PTR [rax+rcx*2]
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL21@ImParseFor
$LN22@ImParseFor:

; 3360 :     {
; 3361 :         fmt = ImAtoi<int>(fmt + 1, &precision);

	mov	r8d, ecx
	neg	r8d
	test	r11d, r11d
	cmove	r8d, ecx

; 3362 :         if (precision < 0 || precision > 99)

	test	r8d, r8d
	js	SHORT $LN7@ImParseFor
	cmp	r8d, 99					; 00000063H
	jle	SHORT $LN6@ImParseFor
$LN7@ImParseFor:

; 3363 :             precision = default_precision;

	mov	r8d, r9d
$LN6@ImParseFor:

; 3364 :     }
; 3365 :     if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation

	movzx	ecx, BYTE PTR [rdx]
	lea	eax, DWORD PTR [rcx-69]
	test	al, 223					; 000000dfH
	mov	eax, -1
	cmove	r8d, eax

; 3366 :         precision = -1;
; 3367 :     if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)

	sub	cl, 71					; 00000047H
	test	cl, 223					; 000000dfH
	jne	SHORT $LN10@ImParseFor
	cmp	r8d, 2147483647				; 7fffffffH
	cmove	r8d, eax
$LN10@ImParseFor:

; 3368 :         precision = -1;
; 3369 :     return (precision == INT_MAX) ? default_precision : precision;

	cmp	r8d, 2147483647				; 7fffffffH
	cmove	r8d, r9d
	mov	eax, r8d

; 3370 : }

	ret	0
?ImParseFormatPrecision@@YAHPEBDH@Z ENDP		; ImParseFormatPrecision
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z
_TEXT	SEGMENT
$T1 = 96
bb$ = 96
id$ = 104
label$ = 112
buf$ = 120
buf_size$dead$ = 128
flags$ = 136
?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z PROC ; ImGui::TempInputText, COMDAT

; 3375 : {

$LN15:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 3376 :     // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
; 3377 :     // We clear ActiveID on the first frame to allow the InputText() taking it back.
; 3378 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r14, r9
	mov	r15, r8
	mov	esi, edx
	mov	rdi, rcx

; 3379 :     const bool init = (g.TempInputId != id);

	mov	ebp, DWORD PTR [rbx+23824]

; 3380 :     if (init)

	cmp	ebp, edx
	je	SHORT $LN2@TempInputT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN2@TempInputT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3383 :     g.CurrentWindow->DC.CursorPos = bb.Min;

	mov	rax, QWORD PTR [rbx+16408]

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	xor	ecx, ecx
	movsd	xmm0, QWORD PTR [rdi]
	mov	r8, r14
	mov	QWORD PTR [rsp+56], rcx
	xor	edx, edx
	mov	QWORD PTR [rsp+48], rcx
	movsd	QWORD PTR [rax+312], xmm0
	lea	r9d, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movss	xmm1, DWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	mov	rcx, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movss	xmm0, DWORD PTR [rdi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	mov	eax, DWORD PTR flags$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm1, DWORD PTR [rdi]
	subss	xmm0, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	bts	eax, 28
	mov	DWORD PTR [rsp+40], eax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+32], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm1
	movss	DWORD PTR $T1[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3385 :     if (init)

	cmp	ebp, esi
	je	SHORT $LN11@TempInputT

; 3386 :     {
; 3387 :         // First frame we started displaying the InputText widget, we expect it to take the active id.
; 3388 :         IM_ASSERT(g.ActiveId == id);
; 3389 :         g.TempInputId = g.ActiveId;

	mov	ecx, DWORD PTR [rbx+16504]
	mov	DWORD PTR [rbx+23824], ecx
$LN11@TempInputT:

; 3390 :     }
; 3391 :     return value_changed;
; 3392 : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z ENDP ; ImGui::TempInputText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalar_DefaultCharsFilter@@YAHHPEBD@Z
_TEXT	SEGMENT
data_type$ = 8
format$ = 16
?InputScalar_DefaultCharsFilter@@YAHHPEBD@Z PROC	; InputScalar_DefaultCharsFilter, COMDAT

; 3396 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	lea	eax, DWORD PTR [rcx-8]
	cmp	eax, 1
	jbe	SHORT $LN3@InputScala

; 3398 :     const char format_last_char = format[0] ? format[strlen(format) - 1] : 0;

	cmp	BYTE PTR [rdx], 0
	je	SHORT $LN10@InputScala
	mov	rax, -1
$LL13@InputScala:
	cmp	BYTE PTR [rdx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL13@InputScala
	movzx	eax, BYTE PTR [rax+rdx-1]

; 3399 :     return (format_last_char == 'x' || format_last_char == 'X') ? ImGuiInputTextFlags_CharsHexadecimal : ImGuiInputTextFlags_CharsDecimal;

	sub	al, 88					; 00000058H
	test	al, 223					; 000000dfH
	mov	eax, 2
	je	SHORT $LN1@InputScala
$LN10@InputScala:
	mov	eax, 1

; 3400 : }

	ret	0
$LN3@InputScala:

; 3397 :         return ImGuiInputTextFlags_CharsScientific;

	mov	eax, 131072				; 00020000H
$LN1@InputScala:

; 3400 : }

	ret	0
?InputScalar_DefaultCharsFilter@@YAHHPEBD@Z ENDP	; InputScalar_DefaultCharsFilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z
_TEXT	SEGMENT
id$1$ = 64
$T1 = 68
label$GSCopy$1$ = 80
data_backup$2 = 80
data_buf$ = 88
fmt_buf$ = 120
__$ArrayPad$ = 152
bb$ = 224
id$ = 232
label$ = 240
data_type$ = 248
p_data$ = 256
format$ = 264
p_clamp_min$ = 272
p_clamp_max$ = 280
?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z PROC ; ImGui::TempInputScalar, COMDAT

; 3406 : {

$LN241:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, QWORD PTR format$[rsp]

; 2006 :     return &GDataTypeInfo[data_type];

	lea	rax, OFFSET FLAT:?GDataTypeInfo@@3QBUImGuiDataTypeInfo@@B

; 3406 : {

	mov	rbx, QWORD PTR p_data$[rsp]
	mov	r13, rcx
	movsxd	r15, r9d

; 2006 :     return &GDataTypeInfo[data_type];

	mov	r12, r15

; 3406 : {

	mov	QWORD PTR label$GSCopy$1$[rsp], r8

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rsi]

; 2006 :     return &GDataTypeInfo[data_type];

	shl	r12, 5
	add	r12, rax

; 3406 : {

	mov	DWORD PTR id$1$[rsp], edx

; 3252 :     while (char c = fmt[0])

	test	cl, cl
	je	SHORT $LN170@TempInputS
$LL16@TempInputS:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [rsi+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN239@TempInputS
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN170@TempInputS

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN239@TempInputS:
	cmovne	rax, rsi
	movzx	ecx, BYTE PTR [rax+1]
	lea	rsi, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL16@TempInputS
$LN170@TempInputS:

; 3288 :     if (fmt_start[0] != '%')

	cmp	BYTE PTR [rsi], 37			; 00000025H
	jne	SHORT $LN160@TempInputS

; 3289 :         return "";
; 3290 :     const char* fmt_end = ImParseFormatFindEnd(fmt_start);

	mov	rcx, rsi
	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd

; 3291 :     if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN2@TempInputS

; 3293 :     ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));

	sub	rax, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edi, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3293 :     ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));

	inc	rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	rax, rdi
	cmovb	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1809 :     if (count < 1)

	cmp	rdi, 1
	jb	SHORT $LN24@TempInputS

; 1810 :         return;
; 1811 :     if (count > 1)

	jbe	SHORT $LN26@TempInputS

; 1812 :         strncpy(dst, src, count - 1);

	lea	r8, QWORD PTR [rdi-1]
	mov	rdx, rsi
	lea	rcx, QWORD PTR fmt_buf$[rsp]
	call	QWORD PTR __imp_strncpy
$LN26@TempInputS:

; 1813 :     dst[count - 1] = 0;

	mov	BYTE PTR fmt_buf$[rsp+rdi-1], 0
$LN24@TempInputS:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3413 :     if (format[0] == 0)

	cmp	BYTE PTR fmt_buf$[rsp], 0

; 3294 :     return buf;

	lea	rsi, QWORD PTR fmt_buf$[rsp]

; 3413 :     if (format[0] == 0)

	jne	SHORT $LN2@TempInputS
$LN160@TempInputS:

; 3414 :         format = type_info->PrintFmt;

	mov	rsi, QWORD PTR [r12+16]
$LN2@TempInputS:

; 3415 :     DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);

	mov	r9, rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	r8d, r15d
	lea	rcx, QWORD PTR data_buf$[rsp]
	mov	edx, 32					; 00000020H
	call	?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z ; ImGui::DataTypeFormatString
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1890 :     char* p = buf;

	lea	rdi, QWORD PTR data_buf$[rsp]
$LL29@TempInputS:

; 1891 :     while (p[0] == ' ' || p[0] == '\t')     // Leading blanks

	movzx	eax, BYTE PTR [rdi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN35@TempInputS
	cmp	al, 9
	jne	SHORT $LN30@TempInputS
$LN35@TempInputS:

; 1892 :         p++;

	inc	rdi
	jmp	SHORT $LL29@TempInputS
$LN30@TempInputS:

; 1893 :     char* p_start = p;

	mov	rdx, rdi

; 1894 :     while (*p != 0)                         // Find end of string

	test	al, al
	je	SHORT $LN171@TempInputS
	npad	7
$LL31@TempInputS:

; 1895 :         p++;

	inc	rdi
	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LL31@TempInputS

; 1896 :     while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks

	cmp	rdi, rdx
	jbe	SHORT $LN171@TempInputS
	npad	3
$LL33@TempInputS:
	movzx	eax, BYTE PTR [rdi-1]
	lea	rcx, QWORD PTR [rdi-1]
	cmp	al, 32					; 00000020H
	je	SHORT $LN36@TempInputS
	cmp	al, 9
	jne	SHORT $LN171@TempInputS
$LN36@TempInputS:

; 1897 :         p--;

	mov	rdi, rcx
	cmp	rcx, rdx
	ja	SHORT $LL33@TempInputS
$LN171@TempInputS:

; 1898 :     if (p_start != buf)                     // Copy memory if we had leading blanks

	lea	rax, QWORD PTR data_buf$[rsp]
	sub	rdi, rdx
	cmp	rdx, rax
	je	SHORT $LN37@TempInputS

; 1899 :         memmove(buf, p_start, p - p_start);

	mov	r8, rdi
	lea	rcx, QWORD PTR data_buf$[rsp]
	call	memmove
$LN37@TempInputS:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3396 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	lea	eax, DWORD PTR [r15-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1900 :     buf[p - p_start] = 0;                   // Zero terminate

	mov	BYTE PTR data_buf$[rsp+rdi], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3396 :     if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)

	cmp	eax, 1
	jbe	SHORT $LN41@TempInputS

; 3398 :     const char format_last_char = format[0] ? format[strlen(format) - 1] : 0;

	cmp	BYTE PTR [rsi], 0
	je	SHORT $LN148@TempInputS
	mov	rax, -1
	npad	4
$LL166@TempInputS:
	cmp	BYTE PTR [rsi+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL166@TempInputS
	movzx	eax, BYTE PTR [rax+rsi-1]

; 3399 :     return (format_last_char == 'x' || format_last_char == 'X') ? ImGuiInputTextFlags_CharsHexadecimal : ImGuiInputTextFlags_CharsDecimal;

	sub	al, 88					; 00000058H
	test	al, 223					; 000000dfH
	jne	SHORT $LN148@TempInputS
	mov	ebp, 2
	jmp	SHORT $LN39@TempInputS
$LN148@TempInputS:
	mov	ebp, 1
	jmp	SHORT $LN39@TempInputS
$LN41@TempInputS:

; 3397 :         return ImGuiInputTextFlags_CharsScientific;

	mov	ebp, 131072				; 00020000H
$LN39@TempInputS:

; 3378 :     ImGuiContext& g = *GImGui;

	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3379 :     const bool init = (g.TempInputId != id);

	mov	r14d, DWORD PTR [rdi+23824]

; 3380 :     if (init)

	cmp	r14d, DWORD PTR id$1$[rsp]
	je	SHORT $LN48@TempInputS
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN48@TempInputS:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3383 :     g.CurrentWindow->DC.CursorPos = bb.Min;

	mov	rax, QWORD PTR [rdi+16408]

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	lea	r8, QWORD PTR data_buf$[rsp]
	movsd	xmm0, QWORD PTR [r13]
	or	ebp, 402653200				; 18000010H
	mov	rcx, QWORD PTR label$GSCopy$1$[rsp]
	mov	r9d, 32					; 00000020H
	xor	edx, edx
	movsd	QWORD PTR [rax+312], xmm0
	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movss	xmm1, DWORD PTR [r13+8]
	movss	xmm0, DWORD PTR [r13+12]
	subss	xmm1, DWORD PTR [r13]
	subss	xmm0, DWORD PTR [r13+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR $T1[rsp]
	mov	DWORD PTR [rsp+40], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm1
	movss	DWORD PTR $T1[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3384 :     bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);

	mov	QWORD PTR [rsp+32], rax
	call	?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextEx

; 3385 :     if (init)

	mov	ebp, DWORD PTR id$1$[rsp]
	cmp	r14d, ebp
	je	SHORT $LN49@TempInputS

; 3386 :     {
; 3387 :         // First frame we started displaying the InputText widget, we expect it to take the active id.
; 3388 :         IM_ASSERT(g.ActiveId == id);
; 3389 :         g.TempInputId = g.ActiveId;

	mov	ecx, DWORD PTR [rdi+16504]
	mov	DWORD PTR [rdi+23824], ecx
$LN49@TempInputS:

; 3422 :     if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags))

	test	al, al
	je	$LN168@TempInputS

; 3423 :     {
; 3424 :         // Backup old value
; 3425 :         size_t data_type_size = type_info->Size;

	mov	rdi, QWORD PTR [r12]

; 3426 :         ImGuiDataTypeTempStorage data_backup;
; 3427 :         memcpy(&data_backup, p_data, data_type_size);

	lea	rcx, QWORD PTR data_backup$2[rsp]
	mov	r8, rdi
	mov	rdx, rbx
	call	memcpy

; 3428 : 
; 3429 :         // Apply new value (or operations) then clamp
; 3430 :         DataTypeApplyFromText(data_buf, data_type, p_data, format);

	mov	r9, rsi
	lea	rcx, QWORD PTR data_buf$[rsp]
	mov	r8, rbx
	mov	edx, r15d
	call	?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z ; ImGui::DataTypeApplyFromText

; 3431 :         if (p_clamp_min || p_clamp_max)

	mov	r10, QWORD PTR p_clamp_min$[rsp]
	mov	r8, QWORD PTR p_clamp_max$[rsp]
	test	r10, r10
	jne	SHORT $LN146@TempInputS
	test	r8, r8
	je	$LN112@TempInputS

; 3432 :         {
; 3433 :             if (p_clamp_min && p_clamp_max && DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0)

	jmp	SHORT $LN6@TempInputS
$LN146@TempInputS:
	test	r8, r8
	je	SHORT $LN6@TempInputS
	mov	rdx, r10
	mov	ecx, r15d
	call	?DataTypeCompare@ImGui@@YAHHPEBX0@Z	; ImGui::DataTypeCompare
	test	eax, eax
	jle	SHORT $LN6@TempInputS
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	rax, r10
	mov	r10, r8
	mov	r8, rax
$LN6@TempInputS:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2165 :     switch (data_type)

	cmp	r15d, 9
	ja	$LN112@TempInputS
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN165@TempInputS[rdx+r15*4]
	add	rcx, rdx
	jmp	rcx
$LN62@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN150@TempInputS
	movzx	eax, BYTE PTR [r10]
	cmp	BYTE PTR [rbx], al
	jge	SHORT $LN150@TempInputS
	mov	BYTE PTR [rbx], al
	jmp	$LN112@TempInputS
$LN150@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rbx], al
	jle	$LN112@TempInputS
	mov	BYTE PTR [rbx], al

; 2167 :     case ImGuiDataType_S8:     return DataTypeClampT<ImS8  >((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);

	jmp	$LN112@TempInputS
$LN63@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN151@TempInputS
	movzx	eax, BYTE PTR [r10]
	cmp	BYTE PTR [rbx], al
	jae	SHORT $LN151@TempInputS
	mov	BYTE PTR [rbx], al
	jmp	$LN112@TempInputS
$LN151@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rbx], al
	jbe	$LN112@TempInputS
	mov	BYTE PTR [rbx], al

; 2168 :     case ImGuiDataType_U8:     return DataTypeClampT<ImU8  >((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);

	jmp	$LN112@TempInputS
$LN64@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN152@TempInputS
	movzx	eax, WORD PTR [r10]
	cmp	WORD PTR [rbx], ax
	jge	SHORT $LN152@TempInputS
	mov	WORD PTR [rbx], ax
	jmp	$LN112@TempInputS
$LN152@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rbx], ax
	jle	$LN112@TempInputS
	mov	WORD PTR [rbx], ax

; 2169 :     case ImGuiDataType_S16:    return DataTypeClampT<ImS16 >((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);

	jmp	$LN112@TempInputS
$LN65@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN153@TempInputS
	movzx	eax, WORD PTR [r10]
	cmp	WORD PTR [rbx], ax
	jae	SHORT $LN153@TempInputS
	mov	WORD PTR [rbx], ax
	jmp	$LN112@TempInputS
$LN153@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rbx], ax
	jbe	$LN112@TempInputS
	mov	WORD PTR [rbx], ax

; 2170 :     case ImGuiDataType_U16:    return DataTypeClampT<ImU16 >((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);

	jmp	$LN112@TempInputS
$LN66@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN154@TempInputS
	mov	eax, DWORD PTR [r10]
	cmp	DWORD PTR [rbx], eax
	jge	SHORT $LN154@TempInputS
	mov	DWORD PTR [rbx], eax
	jmp	$LN112@TempInputS
$LN154@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rbx], eax
	jle	$LN112@TempInputS
	mov	DWORD PTR [rbx], eax

; 2171 :     case ImGuiDataType_S32:    return DataTypeClampT<ImS32 >((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);

	jmp	$LN112@TempInputS
$LN67@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN155@TempInputS
	mov	eax, DWORD PTR [r10]
	cmp	DWORD PTR [rbx], eax
	jae	SHORT $LN155@TempInputS
	mov	DWORD PTR [rbx], eax
	jmp	$LN112@TempInputS
$LN155@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rbx], eax
	jbe	$LN112@TempInputS
	mov	DWORD PTR [rbx], eax

; 2172 :     case ImGuiDataType_U32:    return DataTypeClampT<ImU32 >((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);

	jmp	$LN112@TempInputS
$LN68@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN156@TempInputS
	mov	rax, QWORD PTR [r10]
	cmp	QWORD PTR [rbx], rax
	jge	SHORT $LN156@TempInputS
	mov	QWORD PTR [rbx], rax
	jmp	$LN112@TempInputS
$LN156@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	$LN112@TempInputS
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rbx], rax
	jle	$LN112@TempInputS
	mov	QWORD PTR [rbx], rax

; 2173 :     case ImGuiDataType_S64:    return DataTypeClampT<ImS64 >((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);

	jmp	$LN112@TempInputS
$LN69@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN157@TempInputS
	mov	rax, QWORD PTR [r10]
	cmp	QWORD PTR [rbx], rax
	jae	SHORT $LN157@TempInputS
	mov	QWORD PTR [rbx], rax
	jmp	SHORT $LN112@TempInputS
$LN157@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN112@TempInputS
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rbx], rax
	jbe	SHORT $LN112@TempInputS
	mov	QWORD PTR [rbx], rax

; 2174 :     case ImGuiDataType_U64:    return DataTypeClampT<ImU64 >((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);

	jmp	SHORT $LN112@TempInputS
$LN70@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN158@TempInputS
	movss	xmm0, DWORD PTR [r10]
	comiss	xmm0, DWORD PTR [rbx]
	jbe	SHORT $LN158@TempInputS
	movss	DWORD PTR [rbx], xmm0
	jmp	SHORT $LN112@TempInputS
$LN158@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN112@TempInputS
	movss	xmm1, DWORD PTR [r8]
	movss	xmm0, DWORD PTR [rbx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN112@TempInputS
	movss	DWORD PTR [rbx], xmm1

; 2175 :     case ImGuiDataType_Float:  return DataTypeClampT<float >((float* )p_data, (const float* )p_min, (const float* )p_max);

	jmp	SHORT $LN112@TempInputS
$LN71@TempInputS:

; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	r10, r10
	je	SHORT $LN159@TempInputS
	movsd	xmm0, QWORD PTR [r10]
	comisd	xmm0, QWORD PTR [rbx]
	jbe	SHORT $LN159@TempInputS
	movsd	QWORD PTR [rbx], xmm0
	jmp	SHORT $LN112@TempInputS
$LN159@TempInputS:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN112@TempInputS
	movsd	xmm1, QWORD PTR [r8]
	movsd	xmm0, QWORD PTR [rbx]
	comisd	xmm0, xmm1
	jbe	SHORT $LN112@TempInputS
	movsd	QWORD PTR [rbx], xmm1
$LN112@TempInputS:

; 3434 :                 ImSwap(p_clamp_min, p_clamp_max);
; 3435 :             DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);
; 3436 :         }
; 3437 : 
; 3438 :         // Only mark as edited if new value is different
; 3439 :         value_changed = memcmp(&data_backup, p_data, data_type_size) != 0;

	mov	r8, rdi
	lea	rcx, QWORD PTR data_backup$2[rsp]
	mov	rdx, rbx
	call	memcmp
	test	eax, eax
	setne	al

; 3440 :         if (value_changed)

	test	al, al
	je	SHORT $LN7@TempInputS
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	edx, DWORD PTR [rcx+16504]
	cmp	edx, ebp
	je	SHORT $LN116@TempInputS
	test	edx, edx
	jne	SHORT $LN115@TempInputS
$LN116@TempInputS:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rcx+16520], 257		; 00000101H
$LN115@TempInputS:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rcx+18624], 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3422 :     if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags))

	jmp	SHORT $LN7@TempInputS
$LN168@TempInputS:

; 3441 :             MarkItemEdited(id);
; 3442 :     }
; 3443 :     return value_changed;

	xor	al, al
$LN7@TempInputS:

; 3444 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+224]
	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	3
$LN165@TempInputS:
	DD	$LN62@TempInputS
	DD	$LN63@TempInputS
	DD	$LN64@TempInputS
	DD	$LN65@TempInputS
	DD	$LN66@TempInputS
	DD	$LN67@TempInputS
	DD	$LN68@TempInputS
	DD	$LN69@TempInputS
	DD	$LN70@TempInputS
	DD	$LN71@TempInputS
?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z ENDP ; ImGui::TempInputScalar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z
_TEXT	SEGMENT
label$ = 96
data_type$dead$ = 104
p_data$ = 112
components$dead$ = 120
p_step$dead$ = 128
p_step_fast$dead$ = 136
format$dead$ = 144
flags$dead$ = 152
?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z PROC	; ImGui::InputScalarN, COMDAT

; 3524 : {

$LN53:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3524 : {

	mov	rsi, r8
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3526 :     if (window->SkipItems)

	mov	rax, QWORD PTR [rbx+16408]
	cmp	BYTE PTR [rax+240], 0
	je	SHORT $LN5@InputScala

; 3527 :         return false;

	xor	al, al

; 3556 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@InputScala:
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], r14
	mov	QWORD PTR [rsp+112], r15

; 3528 : 
; 3529 :     ImGuiContext& g = *GImGui;
; 3530 :     bool value_changed = false;
; 3531 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 3532 :     PushID(label);

	mov	rcx, rdi
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 3533 :     PushMultiItemsWidths(components, CalcItemWidth());

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movaps	xmm1, xmm0
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 3537 :         PushID(i);

	xor	ecx, ecx
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	xor	r15d, r15d
	lea	r14, OFFSET FLAT:??_C@_04GFJLOHHD@?$CF?43f@
	mov	DWORD PTR [rsp+48], r15d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+40], r14
	xor	r9d, r9d
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], r15
	lea	edx, QWORD PTR [r15+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	movzx	ebp, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR [r8+16408]
	mov	BYTE PTR [rcx+237], 1
	mov	r8, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3537 :         PushID(i);

	lea	ecx, QWORD PTR [r15+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3537 :         PushID(i);

	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3538 :         if (i > 0)
; 3539 :             SameLine(0, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	mov	DWORD PTR [rsp+48], r15d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+40], r14
	lea	r8, QWORD PTR [rsi+4]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r15
	lea	edx, QWORD PTR [r15+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	or	bpl, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r9, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	r8, DWORD PTR [r9+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r9+520]
	mov	ecx, DWORD PTR [rax+r8*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [r8-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r9+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3537 :         PushID(i);

	lea	ecx, QWORD PTR [r15+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r9+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3537 :         PushID(i);

	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3538 :         if (i > 0)
; 3539 :             SameLine(0, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	mov	DWORD PTR [rsp+48], r15d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+40], r14
	lea	r8, QWORD PTR [rsi+8]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r15
	lea	edx, QWORD PTR [r15+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8415 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3540 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	or	bpl, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r9+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]

; 3327 :     const char* text_display_end = text;

	mov	r15, QWORD PTR [rsp+112]
	mov	r14, QWORD PTR [rsp+104]

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN7@InputScala
	npad	7
$LL26@InputScala:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN27@InputScala
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN46@InputScala
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN27@InputScala
$LN46@InputScala:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL26@InputScala
$LN27@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3548 :     if (label != label_end)

	cmp	rdi, rdx
	je	SHORT $LN7@InputScala

; 3549 :     {
; 3550 :         SameLine(0.0f, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3551 :         TextEx(label, label_end);

	mov	rcx, rdi
	xor	r8d, r8d
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN7@InputScala:

; 3552 :     }
; 3553 : 
; 3554 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 3555 :     return value_changed;

	movzx	eax, bpl
	mov	rbp, QWORD PTR [rsp+96]

; 3556 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z ENDP	; ImGui::InputScalarN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z
_TEXT	SEGMENT
label$ = 80
data_type$dead$ = 88
p_data$ = 96
components$dead$ = 104
ItemWidth$ = 112
p_step$dead$ = 120
p_step_fast$dead$ = 128
format$dead$ = 136
flags$dead$ = 144
?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z PROC	; ImGui::InputScalarNWidth, COMDAT

; 3559 : {

$LN53:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3559 : {

	mov	rsi, r8
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3561 :     if (window->SkipItems)

	mov	rax, QWORD PTR [rbx+16408]
	cmp	BYTE PTR [rax+240], 0
	je	SHORT $LN5@InputScala

; 3562 :         return false;

	xor	al, al

; 3590 :     return value_changed;
; 3591 : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@InputScala:
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], r14

; 3563 : 
; 3564 :     ImGuiContext& g = *GImGui;
; 3565 :     bool value_changed = false;
; 3566 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 3567 :     PushID(label);

	mov	rcx, rdi
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 3568 :     PushMultiItemsWidths(components, ItemWidth);

	movss	xmm1, DWORD PTR ItemWidth$[rsp]
	call	?PushMultiItemsWidths@ImGui@@YAXHM@Z	; ImGui::PushMultiItemsWidths

; 3572 :         PushID(i);

	xor	ecx, ecx
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	xor	r14d, r14d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	DWORD PTR [rsp+48], r14d
	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], r14
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], r14
	lea	edx, QWORD PTR [r14+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	movzx	ebp, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR [r8+16408]
	mov	BYTE PTR [rcx+237], 1
	mov	r8, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3572 :         PushID(i);

	lea	ecx, QWORD PTR [r14+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3572 :         PushID(i);

	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3573 :         if (i > 0)
; 3574 :             SameLine(0, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	mov	DWORD PTR [rsp+48], r14d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+40], r14
	lea	r8, QWORD PTR [rsi+4]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r14
	lea	edx, QWORD PTR [r14+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	or	bpl, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r9, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	r8, DWORD PTR [r9+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r9+520]
	mov	ecx, DWORD PTR [rax+r8*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [r8-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r9+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3572 :         PushID(i);

	lea	ecx, QWORD PTR [r14+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r9+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3572 :         PushID(i);

	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 3573 :         if (i > 0)
; 3574 :             SameLine(0, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	mov	DWORD PTR [rsp+48], r14d
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+40], r14
	lea	r8, QWORD PTR [rsi+8]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r14
	lea	edx, QWORD PTR [r14+8]
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8415 :     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3575 :         value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);

	or	bpl, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r9+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
	mov	DWORD PTR [r8+500], ecx

; 3327 :     const char* text_display_end = text;

	mov	r14, QWORD PTR [rsp+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN7@InputScala
$LL28@InputScala:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN29@InputScala
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN46@InputScala
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN29@InputScala
$LN46@InputScala:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL28@InputScala
$LN29@InputScala:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3583 :     if (label != label_end)

	cmp	rdi, rdx
	je	SHORT $LN7@InputScala

; 3584 :     {
; 3585 :         SameLine(0.0f, g.Style.ItemInnerSpacing.x);

	movss	xmm1, DWORD PTR [rbx+14636]
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 3586 :         TextEx(label, label_end);

	mov	rcx, rdi
	xor	r8d, r8d
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
$LN7@InputScala:

; 3587 :     }
; 3588 : 
; 3589 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 3590 :     return value_changed;
; 3591 : }

	mov	rbx, QWORD PTR [rsp+96]
	movzx	eax, bpl
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?InputScalarNWidth@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z ENDP	; ImGui::InputScalarNWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z
_TEXT	SEGMENT
text_begin$ = 8
out_text_end$ = 16
?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z PROC ; InputTextCalcTextLenAndLineCount, COMDAT

; 3674 :     int line_count = 0;
; 3675 :     const char* s = text_begin;
; 3676 :     while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding

	movzx	r9d, BYTE PTR [rcx]
	lea	r8, QWORD PTR [rcx+1]
	xor	eax, eax
	test	r9b, r9b
	je	SHORT $LN3@InputTextC
	npad	1
$LL2@InputTextC:
	cmp	r9b, 10
	lea	ecx, DWORD PTR [rax+1]
	movzx	r9d, BYTE PTR [r8]
	cmovne	ecx, eax
	inc	r8
	mov	eax, ecx
	test	r9b, r9b
	jne	SHORT $LL2@InputTextC
$LN3@InputTextC:

; 3677 :         if (c == '\n')
; 3678 :             line_count++;
; 3679 :     s--;
; 3680 :     if (s[0] != '\n' && s[0] != '\r')

	movzx	ecx, BYTE PTR [r8-1]
	dec	r8
	mov	QWORD PTR [rdx], r8
	cmp	cl, 10
	je	SHORT $LN5@InputTextC
	cmp	cl, 13
	je	SHORT $LN5@InputTextC

; 3681 :         line_count++;

	inc	eax
$LN5@InputTextC:

; 3682 :     *out_text_end = s;
; 3683 :     return line_count;
; 3684 : }

	ret	0
?InputTextCalcTextLenAndLineCount@@YAHPEBDPEAPEBD@Z ENDP ; InputTextCalcTextLenAndLineCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextCalcTextSizeW@@YA?AUImVec2@@PEAUImGuiContext@@PEBG1PEAPEBGPEAU1@_N@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
ctx$ = 16
text_begin$ = 24
text_end$ = 32
remaining$ = 40
out_offset$dead$ = 48
stop_on_new_line$ = 56
?InputTextCalcTextSizeW@@YA?AUImVec2@@PEAUImGuiContext@@PEBG1PEAPEBGPEAU1@_N@Z PROC ; InputTextCalcTextSizeW, COMDAT

; 3688 :     ImGuiContext& g = *ctx;
; 3689 :     ImFont* font = g.Font;

	mov	r11, QWORD PTR [rdx+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3690 :     const float line_height = g.FontSize;

	movss	xmm2, DWORD PTR [rdx+15696]
	mov	r10, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR [rcx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3691 :     const float scale = line_height / font->FontSize;

	movaps	xmm4, xmm2
	xorps	xmm3, xmm3
	xorps	xmm1, xmm1
	divss	xmm4, DWORD PTR [r11+20]

; 3692 : 
; 3693 :     ImVec2 text_size = ImVec2(0, 0);
; 3694 :     float line_width = 0.0f;
; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	r8, r9
	jae	SHORT $LN36@InputTextC
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	movzx	edx, BYTE PTR stop_on_new_line$[rsp]
$LL2@InputTextC:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3699 :         unsigned int c = (unsigned int)(*s++);

	movzx	ecx, WORD PTR [r8]
	add	r8, 2

; 3700 :         if (c == '\n')

	cmp	ecx, 10
	jne	SHORT $LN4@InputTextC
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [r10]
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3703 :             text_size.y += line_height;

	movaps	xmm1, xmm2
	addss	xmm1, DWORD PTR [r10+4]
	movss	DWORD PTR [r10], xmm0
	movss	DWORD PTR [r10+4], xmm1

; 3704 :             line_width = 0.0f;

	movaps	xmm1, xmm3

; 3705 :             if (stop_on_new_line)

	test	dl, dl
	jne	SHORT $LN30@InputTextC

; 3706 :                 break;
; 3707 :             continue;

	jmp	SHORT $LN31@InputTextC
$LN4@InputTextC:

; 3708 :         }
; 3709 :         if (c == '\r')

	cmp	ecx, 13
	je	SHORT $LN31@InputTextC
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [r11]
	jge	SHORT $LN21@InputTextC
	mov	rax, QWORD PTR [r11+8]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN22@InputTextC
$LN21@InputTextC:
	movss	xmm0, DWORD PTR [r11+16]
$LN22@InputTextC:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	mulss	xmm0, xmm4

; 3713 :         line_width += char_width;

	addss	xmm1, xmm0
$LN31@InputTextC:

; 3692 : 
; 3693 :     ImVec2 text_size = ImVec2(0, 0);
; 3694 :     float line_width = 0.0f;
; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	r8, r9
	jb	SHORT $LL2@InputTextC
$LN30@InputTextC:

; 3714 :     }
; 3715 : 
; 3716 :     if (text_size.x < line_width)

	comiss	xmm1, DWORD PTR [r10]
	jbe	SHORT $LN33@InputTextC

; 3717 :         text_size.x = line_width;

	movss	DWORD PTR [r10], xmm1
$LN33@InputTextC:

; 3718 : 
; 3719 :     if (out_offset)
; 3720 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n
; 3721 : 
; 3722 :     if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n

	comiss	xmm1, xmm3
	ja	SHORT $LN37@InputTextC
$LN36@InputTextC:
	movss	xmm0, DWORD PTR [r10+4]
	ucomiss	xmm0, xmm3
	jp	SHORT $LN9@InputTextC
	jne	SHORT $LN9@InputTextC
$LN37@InputTextC:

; 3723 :         text_size.y += line_height;

	addss	xmm2, DWORD PTR [r10+4]
	movss	DWORD PTR [r10+4], xmm2
$LN9@InputTextC:

; 3724 : 
; 3725 :     if (remaining)

	mov	rax, QWORD PTR remaining$[rsp]
	test	rax, rax
	je	SHORT $LN38@InputTextC

; 3726 :         *remaining = s;

	mov	QWORD PTR [rax], r8
$LN38@InputTextC:

; 3727 : 
; 3728 :     return text_size;
; 3729 : }

	mov	rax, r10
	ret	0
?InputTextCalcTextSizeW@@YA?AUImVec2@@PEAUImGuiContext@@PEBG1PEAPEBGPEAU1@_N@Z ENDP ; InputTextCalcTextSizeW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPEBUImGuiInputTextState@@@Z
_TEXT	SEGMENT
obj$ = 8
?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPEBUImGuiInputTextState@@@Z PROC ; ImStb::STB_TEXTEDIT_STRINGLEN, COMDAT

; 3735 : static int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj->CurLenW; }

	mov	eax, DWORD PTR [rcx+12]
	ret	0
?STB_TEXTEDIT_STRINGLEN@ImStb@@YAHPEBUImGuiInputTextState@@@Z ENDP ; ImStb::STB_TEXTEDIT_STRINGLEN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPEBUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 8
idx$ = 16
?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPEBUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_GETCHAR, COMDAT

; 3736 : static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { return obj->TextW[idx]; }

	mov	rax, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3736 : static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { return obj->TextW[idx]; }

	movzx	eax, WORD PTR [rax+rdx*2]
	ret	0
?STB_TEXTEDIT_GETCHAR@ImStb@@YAGPEBUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_GETCHAR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPEAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
obj$ = 8
line_start_idx$ = 16
char_idx$ = 24
?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPEAUImGuiInputTextState@@HH@Z PROC ; ImStb::STB_TEXTEDIT_GETWIDTH, COMDAT

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	lea	eax, DWORD PTR [rdx+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mov	rax, QWORD PTR [rcx+32]
	movzx	r9d, WORD PTR [rax+rdx*2]
	cmp	r9d, 10
	jne	SHORT $LN2@STB_TEXTED
	movss	xmm0, DWORD PTR __real@bf800000
	ret	0
$LN2@STB_TEXTED:
	mov	r8, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [r8+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	r9d, DWORD PTR [rdx]
	jge	SHORT $LN8@STB_TEXTED
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movss	xmm0, DWORD PTR [r8+15696]
	divss	xmm0, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	mov	rax, QWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rax+r9*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mulss	xmm0, xmm1
	ret	0
$LN8@STB_TEXTED:
	movss	xmm0, DWORD PTR [r8+15696]
	divss	xmm0, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	movss	xmm1, DWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mulss	xmm0, xmm1
	ret	0
?STB_TEXTEDIT_GETWIDTH@ImStb@@YAMPEAUImGuiInputTextState@@HH@Z ENDP ; ImStb::STB_TEXTEDIT_GETWIDTH
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z
_TEXT	SEGMENT
key$ = 8
?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z PROC		; ImStb::STB_TEXTEDIT_KEYTOTEXT, COMDAT

; 3738 : static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x200000 ? 0 : key; }

	xor	eax, eax
	cmp	ecx, 2097152				; 00200000H
	cmovge	ecx, eax
	mov	eax, ecx
	ret	0
?STB_TEXTEDIT_KEYTOTEXT@ImStb@@YAHH@Z ENDP		; ImStb::STB_TEXTEDIT_KEYTOTEXT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
r$ = 32
obj$ = 40
line_start_idx$ = 48
?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_LAYOUTROW, COMDAT

; 3741 : {

	push	rbx
	sub	rsp, 16

; 3742 :     const ImWchar* text = obj->TextW.Data;
; 3743 :     const ImWchar* text_remaining = NULL;
; 3744 :     const ImVec2 size = InputTextCalcTextSizeW(obj->Ctx, text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

	movsxd	rax, DWORD PTR [rdx+12]
	mov	r10, rcx
	mov	rbx, QWORD PTR [rdx+32]
	xorps	xmm4, xmm4
	movaps	XMMWORD PTR [rsp], xmm6
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	lea	r11, QWORD PTR [rbx+rax*2]

; 3688 :     ImGuiContext& g = *ctx;

	mov	rax, QWORD PTR [rdx]

; 3689 :     ImFont* font = g.Font;

	mov	r9, QWORD PTR [rax+15688]

; 3690 :     const float line_height = g.FontSize;

	movss	xmm6, DWORD PTR [rax+15696]

; 3742 :     const ImWchar* text = obj->TextW.Data;
; 3743 :     const ImWchar* text_remaining = NULL;
; 3744 :     const ImVec2 size = InputTextCalcTextSizeW(obj->Ctx, text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

	movsxd	rax, r8d

; 3691 :     const float scale = line_height / font->FontSize;

	movaps	xmm5, xmm6
	divss	xmm5, DWORD PTR [r9+20]

; 3742 :     const ImWchar* text = obj->TextW.Data;
; 3743 :     const ImWchar* text_remaining = NULL;
; 3744 :     const ImVec2 size = InputTextCalcTextSizeW(obj->Ctx, text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

	lea	r8, QWORD PTR [rax+rax]
	lea	rdx, QWORD PTR [r8+rbx]

; 3697 :     while (s < text_end)

	cmp	rdx, r11
	jae	SHORT $LN32@STB_TEXTED
$LL4@STB_TEXTED:

; 3698 :     {
; 3699 :         unsigned int c = (unsigned int)(*s++);

	movzx	ecx, WORD PTR [rdx]
	add	rdx, 2

; 3700 :         if (c == '\n')

	cmp	ecx, 10
	je	SHORT $LN36@STB_TEXTED

; 3705 :             if (stop_on_new_line)
; 3706 :                 break;
; 3707 :             continue;
; 3708 :         }
; 3709 :         if (c == '\r')

	cmp	ecx, 13
	je	SHORT $LN33@STB_TEXTED
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [r9]
	jge	SHORT $LN23@STB_TEXTED
	mov	rax, QWORD PTR [r9+8]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN24@STB_TEXTED
$LN23@STB_TEXTED:
	movss	xmm0, DWORD PTR [r9+16]
$LN24@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	mulss	xmm0, xmm5

; 3713 :         line_width += char_width;

	addss	xmm1, xmm0
$LN33@STB_TEXTED:

; 3692 : 
; 3693 :     ImVec2 text_size = ImVec2(0, 0);
; 3694 :     float line_width = 0.0f;
; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	rdx, r11
	jb	SHORT $LL4@STB_TEXTED
	jmp	SHORT $LN32@STB_TEXTED
$LN36@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3704 :             line_width = 0.0f;

	movaps	xmm1, xmm4
	addss	xmm2, xmm6
$LN32@STB_TEXTED:

; 3714 :     }
; 3715 : 
; 3716 :     if (text_size.x < line_width)
; 3717 :         text_size.x = line_width;
; 3718 : 
; 3719 :     if (out_offset)
; 3720 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n
; 3721 : 
; 3722 :     if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n

	comiss	xmm1, xmm4
	movaps	xmm0, xmm1
	maxss	xmm0, xmm3
	ja	SHORT $LN12@STB_TEXTED
	ucomiss	xmm2, xmm4
	jp	SHORT $LN11@STB_TEXTED
	jne	SHORT $LN11@STB_TEXTED
$LN12@STB_TEXTED:

; 3723 :         text_size.y += line_height;

	addss	xmm2, xmm6
$LN11@STB_TEXTED:

; 3745 :     r->x0 = 0.0f;
; 3746 :     r->x1 = size.x;
; 3747 :     r->baseline_y_delta = size.y;
; 3748 :     r->ymin = 0.0f;
; 3749 :     r->ymax = size.y;
; 3750 :     r->num_chars = (int)(text_remaining - (text + line_start_idx));
; 3751 : }

	movaps	xmm6, XMMWORD PTR [rsp]
	xor	eax, eax
	sub	rdx, r8
	movss	DWORD PTR [r10+4], xmm0
	sub	rdx, rbx
	movss	DWORD PTR [r10+8], xmm2
	sar	rdx, 1
	mov	DWORD PTR [r10+20], edx
	movss	DWORD PTR [r10+16], xmm2
	mov	DWORD PTR [r10], eax
	mov	DWORD PTR [r10+12], eax
	add	rsp, 16
	pop	rbx
	ret	0
?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_LAYOUTROW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?is_separator@ImStb@@YA_NI@Z
_TEXT	SEGMENT
c$ = 8
?is_separator@ImStb@@YA_NI@Z PROC			; ImStb::is_separator, COMDAT

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN6@is_separat
	mov	rdx, 576552020358472704			; 0800530200002400H
	bt	rdx, rcx
	jb	SHORT $LN3@is_separat
$LN6@is_separat:
	add	ecx, -91				; ffffffa5H
	cmp	ecx, 34					; 00000022H
	ja	SHORT $LN5@is_separat
	mov	rax, 30064771077			; 0000000700000005H
	bt	rax, rcx
	jae	SHORT $LN5@is_separat
$LN3@is_separat:
	mov	al, 1

; 3756 : }

	ret	0
$LN5@is_separat:

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	xor	al, al

; 3756 : }

	ret	0
?is_separator@ImStb@@YA_NI@Z ENDP			; ImStb::is_separator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 16
idx$ = 24
?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::is_word_boundary_from_right, COMDAT

; 3759 : {

	sub	rsp, 8

; 3760 :     // When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.
; 3761 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	test	DWORD PTR [rcx+3720], 32768		; 00008000H
	jne	$LN3@is_word_bo
	test	edx, edx
	jle	$LN3@is_word_bo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	mov	r11d, 12288				; 00003000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3764 :     bool prev_white = ImCharIsBlankW(obj->TextW[idx - 1]);

	movzx	ecx, WORD PTR [rax+rdx*2-2]
	mov	QWORD PTR [rsp], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	r8, QWORD PTR [rax+rdx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN14@is_word_bo
	cmp	ecx, 9
	je	SHORT $LN14@is_word_bo
	cmp	cx, r11w
	je	SHORT $LN14@is_word_bo
	xor	r9b, r9b
	jmp	SHORT $LN15@is_word_bo
$LN14@is_word_bo:
	mov	r9b, 1
$LN15@is_word_bo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	mov	rbx, 576552020358472704			; 0800530200002400H
	mov	r10, 30064771077			; 0000000700000005H
	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN36@is_word_bo
	bt	rbx, rcx
	jb	SHORT $LN20@is_word_bo
$LN36@is_word_bo:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN35@is_word_bo
	movzx	eax, cx
	bt	r10, rax
	jae	SHORT $LN35@is_word_bo
$LN20@is_word_bo:
	mov	dl, 1
	jmp	SHORT $LN21@is_word_bo
$LN35@is_word_bo:
	xor	dl, dl
$LN21@is_word_bo:

; 3765 :     bool prev_separ = is_separator(obj->TextW[idx - 1]);
; 3766 :     bool curr_white = ImCharIsBlankW(obj->TextW[idx]);

	movzx	ecx, WORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN26@is_word_bo
	cmp	ecx, 9
	je	SHORT $LN26@is_word_bo
	cmp	cx, r11w
	je	SHORT $LN26@is_word_bo
	xor	r8b, r8b
	jmp	SHORT $LN27@is_word_bo
$LN26@is_word_bo:
	mov	r8b, 1
$LN27@is_word_bo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN39@is_word_bo
	bt	rbx, rcx
	jb	SHORT $LN32@is_word_bo
$LN39@is_word_bo:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN38@is_word_bo
	movzx	eax, cx
	bt	r10, rax
	jae	SHORT $LN38@is_word_bo
$LN32@is_word_bo:
	mov	al, 1
	jmp	SHORT $LN33@is_word_bo
$LN38@is_word_bo:
	xor	al, al
$LN33@is_word_bo:
	mov	rbx, QWORD PTR [rsp]

; 3767 :     bool curr_separ = is_separator(obj->TextW[idx]);
; 3768 :     return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	r9b, r9b
	jne	SHORT $LN5@is_word_bo
	test	dl, dl
	jne	SHORT $LN5@is_word_bo
	test	al, al
	je	SHORT $LN3@is_word_bo
$LN34@is_word_bo:
	test	dl, dl
	jne	SHORT $LN3@is_word_bo
$LN8@is_word_bo:
	mov	eax, 1

; 3769 : }

	add	rsp, 8
	ret	0
$LN5@is_word_bo:

; 3767 :     bool curr_separ = is_separator(obj->TextW[idx]);
; 3768 :     return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	al, al
	jne	SHORT $LN34@is_word_bo
	test	r8b, r8b
	je	SHORT $LN8@is_word_bo
$LN3@is_word_bo:

; 3769 : }

	xor	eax, eax
	add	rsp, 8
	ret	0
?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::is_word_boundary_from_right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 16
idx$ = 24
?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::is_word_boundary_from_left, COMDAT

; 3771 : {

	sub	rsp, 8

; 3772 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	test	DWORD PTR [rcx+3720], 32768		; 00008000H
	jne	$LN3@is_word_bo
	test	edx, edx
	jle	$LN3@is_word_bo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r11, edx
	mov	rdx, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3772 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	mov	QWORD PTR [rsp+16], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	mov	ebx, 12288				; 00003000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3772 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	mov	QWORD PTR [rsp], rdi

; 3773 :         return 0;
; 3774 : 
; 3775 :     bool prev_white = ImCharIsBlankW(obj->TextW[idx]);

	movzx	ecx, WORD PTR [rdx+r11*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN13@is_word_bo
	cmp	ecx, 9
	je	SHORT $LN13@is_word_bo
	cmp	cx, bx
	je	SHORT $LN13@is_word_bo
	xor	r9b, r9b
	jmp	SHORT $LN14@is_word_bo
$LN13@is_word_bo:
	mov	r9b, 1
$LN14@is_word_bo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	mov	rdi, 576552020358472704			; 0800530200002400H
	mov	r10, 30064771077			; 0000000700000005H
	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN35@is_word_bo
	bt	rdi, rcx
	jb	SHORT $LN19@is_word_bo
$LN35@is_word_bo:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN34@is_word_bo
	movzx	eax, cx
	bt	r10, rax
	jae	SHORT $LN34@is_word_bo
$LN19@is_word_bo:
	mov	r8b, 1
	jmp	SHORT $LN20@is_word_bo
$LN34@is_word_bo:
	xor	r8b, r8b
$LN20@is_word_bo:

; 3776 :     bool prev_separ = is_separator(obj->TextW[idx]);
; 3777 :     bool curr_white = ImCharIsBlankW(obj->TextW[idx - 1]);

	movzx	ecx, WORD PTR [rdx+r11*2-2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN25@is_word_bo
	cmp	ecx, 9
	je	SHORT $LN25@is_word_bo
	cmp	cx, bx
	je	SHORT $LN25@is_word_bo
	xor	dl, dl
	jmp	SHORT $LN26@is_word_bo
$LN25@is_word_bo:
	mov	dl, 1
$LN26@is_word_bo:
	mov	rbx, QWORD PTR [rsp+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN38@is_word_bo
	bt	rdi, rcx
	jb	SHORT $LN31@is_word_bo
$LN38@is_word_bo:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN37@is_word_bo
	movzx	eax, cx
	bt	r10, rax
	jae	SHORT $LN37@is_word_bo
$LN31@is_word_bo:
	mov	al, 1
	jmp	SHORT $LN32@is_word_bo
$LN37@is_word_bo:
	xor	al, al
$LN32@is_word_bo:
	mov	rdi, QWORD PTR [rsp]

; 3778 :     bool curr_separ = is_separator(obj->TextW[idx - 1]);
; 3779 :     return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	r9b, r9b
	je	SHORT $LN5@is_word_bo
	test	al, al
	jne	SHORT $LN33@is_word_bo
	test	dl, dl
	je	SHORT $LN7@is_word_bo
$LN3@is_word_bo:

; 3780 : }

	xor	eax, eax
	add	rsp, 8
	ret	0
$LN5@is_word_bo:

; 3778 :     bool curr_separ = is_separator(obj->TextW[idx - 1]);
; 3779 :     return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	al, al
	je	SHORT $LN3@is_word_bo
$LN33@is_word_bo:
	test	r8b, r8b
	jne	SHORT $LN3@is_word_bo
$LN7@is_word_bo:
	mov	eax, 1

; 3780 : }

	add	rsp, 8
	ret	0
?is_word_boundary_from_left@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::is_word_boundary_from_left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 24
idx$ = 32
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL, COMDAT

; 3781 : static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

	push	rsi
	push	rdi
	mov	r9d, edx
	xor	esi, esi
	sub	r9d, 1
	mov	rdi, rcx
	js	$LN50@STB_TEXTED
	mov	QWORD PTR [rsp+24], rbx
	mov	ebx, DWORD PTR [rcx+3720]
	mov	QWORD PTR [rsp+32], rbp
	and	ebx, 32768				; 00008000H
	mov	QWORD PTR [rsp+40], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	ebp, 12288				; 00003000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3781 : static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

	mov	QWORD PTR [rsp+48], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r14, 576552020358472704			; 0800530200002400H
	mov	r15, 30064771077			; 0000000700000005H
	movsxd	r11, r9d
$LL2@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3761 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	test	ebx, ebx
	jne	$LN43@STB_TEXTED
	test	r11, r11
	jle	$LN43@STB_TEXTED
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3764 :     bool prev_white = ImCharIsBlankW(obj->TextW[idx - 1]);

	movzx	ecx, WORD PTR [rdx+r11*2-2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN18@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN18@STB_TEXTED
	cmp	cx, bp
	je	SHORT $LN18@STB_TEXTED
	xor	r10b, r10b
	jmp	SHORT $LN19@STB_TEXTED
$LN18@STB_TEXTED:
	mov	r10b, 1
$LN19@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN45@STB_TEXTED
	bt	r14, rcx
	jb	SHORT $LN24@STB_TEXTED
$LN45@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN44@STB_TEXTED
	movzx	eax, cx
	bt	r15, rax
	jae	SHORT $LN44@STB_TEXTED
$LN24@STB_TEXTED:
	mov	r8b, 1
	jmp	SHORT $LN25@STB_TEXTED
$LN44@STB_TEXTED:
	xor	r8b, r8b
$LN25@STB_TEXTED:

; 3766 :     bool curr_white = ImCharIsBlankW(obj->TextW[idx]);

	movzx	ecx, WORD PTR [rdx+r11*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN30@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN30@STB_TEXTED
	cmp	cx, bp
	je	SHORT $LN30@STB_TEXTED
	xor	dl, dl
	jmp	SHORT $LN31@STB_TEXTED
$LN30@STB_TEXTED:
	mov	dl, 1
$LN31@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN48@STB_TEXTED
	bt	r14, rcx
	jb	SHORT $LN36@STB_TEXTED
$LN48@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN47@STB_TEXTED
	movzx	eax, cx
	bt	r15, rax
	jae	SHORT $LN47@STB_TEXTED
$LN36@STB_TEXTED:
	mov	al, 1
	jmp	SHORT $LN37@STB_TEXTED
$LN47@STB_TEXTED:
	xor	al, al
$LN37@STB_TEXTED:

; 3768 :     return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	r10b, r10b
	jne	SHORT $LN9@STB_TEXTED
	test	r8b, r8b
	jne	SHORT $LN9@STB_TEXTED
	test	al, al
	je	SHORT $LN11@STB_TEXTED
$LN42@STB_TEXTED:
	test	r8b, r8b
	jne	SHORT $LN11@STB_TEXTED
$LN12@STB_TEXTED:
	mov	eax, 1
	jmp	SHORT $LN13@STB_TEXTED
$LN9@STB_TEXTED:
	test	al, al
	jne	SHORT $LN42@STB_TEXTED
	test	dl, dl
	je	SHORT $LN12@STB_TEXTED
$LN11@STB_TEXTED:
	mov	eax, esi
$LN13@STB_TEXTED:

; 3781 : static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

	test	eax, eax
	jne	SHORT $LN70@STB_TEXTED
$LN43@STB_TEXTED:
	dec	r9d
	sub	r11, 1
	jns	$LL2@STB_TEXTED
$LN70@STB_TEXTED:
	mov	r14, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+24]
	mov	r15, QWORD PTR [rsp+48]
$LN50@STB_TEXTED:
	test	r9d, r9d
	cmovs	r9d, esi
	mov	eax, r9d
	pop	rdi
	pop	rsi
	ret	0
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 32
idx$ = 40
?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC, COMDAT

; 3782 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }

	push	rbx
	push	rdi
	sub	rsp, 8
	movsxd	rbx, DWORD PTR [rcx+12]
	lea	r8d, DWORD PTR [rdx+1]
	mov	rdi, rcx
	cmp	r8d, ebx
	jge	$LN70@STB_TEXTED
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+40], rsi
	mov	esi, DWORD PTR [rcx+3720]
	mov	QWORD PTR [rsp+48], r12
	and	esi, 32768				; 00008000H
	mov	QWORD PTR [rsp+56], r14
	mov	r12, 30064771077			; 0000000700000005H
	mov	QWORD PTR [rsp], r15
	mov	r14d, 12288				; 00003000H
	mov	r15, 576552020358472704			; 0800530200002400H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r10, r8d
	npad	4
$LL2@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3772 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	test	esi, esi
	jne	$LN42@STB_TEXTED
	test	r10, r10
	jle	$LN42@STB_TEXTED
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3775 :     bool prev_white = ImCharIsBlankW(obj->TextW[idx]);

	movzx	ecx, WORD PTR [rdx+r10*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN17@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN17@STB_TEXTED
	cmp	cx, r14w
	je	SHORT $LN17@STB_TEXTED
	xor	r11b, r11b
	jmp	SHORT $LN18@STB_TEXTED
$LN17@STB_TEXTED:
	mov	r11b, 1
$LN18@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN44@STB_TEXTED
	bt	r15, rcx
	jb	SHORT $LN23@STB_TEXTED
$LN44@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN43@STB_TEXTED
	movzx	eax, cx
	bt	r12, rax
	jae	SHORT $LN43@STB_TEXTED
$LN23@STB_TEXTED:
	mov	r9b, 1
	jmp	SHORT $LN24@STB_TEXTED
$LN43@STB_TEXTED:
	xor	r9b, r9b
$LN24@STB_TEXTED:

; 3777 :     bool curr_white = ImCharIsBlankW(obj->TextW[idx - 1]);

	movzx	ecx, WORD PTR [rdx+r10*2-2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN29@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN29@STB_TEXTED
	cmp	cx, r14w
	je	SHORT $LN29@STB_TEXTED
	xor	dl, dl
	jmp	SHORT $LN30@STB_TEXTED
$LN29@STB_TEXTED:
	mov	dl, 1
$LN30@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN47@STB_TEXTED
	bt	r15, rcx
	jb	SHORT $LN35@STB_TEXTED
$LN47@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN46@STB_TEXTED
	movzx	eax, cx
	bt	r12, rax
	jae	SHORT $LN46@STB_TEXTED
$LN35@STB_TEXTED:
	mov	al, 1
	jmp	SHORT $LN36@STB_TEXTED
$LN46@STB_TEXTED:
	xor	al, al
$LN36@STB_TEXTED:

; 3779 :     return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	r11b, r11b
	je	SHORT $LN9@STB_TEXTED
	test	al, al
	jne	SHORT $LN41@STB_TEXTED
	test	dl, dl
	je	SHORT $LN11@STB_TEXTED
$LN10@STB_TEXTED:
	xor	eax, eax
$LN12@STB_TEXTED:

; 3782 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }

	test	eax, eax
	jne	SHORT $LN69@STB_TEXTED
$LN42@STB_TEXTED:
	inc	r8d
	inc	r10
	cmp	r10, rbx
	jl	$LL2@STB_TEXTED
$LN69@STB_TEXTED:
	mov	r14, QWORD PTR [rsp+56]
	cmp	r8d, ebx
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	r15, QWORD PTR [rsp]
$LN70@STB_TEXTED:
	cmovg	r8d, ebx
	mov	eax, r8d
	add	rsp, 8
	pop	rdi
	pop	rbx
	ret	0
$LN9@STB_TEXTED:

; 3779 :     return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	al, al
	je	SHORT $LN10@STB_TEXTED
$LN41@STB_TEXTED:
	test	r9b, r9b
	jne	SHORT $LN10@STB_TEXTED
$LN11@STB_TEXTED:
	mov	eax, 1
	jmp	SHORT $LN12@STB_TEXTED
?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 32
idx$ = 40
?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_WIN, COMDAT

; 3783 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

	push	rbx
	push	rdi
	sub	rsp, 8
	movsxd	rdi, DWORD PTR [rcx+12]
	lea	r9d, DWORD PTR [rdx+1]
	mov	rbx, rcx
	cmp	r9d, edi
	jge	$LN72@STB_TEXTED
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+40], rsi
	mov	esi, DWORD PTR [rcx+3720]
	mov	QWORD PTR [rsp+48], r12
	and	esi, 32768				; 00008000H
	mov	QWORD PTR [rsp+56], r14
	mov	r12, 30064771077			; 0000000700000005H
	mov	QWORD PTR [rsp], r15
	mov	r14d, 12288				; 00003000H
	mov	r15, 576552020358472704			; 0800530200002400H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r10, r9d
	npad	4
$LL2@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3761 :     if ((obj->Flags & ImGuiInputTextFlags_Password) || idx <= 0)

	test	esi, esi
	jne	$LN43@STB_TEXTED
	test	r10, r10
	jle	$LN43@STB_TEXTED
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3764 :     bool prev_white = ImCharIsBlankW(obj->TextW[idx - 1]);

	movzx	ecx, WORD PTR [rdx+r10*2-2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN18@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN18@STB_TEXTED
	cmp	cx, r14w
	je	SHORT $LN18@STB_TEXTED
	xor	r11b, r11b
	jmp	SHORT $LN19@STB_TEXTED
$LN18@STB_TEXTED:
	mov	r11b, 1
$LN19@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN45@STB_TEXTED
	bt	r15, rcx
	jb	SHORT $LN24@STB_TEXTED
$LN45@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN44@STB_TEXTED
	movzx	eax, cx
	bt	r12, rax
	jae	SHORT $LN44@STB_TEXTED
$LN24@STB_TEXTED:
	mov	r8b, 1
	jmp	SHORT $LN25@STB_TEXTED
$LN44@STB_TEXTED:
	xor	r8b, r8b
$LN25@STB_TEXTED:

; 3766 :     bool curr_white = ImCharIsBlankW(obj->TextW[idx]);

	movzx	ecx, WORD PTR [rdx+r10*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN30@STB_TEXTED
	cmp	ecx, 9
	je	SHORT $LN30@STB_TEXTED
	cmp	cx, r14w
	je	SHORT $LN30@STB_TEXTED
	xor	dl, dl
	jmp	SHORT $LN31@STB_TEXTED
$LN30@STB_TEXTED:
	mov	dl, 1
$LN31@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3755 :     return c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r' || c=='.' || c=='!';

	cmp	ecx, 59					; 0000003bH
	ja	SHORT $LN48@STB_TEXTED
	bt	r15, rcx
	jb	SHORT $LN36@STB_TEXTED
$LN48@STB_TEXTED:
	sub	cx, 91					; 0000005bH
	cmp	cx, 34					; 00000022H
	ja	SHORT $LN47@STB_TEXTED
	movzx	eax, cx
	bt	r12, rax
	jae	SHORT $LN47@STB_TEXTED
$LN36@STB_TEXTED:
	mov	al, 1
	jmp	SHORT $LN37@STB_TEXTED
$LN47@STB_TEXTED:
	xor	al, al
$LN37@STB_TEXTED:

; 3768 :     return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ);

	test	r11b, r11b
	jne	SHORT $LN9@STB_TEXTED
	test	r8b, r8b
	jne	SHORT $LN9@STB_TEXTED
	test	al, al
	je	SHORT $LN11@STB_TEXTED
$LN42@STB_TEXTED:
	test	r8b, r8b
	jne	SHORT $LN11@STB_TEXTED
$LN12@STB_TEXTED:
	mov	eax, 1
	jmp	SHORT $LN13@STB_TEXTED
$LN9@STB_TEXTED:
	test	al, al
	jne	SHORT $LN42@STB_TEXTED
	test	dl, dl
	je	SHORT $LN12@STB_TEXTED
$LN11@STB_TEXTED:
	xor	eax, eax
$LN13@STB_TEXTED:

; 3783 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

	test	eax, eax
	jne	SHORT $LN71@STB_TEXTED
$LN43@STB_TEXTED:
	inc	r9d
	inc	r10
	cmp	r10, rdi
	jl	$LL2@STB_TEXTED
$LN71@STB_TEXTED:
	mov	r14, QWORD PTR [rsp+56]
	cmp	r9d, edi
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	r15, QWORD PTR [rsp]
$LN72@STB_TEXTED:
	cmovg	r9d, edi
	mov	eax, r9d
	add	rsp, 8
	pop	rdi
	pop	rbx
	ret	0
?STB_TEXTEDIT_MOVEWORDRIGHT_WIN@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_WIN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z
_TEXT	SEGMENT
obj$ = 48
idx$ = 56
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z PROC ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL, COMDAT

; 3784 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiInputTextState* obj, int idx)  { ImGuiContext& g = *obj->Ctx; if (g.IO.ConfigMacOSXBehaviors) return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx); else return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx); }

	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rcx]
	mov	rsi, rcx
	cmp	BYTE PTR [rax+97], 0
	je	SHORT $LN2@STB_TEXTED
	add	rsp, 32					; 00000020H
	pop	rsi
	jmp	?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC
$LN2@STB_TEXTED:
	mov	QWORD PTR [rsp+48], rbx

; 3783 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

	lea	ebx, DWORD PTR [rdx+1]
	mov	QWORD PTR [rsp+56], rdi
	mov	edi, DWORD PTR [rcx+12]
	cmp	ebx, edi
	jge	SHORT $LN17@STB_TEXTED
$LL6@STB_TEXTED:
	mov	edx, ebx
	mov	rcx, rsi
	call	?is_word_boundary_from_right@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::is_word_boundary_from_right
	test	eax, eax
	jne	SHORT $LN13@STB_TEXTED
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL6@STB_TEXTED
$LN13@STB_TEXTED:
	cmp	ebx, edi
$LN17@STB_TEXTED:
	cmovg	ebx, edi

; 3784 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiInputTextState* obj, int idx)  { ImGuiContext& g = *obj->Ctx; if (g.IO.ConfigMacOSXBehaviors) return STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx); else return STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx); }

	mov	rdi, QWORD PTR [rsp+56]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ENDP ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
obj$ = 24
pos$ = 32
n$ = 40
?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z PROC ; ImStb::STB_TEXTEDIT_DELETECHARS, COMDAT

; 3789 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 3790 :     ImWchar* dst = obj->TextW.Data + pos;

	mov	rdi, QWORD PTR [rcx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	xor	r11d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3790 :     ImWchar* dst = obj->TextW.Data + pos;

	movsxd	rsi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	ebx, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3794 :     obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

	movsxd	r14, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	ebp, 128				; 00000080H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3793 :     obj->Edited = true;

	mov	BYTE PTR [rcx+3718], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	r15d, 2048				; 00000800H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3790 :     ImWchar* dst = obj->TextW.Data + pos;

	lea	rdx, QWORD PTR [rdi+rsi*2]

; 3794 :     obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

	lea	r10, QWORD PTR [rdx+r14*2]
	mov	r9, rdx
$LL6@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	r10, r10
	je	SHORT $LN8@STB_TEXTED
	cmp	r9, r10
	jae	SHORT $LN7@STB_TEXTED
$LN8@STB_TEXTED:
	movzx	eax, WORD PTR [r9]
	test	ax, ax
	je	SHORT $LN7@STB_TEXTED

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	r9, 2

; 2318 :         if (c < 0x80)

	cmp	ax, bp
	jae	SHORT $LN12@STB_TEXTED

; 2319 :             bytes_count++;

	mov	eax, 1

; 2322 :     }

	add	ebx, eax
	jmp	SHORT $LL6@STB_TEXTED
$LN12@STB_TEXTED:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r15w
	sbb	eax, eax
	add	eax, 3

; 2322 :     }

	add	ebx, eax
	jmp	SHORT $LL6@STB_TEXTED
$LN7@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3794 :     obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

	sub	DWORD PTR [rcx+16], ebx

; 3795 :     obj->CurLenW -= n;
; 3796 : 
; 3797 :     // Offset remaining text (FIXME-OPT: Use memmove)
; 3798 :     const ImWchar* src = obj->TextW.Data + pos + n;

	lea	rax, QWORD PTR [r14+rsi]
	sub	DWORD PTR [rcx+12], r8d
	lea	rax, QWORD PTR [rdi+rax*2]

; 3799 :     while (ImWchar c = *src++)

	movzx	ecx, WORD PTR [rax]
	add	rax, 2
	test	cx, cx
	je	SHORT $LN25@STB_TEXTED
$LL2@STB_TEXTED:

; 3800 :         *dst++ = c;

	mov	WORD PTR [rdx], cx
	lea	rdx, QWORD PTR [rdx+2]
	movzx	ecx, WORD PTR [rax]
	lea	rax, QWORD PTR [rax+2]
	test	cx, cx
	jne	SHORT $LL2@STB_TEXTED
$LN25@STB_TEXTED:

; 3801 :     *dst = '\0';
; 3802 : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	WORD PTR [rdx], r11w
	pop	r15
	pop	r14
	ret	0
?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ENDP ; ImStb::STB_TEXTEDIT_DELETECHARS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z
_TEXT	SEGMENT
tv440 = 80
obj$ = 80
pos$ = 88
new_text$ = 96
new_text_len$ = 104
?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z PROC ; ImStb::STB_TEXTEDIT_INSERTCHARS, COMDAT

; 3805 : {

	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3806 :     const bool is_resizable = (obj->Flags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	r10d, DWORD PTR [rcx+3720]
	mov	rsi, rcx

; 3807 :     const int text_len = obj->CurLenW;

	mov	r14d, DWORD PTR [rcx+12]
	mov	r13, r8
	movsxd	r15, r9d

; 3810 :     const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);

	mov	rcx, r8
	shr	r10d, 18
	mov	r9, r15
	movsxd	r12, edx
	and	r10b, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	r11d, 2048				; 00000800H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3810 :     const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);

	lea	rax, QWORD PTR [r15+r15]
	lea	rdx, QWORD PTR [rax+r8]
	mov	QWORD PTR tv440[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	xor	eax, eax
	mov	r8d, 128				; 00000080H
	mov	ebp, eax
$LL8@STB_TEXTED:

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	rdx, rdx
	je	SHORT $LN10@STB_TEXTED
	cmp	rcx, rdx
	jae	SHORT $LN9@STB_TEXTED
$LN10@STB_TEXTED:
	movzx	eax, WORD PTR [rcx]
	test	ax, ax
	je	SHORT $LN9@STB_TEXTED

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	rcx, 2

; 2318 :         if (c < 0x80)

	cmp	ax, r8w
	jae	SHORT $LN14@STB_TEXTED

; 2319 :             bytes_count++;

	mov	eax, 1

; 2322 :     }

	add	ebp, eax
	jmp	SHORT $LL8@STB_TEXTED
$LN14@STB_TEXTED:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r11w
	sbb	eax, eax
	add	eax, 3

; 2322 :     }

	add	ebp, eax
	jmp	SHORT $LL8@STB_TEXTED
$LN9@STB_TEXTED:
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3811 :     if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))

	test	r10b, r10b
	jne	SHORT $LN40@STB_TEXTED
	mov	ecx, DWORD PTR [rsi+16]
	inc	ecx
	add	ecx, ebp
	cmp	ecx, DWORD PTR [rsi+76]
	jg	SHORT $LN41@STB_TEXTED
$LN40@STB_TEXTED:

; 3812 :         return false;
; 3813 : 
; 3814 :     // Grow internal buffer if needed
; 3815 :     if (new_text_len + text_len + 1 > obj->TextW.Size)

	lea	eax, DWORD PTR [r15+1]
	add	eax, r14d
	cmp	eax, DWORD PTR [rsi+24]
	jle	SHORT $LN3@STB_TEXTED

; 3816 :     {
; 3817 :         if (!is_resizable)

	test	r10b, r10b
	jne	SHORT $LN4@STB_TEXTED
$LN41@STB_TEXTED:

; 3818 :             return false;

	xor	al, al
	jmp	$LN1@STB_TEXTED
$LN4@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	mov	eax, 256				; 00000100H
	mov	ecx, r15d
	cmp	r15d, eax
	cmovle	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3820 :         obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);

	lea	eax, DWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	eax, 32					; 00000020H
	jge	SHORT $LN24@STB_TEXTED
	mov	eax, 32					; 00000020H
	jmp	SHORT $LN25@STB_TEXTED
$LN24@STB_TEXTED:
	cmp	eax, ecx
	cmovg	eax, ecx
$LN25@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rsi+28]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3820 :         obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);

	lea	ebx, DWORD PTR [r14+1]
	add	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	ebx, ecx
	jle	SHORT $LN27@STB_TEXTED

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN31@STB_TEXTED
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN32@STB_TEXTED
$LN31@STB_TEXTED:
	mov	eax, 8
$LN32@STB_TEXTED:
	cmp	eax, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rsi+24]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	edx, ebx
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::reserve
	mov	r9, r15
$LN27@STB_TEXTED:
	mov	DWORD PTR [rsi+24], ebx
$LN3@STB_TEXTED:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3823 :     ImWchar* text = obj->TextW.Data;

	mov	rbx, QWORD PTR [rsi+32]

; 3824 :     if (pos != text_len)

	cmp	r12d, r14d
	je	SHORT $LN37@STB_TEXTED

; 3825 :         memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));

	sub	r14d, r12d
	lea	rax, QWORD PTR [r9+r12]
	movsxd	r8, r14d
	lea	rdx, QWORD PTR [rbx+r12*2]
	add	r8, r8
	lea	rcx, QWORD PTR [rbx+rax*2]
	call	memmove
$LN37@STB_TEXTED:

; 3826 :     memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

	mov	r8, QWORD PTR tv440[rsp]
	lea	rcx, QWORD PTR [rbx+r12*2]
	mov	rdx, r13
	call	memcpy

; 3827 : 
; 3828 :     obj->Edited = true;
; 3829 :     obj->CurLenW += new_text_len;

	add	DWORD PTR [rsi+12], r15d

; 3830 :     obj->CurLenA += new_text_len_utf8;

	add	DWORD PTR [rsi+16], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, DWORD PTR [rsi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3831 :     obj->TextW[obj->CurLenW] = '\0';

	xor	edx, edx
	mov	BYTE PTR [rsi+3718], 1
	mov	rax, QWORD PTR [rsi+32]
	mov	WORD PTR [rax+rcx*2], dx

; 3832 : 
; 3833 :     return true;

	mov	al, 1
$LN1@STB_TEXTED:

; 3834 : }

	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	ret	0
?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ENDP ; ImStb::STB_TEXTEDIT_INSERTCHARS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z
_TEXT	SEGMENT
r$ = 32
str$ = 128
x$ = 136
y$ = 144
?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z PROC ; ImStb::stb_text_locate_coord, COMDAT

; 402  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	r14
	sub	rsp, 112				; 00000070H

; 403  :    StbTexteditRow r;
; 404  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	esi, DWORD PTR [rcx+12]

; 405  :    float base_y = 0, prev_x;
; 406  :    int i=0, k;

	xor	edi, edi
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebx, edi
	movaps	XMMWORD PTR [rax-40], xmm7

; 407  : 
; 408  :    r.x0 = r.x1 = 0;
; 409  :    r.ymin = r.ymax = 0;
; 410  :    r.num_chars = 0;

	mov	edx, edi
	movaps	XMMWORD PTR [rax-56], xmm8
	xorps	xmm6, xmm6
	mov	QWORD PTR [rax-76], rbx
	xorps	xmm3, xmm3
	mov	DWORD PTR [rax-68], edx
	movaps	xmm7, xmm2
	movss	DWORD PTR [rax-84], xmm6
	movaps	xmm8, xmm1
	movss	DWORD PTR [rax-88], xmm3
	mov	r14, rcx

; 411  : 
; 412  :    // search rows to find one that straddles 'y'
; 413  :    while (i < n) {

	test	esi, esi
	jle	SHORT $LN38@stb_text_l
$LL2@stb_text_l:

; 414  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	mov	r8d, ebx
	lea	rcx, QWORD PTR r$[rsp]
	mov	rdx, r14
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 415  :       if (r.num_chars <= 0)

	mov	edx, DWORD PTR r$[rsp+20]
	test	edx, edx
	jle	SHORT $LN46@stb_text_l

; 416  :          return n;
; 417  : 
; 418  :       if (i==0 && y < base_y + r.ymin)

	test	ebx, ebx
	jne	SHORT $LN8@stb_text_l
	movss	xmm0, DWORD PTR r$[rsp+12]
	addss	xmm0, xmm6
	comiss	xmm0, xmm7
	ja	SHORT $LN37@stb_text_l
$LN8@stb_text_l:

; 420  : 
; 421  :       if (y < base_y + r.ymax)

	movss	xmm0, DWORD PTR r$[rsp+16]
	addss	xmm0, xmm6
	comiss	xmm0, xmm7
	ja	SHORT $LN48@stb_text_l

; 422  :          break;
; 423  : 
; 424  :       i += r.num_chars;
; 425  :       base_y += r.baseline_y_delta;

	addss	xmm6, DWORD PTR r$[rsp+8]
	add	ebx, edx
	cmp	ebx, esi
	jl	SHORT $LL2@stb_text_l

; 430  :       return n;

	mov	eax, esi
	jmp	$LN17@stb_text_l
$LN37@stb_text_l:

; 419  :          return 0;

	xor	eax, eax
	jmp	$LN17@stb_text_l
$LN48@stb_text_l:

; 420  : 
; 421  :       if (y < base_y + r.ymax)

	movss	xmm6, DWORD PTR r$[rsp+4]
	movss	xmm3, DWORD PTR r$[rsp]
$LN38@stb_text_l:

; 426  :    }
; 427  : 
; 428  :    // below all text, return 'after' last character
; 429  :    if (i >= n)

	cmp	ebx, esi
	jl	SHORT $LN10@stb_text_l
$LN46@stb_text_l:

; 430  :       return n;

	mov	eax, esi
	jmp	$LN17@stb_text_l
$LN10@stb_text_l:

; 431  : 
; 432  :    // check if it's before the beginning of the line
; 433  :    if (x < r.x0)

	comiss	xmm3, xmm8
	jbe	SHORT $LN11@stb_text_l

; 434  :       return i;

	mov	eax, ebx
	jmp	$LN17@stb_text_l
$LN11@stb_text_l:

; 435  : 
; 436  :    // check if it's before the end of the line
; 437  :    if (x < r.x1) {

	comiss	xmm6, xmm8
	jbe	SHORT $LN5@stb_text_l

; 438  :       // search characters in row for one that straddles 'x'
; 439  :       prev_x = r.x0;
; 440  :       for (k=0; k < r.num_chars; ++k) {

	test	edx, edx
	jle	SHORT $LN5@stb_text_l
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r14+32]
	movss	xmm2, DWORD PTR __real@bf800000
	movsxd	rcx, ebx
	lea	r9, QWORD PTR [rax+rcx*2]
$LL6@stb_text_l:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movzx	ecx, WORD PTR [r9]
	cmp	ecx, 10
	jne	SHORT $LN20@stb_text_l
	movaps	xmm0, xmm2
	jmp	SHORT $LN19@stb_text_l
$LN20@stb_text_l:
	mov	r10, QWORD PTR [r14]
	mov	r8, QWORD PTR [r10+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [r8]
	jge	SHORT $LN26@stb_text_l
	mov	rax, QWORD PTR [r8+8]
	movss	xmm1, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN27@stb_text_l
$LN26@stb_text_l:
	movss	xmm1, DWORD PTR [r8+16]
$LN27@stb_text_l:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movss	xmm0, DWORD PTR [r10+15696]
	divss	xmm0, DWORD PTR [r8+20]
	mulss	xmm0, xmm1
$LN19@stb_text_l:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 442  :          if (x < prev_x+w) {

	movaps	xmm1, xmm0
	addss	xmm1, xmm3
	comiss	xmm1, xmm8
	ja	SHORT $LN39@stb_text_l

; 438  :       // search characters in row for one that straddles 'x'
; 439  :       prev_x = r.x0;
; 440  :       for (k=0; k < r.num_chars; ++k) {

	inc	edi
	add	r9, 2

; 444  :                return k+i;
; 445  :             else
; 446  :                return k+i+1;
; 447  :          }
; 448  :          prev_x += w;

	movaps	xmm3, xmm1
	cmp	edi, edx
	jl	SHORT $LL6@stb_text_l
$LN5@stb_text_l:

; 454  :    if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)

	mov	rcx, QWORD PTR [r14+32]
	lea	eax, DWORD PTR [rdx+rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 454  :    if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)

	lea	r8d, DWORD PTR [rax-1]
	cmp	WORD PTR [rcx+rdx*2-2], 10
	cmove	eax, r8d
$LN17@stb_text_l:

; 455  :       return i+r.num_chars-1;
; 456  :    else
; 457  :       return i+r.num_chars;
; 458  : }

	movaps	xmm6, XMMWORD PTR [rsp+96]
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm7, XMMWORD PTR [rsp+80]
	mov	rsp, r11
	pop	r14
	ret	0
$LN39@stb_text_l:

; 443  :             if (x < prev_x+w/2)

	mulss	xmm0, DWORD PTR __real@3f000000
	lea	ecx, DWORD PTR [rdi+rbx]
	lea	eax, DWORD PTR [rcx+1]
	addss	xmm0, xmm3
	comiss	xmm0, xmm8
	cmova	eax, ecx
	jmp	SHORT $LN17@stb_text_l
?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z ENDP ; ImStb::stb_text_locate_coord
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
_TEXT	SEGMENT
r$1 = 32
str$ = 96
state$ = 104
x$ = 112
y$ = 120
?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z PROC ; ImStb::stb_textedit_click, COMDAT

; 462  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 463  :    // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 464  :    // goes off the top or bottom of the text
; 465  :    if( state->single_line )

	cmp	BYTE PTR [rdx+23], 0
	mov	rbx, rdx
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	rdi, rcx
	movaps	xmm6, xmm2
	je	SHORT $LN2@stb_texted

; 466  :    {
; 467  :       StbTexteditRow r;
; 468  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	mov	rdx, rcx
	xor	r8d, r8d
	lea	rcx, QWORD PTR r$1[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 469  :       y = r.ymin;

	movss	xmm3, DWORD PTR r$1[rsp+12]
$LN2@stb_texted:

; 470  :    }
; 471  : 
; 472  :    state->cursor = stb_text_locate_coord(str, x, y);

	movaps	xmm2, xmm3
	movaps	xmm1, xmm6
	mov	rcx, rdi
	call	?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord

; 473  :    state->select_start = state->cursor;
; 474  :    state->select_end = state->cursor;
; 475  :    state->has_preferred_x = 0;
; 476  : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	DWORD PTR [rbx], eax
	mov	DWORD PTR [rbx+4], eax
	mov	DWORD PTR [rbx+8], eax
	mov	BYTE PTR [rbx+22], 0
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ENDP ; ImStb::stb_textedit_click
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z
_TEXT	SEGMENT
r$1 = 32
str$ = 96
state$ = 104
x$ = 112
y$ = 120
?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z PROC ; ImStb::stb_textedit_drag, COMDAT

; 480  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 481  :    int p = 0;
; 482  : 
; 483  :    // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
; 484  :    // goes off the top or bottom of the text
; 485  :    if( state->single_line )

	cmp	BYTE PTR [rdx+23], 0
	mov	rbx, rdx
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	rdi, rcx
	movaps	xmm6, xmm2
	je	SHORT $LN2@stb_texted

; 486  :    {
; 487  :       StbTexteditRow r;
; 488  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	mov	rdx, rcx
	xor	r8d, r8d
	lea	rcx, QWORD PTR r$1[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 489  :       y = r.ymin;

	movss	xmm3, DWORD PTR r$1[rsp+12]
$LN2@stb_texted:

; 490  :    }
; 491  : 
; 492  :    if (state->select_start == state->select_end)

	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	jne	SHORT $LN3@stb_texted

; 493  :       state->select_start = state->cursor;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+4], eax
$LN3@stb_texted:

; 494  : 
; 495  :    p = stb_text_locate_coord(str, x, y);

	movaps	xmm2, xmm3
	movaps	xmm1, xmm6
	mov	rcx, rdi
	call	?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord

; 496  :    state->cursor = state->select_end = p;
; 497  : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx], eax
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?stb_textedit_drag@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ENDP ; ImStb::stb_textedit_drag
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z
_TEXT	SEGMENT
r$ = 32
find$ = 96
str$ = 104
n$ = 112
single_line$ = 120
?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z PROC ; ImStb::stb_textedit_find_charpos, COMDAT

; 522  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 64					; 00000040H

; 523  :    StbTexteditRow r;
; 524  :    int prev_start = 0;
; 525  :    int z = STB_TEXTEDIT_STRINGLEN(str);

	movsxd	rbp, DWORD PTR [rdx+12]
	xor	r15d, r15d
	mov	r12d, r8d
	mov	rsi, rdx
	mov	rdi, rcx

; 526  :    int i=0, first;

	mov	ebx, r15d

; 527  : 
; 528  :    if (n == z && single_line) {

	cmp	r8d, ebp
	jne	SHORT $LN8@stb_texted
	test	r9d, r9d
	je	SHORT $LN8@stb_texted

; 529  :       // special case if it's at the end (may not be needed?)
; 530  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 531  :       find->y = 0;
; 532  :       find->first_char = 0;
; 533  :       find->length = z;
; 534  :       find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR r$[rsp+16]
	subss	xmm0, DWORD PTR r$[rsp+12]
	mov	DWORD PTR [rdi+4], r15d
	mov	DWORD PTR [rdi+12], r15d
	mov	DWORD PTR [rdi+16], ebp
	movss	DWORD PTR [rdi+8], xmm0

; 535  :       find->x = r.x1;

	movss	xmm0, DWORD PTR r$[rsp+4]
	movss	DWORD PTR [rdi], xmm0

; 536  :       return;

	jmp	$LN6@stb_texted
$LN8@stb_texted:

; 537  :    }
; 538  : 
; 539  :    // search rows to find the one that straddles character n
; 540  :    find->y = 0;

	mov	DWORD PTR [rcx+4], r15d

; 541  : 
; 542  :    for(;;) {
; 543  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	xor	r8d, r8d
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 544  :       if (n < i + r.num_chars)

	mov	edx, DWORD PTR r$[rsp+20]
	cmp	r12d, edx
	jl	SHORT $LN39@stb_texted
	mov	QWORD PTR [rsp+96], r14
	npad	4
$LL2@stb_texted:

; 545  :          break;
; 546  :       if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE)  // [DEAR IMGUI] special handling for last line

	lea	ecx, DWORD PTR [rdx+rbx]
	cmp	ecx, ebp
	jne	SHORT $LN10@stb_texted
	test	ebp, ebp
	jle	SHORT $LN10@stb_texted
	mov	rax, QWORD PTR [rsi+32]
	cmp	WORD PTR [rax+rbp*2-2], 10
	jne	SHORT $LN49@stb_texted
$LN10@stb_texted:

; 547  :          break;   // [DEAR IMGUI]
; 548  :       prev_start = i;
; 549  :       i += r.num_chars;
; 550  :       find->y += r.baseline_y_delta;

	movss	xmm0, DWORD PTR r$[rsp+8]
	mov	r15d, ebx
	mov	ebx, ecx
	addss	xmm0, DWORD PTR [rdi+4]
	movss	DWORD PTR [rdi+4], xmm0

; 551  :       if (i == z) // [DEAR IMGUI]

	cmp	ecx, ebp
	je	SHORT $LN49@stb_texted

; 541  : 
; 542  :    for(;;) {
; 543  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	mov	r8d, ecx
	mov	rdx, rsi
	lea	rcx, QWORD PTR r$[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 544  :       if (n < i + r.num_chars)

	mov	edx, DWORD PTR r$[rsp+20]
	lea	eax, DWORD PTR [rdx+rbx]
	cmp	r12d, eax
	jge	SHORT $LL2@stb_texted
$LN49@stb_texted:
	mov	r14, QWORD PTR [rsp+96]
$LN39@stb_texted:

; 552  :          break;   // [DEAR IMGUI]
; 553  :    }
; 554  : 
; 555  :    find->first_char = first = i;
; 556  :    find->length = r.num_chars;
; 557  :    find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR r$[rsp+16]

; 558  :    find->prev_first = prev_start;
; 559  : 
; 560  :    // now scan to find xpos
; 561  :    find->x = r.x0;

	movss	xmm2, DWORD PTR r$[rsp]
	movss	DWORD PTR [rdi], xmm2
	mov	DWORD PTR [rdi+12], ebx
	mov	DWORD PTR [rdi+16], edx
	mov	DWORD PTR [rdi+20], r15d
	subss	xmm0, DWORD PTR r$[rsp+12]
	movss	DWORD PTR [rdi+8], xmm0

; 562  :    for (i=0; first+i < n; ++i)

	cmp	ebx, r12d
	jge	SHORT $LN6@stb_texted
	movss	xmm3, DWORD PTR __real@bf800000
	movsxd	rax, ebx
	lea	r8, QWORD PTR [rax+rax]
	npad	6
$LL7@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mov	rax, QWORD PTR [rsi+32]
	movzx	ecx, WORD PTR [r8+rax]
	cmp	ecx, 10
	jne	SHORT $LN18@stb_texted
	movaps	xmm0, xmm3
	jmp	SHORT $LN17@stb_texted
$LN18@stb_texted:
	mov	r9, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [r9+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [rdx]
	jge	SHORT $LN24@stb_texted
	mov	rax, QWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN25@stb_texted
$LN24@stb_texted:
	movss	xmm1, DWORD PTR [rdx+16]
$LN25@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movss	xmm0, DWORD PTR [r9+15696]
	divss	xmm0, DWORD PTR [rdx+20]
	mulss	xmm0, xmm1
$LN17@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 563  :       find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);

	addss	xmm0, xmm2
	inc	ebx
	add	r8, 2
	movss	DWORD PTR [rdi], xmm0
	movaps	xmm2, xmm0
	cmp	ebx, r12d
	jl	SHORT $LL7@stb_texted
$LN6@stb_texted:

; 564  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ENDP ; ImStb::stb_textedit_find_charpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_clamp@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
str$ = 8
state$ = 16
?stb_textedit_clamp@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_clamp, COMDAT

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rcx+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [rdx+4]
	mov	r8d, DWORD PTR [rdx+8]
	cmp	ecx, r8d
	je	SHORT $LN5@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, eax
	jle	SHORT $LN3@stb_texted
	mov	DWORD PTR [rdx+4], eax
	mov	ecx, eax
$LN3@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	r8d, eax
	jle	SHORT $LN4@stb_texted
	mov	DWORD PTR [rdx+8], eax
	mov	r8d, eax
$LN4@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, r8d
	jne	SHORT $LN5@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rdx], ecx
$LN5@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rdx], eax
	jle	SHORT $LN6@stb_texted
	mov	DWORD PTR [rdx], eax
$LN6@stb_texted:

; 580  : }

	ret	0
?stb_textedit_clamp@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_clamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
where$ = 64
len$ = 72
?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_textedit_delete, COMDAT

; 584  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, r9d
	mov	rbx, rcx
	movsxd	rsi, r8d

; 1340 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);

	lea	rcx, QWORD PTR [rdx+32]

; 584  : {

	mov	rbp, rdx

; 1340 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);

	mov	r8d, edi
	mov	edx, esi
	xor	r9d, r9d
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 1341 :    if (p) {

	test	rax, rax
	je	SHORT $LN5@stb_texted

; 1342 :       for (i=0; i < length; ++i)

	mov	r10, rdi
	test	edi, edi
	jle	SHORT $LN5@stb_texted
	lea	r8, QWORD PTR [rsi+rsi]
	sub	r8, rax
	npad	12
$LL6@stb_texted:

; 1343 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	mov	rcx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rdx, QWORD PTR [r8+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1342 :       for (i=0; i < length; ++i)

	lea	rax, QWORD PTR [rax+2]

; 1343 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	movzx	edx, WORD PTR [rdx+rcx]
	mov	WORD PTR [rax-2], dx
	sub	r10, 1
	jne	SHORT $LL6@stb_texted
$LN5@stb_texted:

; 585  :    stb_text_makeundo_delete(str, state, where, len);
; 586  :    STB_TEXTEDIT_DELETECHARS(str, where, len);

	mov	r8d, edi
	mov	edx, esi
	mov	rcx, rbx
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS

; 587  :    state->has_preferred_x = 0;
; 588  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	mov	BYTE PTR [rbp+22], 0
	mov	rbp, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_textedit_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_delete_selection, COMDAT

; 592  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rcx+12]

; 592  : {

	mov	rbx, rdx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	edx, DWORD PTR [rdx+4]

; 592  : {

	mov	r10, rcx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rbx+8]
	cmp	edx, r8d
	je	SHORT $LN10@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	ecx, edx
	cmp	edx, eax
	jle	SHORT $LN8@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	ecx, eax
$LN8@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, r8d
	cmp	r8d, eax
	jle	SHORT $LN9@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	r9d, eax
$LN9@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	edx, ecx
	mov	r8d, r9d
	cmp	ecx, r9d
	jne	SHORT $LN10@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN10@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rbx], eax
	jle	SHORT $LN11@stb_texted
	mov	DWORD PTR [rbx], eax
$LN11@stb_texted:

; 593  :    stb_textedit_clamp(str, state);
; 594  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	edx, r8d
	je	SHORT $LN2@stb_texted

; 595  :       if (state->select_start < state->select_end) {

	mov	rcx, r10
	jge	SHORT $LN3@stb_texted

; 596  :          stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

	sub	r8d, edx
	mov	r9d, r8d
	mov	r8d, edx
	mov	rdx, rbx
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 597  :          state->select_end = state->cursor = state->select_start;

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rbx+8], eax

; 601  :       }
; 602  :       state->has_preferred_x = 0;

	mov	DWORD PTR [rbx], eax
	mov	BYTE PTR [rbx+22], 0

; 603  :    }
; 604  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stb_texted:

; 598  :       } else {
; 599  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	sub	edx, r8d
	mov	r9d, edx
	mov	rdx, rbx
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 600  :          state->select_start = state->cursor = state->select_end;

	mov	eax, DWORD PTR [rbx+8]

; 601  :       }
; 602  :       state->has_preferred_x = 0;

	mov	rcx, rbx
	mov	DWORD PTR [rbx+4], eax
	mov	DWORD PTR [rbx], eax
	mov	BYTE PTR [rbx+22], 0
$LN2@stb_texted:

; 603  :    }
; 604  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_delete_selection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_sortselection@ImStb@@YAXPEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
state$ = 8
?stb_textedit_sortselection@ImStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_sortselection, COMDAT

; 609  :    if (state->select_end < state->select_start) {

	mov	eax, DWORD PTR [rcx+8]
	mov	edx, DWORD PTR [rcx+4]
	cmp	eax, edx
	jge	SHORT $LN2@stb_texted

; 610  :       int temp = state->select_end;
; 611  :       state->select_end = state->select_start;

	mov	DWORD PTR [rcx+8], edx

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rcx+4], eax
$LN2@stb_texted:

; 613  :    }
; 614  : }

	ret	0
?stb_textedit_sortselection@ImStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_sortselection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_move_to_first@ImStb@@YAXPEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
state$ = 8
?stb_textedit_move_to_first@ImStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_move_to_first, COMDAT

; 619  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	eax, DWORD PTR [rcx+4]
	mov	edx, DWORD PTR [rcx+8]
	cmp	eax, edx
	je	SHORT $LN2@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN5@stb_texted

; 610  :       int temp = state->select_end;

	mov	eax, edx

; 611  :       state->select_end = state->select_start;
; 612  :       state->select_start = temp;

	mov	DWORD PTR [rcx+4], edx
$LN5@stb_texted:

; 620  :       stb_textedit_sortselection(state);
; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rcx], eax

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rcx+8], eax

; 623  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rcx+22], 0
$LN2@stb_texted:

; 624  :    }
; 625  : }

	ret	0
?stb_textedit_move_to_first@ImStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_move_to_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_move_to_last@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
str$ = 8
state$ = 16
?stb_textedit_move_to_last@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_move_to_last, COMDAT

; 630  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	eax, DWORD PTR [rdx+4]
	mov	r8, rcx
	mov	r9d, DWORD PTR [rdx+8]
	cmp	eax, r9d
	je	SHORT $LN2@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN5@stb_texted

; 610  :       int temp = state->select_end;
; 611  :       state->select_end = state->select_start;

	mov	DWORD PTR [rdx+8], eax

; 612  :       state->select_start = temp;

	mov	ecx, r9d
	mov	DWORD PTR [rdx+4], r9d
	mov	r8d, DWORD PTR [r8+12]
	jmp	SHORT $LN14@stb_texted
$LN5@stb_texted:

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	r8d, DWORD PTR [rcx+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, eax
	mov	eax, r9d
$LN14@stb_texted:

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, r8d
	cmovg	ecx, r8d

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	eax, r8d
	jle	SHORT $LN10@stb_texted
	mov	DWORD PTR [rdx+8], r8d
	mov	eax, r8d
$LN10@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, eax
	jne	SHORT $LN11@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rdx], ecx
$LN11@stb_texted:

; 631  :       stb_textedit_sortselection(state);
; 632  :       stb_textedit_clamp(str, state);
; 633  :       state->cursor = state->select_end;

	mov	DWORD PTR [rdx], eax

; 634  :       state->select_start = state->select_end;

	mov	DWORD PTR [rdx+4], eax

; 635  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rdx+22], 0
$LN2@stb_texted:

; 636  :    }
; 637  : }

	ret	0
?stb_textedit_move_to_last@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_move_to_last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
state$ = 8
?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_prep_selection_at_cursor, COMDAT

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN2@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rcx+8], eax
	mov	DWORD PTR [rcx+4], eax

; 685  : }

	ret	0
$LN2@stb_texted:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rcx], eax

; 685  : }

	ret	0
?stb_textedit_prep_selection_at_cursor@ImStb@@YAXPEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_prep_selection_at_cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_textedit_cut, COMDAT

; 689  : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 690  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	eax, DWORD PTR [rdx+8]
	mov	rbx, rdx
	cmp	DWORD PTR [rdx+4], eax
	je	SHORT $LN2@stb_texted

; 691  :       stb_textedit_delete_selection(str,state); // implicitly clamps

	call	?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection

; 692  :       state->has_preferred_x = 0;
; 693  :       return 1;

	mov	eax, 1
	mov	BYTE PTR [rbx+22], 0

; 696  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@stb_texted:

; 694  :    }
; 695  :    return 0;

	xor	eax, eax

; 696  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stb_textedit_cut@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_textedit_cut
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
text$ = 64
len$ = 72
?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z PROC ; ImStb::stb_textedit_paste_internal, COMDAT

; 700  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rcx+12]

; 700  : {

	mov	rbx, rdx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	edx, DWORD PTR [rdx+4]

; 700  : {

	mov	edi, r9d
	mov	rbp, r8
	mov	rsi, rcx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r10d, DWORD PTR [rbx+8]
	cmp	edx, r10d
	je	SHORT $LN8@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	edx, eax
	jle	SHORT $LN6@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	edx, eax
$LN6@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	r10d, eax
	jle	SHORT $LN7@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	r10d, eax
$LN7@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	edx, r10d
	jne	SHORT $LN8@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN8@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rbx], eax
	jle	SHORT $LN9@stb_texted
	mov	DWORD PTR [rbx], eax
$LN9@stb_texted:

; 701  :    // if there's a selection, the paste should delete it
; 702  :    stb_textedit_clamp(str, state);
; 703  :    stb_textedit_delete_selection(str,state);

	mov	rdx, rbx
	call	?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection

; 704  :    // try to insert the characters
; 705  :    if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

	mov	edx, DWORD PTR [rbx]
	mov	r9d, edi
	mov	r8, rbp
	mov	rcx, rsi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN2@stb_texted

; 1334 :    stb_text_createundo(&state->undostate, where, 0, length);

	mov	edx, DWORD PTR [rbx]
	lea	rcx, QWORD PTR [rbx+32]
	mov	r9d, edi
	xor	r8d, r8d
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 706  :       stb_text_makeundo_insert(state, state->cursor, len);
; 707  :       state->cursor += len;

	add	DWORD PTR [rbx], edi

; 708  :       state->has_preferred_x = 0;
; 709  :       return 1;

	mov	eax, 1
	mov	BYTE PTR [rbx+22], 0
	jmp	SHORT $LN1@stb_texted
$LN2@stb_texted:

; 710  :    }
; 711  :    // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
; 712  :    return 0;

	xor	eax, eax
$LN1@stb_texted:

; 713  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_textedit_paste_internal@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEAGH@Z ENDP ; ImStb::stb_textedit_paste_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
find$1 = 48
find$2 = 48
row$3 = 72
row$4 = 72
row_count$1$ = 96
ch$5 = 96
__$ArrayPad$ = 104
str$ = 224
state$ = 232
key$ = 240
?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_key, COMDAT

; 721  : {

	mov	r11, rsp
	push	rbx
	push	rdi
	push	r12
	push	r13
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 858  : 
; 859  :          if (!is_page && state->single_line) {

	mov	QWORD PTR [r11+32], rbp
	mov	r12d, 1
	mov	QWORD PTR [r11-40], rsi
	mov	rbx, rdx
	mov	QWORD PTR [r11-48], r14
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [r11-56], r15
	mov	r13d, r8d
	movaps	XMMWORD PTR [r11-72], xmm6
	mov	rdi, rcx
	movaps	XMMWORD PTR [r11-88], xmm7
	movaps	XMMWORD PTR [r11-104], xmm8
	mov	DWORD PTR row_count$1$[rsp], r12d
	npad	7
$retry$659:

; 722  : retry:
; 723  :    switch (key) {

	cmp	r13d, 6291456				; 00600000H
	jg	SHORT $LN117@stb_texted
	je	$LN42@stb_texted
	lea	eax, DWORD PTR [r13-2097152]
	cmp	eax, 15
	ja	$LN26@stb_texted
	cdqe
	mov	ecx, DWORD PTR $LN483@stb_texted[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN117@stb_texted:
	lea	eax, DWORD PTR [r13-6291457]
	cmp	eax, 14
	ja	$LN26@stb_texted
	cdqe
	mov	ecx, DWORD PTR $LN482@stb_texted[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN55@stb_texted:

; 848  : 
; 849  :       case STB_TEXTEDIT_K_DOWN:
; 850  :       case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
; 851  :       case STB_TEXTEDIT_K_PGDOWN:
; 852  :       case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
; 853  :          StbFindState find;
; 854  :          StbTexteditRow row;
; 855  :          int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
; 856  :          int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;

	mov	eax, r13d
	btr	eax, 22

; 857  :          int row_count = is_page ? state->row_count_per_page : 1;

	cmp	eax, 2097167				; 0020000fH
	je	$LN478@stb_texted

; 858  : 
; 859  :          if (!is_page && state->single_line) {

	cmp	BYTE PTR [rbx+23], 0
	je	$LN490@stb_texted

; 860  :             // on windows, up&down in single-line behave like left&right
; 861  :             key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);

	and	r13d, 4194304				; 00400000H
	or	r13d, 2097153				; 00200001H

; 862  :             goto retry;

	jmp	SHORT $retry$659
$LN68@stb_texted:

; 914  :       }
; 915  : 
; 916  :       case STB_TEXTEDIT_K_UP:
; 917  :       case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
; 918  :       case STB_TEXTEDIT_K_PGUP:
; 919  :       case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
; 920  :          StbFindState find;
; 921  :          StbTexteditRow row;
; 922  :          int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
; 923  :          int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;

	mov	eax, r13d
	btr	eax, 22

; 924  :          int row_count = is_page ? state->row_count_per_page : 1;

	cmp	eax, 2097166				; 0020000eH
	je	$LN479@stb_texted

; 925  : 
; 926  :          if (!is_page && state->single_line) {

	cmp	BYTE PTR [rbx+23], 0
	je	$LN446@stb_texted

; 927  :             // on windows, up&down become left&right
; 928  :             key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);

	and	r13d, 4194304				; 00400000H
	bts	r13d, 21

; 929  :             goto retry;

	jmp	$retry$659
$LN33@stb_texted:

; 743  :                   stb_text_makeundo_insert(state, state->cursor, 1);
; 744  :                   ++state->cursor;
; 745  :                   state->has_preferred_x = 0;
; 746  :                }
; 747  :             }
; 748  :          }
; 749  :          break;
; 750  :       }
; 751  : 
; 752  : #ifdef STB_TEXTEDIT_K_INSERT
; 753  :       case STB_TEXTEDIT_K_INSERT:
; 754  :          state->insert_mode = !state->insert_mode;
; 755  :          break;
; 756  : #endif
; 757  : 
; 758  :       case STB_TEXTEDIT_K_UNDO:
; 759  :          stb_text_undo(str, state);

	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_text_undo

; 760  :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 761  :          break;

	jmp	$LN32@stb_texted
$LN34@stb_texted:

; 1283 :    StbUndoState *s = &state->undostate;

	lea	rbp, QWORD PTR [rbx+32]

; 1284 :    StbUndoRecord *u, r;
; 1285 :    if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	movsx	rax, WORD PTR [rbp+3584]
	cmp	eax, 99					; 00000063H
	je	$LN89@stb_texted

; 1286 :       return;
; 1287 : 
; 1288 :    // we need to do two things: apply the redo record, and create an undo record
; 1289 :    u = &s->undo_rec[s->undo_point];

	movsx	r8, WORD PTR [rbp+3582]

; 1290 :    r = s->undo_rec[s->redo_point];

	add	rax, rax
	shl	r8, 4
	add	r8, rbp
	movups	xmm1, XMMWORD PTR [rbp+rax*8]

; 1291 : 
; 1292 :    // we KNOW there must be room for the undo record, because the redo record
; 1293 :    // was derived from an undo record
; 1294 : 
; 1295 :    u->delete_length = r.insert_length;
; 1296 :    u->insert_length = r.delete_length;
; 1297 :    u->where = r.where;
; 1298 :    u->char_storage = -1;

	mov	DWORD PTR [r8+12], -1
	movq	r14, xmm1
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	mov	rax, r14
	movd	r10d, xmm0
	shr	rax, 32					; 00000020H
	mov	DWORD PTR [r8+8], eax
	mov	DWORD PTR [r8+4], r10d
	mov	DWORD PTR [r8], r14d
	test	r10d, r10d

; 1299 : 
; 1300 :    if (r.delete_length) {

	je	SHORT $LN465@stb_texted

; 1301 :       // the redo record requires us to delete characters, so the undo record
; 1302 :       // needs to store the characters
; 1303 : 
; 1304 :       if (s->undo_char_point + u->insert_length > s->redo_char_point) {

	mov	ecx, DWORD PTR [rbp+3588]
	xor	esi, esi
	lea	eax, DWORD PTR [r10+rcx]
	cmp	eax, DWORD PTR [rbp+3592]
	jle	SHORT $LN232@stb_texted

; 1305 :          u->insert_length = 0;

	mov	QWORD PTR [r8+4], rsi

; 1306 :          u->delete_length = 0;
; 1307 :       } else {

	jmp	SHORT $LN228@stb_texted
$LN232@stb_texted:

; 1308 :          int i;
; 1309 :          u->char_storage = s->undo_char_point;

	mov	DWORD PTR [r8+12], ecx

; 1310 :          s->undo_char_point = s->undo_char_point + u->insert_length;

	add	DWORD PTR [rbp+3588], r10d

; 1311 : 
; 1312 :          // now save the characters
; 1313 :          for (i=0; i < u->insert_length; ++i)

	cmp	DWORD PTR [r8+4], esi
	jle	SHORT $LN228@stb_texted
	npad	15
$LL229@stb_texted:

; 1314 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	mov	eax, DWORD PTR [r8]
	mov	rdx, QWORD PTR [rdi+32]
	add	eax, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r9, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1314 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	mov	eax, DWORD PTR [r8+12]
	add	eax, esi
	inc	esi
	movsxd	rcx, eax
	movzx	eax, WORD PTR [rdx+r9*2]
	mov	WORD PTR [rbp+rcx*2+1584], ax
	cmp	esi, DWORD PTR [r8+4]
	jl	SHORT $LL229@stb_texted
$LN228@stb_texted:

; 1315 :       }
; 1316 : 
; 1317 :       STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);

	mov	r8d, r10d
	mov	edx, r14d
	mov	rcx, rdi
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
$LN465@stb_texted:

; 1318 :    }
; 1319 : 
; 1320 :    if (r.insert_length) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	movd	esi, xmm0
	test	esi, esi
	je	SHORT $LN234@stb_texted

; 1321 :       // easy case: need to insert n characters
; 1322 :       STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);

	psrldq	xmm1, 12
	lea	r8, QWORD PTR [rbp+1584]
	movd	eax, xmm1
	mov	r9d, esi
	mov	edx, r14d
	movsxd	rcx, eax
	lea	r8, QWORD PTR [r8+rcx*2]
	mov	rcx, rdi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS

; 1323 :       s->redo_char_point += r.insert_length;

	add	DWORD PTR [rbp+3592], esi
$LN234@stb_texted:

; 1324 :    }
; 1325 : 
; 1326 :    state->cursor = r.where + r.insert_length;

	lea	eax, DWORD PTR [r14+rsi]
	mov	DWORD PTR [rbx], eax

; 1327 : 
; 1328 :    s->undo_point++;

	inc	WORD PTR [rbp+3582]

; 1329 :    s->redo_point++;

	inc	WORD PTR [rbp+3584]

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN35@stb_texted:

; 762  : 
; 763  :       case STB_TEXTEDIT_K_REDO:
; 764  :          stb_text_redo(str, state);
; 765  :          state->has_preferred_x = 0;
; 766  :          break;
; 767  : 
; 768  :       case STB_TEXTEDIT_K_LEFT:
; 769  :          // if currently there's a selection, move cursor to start of selection
; 770  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+4]
	mov	ecx, DWORD PTR [rbx+8]
	cmp	eax, ecx
	je	SHORT $LN36@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN366@stb_texted

; 610  :       int temp = state->select_end;

	mov	eax, ecx

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], ecx
$LN366@stb_texted:

; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rbx], eax

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], eax

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN36@stb_texted:

; 771  :             stb_textedit_move_to_first(state);
; 772  :          else
; 773  :             if (state->cursor > 0)

	mov	eax, DWORD PTR [rbx]
	test	eax, eax
	jle	$LN89@stb_texted

; 774  :                --state->cursor;

	dec	eax

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
	mov	DWORD PTR [rbx], eax

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN39@stb_texted:

; 775  :          state->has_preferred_x = 0;
; 776  :          break;
; 777  : 
; 778  :       case STB_TEXTEDIT_K_RIGHT:
; 779  :          // if currently there's a selection, move cursor to end of selection
; 780  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+4]
	mov	r8d, DWORD PTR [rbx+8]
	cmp	eax, r8d
	je	SHORT $LN40@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN353@stb_texted

; 611  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], eax

; 612  :       state->select_start = temp;

	mov	ecx, r8d
	mov	DWORD PTR [rbx+4], r8d

; 682  :       state->select_start = state->select_end = state->cursor;

	jmp	SHORT $LN652@stb_texted
$LN353@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, eax
	mov	eax, r8d
$LN652@stb_texted:

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, DWORD PTR [rdi+12]
	cmp	ecx, edx
	cmovg	ecx, edx

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	eax, edx
	jle	SHORT $LN358@stb_texted
	mov	DWORD PTR [rbx+8], edx
	mov	eax, edx
$LN358@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, eax
	jne	SHORT $LN359@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN359@stb_texted:

; 633  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 634  :       state->select_start = state->select_end;

	mov	DWORD PTR [rbx+4], eax

; 635  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 781  :             stb_textedit_move_to_last(str, state);

	jmp	SHORT $LN653@stb_texted
$LN40@stb_texted:

; 782  :          else
; 783  :             ++state->cursor;

	inc	DWORD PTR [rbx]
	mov	eax, DWORD PTR [rbx]
$LN653@stb_texted:

; 579  :    if (state->cursor > n) state->cursor = n;

	mov	ecx, DWORD PTR [rdi+12]
	cmp	eax, ecx
	jle	SHORT $LN466@stb_texted
	mov	DWORD PTR [rbx], ecx
$LN466@stb_texted:

; 784  :          stb_textedit_clamp(str, state);
; 785  :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 786  :          break;

	jmp	$LN32@stb_texted
$LN44@stb_texted:

; 797  : 
; 798  : #ifdef STB_TEXTEDIT_MOVEWORDLEFT
; 799  :       case STB_TEXTEDIT_K_WORDLEFT:
; 800  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+4]
	mov	ecx, DWORD PTR [rbx+8]
	cmp	eax, ecx
	je	SHORT $LN45@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN341@stb_texted

; 610  :       int temp = state->select_end;

	mov	eax, ecx

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], ecx
$LN341@stb_texted:

; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rbx], eax

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], eax

; 623  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 801  :             stb_textedit_move_to_first(state);

	jmp	$LN32@stb_texted
$LN45@stb_texted:

; 802  :          else {
; 803  :             state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	mov	edx, DWORD PTR [rbx]
	mov	rcx, rdi
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
	mov	DWORD PTR [rbx], eax

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rdi+12]

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	eax, ecx
	jle	$LN32@stb_texted
	mov	DWORD PTR [rbx], ecx

; 804  :             stb_textedit_clamp( str, state );
; 805  :          }
; 806  :          break;

	jmp	$LN32@stb_texted
$LN49@stb_texted:

; 817  : #endif
; 818  : 
; 819  : #ifdef STB_TEXTEDIT_MOVEWORDRIGHT
; 820  :       case STB_TEXTEDIT_K_WORDRIGHT:
; 821  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+4]
	mov	r8d, DWORD PTR [rbx+8]
	cmp	eax, r8d
	je	SHORT $LN50@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN372@stb_texted

; 611  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], eax

; 612  :       state->select_start = temp;

	mov	ecx, r8d
	mov	DWORD PTR [rbx+4], r8d

; 682  :       state->select_start = state->select_end = state->cursor;

	jmp	SHORT $LN654@stb_texted
$LN372@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, eax
	mov	eax, r8d
$LN654@stb_texted:

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, DWORD PTR [rdi+12]
	cmp	ecx, edx
	cmovg	ecx, edx

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	eax, edx
	jle	SHORT $LN377@stb_texted
	mov	DWORD PTR [rbx+8], edx
	mov	eax, edx
$LN377@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, eax
	jne	SHORT $LN378@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN378@stb_texted:

; 633  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 634  :       state->select_start = state->select_end;

	mov	DWORD PTR [rbx+4], eax

; 635  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 822  :             stb_textedit_move_to_last(str, state);

	jmp	$LN32@stb_texted
$LN50@stb_texted:

; 823  :          else {
; 824  :             state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	mov	edx, DWORD PTR [rbx]
	mov	rcx, rdi
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
	mov	DWORD PTR [rbx], eax

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rdi+12]

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	eax, ecx
	jle	$LN32@stb_texted
	mov	DWORD PTR [rbx], ecx

; 825  :             stb_textedit_clamp( str, state );
; 826  :          }
; 827  :          break;

	jmp	$LN32@stb_texted
$LN90@stb_texted:

; 1007 : 
; 1008 : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 1009 :       case STB_TEXTEDIT_K_TEXTSTART2:
; 1010 : #endif
; 1011 :       case STB_TEXTEDIT_K_TEXTSTART:
; 1012 :          state->cursor = state->select_start = state->select_end = 0;

	xor	esi, esi
	mov	QWORD PTR [rbx+4], rsi
	mov	DWORD PTR [rbx], esi

; 1013 :          state->has_preferred_x = 0;
; 1014 :          break;

	jmp	$LN655@stb_texted
$LN91@stb_texted:

; 1015 : 
; 1016 : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 1017 :       case STB_TEXTEDIT_K_TEXTEND2:
; 1018 : #endif
; 1019 :       case STB_TEXTEDIT_K_TEXTEND:
; 1020 :          state->cursor = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rdi+12]

; 1021 :          state->select_start = state->select_end = 0;

	xor	esi, esi
	mov	QWORD PTR [rbx+4], rsi
	mov	DWORD PTR [rbx], eax

; 1022 :          state->has_preferred_x = 0;
; 1023 :          break;

	jmp	$LN655@stb_texted
$LN94@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rbx+4]
	mov	ecx, DWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rdi+12]
	cmp	r8d, ecx
	je	SHORT $LN295@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, r8d
	cmp	r8d, eax
	jle	SHORT $LN293@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	edx, eax
$LN293@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, ecx
	cmp	ecx, eax
	jle	SHORT $LN294@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	r9d, eax
$LN294@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	r8d, edx
	mov	ecx, r9d
	cmp	edx, r9d
	jne	SHORT $LN295@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN295@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	edx, DWORD PTR [rbx]
	cmp	edx, eax
	jle	SHORT $LN296@stb_texted
	mov	DWORD PTR [rbx], eax
	mov	edx, eax
$LN296@stb_texted:

; 619  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	r8d, ecx
	je	SHORT $LN467@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	mov	edx, r8d
	jle	SHORT $LN302@stb_texted

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], ecx
	mov	edx, ecx
$LN302@stb_texted:

; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], edx

; 623  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
$LN467@stb_texted:

; 1042 : 
; 1043 : 
; 1044 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1045 :       case STB_TEXTEDIT_K_LINESTART2:
; 1046 : #endif
; 1047 :       case STB_TEXTEDIT_K_LINESTART:
; 1048 :          stb_textedit_clamp(str, state);
; 1049 :          stb_textedit_move_to_first(state);
; 1050 :          if (state->single_line)

	cmp	BYTE PTR [rbx+23], 0
	je	SHORT $LN406@stb_texted

; 1051 :             state->cursor = 0;

	xor	esi, esi
	mov	DWORD PTR [rbx], esi
	mov	BYTE PTR [rbx+22], sil
	jmp	$LN32@stb_texted
$LN406@stb_texted:

; 1052 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	test	edx, edx
	jle	$LN466@stb_texted
	npad	3
$LL18@stb_texted:
	mov	rax, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	ecx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1052 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rax+rcx*2-2], 10
	je	$LN466@stb_texted

; 1053 :             --state->cursor;

	dec	edx
	mov	DWORD PTR [rbx], edx
	test	edx, edx
	jg	SHORT $LL18@stb_texted

; 1054 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1055 :          break;

	jmp	$LN32@stb_texted
$LN97@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [rbx+4]
	mov	eax, DWORD PTR [rbx+8]

; 1056 : 
; 1057 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1058 :       case STB_TEXTEDIT_K_LINEEND2:
; 1059 : #endif
; 1060 :       case STB_TEXTEDIT_K_LINEEND: {
; 1061 :          int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	r8d, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	ecx, eax
	je	SHORT $LN308@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, ecx
	cmp	ecx, r8d
	jle	SHORT $LN306@stb_texted
	mov	DWORD PTR [rbx+4], r8d
	mov	edx, r8d
$LN306@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, eax
	cmp	eax, r8d
	jle	SHORT $LN307@stb_texted
	mov	DWORD PTR [rbx+8], r8d
	mov	r9d, r8d
$LN307@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	ecx, edx
	mov	eax, r9d
	cmp	edx, r9d
	jne	SHORT $LN308@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN308@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	edx, DWORD PTR [rbx]
	cmp	edx, r8d
	jle	SHORT $LN309@stb_texted
	mov	DWORD PTR [rbx], r8d
	mov	edx, r8d
$LN309@stb_texted:

; 619  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	ecx, eax
	je	SHORT $LN468@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	mov	edx, ecx
	jle	SHORT $LN224@stb_texted

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], eax
	mov	edx, eax
$LN224@stb_texted:

; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], edx

; 623  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
$LN468@stb_texted:

; 1062 :          stb_textedit_clamp(str, state);
; 1063 :          stb_textedit_move_to_first(state);
; 1064 :          if (state->single_line)

	cmp	BYTE PTR [rbx+23], 0
	je	SHORT $LN407@stb_texted

; 1065 :              state->cursor = n;

	mov	DWORD PTR [rbx], r8d
	mov	BYTE PTR [rbx+22], 0
	jmp	$LN32@stb_texted
$LN407@stb_texted:

; 1066 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	edx, r8d
	jge	$LN466@stb_texted
	npad	8
$LL20@stb_texted:
	mov	rax, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1066 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rax+rcx*2], 10
	je	$LN466@stb_texted

; 1067 :              ++state->cursor;

	inc	edx
	mov	DWORD PTR [rbx], edx
	cmp	edx, r8d
	jl	SHORT $LL20@stb_texted

; 1068 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1069 :          break;

	jmp	$LN32@stb_texted
$LN42@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rbx+4]
	mov	edx, DWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rdi+12]
	cmp	r8d, edx
	je	SHORT $LN198@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	eax, r8d
	cmp	r8d, ecx
	jle	SHORT $LN196@stb_texted
	mov	DWORD PTR [rbx+4], ecx
	mov	eax, ecx
$LN196@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, edx
	cmp	edx, ecx
	jle	SHORT $LN197@stb_texted
	mov	DWORD PTR [rbx+8], ecx
	mov	r9d, ecx
$LN197@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	r8d, eax
	mov	edx, r9d
	cmp	eax, r9d
	jne	SHORT $LN198@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], eax
$LN198@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	eax, DWORD PTR [rbx]
	cmp	eax, ecx
	cmovg	eax, ecx

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	r8d, edx
	jne	SHORT $LN202@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx+4], eax
	jmp	SHORT $LN203@stb_texted
$LN202@stb_texted:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	eax, edx
$LN203@stb_texted:

; 787  : 
; 788  :       case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
; 789  :          stb_textedit_clamp(str, state);
; 790  :          stb_textedit_prep_selection_at_cursor(state);
; 791  :          // move selection left
; 792  :          if (state->select_end > 0)

	test	eax, eax
	jle	SHORT $LN43@stb_texted

; 793  :             --state->select_end;

	dec	eax
	mov	DWORD PTR [rbx+8], eax
$LN43@stb_texted:

; 794  :          state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 795  :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 796  :          break;

	jmp	$LN32@stb_texted
$LN478@stb_texted:

; 857  :          int row_count = is_page ? state->row_count_per_page : 1;

	mov	ebp, DWORD PTR [rbx+16]
	mov	DWORD PTR row_count$1$[rsp], ebp

; 858  : 
; 859  :          if (!is_page && state->single_line) {

	jmp	SHORT $LN444@stb_texted
$LN490@stb_texted:
	mov	ebp, r12d
$LN444@stb_texted:

; 863  :          }
; 864  : 
; 865  :          if (sel)

	mov	ecx, DWORD PTR [rbx+4]
	mov	eax, DWORD PTR [rbx+8]
	bt	r13d, 22
	jae	$LN60@stb_texted

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	ecx, eax
	jne	SHORT $LN266@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	ecx, DWORD PTR [rbx]
	mov	eax, ecx
	mov	DWORD PTR [rbx+8], ecx
	mov	DWORD PTR [rbx+4], ecx
$LN325@stb_texted:

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	edx, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	ecx, eax
	je	SHORT $LN191@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, edx
	jle	SHORT $LN189@stb_texted
	mov	DWORD PTR [rbx+4], edx
	mov	ecx, edx
$LN189@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	eax, edx
	jle	SHORT $LN190@stb_texted
	mov	DWORD PTR [rbx+8], edx
	mov	eax, edx
$LN190@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, eax
	jne	SHORT $LN191@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN191@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, edx
	jle	SHORT $LN192@stb_texted
	mov	DWORD PTR [rbx], edx
	mov	r8d, edx
$LN192@stb_texted:

; 868  :             stb_textedit_move_to_last(str, state);
; 869  : 
; 870  :          // compute current position of cursor point
; 871  :          stb_textedit_clamp(str, state);
; 872  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	movzx	r9d, BYTE PTR [rbx+23]
	lea	rcx, QWORD PTR find$2[rsp]
	mov	rdx, rdi
	call	?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ; ImStb::stb_textedit_find_charpos

; 873  : 
; 874  :          for (j = 0; j < row_count; ++j) {

	xor	esi, esi
	mov	r12d, esi
	test	ebp, ebp
	jle	$LN32@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	movss	xmm8, DWORD PTR find$2[rsp]
	movss	xmm7, DWORD PTR __real@bf800000
	mov	r11d, DWORD PTR find$2[rsp+16]
	mov	r15d, DWORD PTR find$2[rsp+12]
$LL6@stb_texted:

; 875  :             float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	cmp	BYTE PTR [rbx+22], sil
	je	SHORT $LN109@stb_texted
	movss	xmm6, DWORD PTR [rbx+28]
	jmp	SHORT $LN110@stb_texted
$LN266@stb_texted:

; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 866  :             stb_textedit_prep_selection_at_cursor(state);

	jmp	SHORT $LN325@stb_texted
$LN60@stb_texted:

; 867  :          else if (STB_TEXT_HAS_SELECTION(state))

	cmp	ecx, eax
	je	SHORT $LN325@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	mov	edx, ecx
	jle	SHORT $LN328@stb_texted

; 610  :       int temp = state->select_end;

	mov	edx, eax

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], eax
	mov	eax, ecx
	mov	DWORD PTR [rbx+8], ecx
$LN328@stb_texted:

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	ecx, DWORD PTR [rdi+12]
	cmp	edx, ecx
	cmovg	edx, ecx

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	eax, ecx
	jle	SHORT $LN333@stb_texted
	mov	DWORD PTR [rbx+8], ecx
	mov	eax, ecx
$LN333@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	edx, eax
	jne	SHORT $LN334@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN334@stb_texted:

; 633  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 634  :       state->select_start = state->select_end;

	mov	DWORD PTR [rbx+4], eax

; 635  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
	mov	edx, DWORD PTR [rdi+12]

; 682  :       state->select_start = state->select_end = state->cursor;

	jmp	$LN191@stb_texted
$LN109@stb_texted:

; 875  :             float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	movaps	xmm6, xmm8
$LN110@stb_texted:

; 876  :             int start = find.first_char + find.length;

	add	r15d, r11d

; 877  : 
; 878  :             if (find.length == 0)

	test	r11d, r11d
	je	$LN32@stb_texted

; 883  :             if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)

	mov	rax, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r14, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 883  :             if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rax+r14*2-2], 10
	jne	$LN32@stb_texted

; 884  :                break;
; 885  : 
; 886  :             // now find character position down a row
; 887  :             state->cursor = start;
; 888  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	mov	r8d, r15d
	mov	DWORD PTR [rbx], r15d
	mov	rdx, rdi
	lea	rcx, QWORD PTR row$4[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 889  :             x = row.x0;
; 890  :             for (i=0; i < row.num_chars; ++i) {

	mov	r11d, DWORD PTR row$4[rsp+20]
	mov	r9d, esi
	movss	xmm2, DWORD PTR row$4[rsp]
	test	r11d, r11d
	jle	SHORT $LN486@stb_texted

; 635  :       state->has_preferred_x = 0;

	lea	r8, QWORD PTR [r14+r14]
	npad	4
$LL9@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mov	rax, QWORD PTR [rdi+32]
	movzx	ecx, WORD PTR [r8+rax]
	cmp	ecx, 10
	je	SHORT $LN486@stb_texted
	mov	r10, QWORD PTR [rdi]
	mov	rdx, QWORD PTR [r10+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [rdx]
	jge	SHORT $LN154@stb_texted
	mov	rax, QWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN155@stb_texted
$LN154@stb_texted:
	movss	xmm1, DWORD PTR [rdx+16]
$LN155@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movss	xmm0, DWORD PTR [r10+15696]
	divss	xmm0, DWORD PTR [rdx+20]
	mulss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 893  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	ucomiss	xmm0, xmm7
	jp	SHORT $LN481@stb_texted
	je	SHORT $LN486@stb_texted
$LN481@stb_texted:

; 894  :                   break;
; 895  :                #endif
; 896  :                x += dx;

	addss	xmm2, xmm0

; 897  :                if (x > goal_x)

	comiss	xmm2, xmm6
	ja	SHORT $LN486@stb_texted

; 898  :                   break;
; 899  :                ++state->cursor;

	inc	DWORD PTR [rbx]
	inc	r9d
	add	r8, 2
	cmp	r9d, r11d
	jl	SHORT $LL9@stb_texted
$LN486@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [rbx+4]
	mov	edx, DWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rdi+12]
	cmp	ecx, edx
	je	SHORT $LN144@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, eax
	jle	SHORT $LN142@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	ecx, eax
$LN142@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	edx, eax
	jle	SHORT $LN143@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	edx, eax
$LN143@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, edx
	jne	SHORT $LN144@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN144@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	ecx, DWORD PTR [rbx]
	cmp	ecx, eax
	jle	SHORT $LN145@stb_texted
	mov	DWORD PTR [rbx], eax
	mov	ecx, eax
$LN145@stb_texted:

; 900  :             }
; 901  :             stb_textedit_clamp(str, state);
; 902  : 
; 903  :             state->has_preferred_x = 1;
; 904  :             state->preferred_x = goal_x;

	movss	DWORD PTR [rbx+28], xmm6
	mov	BYTE PTR [rbx+22], 1

; 905  : 
; 906  :             if (sel)

	bt	r13d, 22
	jae	SHORT $LN445@stb_texted

; 907  :                state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], ecx
$LN445@stb_texted:

; 873  : 
; 874  :          for (j = 0; j < row_count; ++j) {

	inc	r12d
	cmp	r12d, DWORD PTR row_count$1$[rsp]
	jl	$LL6@stb_texted

; 908  : 
; 909  :             // go to next line
; 910  :             find.first_char = find.first_char + find.length;
; 911  :             find.length = row.num_chars;
; 912  :          }
; 913  :          break;

	jmp	$LN32@stb_texted
$LN479@stb_texted:

; 924  :          int row_count = is_page ? state->row_count_per_page : 1;

	mov	r12d, DWORD PTR [rbx+16]
$LN446@stb_texted:

; 930  :          }
; 931  : 
; 932  :          if (sel)

	mov	eax, DWORD PTR [rbx+4]
	mov	ecx, DWORD PTR [rbx+8]
	bt	r13d, 22
	jae	$LN73@stb_texted

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	eax, ecx
	jne	SHORT $LN270@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [rbx]
	mov	ecx, eax
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx+4], eax
$LN344@stb_texted:

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	edx, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	eax, ecx
	je	SHORT $LN184@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	eax, edx
	jle	SHORT $LN182@stb_texted
	mov	DWORD PTR [rbx+4], edx
	mov	eax, edx
$LN182@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	ecx, edx
	jle	SHORT $LN183@stb_texted
	mov	DWORD PTR [rbx+8], edx
	mov	ecx, edx
$LN183@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	eax, ecx
	jne	SHORT $LN184@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], eax
$LN184@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, edx
	jle	SHORT $LN185@stb_texted
	mov	DWORD PTR [rbx], edx
	mov	r8d, edx
$LN185@stb_texted:

; 935  :             stb_textedit_move_to_first(state);
; 936  : 
; 937  :          // compute current position of cursor point
; 938  :          stb_textedit_clamp(str, state);
; 939  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	movzx	r9d, BYTE PTR [rbx+23]
	lea	rcx, QWORD PTR find$1[rsp]
	mov	rdx, rdi
	call	?stb_textedit_find_charpos@ImStb@@YAXPEAUStbFindState@1@PEAUImGuiInputTextState@@HH@Z ; ImStb::stb_textedit_find_charpos

; 940  : 
; 941  :          for (j = 0; j < row_count; ++j) {

	xor	esi, esi
	mov	r15d, esi
	test	r12d, r12d
	jle	$LN32@stb_texted
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movss	xmm8, DWORD PTR find$1[rsp]
	movss	xmm7, DWORD PTR __real@bf800000
	mov	ebp, DWORD PTR find$1[rsp+20]
	mov	eax, DWORD PTR find$1[rsp+12]
$LL12@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 942  :             float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	cmp	BYTE PTR [rbx+22], sil
	je	SHORT $LN113@stb_texted
	movss	xmm6, DWORD PTR [rbx+28]
	jmp	SHORT $LN114@stb_texted
$LN270@stb_texted:

; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], ecx

; 933  :             stb_textedit_prep_selection_at_cursor(state);

	jmp	SHORT $LN344@stb_texted
$LN73@stb_texted:

; 934  :          else if (STB_TEXT_HAS_SELECTION(state))

	cmp	eax, ecx
	je	SHORT $LN344@stb_texted

; 609  :    if (state->select_end < state->select_start) {

	jle	SHORT $LN347@stb_texted

; 610  :       int temp = state->select_end;

	mov	eax, ecx

; 612  :       state->select_start = temp;

	mov	DWORD PTR [rbx+4], ecx
$LN347@stb_texted:

; 621  :       state->cursor = state->select_start;

	mov	DWORD PTR [rbx], eax

; 622  :       state->select_end = state->select_start;

	mov	DWORD PTR [rbx+8], eax

; 623  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
	mov	edx, DWORD PTR [rdi+12]

; 682  :       state->select_start = state->select_end = state->cursor;

	jmp	SHORT $LN184@stb_texted
$LN113@stb_texted:

; 942  :             float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	movaps	xmm6, xmm8
$LN114@stb_texted:

; 943  : 
; 944  :             // can only go up if there's a previous row
; 945  :             if (find.prev_first == find.first_char)

	cmp	ebp, eax
	je	$LN32@stb_texted

; 946  :                break;
; 947  : 
; 948  :             // now find character position up a row
; 949  :             state->cursor = find.prev_first;
; 950  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	mov	r8d, ebp
	mov	DWORD PTR [rbx], ebp
	mov	rdx, rdi
	lea	rcx, QWORD PTR row$3[rsp]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 951  :             x = row.x0;
; 952  :             for (i=0; i < row.num_chars; ++i) {

	mov	r11d, DWORD PTR row$3[rsp+20]
	mov	r9d, esi
	movss	xmm2, DWORD PTR row$3[rsp]
	test	r11d, r11d
	jle	SHORT $LN487@stb_texted
	npad	14
$LL15@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	eax, DWORD PTR [r9+rbp]
	movsxd	rcx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	mov	rax, QWORD PTR [rdi+32]
	movzx	r8d, WORD PTR [rax+rcx*2]
	cmp	r8d, 10
	je	SHORT $LN487@stb_texted
	mov	r10, QWORD PTR [rdi]
	mov	rdx, QWORD PTR [r10+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	r8d, DWORD PTR [rdx]
	jge	SHORT $LN136@stb_texted
	mov	rax, QWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rax+r8*4]
	jmp	SHORT $LN137@stb_texted
$LN136@stb_texted:
	movss	xmm1, DWORD PTR [rdx+16]
$LN137@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3737 : static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *obj->Ctx; return g.Font->GetCharAdvance(c) * (g.FontSize / g.Font->FontSize); }

	movss	xmm0, DWORD PTR [r10+15696]
	divss	xmm0, DWORD PTR [rdx+20]
	mulss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 955  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	ucomiss	xmm0, xmm7
	jp	SHORT $LN480@stb_texted
	je	SHORT $LN487@stb_texted
$LN480@stb_texted:

; 956  :                   break;
; 957  :                #endif
; 958  :                x += dx;

	addss	xmm2, xmm0

; 959  :                if (x > goal_x)

	comiss	xmm2, xmm6
	ja	SHORT $LN487@stb_texted

; 960  :                   break;
; 961  :                ++state->cursor;

	inc	DWORD PTR [rbx]
	inc	r9d
	cmp	r9d, r11d
	jl	SHORT $LL15@stb_texted
$LN487@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [rbx+4]
	mov	edx, DWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rdi+12]
	cmp	ecx, edx
	je	SHORT $LN126@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, eax
	jle	SHORT $LN124@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	ecx, eax
$LN124@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	edx, eax
	jle	SHORT $LN125@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	edx, eax
$LN125@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, edx
	jne	SHORT $LN126@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], ecx
$LN126@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	ecx, DWORD PTR [rbx]
	cmp	ecx, eax
	jle	SHORT $LN127@stb_texted
	mov	DWORD PTR [rbx], eax
	mov	ecx, eax
$LN127@stb_texted:

; 962  :             }
; 963  :             stb_textedit_clamp(str, state);
; 964  : 
; 965  :             state->has_preferred_x = 1;
; 966  :             state->preferred_x = goal_x;

	movss	DWORD PTR [rbx+28], xmm6
	mov	BYTE PTR [rbx+22], 1

; 967  : 
; 968  :             if (sel)

	bt	r13d, 22
	jae	SHORT $LN79@stb_texted

; 969  :                state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], ecx
$LN79@stb_texted:

; 970  : 
; 971  :             // go to previous line
; 972  :             // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
; 973  :             prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;

	test	ebp, ebp
	jle	SHORT $LN115@stb_texted
	lea	r8d, DWORD PTR [rbp-1]

; 974  :             while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)

	test	r8d, r8d
	jle	SHORT $LN17@stb_texted
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdx, QWORD PTR [rdi+32]
	add	rdx, -2
	movsxd	rcx, r8d
	lea	rdx, QWORD PTR [rdx+rcx*2]
$LL16@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 974  :             while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rdx], 10
	je	SHORT $LN17@stb_texted

; 975  :                --prev_scan;

	dec	r8d
	dec	rcx
	sub	rdx, 2
	test	rcx, rcx
	jg	SHORT $LL16@stb_texted

; 974  :             while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)

	jmp	SHORT $LN17@stb_texted
$LN115@stb_texted:

; 970  : 
; 971  :             // go to previous line
; 972  :             // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
; 973  :             prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;

	mov	r8d, esi
$LN17@stb_texted:

; 940  : 
; 941  :          for (j = 0; j < row_count; ++j) {

	inc	r15d

; 976  :             find.first_char = find.prev_first;

	mov	eax, ebp

; 977  :             find.prev_first = prev_scan;

	mov	ebp, r8d
	cmp	r15d, r12d
	jl	$LL12@stb_texted

; 978  :          }
; 979  :          break;

	jmp	$LN32@stb_texted
$LN47@stb_texted:

; 807  : 
; 808  :       case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
; 809  :          if( !STB_TEXT_HAS_SELECTION( state ) )

	mov	esi, DWORD PTR [rbx+4]
	cmp	esi, DWORD PTR [rbx+8]
	jne	SHORT $LN469@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	esi, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+8], esi
	mov	DWORD PTR [rbx+4], esi
$LN469@stb_texted:

; 810  :             stb_textedit_prep_selection_at_cursor(state);
; 811  : 
; 812  :          state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	mov	edx, DWORD PTR [rbx]
	mov	rcx, rdi
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
	mov	DWORD PTR [rbx], eax

; 813  :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], eax

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	esi, eax
	je	SHORT $LN251@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	esi, ecx
	jle	SHORT $LN249@stb_texted
	mov	DWORD PTR [rbx+4], ecx
	mov	esi, ecx
$LN249@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	edx, eax
	cmp	eax, ecx
	jle	SHORT $LN250@stb_texted
	mov	DWORD PTR [rbx+8], ecx
	mov	edx, ecx
$LN250@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	esi, edx
	jne	SHORT $LN251@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], esi
	mov	eax, esi
$LN251@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	eax, ecx
	jle	$LN32@stb_texted
	mov	DWORD PTR [rbx], ecx

; 814  : 
; 815  :          stb_textedit_clamp( str, state );
; 816  :          break;

	jmp	$LN32@stb_texted
$LN52@stb_texted:

; 828  : 
; 829  :       case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
; 830  :          if( !STB_TEXT_HAS_SELECTION( state ) )

	mov	esi, DWORD PTR [rbx+4]
	cmp	esi, DWORD PTR [rbx+8]
	jne	SHORT $LN470@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	esi, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+8], esi
	mov	DWORD PTR [rbx+4], esi
$LN470@stb_texted:

; 831  :             stb_textedit_prep_selection_at_cursor(state);
; 832  : 
; 833  :          state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	mov	edx, DWORD PTR [rbx]
	mov	rcx, rdi
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
	mov	DWORD PTR [rbx], eax

; 834  :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], eax

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	esi, eax
	je	SHORT $LN277@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	esi, ecx
	jle	SHORT $LN275@stb_texted
	mov	DWORD PTR [rbx+4], ecx
	mov	esi, ecx
$LN275@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	edx, eax
	cmp	eax, ecx
	jle	SHORT $LN276@stb_texted
	mov	DWORD PTR [rbx+8], ecx
	mov	edx, ecx
$LN276@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	esi, edx
	jne	SHORT $LN277@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], esi
	mov	eax, esi
$LN277@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	eax, ecx
	jle	$LN32@stb_texted
	mov	DWORD PTR [rbx], ecx

; 835  : 
; 836  :          stb_textedit_clamp( str, state );
; 837  :          break;

	jmp	$LN32@stb_texted
$LN54@stb_texted:

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	mov	edx, DWORD PTR [rbx+4]
	mov	eax, DWORD PTR [rbx+8]
	cmp	edx, eax
	jne	SHORT $LN255@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [rbx]
	mov	edx, eax
	mov	DWORD PTR [rbx+4], eax
	jmp	SHORT $LN256@stb_texted
$LN255@stb_texted:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax
$LN256@stb_texted:

; 838  : #endif
; 839  : 
; 840  :       case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
; 841  :          stb_textedit_prep_selection_at_cursor(state);
; 842  :          // move selection right
; 843  :          ++state->select_end;

	inc	eax
	mov	DWORD PTR [rbx+8], eax

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	edx, eax
	je	SHORT $LN262@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	edx, ecx
	jle	SHORT $LN260@stb_texted
	mov	DWORD PTR [rbx+4], ecx
	mov	edx, ecx
$LN260@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r8d, eax
	cmp	eax, ecx
	jle	SHORT $LN261@stb_texted
	mov	DWORD PTR [rbx+8], ecx
	mov	r8d, ecx
$LN261@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	edx, r8d
	mov	eax, r8d
	cmove	eax, r8d
$LN262@stb_texted:

; 844  :          stb_textedit_clamp(str, state);
; 845  :          state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 846  :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 847  :          break;

	jmp	$LN32@stb_texted
$LN80@stb_texted:

; 980  :       }
; 981  : 
; 982  :       case STB_TEXTEDIT_K_DELETE:
; 983  :       case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
; 984  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	jne	SHORT $LN656@stb_texted

; 985  :             stb_textedit_delete_selection(str, state);
; 986  :          else {
; 987  :             int n = STB_TEXTEDIT_STRINGLEN(str);
; 988  :             if (state->cursor < n)

	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, DWORD PTR [rdi+12]
	jge	SHORT $LN89@stb_texted

; 989  :                stb_textedit_delete(str, state, state->cursor, 1);

	mov	r9d, r12d
	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN85@stb_texted:

; 990  :          }
; 991  :          state->has_preferred_x = 0;
; 992  :          break;
; 993  : 
; 994  :       case STB_TEXTEDIT_K_BACKSPACE:
; 995  :       case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
; 996  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	je	SHORT $LN87@stb_texted
$LN656@stb_texted:

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection
	mov	BYTE PTR [rbx+22], 0

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN87@stb_texted:

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rdi+12]

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, eax
	jle	SHORT $LN285@stb_texted
	mov	DWORD PTR [rbx], eax
	mov	r8d, eax
$LN285@stb_texted:

; 997  :             stb_textedit_delete_selection(str, state);
; 998  :          else {
; 999  :             stb_textedit_clamp(str, state);
; 1000 :             if (state->cursor > 0) {

	test	r8d, r8d
	jle	SHORT $LN89@stb_texted

; 1001 :                stb_textedit_delete(str, state, state->cursor-1, 1);

	dec	r8d
	mov	r9d, r12d
	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 1002 :                --state->cursor;

	dec	DWORD PTR [rbx]
$LN89@stb_texted:

; 1003 :             }
; 1004 :          }
; 1005 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1006 :          break;

	jmp	$LN32@stb_texted
$LN92@stb_texted:

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	jne	SHORT $LN312@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+4], eax
$LN312@stb_texted:

; 1024 : 
; 1025 : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 1026 :       case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
; 1027 : #endif
; 1028 :       case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
; 1029 :          stb_textedit_prep_selection_at_cursor(state);
; 1030 :          state->cursor = state->select_end = 0;

	xor	esi, esi
	mov	DWORD PTR [rbx+8], esi
	mov	DWORD PTR [rbx], esi

; 1031 :          state->has_preferred_x = 0;
; 1032 :          break;

	jmp	$LN655@stb_texted
$LN93@stb_texted:

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	jne	SHORT $LN288@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx+4], eax

; 1033 : 
; 1034 : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 1035 :       case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
; 1036 : #endif
; 1037 :       case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
; 1038 :          stb_textedit_prep_selection_at_cursor(state);
; 1039 :          state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx], eax

; 1040 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1041 :          break;

	jmp	$LN32@stb_texted
$LN288@stb_texted:

; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax

; 1033 : 
; 1034 : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 1035 :       case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
; 1036 : #endif
; 1037 :       case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
; 1038 :          stb_textedit_prep_selection_at_cursor(state);
; 1039 :          state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx], eax

; 1040 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1041 :          break;

	jmp	$LN32@stb_texted
$LN100@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rbx+4]
	mov	ecx, DWORD PTR [rbx+8]
	mov	eax, DWORD PTR [rdi+12]
	cmp	r8d, ecx
	je	SHORT $LN319@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, r8d
	cmp	r8d, eax
	jle	SHORT $LN317@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	edx, eax
$LN317@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, ecx
	cmp	ecx, eax
	jle	SHORT $LN318@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	r9d, eax
$LN318@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	r8d, edx
	mov	ecx, r9d
	cmp	edx, r9d
	jne	SHORT $LN319@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN319@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	edx, DWORD PTR [rbx]
	mov	esi, edx
	cmp	edx, eax
	jle	SHORT $LN320@stb_texted
	mov	DWORD PTR [rbx], eax
	mov	edx, eax
	mov	esi, eax
$LN320@stb_texted:

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	r8d, ecx
	jne	SHORT $LN206@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], edx
	mov	DWORD PTR [rbx+4], edx
	jmp	SHORT $LN207@stb_texted
$LN206@stb_texted:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], ecx
	mov	edx, ecx
	mov	esi, ecx
$LN207@stb_texted:

; 1070 :       }
; 1071 : 
; 1072 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1073 :       case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
; 1074 : #endif
; 1075 :       case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
; 1076 :          stb_textedit_clamp(str, state);
; 1077 :          stb_textedit_prep_selection_at_cursor(state);
; 1078 :          if (state->single_line)

	cmp	BYTE PTR [rbx+23], 0
	je	SHORT $LN413@stb_texted

; 1079 :             state->cursor = 0;

	xor	esi, esi
	mov	DWORD PTR [rbx], esi

; 1082 :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], esi

; 1083 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], sil

; 1084 :          break;

	jmp	$LN32@stb_texted
$LN413@stb_texted:

; 1080 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	test	edx, edx
	jle	SHORT $LN488@stb_texted
$LL22@stb_texted:
	mov	rax, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	ecx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1080 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rax+rcx*2-2], 10
	je	SHORT $LN488@stb_texted

; 1081 :             --state->cursor;

	lea	esi, DWORD PTR [rdx-1]
	mov	DWORD PTR [rbx], esi
	mov	edx, esi
	test	esi, esi
	jg	SHORT $LL22@stb_texted
$LN488@stb_texted:

; 1082 :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], esi

; 1083 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 1084 :          break;

	jmp	$LN32@stb_texted
$LN103@stb_texted:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [rbx+4]
	mov	eax, DWORD PTR [rbx+8]

; 1085 : 
; 1086 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1087 :       case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
; 1088 : #endif
; 1089 :       case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
; 1090 :          int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	r9d, DWORD PTR [rdi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	ecx, eax
	je	SHORT $LN213@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, ecx
	cmp	ecx, r9d
	jle	SHORT $LN211@stb_texted
	mov	DWORD PTR [rbx+4], r9d
	mov	edx, r9d
$LN211@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r8d, eax
	cmp	eax, r9d
	jle	SHORT $LN212@stb_texted
	mov	DWORD PTR [rbx+8], r9d
	mov	r8d, r9d
$LN212@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	ecx, edx
	mov	eax, r8d
	cmp	edx, r8d
	jne	SHORT $LN213@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN213@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	r8d, DWORD PTR [rbx]
	mov	edx, r8d
	cmp	r8d, r9d
	jle	SHORT $LN214@stb_texted
	mov	DWORD PTR [rbx], r9d
	mov	r8d, r9d
	mov	edx, r9d
$LN214@stb_texted:

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	ecx, eax
	jne	SHORT $LN217@stb_texted

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], r8d
	mov	DWORD PTR [rbx+4], r8d
	jmp	SHORT $LN218@stb_texted
$LN217@stb_texted:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rbx], eax
	mov	r8d, eax
	mov	edx, eax
$LN218@stb_texted:

; 1091 :          stb_textedit_clamp(str, state);
; 1092 :          stb_textedit_prep_selection_at_cursor(state);
; 1093 :          if (state->single_line)

	cmp	BYTE PTR [rbx+23], 0
	je	SHORT $LN414@stb_texted

; 1094 :              state->cursor = n;

	mov	edx, r9d
	mov	DWORD PTR [rbx], r9d

; 1097 :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], edx

; 1098 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
	jmp	$LN32@stb_texted
$LN414@stb_texted:

; 1095 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	r8d, r9d
	jge	SHORT $LN489@stb_texted
	npad	13
$LL24@stb_texted:
	mov	rax, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1095 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	WORD PTR [rax+rcx*2], 10
	je	SHORT $LN489@stb_texted

; 1096 :             ++state->cursor;

	lea	edx, DWORD PTR [r8+1]
	mov	DWORD PTR [rbx], edx
	mov	r8d, edx
	cmp	edx, r9d
	jl	SHORT $LL24@stb_texted
$LN489@stb_texted:

; 1097 :          state->select_end = state->cursor;

	mov	DWORD PTR [rbx+8], edx

; 1098 :          state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
	jmp	$LN32@stb_texted
$LN26@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3738 : static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x200000 ? 0 : key; }

	xor	esi, esi
	cmp	r13d, 2097152				; 00200000H
	cmovge	r13d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 726  :          if (c > 0) {

	test	r13d, r13d
	jle	$LN32@stb_texted

; 727  :             STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

	mov	WORD PTR ch$5[rsp], r13w

; 728  : 
; 729  :             // can't add newline in single-line mode
; 730  :             if (c == '\n' && state->single_line)

	cmp	r13d, 10
	jne	SHORT $LN28@stb_texted
	cmp	BYTE PTR [rbx+23], sil
	jne	$LN32@stb_texted
$LN28@stb_texted:

; 731  :                break;
; 732  : 
; 733  :             if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {

	cmp	BYTE PTR [rbx+12], sil
	je	SHORT $LN29@stb_texted
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rbx+4], eax
	jne	SHORT $LN29@stb_texted
	mov	r8d, DWORD PTR [rbx]
	cmp	r8d, DWORD PTR [rdi+12]
	jge	SHORT $LN29@stb_texted

; 734  :                stb_text_makeundo_replace(str, state, state->cursor, 1, 1);

	mov	r9d, r12d
	mov	DWORD PTR [rsp+32], r12d
	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z ; ImStb::stb_text_makeundo_replace

; 735  :                STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);

	mov	edx, DWORD PTR [rbx]
	mov	r8d, r12d
	mov	rcx, rdi
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS

; 736  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	mov	edx, DWORD PTR [rbx]
	lea	r8, QWORD PTR ch$5[rsp]
	mov	r9d, r12d
	mov	rcx, rdi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN32@stb_texted

; 737  :                   ++state->cursor;
; 738  :                   state->has_preferred_x = 0;
; 739  :                }
; 740  :             } else {

	jmp	SHORT $LN657@stb_texted
$LN29@stb_texted:

; 741  :                stb_textedit_delete_selection(str,state); // implicitly clamps

	mov	rdx, rbx
	mov	rcx, rdi
	call	?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection

; 742  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	mov	edx, DWORD PTR [rbx]
	lea	r8, QWORD PTR ch$5[rsp]
	mov	r9d, r12d
	mov	rcx, rdi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN32@stb_texted

; 1334 :    stb_text_createundo(&state->undostate, where, 0, length);

	mov	edx, DWORD PTR [rbx]
	lea	rcx, QWORD PTR [rbx+32]
	mov	r9d, r12d
	xor	r8d, r8d
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
$LN657@stb_texted:

; 1099 :          break;
; 1100 :       }
; 1101 :    }
; 1102 : }

	inc	DWORD PTR [rbx]
$LN655@stb_texted:
	mov	BYTE PTR [rbx+22], sil
$LN32@stb_texted:
	movaps	xmm8, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+128]
	movaps	xmm6, XMMWORD PTR [rsp+144]
	mov	r15, QWORD PTR [rsp+160]
	mov	r14, QWORD PTR [rsp+168]
	mov	rsi, QWORD PTR [rsp+176]
	mov	rbp, QWORD PTR [rsp+248]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
$LN483@stb_texted:
	DD	$LN35@stb_texted
	DD	$LN39@stb_texted
	DD	$LN68@stb_texted
	DD	$LN55@stb_texted
	DD	$LN94@stb_texted
	DD	$LN97@stb_texted
	DD	$LN90@stb_texted
	DD	$LN91@stb_texted
	DD	$LN80@stb_texted
	DD	$LN85@stb_texted
	DD	$LN33@stb_texted
	DD	$LN34@stb_texted
	DD	$LN44@stb_texted
	DD	$LN49@stb_texted
	DD	$LN68@stb_texted
	DD	$LN55@stb_texted
$LN482@stb_texted:
	DD	$LN54@stb_texted
	DD	$LN68@stb_texted
	DD	$LN55@stb_texted
	DD	$LN100@stb_texted
	DD	$LN103@stb_texted
	DD	$LN92@stb_texted
	DD	$LN93@stb_texted
	DD	$LN80@stb_texted
	DD	$LN85@stb_texted
	DD	$LN26@stb_texted
	DD	$LN26@stb_texted
	DD	$LN47@stb_texted
	DD	$LN52@stb_texted
	DD	$LN68@stb_texted
	DD	$LN55@stb_texted
?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_flush_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
_TEXT	SEGMENT
state$ = 8
?stb_textedit_flush_redo@ImStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_flush_redo, COMDAT

; 1112 :    state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	WORD PTR [rcx+3584], 99			; 00000063H

; 1113 :    state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	DWORD PTR [rcx+3592], 999		; 000003e7H

; 1114 : }

	ret	0
?stb_textedit_flush_redo@ImStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_flush_redo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z
_TEXT	SEGMENT
state$ = 48
?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_discard_undo, COMDAT

; 1118 : {

	push	rdi
	sub	rsp, 32					; 00000020H

; 1119 :    if (state->undo_point > 0) {

	movzx	edx, WORD PTR [rcx+3582]
	mov	rdi, rcx
	test	dx, dx
	jle	$LN5@stb_texted

; 1120 :       // if the 0th undo state has characters, clean those up
; 1121 :       if (state->undo_rec[0].char_storage >= 0) {

	cmp	DWORD PTR [rcx+12], 0
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+12]
	jl	SHORT $LN3@stb_texted

; 1122 :          int n = state->undo_rec[0].insert_length, i;
; 1123 :          // delete n characters from all other records
; 1124 :          state->undo_char_point -= n;
; 1125 :          STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));

	lea	rax, QWORD PTR [rcx+1584]
	mov	QWORD PTR [rsp+56], rsi
	movsxd	rsi, DWORD PTR [rcx+4]
	sub	DWORD PTR [rcx+3588], esi
	movsxd	r8, DWORD PTR [rcx+3588]
	add	rcx, 1584				; 00000630H
	add	r8, r8
	lea	rdx, QWORD PTR [rax+rsi*2]
	call	memmove

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movzx	edx, WORD PTR [rdi+3582]
	xor	ecx, ecx
	cmp	cx, dx
	jge	SHORT $LN17@stb_texted
$LL4@stb_texted:

; 1127 :             if (state->undo_rec[i].char_storage >= 0)

	mov	eax, DWORD PTR [rbx]
	test	eax, eax
	js	SHORT $LN2@stb_texted

; 1128 :                state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it

	sub	eax, esi
	mov	DWORD PTR [rbx], eax
$LN2@stb_texted:

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movsx	edx, WORD PTR [rdi+3582]
	inc	ecx
	add	rbx, 16
	cmp	ecx, edx
	jl	SHORT $LL4@stb_texted
$LN17@stb_texted:
	mov	rsi, QWORD PTR [rsp+56]
$LN3@stb_texted:

; 1129 :       }
; 1130 :       --state->undo_point;

	dec	dx

; 1131 :       STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));

	mov	rcx, rdi
	movsx	r8, dx
	mov	WORD PTR [rdi+3582], dx
	lea	rdx, QWORD PTR [rdi+16]
	shl	r8, 4
	call	memmove
	mov	rbx, QWORD PTR [rsp+48]
$LN5@stb_texted:

; 1132 :    }
; 1133 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_discard_undo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z
_TEXT	SEGMENT
state$ = 48
?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z PROC ; ImStb::stb_textedit_discard_redo, COMDAT

; 1140 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 1141 :    int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;
; 1142 : 
; 1143 :    if (state->redo_point <= k) {

	cmp	WORD PTR [rcx+3584], 98			; 00000062H
	mov	rbx, rcx
	jg	$LN5@stb_texted

; 1144 :       // if the k'th undo state has characters, clean those up
; 1145 :       if (state->undo_rec[k].char_storage >= 0) {

	cmp	DWORD PTR [rcx+1580], 0
	mov	QWORD PTR [rsp+48], rsi
	mov	esi, 98					; 00000062H
	jl	$LN3@stb_texted

; 1147 :          // move the remaining redo character data to the end of the buffer
; 1148 :          state->redo_char_point += n;
; 1149 :          STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));

	mov	eax, 999				; 000003e7H
	mov	QWORD PTR [rsp+56], rdi
	movsxd	rdi, DWORD PTR [rcx+1572]
	add	DWORD PTR [rcx+3592], edi
	movsxd	rdx, DWORD PTR [rcx+3592]
	mov	rcx, rdx
	mov	r9, rdx
	sub	rcx, rdi
	sub	eax, edx
	add	rcx, 792				; 00000318H
	movsxd	r8, eax
	add	r9, 792					; 00000318H
	add	r8, r8
	lea	rdx, QWORD PTR [rbx+rcx*2]
	lea	rcx, QWORD PTR [rbx+r9*2]
	call	memmove
	movsx	rcx, WORD PTR [rbx+3584]

; 1150 :          // adjust the position of all the other records to account for above memmove
; 1151 :          for (i=state->redo_point; i < k; ++i)

	cmp	rcx, rsi
	jge	SHORT $LN17@stb_texted

; 1146 :          int n = state->undo_rec[k].insert_length, i;

	mov	rax, rcx
	mov	edx, esi
	shl	rax, 4
	add	rax, 12
	add	rax, rbx
	sub	rdx, rcx
$LL4@stb_texted:

; 1152 :             if (state->undo_rec[i].char_storage >= 0)

	mov	ecx, DWORD PTR [rax]
	test	ecx, ecx
	js	SHORT $LN2@stb_texted

; 1153 :                state->undo_rec[i].char_storage += n;

	add	ecx, edi
	mov	DWORD PTR [rax], ecx
$LN2@stb_texted:

; 1150 :          // adjust the position of all the other records to account for above memmove
; 1151 :          for (i=state->redo_point; i < k; ++i)

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL4@stb_texted
$LN17@stb_texted:
	mov	rdi, QWORD PTR [rsp+56]
$LN3@stb_texted:

; 1154 :       }
; 1155 :       // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
; 1156 :       // [DEAR IMGUI]
; 1157 :       size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));

	movsx	rcx, WORD PTR [rbx+3584]

; 1158 :       const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
; 1159 :       const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
; 1160 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
; 1161 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
; 1162 :       STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

	mov	rdx, rcx
	sub	esi, ecx
	shl	rdx, 4
	add	rdx, rbx
	movsxd	r8, esi
	shl	r8, 4
	lea	rcx, QWORD PTR [rdx+16]
	call	memmove

; 1163 : 
; 1164 :       // now move redo_point to point to the new one
; 1165 :       ++state->redo_point;

	inc	WORD PTR [rbx+3584]
	mov	rsi, QWORD PTR [rsp+48]
$LN5@stb_texted:

; 1166 :    }
; 1167 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stb_textedit_discard_redo@ImStb@@YAXPEAUStbUndoState@1@@Z ENDP ; ImStb::stb_textedit_discard_redo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z
_TEXT	SEGMENT
state$ = 48
numchars$ = 56
?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z PROC ; ImStb::stb_text_create_undo_record, COMDAT

; 1170 : {

	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1171 :    // any time we create a new undo record, we discard redo
; 1172 :    stb_textedit_flush_redo(state);
; 1173 : 
; 1174 :    // if we have no free records, we have to make room, by sliding the
; 1175 :    // existing records down
; 1176 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	cmp	WORD PTR [rcx+3582], 99			; 00000063H
	mov	r14d, edx
	mov	rdi, rcx

; 1112 :    state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	WORD PTR [rcx+3584], 99			; 00000063H

; 1113 :    state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	DWORD PTR [rcx+3592], 999		; 000003e7H

; 1171 :    // any time we create a new undo record, we discard redo
; 1172 :    stb_textedit_flush_redo(state);
; 1173 : 
; 1174 :    // if we have no free records, we have to make room, by sliding the
; 1175 :    // existing records down
; 1176 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	jne	SHORT $LN4@stb_text_c

; 1177 :       stb_textedit_discard_undo(state);

	call	?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z ; ImStb::stb_textedit_discard_undo
$LN4@stb_text_c:
	mov	QWORD PTR [rsp+56], rbp

; 1178 : 
; 1179 :    // if the characters to store won't possibly fit in the buffer, we can't undo
; 1180 :    if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {

	cmp	r14d, 999				; 000003e7H
	jle	SHORT $LN17@stb_text_c

; 1181 :       state->undo_point = 0;

	xor	ebp, ebp
	mov	WORD PTR [rdi+3582], bp

; 1182 :       state->undo_char_point = 0;
; 1183 :       return NULL;

	xor	eax, eax
	mov	DWORD PTR [rdi+3588], ebp
	mov	rbp, QWORD PTR [rsp+56]

; 1191 : }

	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN17@stb_text_c:

; 1184 :    }
; 1185 : 
; 1186 :    // if we don't have enough free characters in the buffer, we have to make room
; 1187 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	mov	edx, DWORD PTR [rdi+3588]
	lea	eax, DWORD PTR [rdx+r14]
	cmp	eax, 999				; 000003e7H
	jle	$LN25@stb_text_c
	mov	QWORD PTR [rsp+48], rbx
	xor	ebp, ebp
	mov	QWORD PTR [rsp+64], rsi
$LL2@stb_text_c:

; 1119 :    if (state->undo_point > 0) {

	movzx	ecx, WORD PTR [rdi+3582]
	test	cx, cx
	jle	SHORT $LN13@stb_text_c

; 1120 :       // if the 0th undo state has characters, clean those up
; 1121 :       if (state->undo_rec[0].char_storage >= 0) {

	cmp	DWORD PTR [rdi+12], ebp
	lea	rbx, QWORD PTR [rdi+12]
	jl	SHORT $LN11@stb_text_c

; 1122 :          int n = state->undo_rec[0].insert_length, i;

	movsxd	rsi, DWORD PTR [rdi+4]

; 1123 :          // delete n characters from all other records
; 1124 :          state->undo_char_point -= n;
; 1125 :          STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));

	lea	rax, QWORD PTR [rdi+1584]
	sub	edx, esi
	lea	rcx, QWORD PTR [rdi+1584]
	movsxd	r8, edx
	mov	DWORD PTR [rdi+3588], edx
	add	r8, r8
	lea	rdx, QWORD PTR [rax+rsi*2]
	call	memmove

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movzx	ecx, WORD PTR [rdi+3582]
	mov	edx, ebp
	cmp	bp, cx
	jge	SHORT $LN11@stb_text_c
$LL12@stb_text_c:

; 1127 :             if (state->undo_rec[i].char_storage >= 0)

	mov	eax, DWORD PTR [rbx]
	test	eax, eax
	js	SHORT $LN10@stb_text_c

; 1128 :                state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it

	sub	eax, esi
	mov	DWORD PTR [rbx], eax
$LN10@stb_text_c:

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movsx	ecx, WORD PTR [rdi+3582]
	inc	edx
	add	rbx, 16
	cmp	edx, ecx
	jl	SHORT $LL12@stb_text_c
$LN11@stb_text_c:

; 1129 :       }
; 1130 :       --state->undo_point;

	dec	cx

; 1131 :       STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));

	lea	rdx, QWORD PTR [rdi+16]
	movsx	r8, cx
	mov	WORD PTR [rdi+3582], cx
	mov	rcx, rdi
	shl	r8, 4
	call	memmove
$LN13@stb_text_c:

; 1184 :    }
; 1185 : 
; 1186 :    // if we don't have enough free characters in the buffer, we have to make room
; 1187 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	mov	edx, DWORD PTR [rdi+3588]
	lea	eax, DWORD PTR [rdx+r14]
	cmp	eax, 999				; 000003e7H
	jg	$LL2@stb_text_c
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
$LN25@stb_text_c:

; 1188 :       stb_textedit_discard_undo(state);
; 1189 : 
; 1190 :    return &state->undo_rec[state->undo_point++];

	movsx	rcx, WORD PTR [rdi+3582]
	mov	rbp, QWORD PTR [rsp+56]
	lea	eax, DWORD PTR [rcx+1]
	mov	WORD PTR [rdi+3582], ax
	mov	rax, rcx
	shl	rax, 4
	add	rax, rdi

; 1191 : }

	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stb_text_create_undo_record@ImStb@@YAPEAUStbUndoRecord@1@PEAUStbUndoState@1@H@Z ENDP ; ImStb::stb_text_create_undo_record
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z
_TEXT	SEGMENT
state$ = 64
pos$ = 72
insert_len$ = 80
delete_len$ = 88
?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z PROC ; ImStb::stb_text_createundo, COMDAT

; 1194 : {

	mov	QWORD PTR [rsp+32], rbp
	push	rdi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H

; 1176 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	cmp	WORD PTR [rcx+3582], 99			; 00000063H

; 1194 : {

	mov	r15d, r9d
	mov	ebp, r8d

; 1112 :    state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	WORD PTR [rcx+3584], 99			; 00000063H

; 1194 : {

	mov	r12d, edx

; 1113 :    state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	DWORD PTR [rcx+3592], 999		; 000003e7H

; 1194 : {

	mov	rdi, rcx

; 1176 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	jne	SHORT $LN9@stb_text_c

; 1177 :       stb_textedit_discard_undo(state);

	call	?stb_textedit_discard_undo@ImStb@@YAXPEAUStbUndoState@1@@Z ; ImStb::stb_textedit_discard_undo
$LN9@stb_text_c:
	mov	QWORD PTR [rsp+80], r14

; 1178 : 
; 1179 :    // if the characters to store won't possibly fit in the buffer, we can't undo
; 1180 :    if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {

	cmp	ebp, 999				; 000003e7H
	jle	SHORT $LN22@stb_text_c

; 1181 :       state->undo_point = 0;

	xor	r14d, r14d
	mov	WORD PTR [rdi+3582], r14w

; 1210 :    }
; 1211 : }

	xor	eax, eax

; 1182 :       state->undo_char_point = 0;

	mov	DWORD PTR [rdi+3588], r14d

; 1210 :    }
; 1211 : }

	jmp	$LN4@stb_text_c
$LN22@stb_text_c:

; 1187 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	mov	edx, DWORD PTR [rdi+3588]
	lea	eax, DWORD PTR [rdx+rbp]
	cmp	eax, 999				; 000003e7H
	jle	$LN31@stb_text_c
	mov	QWORD PTR [rsp+64], rbx
	xor	r14d, r14d
	mov	QWORD PTR [rsp+72], rsi
	npad	13
$LL7@stb_text_c:

; 1119 :    if (state->undo_point > 0) {

	movzx	ecx, WORD PTR [rdi+3582]
	test	cx, cx
	jle	$LN18@stb_text_c

; 1120 :       // if the 0th undo state has characters, clean those up
; 1121 :       if (state->undo_rec[0].char_storage >= 0) {

	cmp	DWORD PTR [rdi+12], r14d
	lea	rbx, QWORD PTR [rdi+12]
	jl	SHORT $LN16@stb_text_c

; 1122 :          int n = state->undo_rec[0].insert_length, i;

	movsxd	rsi, DWORD PTR [rdi+4]

; 1123 :          // delete n characters from all other records
; 1124 :          state->undo_char_point -= n;
; 1125 :          STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));

	lea	rax, QWORD PTR [rdi+1584]
	sub	edx, esi
	lea	rcx, QWORD PTR [rdi+1584]
	movsxd	r8, edx
	mov	DWORD PTR [rdi+3588], edx
	add	r8, r8
	lea	rdx, QWORD PTR [rax+rsi*2]
	call	memmove

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movzx	ecx, WORD PTR [rdi+3582]
	mov	edx, r14d
	cmp	r14w, cx
	jge	SHORT $LN16@stb_text_c
$LL17@stb_text_c:

; 1127 :             if (state->undo_rec[i].char_storage >= 0)

	mov	eax, DWORD PTR [rbx]
	test	eax, eax
	js	SHORT $LN15@stb_text_c

; 1128 :                state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it

	sub	eax, esi
	mov	DWORD PTR [rbx], eax
$LN15@stb_text_c:

; 1126 :          for (i=0; i < state->undo_point; ++i)

	movsx	ecx, WORD PTR [rdi+3582]
	inc	edx
	add	rbx, 16
	cmp	edx, ecx
	jl	SHORT $LL17@stb_text_c
$LN16@stb_text_c:

; 1129 :       }
; 1130 :       --state->undo_point;

	dec	cx

; 1131 :       STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));

	lea	rdx, QWORD PTR [rdi+16]
	movsx	r8, cx
	mov	WORD PTR [rdi+3582], cx
	mov	rcx, rdi
	shl	r8, 4
	call	memmove
$LN18@stb_text_c:

; 1187 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	mov	edx, DWORD PTR [rdi+3588]
	lea	eax, DWORD PTR [rdx+rbp]
	cmp	eax, 999				; 000003e7H
	jg	$LL7@stb_text_c
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN31@stb_text_c:

; 1188 :       stb_textedit_discard_undo(state);
; 1189 : 
; 1190 :    return &state->undo_rec[state->undo_point++];

	movsx	rax, WORD PTR [rdi+3582]
	mov	rcx, rax
	inc	ax
	shl	rcx, 4
	mov	WORD PTR [rdi+3582], ax
	add	rcx, rdi

; 1195 :    StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
; 1196 :    if (r == NULL)

	je	SHORT $LN30@stb_text_c

; 1197 :       return NULL;
; 1198 : 
; 1199 :    r->where = pos;

	mov	DWORD PTR [rcx], r12d

; 1200 :    r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;

	mov	DWORD PTR [rcx+4], ebp

; 1201 :    r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

	mov	DWORD PTR [rcx+8], r15d

; 1202 : 
; 1203 :    if (insert_len == 0) {

	test	ebp, ebp
	jne	SHORT $LN3@stb_text_c

; 1204 :       r->char_storage = -1;

	mov	DWORD PTR [rcx+12], -1
$LN30@stb_text_c:

; 1210 :    }
; 1211 : }

	xor	eax, eax
	jmp	SHORT $LN4@stb_text_c
$LN3@stb_text_c:

; 1205 :       return NULL;
; 1206 :    } else {
; 1207 :       r->char_storage = state->undo_char_point;

	mov	eax, DWORD PTR [rdi+3588]
	mov	DWORD PTR [rcx+12], eax

; 1208 :       state->undo_char_point += insert_len;

	add	DWORD PTR [rdi+3588], ebp

; 1209 :       return &state->undo_char[r->char_storage];

	movsxd	rax, DWORD PTR [rcx+12]
	add	rax, 792				; 00000318H
	lea	rax, QWORD PTR [rdi+rax*2]
$LN4@stb_text_c:

; 1210 :    }
; 1211 : }

	mov	r14, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ENDP ; ImStb::stb_text_createundo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
u$5$ = 32
str$ = 80
state$ = 88
?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_text_undo, COMDAT

; 1214 : {

	push	rbx
	push	rbp
	sub	rsp, 56					; 00000038H

; 1215 :    StbUndoState *s = &state->undostate;
; 1216 :    StbUndoRecord u, *r;
; 1217 :    if (s->undo_point == 0)

	movsx	rax, WORD PTR [rdx+3614]
	mov	rbx, rdx
	mov	rbp, rcx
	test	ax, ax
	je	$LN1@stb_text_u

; 1218 :       return;
; 1219 : 
; 1220 :    // we need to do two things: apply the undo record, and create a redo record
; 1221 :    u = s->undo_rec[s->undo_point-1];
; 1222 :    r = &s->undo_rec[s->redo_point-1];

	movsx	rcx, WORD PTR [rdx+3616]
	add	rax, rax
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+96], r14
	mov	QWORD PTR [rsp+48], r15
	movups	xmm1, XMMWORD PTR [rdx+rax*8+16]
	shl	rcx, 4
	add	rcx, rdx
	mov	QWORD PTR [rsp+88], rdi

; 1223 :    r->char_storage = -1;
; 1224 : 
; 1225 :    r->insert_length = u.delete_length;
; 1226 :    r->delete_length = u.insert_length;

	movq	r15, xmm1
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	mov	rax, r15
	movd	esi, xmm0
	shr	rax, 32					; 00000020H
	movups	XMMWORD PTR u$5$[rsp], xmm1
	mov	DWORD PTR [rcx+28], -1
	mov	DWORD PTR [rcx+20], esi
	mov	DWORD PTR [rcx+24], eax

; 1227 :    r->where = u.where;

	mov	DWORD PTR [rcx+16], r15d

; 1228 : 
; 1229 :    if (u.delete_length) {

	test	esi, esi
	je	$LN39@stb_text_u

; 1230 :       // if the undo record says to delete characters, then the redo record will
; 1231 :       // need to re-insert the characters that get deleted, so we need to store
; 1232 :       // them.
; 1233 : 
; 1234 :       // there are three cases:
; 1235 :       //    there's enough room to store the characters
; 1236 :       //    characters stored for *redoing* don't leave room for redo
; 1237 :       //    characters stored for *undoing* don't leave room for redo
; 1238 :       // if the last is true, we have to bail
; 1239 : 
; 1240 :       if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {

	mov	r8d, DWORD PTR [rdx+3620]
	add	r8d, esi
	cmp	r8d, 999				; 000003e7H
	jl	SHORT $LN26@stb_text_u

; 1241 :          // the undo records take up too much character space; there's no space to store the redo characters
; 1242 :          r->insert_length = 0;

	xor	r8d, r8d
	mov	DWORD PTR [rcx+20], r8d

; 1243 :       } else {

	jmp	$LN5@stb_text_u
$LN26@stb_text_u:

; 1244 :          int i;
; 1245 : 
; 1246 :          // there's definitely room to store the characters eventually
; 1247 :          while (s->undo_char_point + u.delete_length > s->redo_char_point) {

	mov	edx, DWORD PTR [rdx+3624]
	cmp	r8d, edx
	jle	$LN35@stb_text_u
	npad	2
$LL2@stb_text_u:

; 1248 :             // should never happen:
; 1249 :             if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	movzx	eax, WORD PTR [rbx+3616]
	cmp	ax, 99					; 00000063H
	je	$LN57@stb_text_u

; 1143 :    if (state->redo_point <= k) {

	cmp	ax, 98					; 00000062H
	jg	$LN18@stb_text_u

; 1144 :       // if the k'th undo state has characters, clean those up
; 1145 :       if (state->undo_rec[k].char_storage >= 0) {

	cmp	DWORD PTR [rbx+1612], 0
	jl	$LN16@stb_text_u

; 1146 :          int n = state->undo_rec[k].insert_length, i;

	movsxd	rdi, DWORD PTR [rbx+1604]

; 1147 :          // move the remaining redo character data to the end of the buffer
; 1148 :          state->redo_char_point += n;
; 1149 :          STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));

	mov	eax, 999				; 000003e7H
	lea	ecx, DWORD PTR [rdx+rdi]
	movsxd	r9, ecx
	sub	eax, ecx
	mov	DWORD PTR [rbx+3624], ecx
	mov	rcx, r9
	sub	rcx, rdi
	movsxd	r8, eax
	add	rcx, 808				; 00000328H
	add	r9, 808					; 00000328H
	add	r8, r8
	lea	rdx, QWORD PTR [rbx+rcx*2]
	lea	rcx, QWORD PTR [rbx+r9*2]
	call	memmove
	movsx	r9, WORD PTR [rbx+3616]

; 1150 :          // adjust the position of all the other records to account for above memmove
; 1151 :          for (i=state->redo_point; i < k; ++i)

	cmp	r9, 98					; 00000062H
	jge	SHORT $LN16@stb_text_u
	lea	rcx, QWORD PTR [rbx+44]

; 1146 :          int n = state->undo_rec[k].insert_length, i;

	mov	rax, r9
	shl	rax, 4
	mov	r8, rbx
	add	rax, rcx
	sub	r8, rcx
	mov	edx, 98					; 00000062H
	sub	rdx, r9
$LL17@stb_text_u:

; 1152 :             if (state->undo_rec[i].char_storage >= 0)

	mov	ecx, DWORD PTR [rax]
	test	ecx, ecx
	js	SHORT $LN15@stb_text_u

; 1153 :                state->undo_rec[i].char_storage += n;

	add	ecx, edi
	mov	DWORD PTR [r8+rax+44], ecx
$LN15@stb_text_u:

; 1150 :          // adjust the position of all the other records to account for above memmove
; 1151 :          for (i=state->redo_point; i < k; ++i)

	add	rax, 16
	sub	rdx, 1
	jne	SHORT $LL17@stb_text_u
$LN16@stb_text_u:

; 1154 :       }
; 1155 :       // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
; 1156 :       // [DEAR IMGUI]
; 1157 :       size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));

	movsx	rcx, WORD PTR [rbx+3616]

; 1158 :       const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
; 1159 :       const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
; 1160 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
; 1161 :       IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
; 1162 :       STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

	mov	rdx, rcx
	mov	eax, ecx
	shl	rdx, 4
	mov	ecx, 98					; 00000062H
	sub	ecx, eax
	add	rdx, 32					; 00000020H
	movsxd	r8, ecx
	add	rdx, rbx
	shl	r8, 4
	lea	rcx, QWORD PTR [rdx+16]
	call	memmove

; 1163 : 
; 1164 :       // now move redo_point to point to the new one
; 1165 :       ++state->redo_point;

	inc	WORD PTR [rbx+3616]
$LN18@stb_text_u:

; 1244 :          int i;
; 1245 : 
; 1246 :          // there's definitely room to store the characters eventually
; 1247 :          while (s->undo_char_point + u.delete_length > s->redo_char_point) {

	mov	ecx, DWORD PTR [rbx+3620]
	mov	edx, DWORD PTR [rbx+3624]
	add	ecx, esi
	cmp	ecx, edx
	jg	$LL2@stb_text_u

; 1248 :             // should never happen:
; 1249 :             if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	movups	xmm1, XMMWORD PTR u$5$[rsp]
$LN35@stb_text_u:

; 1250 :                return;
; 1251 :             // there's currently not enough room, so discard a redo record
; 1252 :             stb_textedit_discard_redo(s);
; 1253 :          }
; 1254 :          r = &s->undo_rec[s->redo_point-1];

	movsx	r10, WORD PTR [rbx+3616]

; 1255 : 
; 1256 :          r->char_storage = s->redo_char_point - u.delete_length;

	sub	edx, esi
	add	r10, r10
	xor	r8d, r8d
	mov	DWORD PTR [rbx+r10*8+28], edx

; 1257 :          s->redo_char_point = s->redo_char_point - u.delete_length;

	sub	DWORD PTR [rbx+3624], esi

; 1258 : 
; 1259 :          // now save the characters
; 1260 :          for (i=0; i < u.delete_length; ++i)

	test	esi, esi
	jle	SHORT $LN5@stb_text_u

; 1250 :                return;
; 1251 :             // there's currently not enough room, so discard a redo record
; 1252 :             stb_textedit_discard_redo(s);
; 1253 :          }
; 1254 :          r = &s->undo_rec[s->redo_point-1];

	movsxd	r9, r15d
	add	r9, r9
$LL6@stb_text_u:

; 1261 :             s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);

	mov	eax, DWORD PTR [rbx+r10*8+28]
	lea	r9, QWORD PTR [r9+2]
	mov	rdx, QWORD PTR [rbp+32]
	add	eax, r8d
	movsxd	rcx, eax
	inc	r8d
	movzx	eax, WORD PTR [r9+rdx-2]
	mov	WORD PTR [rbx+rcx*2+1616], ax
	cmp	r8d, esi
	jl	SHORT $LL6@stb_text_u
$LN5@stb_text_u:

; 1262 :       }
; 1263 : 
; 1264 :       // now we can carry out the deletion
; 1265 :       STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);

	mov	r8d, esi
	mov	edx, r15d
	mov	rcx, rbp
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
$LN39@stb_text_u:

; 1266 :    }
; 1267 : 
; 1268 :    // check type of recorded action:
; 1269 :    if (u.insert_length) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	movd	edi, xmm0
	test	edi, edi
	je	SHORT $LN12@stb_text_u

; 1270 :       // easy case: was a deletion, so we need to insert n characters
; 1271 :       STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);

	psrldq	xmm1, 12
	mov	r9d, edi
	movd	eax, xmm1
	mov	edx, r15d
	movsxd	rcx, eax
	add	rcx, 808				; 00000328H
	lea	r8, QWORD PTR [rbx+rcx*2]
	mov	rcx, rbp
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS

; 1272 :       s->undo_char_point -= u.insert_length;

	sub	DWORD PTR [rbx+3620], edi
$LN12@stb_text_u:

; 1273 :    }
; 1274 : 
; 1275 :    state->cursor = u.where + u.insert_length;

	lea	eax, DWORD PTR [r15+rdi]
	mov	DWORD PTR [rbx], eax

; 1276 : 
; 1277 :    s->undo_point--;

	dec	WORD PTR [rbx+3614]

; 1278 :    s->redo_point--;

	dec	WORD PTR [rbx+3616]
$LN57@stb_text_u:
	mov	rdi, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+80]
	mov	r15, QWORD PTR [rsp+48]
$LN1@stb_text_u:

; 1279 : }

	add	rsp, 56					; 00000038H
	pop	rbp
	pop	rbx
	ret	0
?stb_text_undo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_text_undo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z
_TEXT	SEGMENT
str$ = 64
state$ = 72
?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z PROC ; ImStb::stb_text_redo, COMDAT

; 1282 : {

	push	rbx
	push	rsi
	push	r15
	sub	rsp, 32					; 00000020H

; 1283 :    StbUndoState *s = &state->undostate;

	lea	rbx, QWORD PTR [rdx+32]
	mov	r15, rdx

; 1284 :    StbUndoRecord *u, r;
; 1285 :    if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	movsx	rax, WORD PTR [rbx+3584]
	mov	rsi, rcx
	cmp	eax, 99					; 00000063H
	je	$LN1@stb_text_r

; 1286 :       return;
; 1287 : 
; 1288 :    // we need to do two things: apply the redo record, and create an undo record
; 1289 :    u = &s->undo_rec[s->undo_point];

	movsx	r8, WORD PTR [rbx+3582]

; 1290 :    r = s->undo_rec[s->redo_point];

	add	rax, rax
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rdi
	shl	r8, 4
	movups	xmm1, XMMWORD PTR [rbx+rax*8]
	add	r8, rbx
	mov	QWORD PTR [rsp+80], r14

; 1291 : 
; 1292 :    // we KNOW there must be room for the undo record, because the redo record
; 1293 :    // was derived from an undo record
; 1294 : 
; 1295 :    u->delete_length = r.insert_length;

	movq	r14, xmm1

; 1296 :    u->insert_length = r.delete_length;

	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	mov	rax, r14
	movd	edi, xmm0
	shr	rax, 32					; 00000020H
	mov	DWORD PTR [r8+8], eax
	mov	DWORD PTR [r8+4], edi

; 1297 :    u->where = r.where;

	mov	DWORD PTR [r8], r14d

; 1298 :    u->char_storage = -1;

	mov	DWORD PTR [r8+12], -1
	test	edi, edi

; 1299 : 
; 1300 :    if (r.delete_length) {

	je	SHORT $LN19@stb_text_r

; 1301 :       // the redo record requires us to delete characters, so the undo record
; 1302 :       // needs to store the characters
; 1303 : 
; 1304 :       if (s->undo_char_point + u->insert_length > s->redo_char_point) {

	mov	ecx, DWORD PTR [rbx+3588]
	lea	eax, DWORD PTR [rcx+rdi]
	cmp	eax, DWORD PTR [rbx+3592]
	jle	SHORT $LN7@stb_text_r

; 1305 :          u->insert_length = 0;

	xor	eax, eax
	mov	QWORD PTR [r8+4], rax

; 1306 :          u->delete_length = 0;
; 1307 :       } else {

	jmp	SHORT $LN3@stb_text_r
$LN7@stb_text_r:

; 1308 :          int i;
; 1309 :          u->char_storage = s->undo_char_point;

	mov	DWORD PTR [r8+12], ecx

; 1313 :          for (i=0; i < u->insert_length; ++i)

	xor	eax, eax
	add	DWORD PTR [rbx+3588], edi
	cmp	DWORD PTR [r8+4], eax
	jle	SHORT $LN3@stb_text_r
	npad	12
$LL4@stb_text_r:

; 1314 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	mov	ecx, DWORD PTR [r8]
	mov	edx, DWORD PTR [r8+12]
	add	ecx, eax
	mov	r10, QWORD PTR [rsi+32]
	add	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r11, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1313 :          for (i=0; i < u->insert_length; ++i)

	inc	eax

; 1314 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	movsxd	r9, edx
	movzx	ecx, WORD PTR [r10+r11*2]
	mov	WORD PTR [rbx+r9*2+1584], cx
	cmp	eax, DWORD PTR [r8+4]
	jl	SHORT $LL4@stb_text_r
$LN3@stb_text_r:

; 1315 :       }
; 1316 : 
; 1317 :       STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);

	mov	r8d, edi
	mov	edx, r14d
	mov	rcx, rsi
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS
$LN19@stb_text_r:

; 1318 :    }
; 1319 : 
; 1320 :    if (r.insert_length) {

	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	movd	edi, xmm0
	test	edi, edi
	je	SHORT $LN9@stb_text_r

; 1321 :       // easy case: need to insert n characters
; 1322 :       STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);

	psrldq	xmm1, 12
	mov	r9d, edi
	movd	eax, xmm1
	mov	edx, r14d
	movsxd	rcx, eax
	add	rcx, 792				; 00000318H
	lea	r8, QWORD PTR [rbx+rcx*2]
	mov	rcx, rsi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS

; 1323 :       s->redo_char_point += r.insert_length;

	add	DWORD PTR [rbx+3592], edi
$LN9@stb_text_r:

; 1324 :    }
; 1325 : 
; 1326 :    state->cursor = r.where + r.insert_length;
; 1327 : 
; 1328 :    s->undo_point++;
; 1329 :    s->redo_point++;

	mov	rbp, QWORD PTR [rsp+64]
	lea	eax, DWORD PTR [r14+rdi]
	mov	r14, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+72]
	mov	DWORD PTR [r15], eax
	inc	WORD PTR [rbx+3582]
	inc	WORD PTR [rbx+3584]
$LN1@stb_text_r:

; 1330 : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbx
	ret	0
?stb_text_redo@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ENDP ; ImStb::stb_text_redo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_insert@ImStb@@YAXPEAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
state$ = 8
where$ = 16
length$ = 24
?stb_text_makeundo_insert@ImStb@@YAXPEAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_text_makeundo_insert, COMDAT

; 1334 :    stb_text_createundo(&state->undostate, where, 0, length);

	mov	r9d, r8d
	add	rcx, 32					; 00000020H
	xor	r8d, r8d
	jmp	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
?stb_text_makeundo_insert@ImStb@@YAXPEAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_text_makeundo_insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
where$ = 64
length$ = 72
?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z PROC ; ImStb::stb_text_makeundo_delete, COMDAT

; 1338 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, r9d
	mov	rbx, rcx
	movsxd	rsi, r8d

; 1339 :    int i;
; 1340 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);

	lea	rcx, QWORD PTR [rdx+32]
	mov	r8d, edi
	mov	edx, esi
	xor	r9d, r9d
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 1341 :    if (p) {

	test	rax, rax
	je	SHORT $LN3@stb_text_m

; 1342 :       for (i=0; i < length; ++i)

	mov	r9, rdi
	test	edi, edi
	jle	SHORT $LN3@stb_text_m
	lea	r8, QWORD PTR [rsi+rsi]
	sub	r8, rax
	npad	4
$LL4@stb_text_m:

; 1343 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	mov	rcx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rdx, QWORD PTR [r8+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1342 :       for (i=0; i < length; ++i)

	lea	rax, QWORD PTR [rax+2]

; 1343 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	movzx	edx, WORD PTR [rdx+rcx]
	mov	WORD PTR [rax-2], dx
	sub	r9, 1
	jne	SHORT $LL4@stb_text_m
$LN3@stb_text_m:

; 1344 :    }
; 1345 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_text_makeundo_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ENDP ; ImStb::stb_text_makeundo_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
where$ = 64
old_length$ = 72
new_length$ = 80
?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z PROC ; ImStb::stb_text_makeundo_replace, COMDAT

; 1348 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, r9d
	mov	rbx, rcx

; 1349 :    int i;
; 1350 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	mov	r9d, DWORD PTR new_length$[rsp]
	lea	rcx, QWORD PTR [rdx+32]
	movsxd	rsi, r8d
	mov	r8d, edi
	mov	edx, esi
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 1351 :    if (p) {

	test	rax, rax
	je	SHORT $LN3@stb_text_m

; 1352 :       for (i=0; i < old_length; ++i)

	mov	r9, rdi
	test	edi, edi
	jle	SHORT $LN3@stb_text_m
	lea	r8, QWORD PTR [rsi+rsi]
	sub	r8, rax
	npad	2
$LL4@stb_text_m:

; 1353 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	mov	rcx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rdx, QWORD PTR [r8+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1352 :       for (i=0; i < old_length; ++i)

	lea	rax, QWORD PTR [rax+2]

; 1353 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	movzx	edx, WORD PTR [rdx+rcx]
	mov	WORD PTR [rax-2], dx
	sub	r9, 1
	jne	SHORT $LL4@stb_text_m
$LN3@stb_text_m:

; 1354 :    }
; 1355 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_text_makeundo_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HHH@Z ENDP ; ImStb::stb_text_makeundo_replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_clear_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
state$ = 8
is_single_line$ = 16
?stb_textedit_clear_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_clear_state, COMDAT

; 1360 :    state->undostate.undo_point = 0;

	xor	r8d, r8d
	mov	DWORD PTR [rcx+3614], 6488064		; 00630000H

; 1361 :    state->undostate.undo_char_point = 0;

	mov	DWORD PTR [rcx+3620], r8d

; 1362 :    state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
; 1363 :    state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
; 1364 :    state->select_end = state->select_start = 0;

	mov	QWORD PTR [rcx+4], r8

; 1365 :    state->cursor = 0;

	mov	DWORD PTR [rcx], r8d

; 1366 :    state->has_preferred_x = 0;
; 1367 :    state->preferred_x = 0;

	mov	DWORD PTR [rcx+28], r8d

; 1368 :    state->cursor_at_end_of_line = 0;

	mov	BYTE PTR [rcx+20], r8b

; 1369 :    state->initialized = 1;
; 1370 :    state->single_line = (unsigned char) is_single_line;
; 1371 :    state->insert_mode = 0;

	mov	BYTE PTR [rcx+12], r8b

; 1372 :    state->row_count_per_page = 0;

	mov	DWORD PTR [rcx+16], r8d
	mov	DWORD PTR [rcx+3624], 999		; 000003e7H
	mov	WORD PTR [rcx+21], 1
	mov	BYTE PTR [rcx+23], dl

; 1373 : }

	ret	0
?stb_textedit_clear_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_clear_state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_initialize_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z
_TEXT	SEGMENT
state$ = 8
is_single_line$ = 16
?stb_textedit_initialize_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z PROC ; ImStb::stb_textedit_initialize_state, COMDAT

; 1360 :    state->undostate.undo_point = 0;

	xor	r8d, r8d
	mov	DWORD PTR [rcx+3614], 6488064		; 00630000H

; 1361 :    state->undostate.undo_char_point = 0;

	mov	DWORD PTR [rcx+3620], r8d

; 1362 :    state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
; 1363 :    state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
; 1364 :    state->select_end = state->select_start = 0;

	mov	QWORD PTR [rcx+4], r8

; 1365 :    state->cursor = 0;

	mov	DWORD PTR [rcx], r8d

; 1366 :    state->has_preferred_x = 0;
; 1367 :    state->preferred_x = 0;

	mov	DWORD PTR [rcx+28], r8d

; 1368 :    state->cursor_at_end_of_line = 0;

	mov	BYTE PTR [rcx+20], r8b

; 1369 :    state->initialized = 1;
; 1370 :    state->single_line = (unsigned char) is_single_line;
; 1371 :    state->insert_mode = 0;

	mov	BYTE PTR [rcx+12], r8b

; 1372 :    state->row_count_per_page = 0;

	mov	DWORD PTR [rcx+16], r8d
	mov	DWORD PTR [rcx+3624], 999		; 000003e7H
	mov	WORD PTR [rcx+21], 1
	mov	BYTE PTR [rcx+23], dl

; 1378 :    stb_textedit_clear_state(state, is_single_line);
; 1379 : }

	ret	0
?stb_textedit_initialize_state@ImStb@@YAXPEAUSTB_TexteditState@1@H@Z ENDP ; ImStb::stb_textedit_initialize_state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
;	COMDAT ?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
ctext$ = 64
len$ = 72
?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z PROC ; ImStb::stb_textedit_paste, COMDAT

; 1387 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rcx+12]

; 1387 : {

	mov	rbx, rdx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	edx, DWORD PTR [rdx+4]

; 1387 : {

	mov	edi, r9d
	mov	rbp, r8
	mov	rsi, rcx

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r10d, DWORD PTR [rbx+8]
	cmp	edx, r10d
	je	SHORT $LN10@stb_texted

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	edx, eax
	jle	SHORT $LN8@stb_texted
	mov	DWORD PTR [rbx+4], eax
	mov	edx, eax
$LN8@stb_texted:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	r10d, eax
	jle	SHORT $LN9@stb_texted
	mov	DWORD PTR [rbx+8], eax
	mov	r10d, eax
$LN9@stb_texted:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	edx, r10d
	jne	SHORT $LN10@stb_texted

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rbx], edx
$LN10@stb_texted:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rbx], eax
	jle	SHORT $LN11@stb_texted
	mov	DWORD PTR [rbx], eax
$LN11@stb_texted:

; 703  :    stb_textedit_delete_selection(str,state);

	mov	rdx, rbx
	call	?stb_textedit_delete_selection@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@@Z ; ImStb::stb_textedit_delete_selection

; 704  :    // try to insert the characters
; 705  :    if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

	mov	edx, DWORD PTR [rbx]
	mov	r9d, edi
	mov	r8, rbp
	mov	rcx, rsi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN4@stb_texted

; 1334 :    stb_text_createundo(&state->undostate, where, 0, length);

	mov	edx, DWORD PTR [rbx]
	lea	rcx, QWORD PTR [rbx+32]
	mov	r9d, edi
	xor	r8d, r8d
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 707  :       state->cursor += len;

	add	DWORD PTR [rbx], edi

; 1388 :    return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);

	mov	eax, 1

; 708  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0

; 709  :       return 1;

	jmp	SHORT $LN3@stb_texted
$LN4@stb_texted:

; 1388 :    return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);

	xor	eax, eax
$LN3@stb_texted:

; 1389 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stb_textedit_paste@ImStb@@YAHPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z ENDP ; ImStb::stb_textedit_paste
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z
_TEXT	SEGMENT
str$ = 48
state$ = 56
text$ = 64
text_len$ = 72
?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z PROC ; ImStb::stb_textedit_replace, COMDAT

; 3862 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 3863 :     stb_text_makeundo_replace(str, state, 0, str->CurLenW, text_len);

	movsxd	rbp, DWORD PTR [rcx+12]
	mov	rsi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1350 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	lea	rcx, QWORD PTR [rdx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3862 : {

	mov	r14, r8
	mov	rbx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1350 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	mov	r8d, ebp
	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3862 : {

	mov	edi, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1350 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
	mov	r9, rax

; 1351 :    if (p) {

	test	rax, rax
	je	SHORT $LN7@stb_texted

; 1352 :       for (i=0; i < old_length; ++i)

	test	ebp, ebp
	jle	SHORT $LN7@stb_texted
	xor	ecx, ecx
	npad	10
$LL8@stb_texted:

; 1353 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	mov	rax, QWORD PTR [rsi+32]
	movzx	edx, WORD PTR [rax+rcx*2]
	mov	WORD PTR [r9+rcx*2], dx
	inc	rcx
	cmp	rcx, rbp
	jl	SHORT $LL8@stb_texted
$LN7@stb_texted:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3864 :     ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str->CurLenW);

	mov	r8d, DWORD PTR [rsi+12]
	xor	edx, edx
	mov	rcx, rsi
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS

; 3865 :     state->cursor = state->select_start = state->select_end = 0;

	mov	QWORD PTR [rbx+4], 0
	mov	DWORD PTR [rbx], 0

; 3866 :     if (text_len <= 0)

	test	edi, edi
	jle	SHORT $LN3@stb_texted

; 3867 :         return;
; 3868 :     if (ImStb::STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len))

	mov	r9d, edi
	mov	r8, r14
	xor	edx, edx
	mov	rcx, rsi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN3@stb_texted

; 3869 :     {
; 3870 :         state->cursor = state->select_start = state->select_end = text_len;

	mov	DWORD PTR [rbx+8], edi
	mov	DWORD PTR [rbx+4], edi
	mov	DWORD PTR [rbx], edi

; 3871 :         state->has_preferred_x = 0;

	mov	BYTE PTR [rbx+22], 0
$LN3@stb_texted:

; 3872 :         return;
; 3873 :     }
; 3874 :     IM_ASSERT(0); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
; 3875 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z ENDP ; ImStb::stb_textedit_replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
key$ = 56
?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z PROC	; ImGuiInputTextState::OnKeyPressed, COMDAT

; 3880 : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8d, edx
	mov	rbx, rcx

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rcx+84]
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rbx+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rbx+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3884 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z ENDP	; ImGuiInputTextState::OnKeyPressed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiInputTextCallbackData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiInputTextCallbackData@@QEAA@XZ PROC		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData, COMDAT

; 3887 : {

	xorps	xmm0, xmm0

; 3888 :     memset(this, 0, sizeof(*this));
; 3889 : }

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	ret	0
??0ImGuiInputTextCallbackData@@QEAA@XZ ENDP		; ImGuiInputTextCallbackData::ImGuiInputTextCallbackData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z
_TEXT	SEGMENT
callback_data$1 = 32
__$ArrayPad$ = 96
p_char$ = 144
flags$ = 152
callback$ = 160
user_data$ = 168
input_source$ = 176
?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z PROC ; InputTextFilterCharacter, COMDAT

; 3950 : {

	push	rbx
	push	rdi
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3951 :     IM_ASSERT(input_source == ImGuiInputSource_Keyboard || input_source == ImGuiInputSource_Clipboard);
; 3952 :     unsigned int c = *p_char;

	mov	r10d, DWORD PTR [rcx]
	mov	rdi, r8
	mov	rbx, rcx

; 3953 : 
; 3954 :     // Filter non-printable (NB: isprint is unreliable! see #2467)
; 3955 :     bool apply_named_filters = true;

	mov	r11b, 1

; 3956 :     if (c < 0x20)

	cmp	r10d, 32				; 00000020H
	jae	SHORT $LN2@InputTextF

; 3957 :     {
; 3958 :         bool pass = false;
; 3959 :         pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline)); // Note that an Enter KEY will emit \r and be ignored (we poll for KEY in InputText() code)

	cmp	r10d, 10
	jne	SHORT $LN30@InputTextF
	bt	edx, 26
	jae	SHORT $LN30@InputTextF
	movzx	eax, r11b
	jmp	SHORT $LN32@InputTextF
$LN30@InputTextF:
	xor	al, al

; 3960 :         pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));

	cmp	r10d, 9
	jne	SHORT $LN32@InputTextF
	bt	edx, 10
	jb	SHORT $LN3@InputTextF
$LN32@InputTextF:

; 3961 :         if (!pass)

	test	al, al
	je	$LN41@InputTextF
$LN3@InputTextF:

; 3962 :             return false;
; 3963 :         apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.

	xor	r11b, r11b
$LN2@InputTextF:

; 3964 :     }
; 3965 : 
; 3966 :     if (input_source != ImGuiInputSource_Clipboard)

	cmp	DWORD PTR input_source$[rsp], 4
	je	SHORT $LN6@InputTextF

; 3967 :     {
; 3968 :         // We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
; 3969 :         if (c == 127)

	cmp	r10d, 127				; 0000007fH
	je	$LN41@InputTextF
	lea	eax, DWORD PTR [r10-57344]
	cmp	eax, 6399				; 000018ffH
	jbe	$LN41@InputTextF
$LN6@InputTextF:

; 3970 :             return false;
; 3971 : 
; 3972 :         // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
; 3973 :         if (c >= 0xE000 && c <= 0xF8FF)
; 3974 :             return false;
; 3975 :     }
; 3976 : 
; 3977 :     // Filter Unicode ranges we are not handling in this build
; 3978 :     if (c > IM_UNICODE_CODEPOINT_MAX)

	cmp	r10d, 65535				; 0000ffffH
	ja	$LN41@InputTextF

; 3979 :         return false;
; 3980 : 
; 3981 :     // Generic named filters
; 3982 :     if (apply_named_filters && (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific)))

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	r11b, r11b
	je	$LN8@InputTextF
	test	edx, 131087				; 0002000fH
	je	$LN8@InputTextF

; 3983 :     {
; 3984 :         // The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, "de_DE.UTF-8");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.
; 3985 :         // The standard mandate that programs starts in the "C" locale where the decimal point is '.'.
; 3986 :         // We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.
; 3987 :         // Change the default decimal_point with:
; 3988 :         //   ImGui::GetCurrentContext()->PlatformLocaleDecimalPoint = *localeconv()->decimal_point;
; 3989 :         // Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.
; 3990 :         ImGuiContext& g = *GImGui;
; 3991 :         const unsigned c_decimal_point = (unsigned int)g.PlatformLocaleDecimalPoint;

	movsx	ecx, BYTE PTR [r8+24020]

; 3992 : 
; 3993 :         // Full-width -> half-width conversion for numeric fields (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)
; 3994 :         // While this is mostly convenient, this has the side-effect for uninformed users accidentally inputting full-width characters that they may
; 3995 :         // scratch their head as to why it works in numerical fields vs in generic text fields it would require support in the font.
; 3996 :         if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsScientific | ImGuiInputTextFlags_CharsHexadecimal))

	test	edx, 131075				; 00020003H
	je	SHORT $LN10@InputTextF

; 3997 :             if (c >= 0xFF01 && c <= 0xFF5E)

	lea	eax, DWORD PTR [r10-65281]
	cmp	eax, 93					; 0000005dH
	ja	SHORT $LN10@InputTextF

; 3998 :                 c = c - 0xFF01 + 0x21;

	add	r10d, -65248				; ffff0120H
$LN10@InputTextF:

; 3999 : 
; 4000 :         // Allow 0-9 . - + * /
; 4001 :         if (flags & ImGuiInputTextFlags_CharsDecimal)

	test	dl, 1
	je	SHORT $LN12@InputTextF

; 4002 :             if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/'))

	lea	eax, DWORD PTR [r10-48]
	cmp	eax, 9
	jbe	SHORT $LN12@InputTextF
	cmp	r10d, ecx
	je	SHORT $LN12@InputTextF
	cmp	r10d, 47				; 0000002fH
	ja	$LN41@InputTextF
	mov	r11, 189115999977472			; 0000ac0000000000H
	bt	r11, r10
	jae	$LN41@InputTextF
$LN12@InputTextF:

; 4003 :                 return false;
; 4004 : 
; 4005 :         // Allow 0-9 . - + * / e E
; 4006 :         if (flags & ImGuiInputTextFlags_CharsScientific)

	bt	edx, 17
	jae	SHORT $LN15@InputTextF

; 4007 :             if (!(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))

	lea	eax, DWORD PTR [r10-48]
	cmp	eax, 9
	jbe	SHORT $LN15@InputTextF
	cmp	r10d, ecx
	je	SHORT $LN15@InputTextF
	lea	eax, DWORD PTR [r10-42]
	cmp	eax, 59					; 0000003bH
	ja	$LN41@InputTextF
	mov	rcx, 576460752437641259			; 080000000800002bH
	bt	rcx, rax
	jae	$LN41@InputTextF
$LN15@InputTextF:

; 4008 :                 return false;
; 4009 : 
; 4010 :         // Allow 0-9 a-F A-F
; 4011 :         if (flags & ImGuiInputTextFlags_CharsHexadecimal)

	test	dl, 2
	je	SHORT $LN18@InputTextF

; 4012 :             if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))

	lea	eax, DWORD PTR [r10-48]
	cmp	eax, 54					; 00000036H
	ja	$LN41@InputTextF
	mov	rcx, 35465847073801215			; 007e0000007e03ffH
	bt	rcx, rax
	jae	$LN41@InputTextF
$LN18@InputTextF:

; 4013 :                 return false;
; 4014 : 
; 4015 :         // Turn a-z into A-Z
; 4016 :         if (flags & ImGuiInputTextFlags_CharsUppercase)

	test	dl, 4
	je	SHORT $LN23@InputTextF

; 4017 :             if (c >= 'a' && c <= 'z')

	lea	eax, DWORD PTR [r10-97]
	cmp	eax, 25
	ja	SHORT $LN23@InputTextF

; 4018 :                 c += (unsigned int)('A' - 'a');

	add	r10d, -32				; ffffffe0H
$LN23@InputTextF:

; 4019 : 
; 4020 :         if (flags & ImGuiInputTextFlags_CharsNoBlank)

	test	dl, 8
	je	SHORT $LN25@InputTextF
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 376  : static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	r10d, 32				; 00000020H
	je	SHORT $LN41@InputTextF
	cmp	r10d, 9
	je	SHORT $LN41@InputTextF
	cmp	r10d, 12288				; 00003000H
	je	SHORT $LN41@InputTextF
$LN25@InputTextF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4024 :         *p_char = c;

	mov	DWORD PTR [rbx], r10d
$LN8@InputTextF:

; 4025 :     }
; 4026 : 
; 4027 :     // Custom callback filter
; 4028 :     if (flags & ImGuiInputTextFlags_CallbackCharFilter)

	bt	edx, 9
	jae	SHORT $LN28@InputTextF

; 3888 :     memset(this, 0, sizeof(*this));

	xor	eax, eax

; 4029 :     {
; 4030 :         ImGuiContext& g = *GImGui;
; 4031 :         ImGuiInputTextCallbackData callback_data;
; 4032 :         callback_data.Ctx = &g;

	mov	QWORD PTR callback_data$1[rsp], r8

; 4037 :         if (callback(&callback_data) != 0)

	lea	rcx, QWORD PTR callback_data$1[rsp]

; 3888 :     memset(this, 0, sizeof(*this));

	mov	QWORD PTR callback_data$1[rsp+26], rax
	mov	QWORD PTR callback_data$1[rsp+34], rax
	mov	QWORD PTR callback_data$1[rsp+42], rax
	mov	QWORD PTR callback_data$1[rsp+50], rax
	mov	DWORD PTR callback_data$1[rsp+58], eax
	mov	WORD PTR callback_data$1[rsp+62], ax

; 4033 :         callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;

	mov	DWORD PTR callback_data$1[rsp+8], 512	; 00000200H

; 4034 :         callback_data.EventChar = (ImWchar)c;

	mov	WORD PTR callback_data$1[rsp+24], r10w

; 4035 :         callback_data.Flags = flags;

	mov	DWORD PTR callback_data$1[rsp+12], edx

; 4036 :         callback_data.UserData = user_data;

	mov	QWORD PTR callback_data$1[rsp+16], r9

; 4037 :         if (callback(&callback_data) != 0)

	call	rdi
	test	eax, eax
	jne	SHORT $LN41@InputTextF

; 4038 :             return false;
; 4039 :         *p_char = callback_data.EventChar;

	movzx	ecx, WORD PTR callback_data$1[rsp+24]

; 4040 :         if (!callback_data.EventChar)

	test	cx, cx
	mov	DWORD PTR [rbx], ecx
	setne	al
	jmp	SHORT $LN1@InputTextF
$LN28@InputTextF:

; 4042 :     }
; 4043 : 
; 4044 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@InputTextF
$LN41@InputTextF:

; 4041 :             return false;

	xor	al, al
$LN1@InputTextF:

; 4045 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rbx
	ret	0
?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z ENDP ; InputTextFilterCharacter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z
_TEXT	SEGMENT
tv681 = 112
state$ = 112
new_buf_a$ = 120
new_length_a$ = 128
?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z PROC ; InputTextReconcileUndoStateAfterUserCallback, COMDAT

; 4051 : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 4052 :     ImGuiContext& g = *GImGui;
; 4053 :     const ImWchar* old_buf = state->TextW.Data;

	mov	r15, QWORD PTR [rcx+32]
	mov	r9, rdx

; 4054 :     const int old_length = state->CurLenW;

	mov	r13d, DWORD PTR [rcx+12]
	mov	rbp, rcx
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4055 :     const int new_length = ImTextCountCharsFromUtf8(new_buf_a, new_buf_a + new_length_a);

	mov	rcx, r9
	movsxd	rax, r8d
	add	rax, rdx
	mov	rdx, rax
	mov	QWORD PTR tv681[rsp], rax
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	lea	r12, QWORD PTR [rbx+24716]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4055 :     const int new_length = ImTextCountCharsFromUtf8(new_buf_a, new_buf_a + new_length_a);

	mov	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	lea	rdi, QWORD PTR [rbx+24720]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4056 :     g.TempBuffer.reserve_discard((new_length + 1) * sizeof(ImWchar));

	lea	r14d, DWORD PTR [rax*2+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	cmp	r14d, DWORD PTR [r12]
	jle	SHORT $LN57@InputTextR
	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN26@InputTextR
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN24@InputTextR

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rbx+244]
$LN24@InputTextR:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN26@InputTextR:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN31@InputTextR

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rbx+244]
$LN31@InputTextR:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	movsxd	rcx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rdi], rax
	mov	DWORD PTR [r12], r14d
$LN57@InputTextR:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4057 :     ImWchar* new_buf = (ImWchar*)(void*)g.TempBuffer.Data;

	mov	r14, QWORD PTR [rdi]

; 4058 :     ImTextStrFromUtf8(new_buf, new_length + 1, new_buf_a, new_buf_a + new_length_a);

	lea	edx, DWORD PTR [rsi+1]
	mov	r9, QWORD PTR tv681[rsp]
	xor	ebx, ebx
	mov	r8, QWORD PTR new_buf_a$[rsp]
	mov	rcx, r14
	mov	QWORD PTR [rsp+32], rbx
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	r13d, esi
	mov	eax, esi
	cmovl	eax, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4062 :     for (first_diff = 0; first_diff < shorter_length; first_diff++)

	movsxd	r9, eax
	test	eax, eax
	jle	SHORT $LN58@InputTextR
	mov	r8, r14
	mov	edx, ebx
	sub	r8, r15
	mov	rcx, r15
	npad	9
$LL4@InputTextR:

; 4063 :         if (old_buf[first_diff] != new_buf[first_diff])

	movzx	eax, WORD PTR [r8+rcx]
	cmp	WORD PTR [rcx], ax
	jne	SHORT $LN58@InputTextR

; 4062 :     for (first_diff = 0; first_diff < shorter_length; first_diff++)

	inc	ebx
	inc	rdx
	add	rcx, 2
	cmp	rdx, r9
	jl	SHORT $LL4@InputTextR
$LN58@InputTextR:

; 4064 :             break;
; 4065 :     if (first_diff == old_length && first_diff == new_length)

	cmp	ebx, r13d
	jne	SHORT $LN12@InputTextR
	cmp	ebx, esi
	je	$LN9@InputTextR
$LN12@InputTextR:

; 4066 :         return;
; 4067 : 
; 4068 :     int old_last_diff = old_length - 1;

	lea	edi, DWORD PTR [r13-1]

; 4069 :     int new_last_diff = new_length - 1;

	lea	r9d, DWORD PTR [rsi-1]
	movsxd	rcx, edi
	movsxd	rsi, ebx

; 4070 :     for (; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff--, new_last_diff--)

	cmp	rcx, rsi
	jl	SHORT $LN59@InputTextR
	movsxd	rdx, r9d
	npad	5
$LL7@InputTextR:
	cmp	rdx, rsi
	jl	SHORT $LN59@InputTextR

; 4071 :         if (old_buf[old_last_diff] != new_buf[new_last_diff])

	movzx	eax, WORD PTR [r14+rdx*2]
	cmp	WORD PTR [r15+rcx*2], ax
	jne	SHORT $LN59@InputTextR

; 4070 :     for (; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff--, new_last_diff--)

	dec	edi
	dec	rcx
	dec	r9d
	dec	rdx
	cmp	rcx, rsi
	jge	SHORT $LL7@InputTextR
$LN59@InputTextR:

; 4072 :             break;
; 4073 : 
; 4074 :     const int insert_len = new_last_diff - first_diff + 1;

	sub	r9d, ebx

; 4075 :     const int delete_len = old_last_diff - first_diff + 1;

	sub	edi, ebx
	inc	r9d
	lea	r8d, DWORD PTR [rdi+1]

; 4076 :     if (insert_len > 0 || delete_len > 0)

	test	r9d, r9d
	jg	SHORT $LN15@InputTextR
	test	r8d, r8d
	jle	SHORT $LN9@InputTextR
$LN15@InputTextR:

; 4077 :         if (STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->Stb.undostate, first_diff, delete_len, insert_len))

	lea	rcx, QWORD PTR [rbp+116]
	mov	edx, ebx
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
	mov	rdx, rax
	test	rax, rax
	je	SHORT $LN9@InputTextR

; 4078 :             for (int i = 0; i < delete_len; i++)

	movsxd	r8, edi
	inc	r8
	test	r8, r8
	jle	SHORT $LN9@InputTextR
	add	rsi, rsi
	sub	rsi, rax
	npad	5
$LL10@InputTextR:

; 4079 :                 p[i] = ImStb::STB_TEXTEDIT_GETCHAR(state, first_diff + i);

	mov	rax, QWORD PTR [rbp+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rcx, QWORD PTR [rsi+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4078 :             for (int i = 0; i < delete_len; i++)

	lea	rdx, QWORD PTR [rdx+2]

; 4079 :                 p[i] = ImStb::STB_TEXTEDIT_GETCHAR(state, first_diff + i);

	movzx	ecx, WORD PTR [rcx+rax]
	mov	WORD PTR [rdx-2], cx
	sub	r8, 1
	jne	SHORT $LL10@InputTextR
$LN9@InputTextR:

; 4080 : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z ENDP ; InputTextReconcileUndoStateAfterUserCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z
_TEXT	SEGMENT
render_cursor$1$ = 80
user_scroll_active$1$ = 81
value_changed$1$ = 81
is_wordmove_key_down$1$ = 82
input_requested_by_nav$1$ = 82
tv11311 = 84
tv11299 = 84
clear_active_id$1$ = 88
validated$1$ = 89
init_state$1$ = 89
flags$1$ = 92
is_startend_key_down$1$ = 96
tv11239 = 100
tv11237 = 104
is_displaying_hint$1$ = 108
hovered$1$ = 109
is_paste$1$ = 109
id$1$ = 112
g$1$ = 120
is_cut$1$ = 128
revert_edit$1$ = 129
buf_display_from_state$1$ = 130
tv11229 = 132
tv10770 = 132
text_size$$sroa$6550$1$ = 136
buf_size$GSCopy$1$ = 136
text_size$$sroa$6551$1$ = 144
apply_new_text$1$ = 144
row_count_per_page$1$ = 144
c$18 = 144
c$19 = 144
c$20 = 144
c$21 = 144
$T22 = 152
is_osx$1$ = 156
is_undo$1$ = 157
is_copy$1$ = 158
state$1$ = 160
c$23 = 160
$T24 = 160
text_size$25 = 160
c$26 = 160
$T27 = 160
$T28 = 160
w_text$29 = 160
$T30 = 160
$T31 = 160
frame_size$ = 160
apply_new_text_length$1$ = 176
clipboard_filtered$1$ = 176
tv11232 = 176
tv10808 = 176
tv11234 = 184
text_remaining$1$ = 192
draw_window$1$ = 200
$T32 = 208
hint$GSCopy$1$ = 216
$T33 = 216
$T34 = 216
$T35 = 216
frame_bb$1$ = 224
callback_user_data$GSCopy$1$ = 232
callback$GSCopy$1$ = 240
bg_offy_up$1$ = 248
label_size$$sroa$6543$1$ = 252
window$1$ = 256
label$GSCopy$1$ = 264
r$36 = 272
r$37 = 272
callback_data$38 = 304
callback_data$39 = 368
clip_rect$40 = 432
c$41 = 432
c$42 = 432
clip_rect$43 = 432
c$44 = 432
cursor_screen_rect$45 = 432
rect$46 = 432
frame_bb$ = 432
draw_pos$ = 448
backup_current_text_length$1$ = 456
buf_end$47 = 456
buf_end$48 = 456
total_bb$ = 456
clip_rect$ = 472
item_data_backup$ = 488
__$ArrayPad$ = 552
label$ = 800
hint$ = 808
buf$ = 816
buf_size$ = 824
size_arg$ = 832
flags$ = 840
callback$ = 848
callback_user_data$ = 856
?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z PROC ; ImGui::InputTextEx, COMDAT

; 4114 : {

$LN1589:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-536]
	sub	rsp, 728				; 000002d8H
	movaps	XMMWORD PTR [rax-88], xmm6
	movaps	XMMWORD PTR [rax-104], xmm7
	movaps	XMMWORD PTR [rax-120], xmm8
	movaps	XMMWORD PTR [rax-136], xmm9
	movaps	XMMWORD PTR [rax-152], xmm10
	movaps	XMMWORD PTR [rax-168], xmm11
	movaps	XMMWORD PTR [rax-184], xmm12
	movaps	XMMWORD PTR [rax-200], xmm13
	movaps	XMMWORD PTR [rax-216], xmm14
	movaps	XMMWORD PTR [rax-232], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	DWORD PTR buf_size$GSCopy$1$[rbp-256], r9d
	mov	QWORD PTR text_remaining$1$[rbp-256], r8
	mov	QWORD PTR hint$GSCopy$1$[rbp-256], rdx
	mov	r12, rcx
	mov	QWORD PTR label$GSCopy$1$[rbp-256], rcx
	mov	rax, QWORD PTR callback$[rbp-256]
	mov	QWORD PTR callback$GSCopy$1$[rbp-256], rax
	mov	rax, QWORD PTR callback_user_data$[rbp-256]
	mov	QWORD PTR callback_user_data$GSCopy$1$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r14, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR g$1$[rsp], r14
	mov	rax, QWORD PTR [r14+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r13, QWORD PTR [r14+16408]
	mov	QWORD PTR window$1$[rbp-256], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4116 :     if (window->SkipItems)

	cmp	BYTE PTR [r13+240], 0
	jne	$LN1465@InputTextE

; 4117 :         return false;
; 4118 : 
; 4119 :     IM_ASSERT(buf != NULL && buf_size >= 0);
; 4120 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
; 4121 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)
; 4122 : 
; 4123 :     ImGuiContext& g = *GImGui;
; 4124 :     ImGuiIO& io = g.IO;
; 4125 :     const ImGuiStyle& style = g.Style;
; 4126 : 
; 4127 :     const bool RENDER_SELECTION_WHEN_INACTIVE = false;
; 4128 :     const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;

	mov	esi, DWORD PTR flags$[rbp-256]
	mov	DWORD PTR flags$1$[rsp], esi
	mov	ebx, esi
	shr	ebx, 26
	and	bl, 1
	mov	DWORD PTR tv11239[rsp], ebx

; 4129 :     const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;

	mov	eax, esi
	shr	eax, 14
	and	al, 1
	mov	DWORD PTR tv11237[rsp], eax

; 4130 :     const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;

	mov	eax, esi
	shr	eax, 15
	and	al, 1
	mov	DWORD PTR tv11234[rbp-256], eax

; 4131 :     const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;

	mov	eax, esi
	shr	eax, 16
	not	al
	and	al, 1
	mov	DWORD PTR tv11232[rbp-256], eax

; 4132 :     const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;

	mov	eax, esi
	shr	eax, 18
	and	al, 1
	mov	DWORD PTR tv11229[rbp-256], eax

; 4133 :     if (is_resizable)
; 4134 :         IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!
; 4135 : 
; 4136 :     if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope (including the scrollbar)

	test	bl, bl
	je	SHORT $LN18@InputTextE

; 4137 :         BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
$LN18@InputTextE:

; 4138 :     const ImGuiID id = window->GetID(label);

	mov	rdx, r12
	mov	rcx, r13
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
	mov	edi, eax
	mov	DWORD PTR id$1$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3327 :     const char* text_display_end = text;

	mov	rdx, r12

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r12, -1
	jae	SHORT $LN614@InputTextE
	npad	6
$LL613@InputTextE:
	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	je	SHORT $LN614@InputTextE
	lea	rcx, QWORD PTR [rdx+1]
	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN1436@InputTextE
	cmp	BYTE PTR [rcx], r8b
	je	SHORT $LN614@InputTextE
$LN1436@InputTextE:

; 3332 :         text_display_end++;

	mov	rdx, rcx

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rcx, -1
	jb	SHORT $LL613@InputTextE
$LN614@InputTextE:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm0, DWORD PTR [r9+15696]

; 5418 :     if (text == text_display_end)

	xor	eax, eax
	movss	xmm1, DWORD PTR __real@bf800000
	movss	DWORD PTR bg_offy_up$1$[rbp-256], xmm1
	movss	xmm9, DWORD PTR __real@7f7fffff
	xorps	xmm7, xmm7
	cmp	r12, rdx
	jne	SHORT $LN610@InputTextE
	xorps	xmm8, xmm8

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN1556@InputTextE
$LN610@InputTextE:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], r12
	movss	DWORD PTR [rsp+32], xmm1
	movaps	xmm3, xmm9
	movaps	xmm2, xmm0
	lea	rdx, QWORD PTR text_size$25[rbp-256]
	mov	rcx, QWORD PTR [r9+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$25[rbp-256]
	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm8, eax
	cvtdq2ps xmm8, xmm8

; 5428 : 
; 5429 :     return text_size;

	movss	xmm0, DWORD PTR text_size$25[rbp-252]
$LN1556@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4140 :     const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line

	movss	DWORD PTR label_size$$sroa$6543$1$[rbp-256], xmm8
	test	bl, bl
	je	SHORT $LN233@InputTextE
	movss	xmm0, DWORD PTR [r14+15696]
	mulss	xmm0, DWORD PTR __real@41000000
$LN233@InputTextE:
	movss	xmm6, DWORD PTR [r14+14616]
	movaps	xmm3, xmm6
	addss	xmm3, xmm6
	addss	xmm3, xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	movaps	xmm2, xmm0
	mov	rdx, QWORD PTR size_arg$[rbp-256]
	mov	rdx, QWORD PTR [rdx]
	lea	rcx, QWORD PTR frame_size$[rbp-256]
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize

; 4141 :     const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);

	comiss	xmm8, xmm7
	jbe	SHORT $LN234@InputTextE
	movaps	xmm1, xmm8
	addss	xmm1, DWORD PTR [r14+14636]
	jmp	SHORT $LN235@InputTextE
$LN234@InputTextE:
	xorps	xmm1, xmm1
$LN235@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm12, DWORD PTR [r13+316]
	movss	DWORD PTR $T22[rbp-256], xmm12
	movaps	xmm0, xmm12
	movss	xmm11, DWORD PTR frame_size$[rbp-252]
	addss	xmm0, xmm11
	movss	xmm8, DWORD PTR [r13+312]
	movss	DWORD PTR frame_bb$1$[rbp-256], xmm8
	movaps	xmm13, xmm8
	movss	xmm10, DWORD PTR frame_size$[rbp-256]
	addss	xmm13, xmm10
	movss	DWORD PTR $T32[rbp-256], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR frame_bb$[rbp-256], xmm8
	movss	DWORD PTR frame_bb$[rbp-252], xmm12
	movss	DWORD PTR frame_bb$[rbp-248], xmm13
	movss	DWORD PTR frame_bb$[rbp-244], xmm0
	movaps	xmm2, xmm12
	addss	xmm2, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4141 :     const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);

	addss	xmm1, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR total_bb$[rbp-256], xmm8
	movss	DWORD PTR total_bb$[rbp-252], xmm12
	movss	DWORD PTR total_bb$[rbp-248], xmm1
	movss	DWORD PTR total_bb$[rbp-244], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4146 :     ImGuiWindow* draw_window = window;

	mov	QWORD PTR draw_window$1$[rbp-256], r13
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1220 :     ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }

	movups	XMMWORD PTR item_data_backup$[rbp-256], xmm0
	subss	xmm2, xmm12
	subss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4150 :     if (is_multiline)

	movss	DWORD PTR $T24[rbp-256], xmm1
	movss	DWORD PTR $T24[rbp-252], xmm2
	lea	rcx, QWORD PTR $T24[rbp-256]
	movaps	xmm1, xmm6
	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	test	bl, bl
	je	$LN19@InputTextE

; 4151 :     {
; 4152 :         ImVec2 backup_pos = window->DC.CursorPos;
; 4153 :         ItemSize(total_bb, style.FramePadding.y);
; 4154 :         if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))

	mov	r9d, 1024				; 00000400H
	lea	r8, QWORD PTR frame_bb$[rbp-256]
	mov	edx, edi
	lea	rcx, QWORD PTR total_bb$[rbp-256]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN1583@InputTextE

; 4155 :         {
; 4156 :             EndGroup();
; 4157 :             return false;
; 4158 :         }
; 4159 :         item_status_flags = g.LastItemData.StatusFlags;

	mov	r15d, DWORD PTR [r14+18624]

; 4160 :         item_data_backup = g.LastItemData;

	movups	xmm0, XMMWORD PTR [r14+18616]
	movups	XMMWORD PTR item_data_backup$[rbp-256], xmm0

; 4161 :         window->DC.CursorPos = backup_pos;

	movss	DWORD PTR [r13+312], xmm8
	movss	DWORD PTR [r13+316], xmm12

; 4162 : 
; 4163 :         // We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
; 4164 :         // FIXME-NAV: Pressing NavActivate will trigger general child activation right before triggering our own below. Harmless but bizarre.
; 4165 :         PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);

	lea	rdx, QWORD PTR [r14+14888]
	mov	ecx, 3
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 4166 :         PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);

	movss	xmm1, DWORD PTR [r14+14620]
	mov	ecx, 7
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 4167 :         PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);

	movss	xmm1, DWORD PTR [r14+14624]
	mov	ecx, 8
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T31[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4168 :         PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0)); // Ensure no clip rect so mouse hover can reach FramePadding edges

	lea	rdx, QWORD PTR $T31[rbp-256]
	mov	ecx, 2
	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movss	xmm1, DWORD PTR frame_bb$[rbp-244]
	movss	xmm12, DWORD PTR frame_bb$[rbp-252]
	movss	DWORD PTR $T22[rbp-256], xmm12
	subss	xmm1, xmm12
	movss	xmm13, DWORD PTR frame_bb$[rbp-248]
	movss	DWORD PTR $T32[rbp-256], xmm13
	movaps	xmm0, xmm13
	movss	xmm8, DWORD PTR frame_bb$[rbp-256]
	movss	DWORD PTR frame_bb$1$[rbp-256], xmm8
	subss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T30[rbp-256], xmm0
	movss	DWORD PTR $T30[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4169 :         bool child_visible = BeginChildEx(label, id, frame_bb.GetSize(), true, ImGuiWindowFlags_NoMove);

	mov	DWORD PTR [rsp+32], 4
	mov	r9b, 1
	lea	r8, QWORD PTR $T30[rbp-256]
	mov	edx, edi
	mov	rcx, r12
	call	?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z ; ImGui::BeginChildEx
	movzx	ebx, al

; 4170 :         PopStyleVar(3);

	mov	ecx, 3
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 4171 :         PopStyleColor();

	mov	r12d, 1
	mov	ecx, r12d
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor

; 4172 :         if (!child_visible)

	test	bl, bl
	jne	SHORT $LN22@InputTextE

; 4173 :         {
; 4174 :             EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild
$LN1583@InputTextE:

; 5050 :         return validated;
; 5051 :     else
; 5052 :         return value_changed;
; 5053 : }

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
$LN1465@InputTextE:
	xor	al, al
$LN230@InputTextE:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+728]
	movaps	xmm6, XMMWORD PTR [r11-24]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [r11-72]
	movaps	xmm10, XMMWORD PTR [r11-88]
	movaps	xmm11, XMMWORD PTR [r11-104]
	movaps	xmm12, XMMWORD PTR [r11-120]
	movaps	xmm13, XMMWORD PTR [r11-136]
	movaps	xmm14, XMMWORD PTR [r11-152]
	movaps	xmm15, XMMWORD PTR [r11-168]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN22@InputTextE:

; 4175 :             EndGroup();
; 4176 :             return false;
; 4177 :         }
; 4178 :         draw_window = g.CurrentWindow; // Child window

	mov	rsi, QWORD PTR [r14+16408]
	mov	QWORD PTR draw_window$1$[rbp-256], rsi

; 4179 :         draw_window->DC.NavLayersActiveMaskNext |= (1 << draw_window->DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.

	movsx	ecx, WORD PTR [rsi+406]
	mov	eax, DWORD PTR [rsi+400]
	bts	ecx, eax
	mov	WORD PTR [rsi+406], cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2545 : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [r14+14612]
	addss	xmm0, DWORD PTR [rsi+312]
	movss	DWORD PTR [rsi+312], xmm0
	movss	xmm1, DWORD PTR [r14+14616]
	addss	xmm1, DWORD PTR [rsi+316]
	movss	DWORD PTR [rsi+316], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4181 :         inner_size.x -= draw_window->ScrollbarSizes.x;

	subss	xmm10, DWORD PTR [rsi+224]

; 4182 :     }

	mov	ebx, DWORD PTR tv11239[rsp]
	jmp	SHORT $LN20@InputTextE
$LN19@InputTextE:

; 4183 :     else
; 4184 :     {
; 4185 :         // Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)
; 4186 :         ItemSize(total_bb, style.FramePadding.y);
; 4187 :         if (!(flags & ImGuiInputTextFlags_MergedItem))

	bt	esi, 28
	jb	SHORT $LN24@InputTextE

; 4188 :             if (!ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_Inputable))

	mov	r9d, 1024				; 00000400H
	lea	r8, QWORD PTR frame_bb$[rbp-256]
	mov	edx, edi
	lea	rcx, QWORD PTR total_bb$[rbp-256]
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN1465@InputTextE
	movss	xmm13, DWORD PTR frame_bb$[rbp-248]
	movss	DWORD PTR $T32[rbp-256], xmm13
	movss	xmm12, DWORD PTR frame_bb$[rbp-252]
	movss	DWORD PTR $T22[rbp-256], xmm12
	movss	xmm8, DWORD PTR frame_bb$[rbp-256]
	movss	DWORD PTR frame_bb$1$[rbp-256], xmm8
$LN24@InputTextE:

; 4189 :                 return false;
; 4190 :         item_status_flags = g.LastItemData.StatusFlags;

	mov	r15d, DWORD PTR [r14+18624]
	mov	r12d, 1
$LN20@InputTextE:

; 4191 :     }
; 4192 :     const bool hovered = ItemHoverable(frame_bb, id, g.LastItemData.InFlags);

	mov	r8d, DWORD PTR [r14+18620]
	mov	edx, edi
	lea	rcx, QWORD PTR frame_bb$[rbp-256]
	call	?ItemHoverable@ImGui@@YA_NAEBUImRect@@IH@Z ; ImGui::ItemHoverable
	movzx	ecx, al
	mov	BYTE PTR hovered$1$[rsp], al

; 4193 :     if (hovered)

	test	al, al
	je	SHORT $LN25@InputTextE

; 4194 :         g.MouseCursor = ImGuiMouseCursor_TextInput;

	mov	DWORD PTR [r14+19936], r12d
$LN25@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3526 :     inline ImGuiInputTextState* GetInputTextState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL; } // Get input text state if active

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	edi, edi
	je	SHORT $LN670@InputTextE
	cmp	DWORD PTR [rsi+19960], edi
	jne	SHORT $LN670@InputTextE
	add	rsi, 19952				; 00004df0H
	jmp	SHORT $LN1557@InputTextE
$LN670@InputTextE:
	xor	esi, esi
$LN1557@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4199 :     const bool input_requested_by_tabbing = (item_status_flags & ImGuiItemStatusFlags_FocusedByTabbing) != 0;

	mov	QWORD PTR state$1$[rbp-256], rsi
	shr	r15d, 8
	and	r15b, 1

; 4200 :     const bool input_requested_by_nav = (g.ActiveId != id) && ((g.NavActivateId == id) && ((g.NavActivateFlags & ImGuiActivateFlags_PreferInput) || (g.NavInputSource == ImGuiInputSource_Keyboard)));

	mov	eax, DWORD PTR [r14+16504]
	cmp	eax, edi
	je	SHORT $LN237@InputTextE
	cmp	DWORD PTR [r14+19112], edi
	jne	SHORT $LN237@InputTextE
	test	BYTE PTR [r14+19124], 1
	jne	SHORT $LN236@InputTextE
	cmp	DWORD PTR [r14+19148], 2
	jne	SHORT $LN237@InputTextE
$LN236@InputTextE:
	mov	r13b, 1
	jmp	SHORT $LN1558@InputTextE
$LN237@InputTextE:
	xor	r13b, r13b
$LN1558@InputTextE:

; 4201 : 
; 4202 :     const bool user_clicked = hovered && io.MouseClicked[0];

	mov	BYTE PTR input_requested_by_nav$1$[rsp], r13b
	test	cl, cl
	je	SHORT $LN239@InputTextE
	cmp	BYTE PTR [r14+14160], 0
	je	SHORT $LN239@InputTextE
	mov	r12b, 1
	jmp	SHORT $LN240@InputTextE
$LN239@InputTextE:
	xor	r12b, r12b
$LN240@InputTextE:

; 4203 :     const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

	test	bl, bl
	je	SHORT $LN241@InputTextE
	test	rsi, rsi
	je	SHORT $LN241@InputTextE
	test	eax, eax
	jne	SHORT $LN241@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rdi, QWORD PTR draw_window$1$[rbp-256]
	movsxd	r8, DWORD PTR [rdi+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3852 :     ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR [rdi+304]

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	r8d, DWORD PTR [rax+r8*4-4]
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	ebx, eax

; 3854 :     ImGuiContext& g = *Ctx;

	mov	rcx, QWORD PTR [rdi]

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rcx+16480], eax
	jne	SHORT $LN937@InputTextE

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	mov	edx, 11
	mov	ecx, eax
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN937@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4203 :     const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

	cmp	DWORD PTR [r14+16552], ebx
	jne	SHORT $LN1541@InputTextE
	mov	dil, 1
	jmp	SHORT $LN1464@InputTextE
$LN1541@InputTextE:
	mov	ebx, DWORD PTR tv11239[rsp]
$LN241@InputTextE:
	xor	dil, dil

; 4204 :     const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

	test	bl, bl
	je	SHORT $LN243@InputTextE
	test	rsi, rsi
	je	SHORT $LN243@InputTextE
$LN1464@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	movsxd	r8, DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3852 :     ImGuiID seed = IDStack.back();

	mov	rax, QWORD PTR [rax+304]

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	r8d, DWORD PTR [rax+r8*4-4]
	xor	edx, edx
	lea	rcx, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr
	mov	ebx, eax

; 3854 :     ImGuiContext& g = *Ctx;

	mov	rcx, QWORD PTR draw_window$1$[rbp-256]
	mov	rcx, QWORD PTR [rcx]

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rcx+16480], eax
	jne	SHORT $LN868@InputTextE

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_08FEBONNKO@?$CDSCROLLY@
	mov	edx, 11
	mov	ecx, eax
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN868@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4204 :     const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);

	cmp	DWORD PTR [r14+16504], ebx
	jne	SHORT $LN243@InputTextE
	mov	bl, 1
	mov	BYTE PTR user_scroll_active$1$[rsp], bl
	mov	BYTE PTR clear_active_id$1$[rsp], 0
	mov	BYTE PTR tv11299[rsp], 0
	mov	edx, DWORD PTR tv11239[rsp]

; 4207 : 
; 4208 :     float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;

	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	movss	xmm9, DWORD PTR [rax+188]
	jmp	SHORT $LN246@InputTextE
$LN243@InputTextE:

; 4205 :     bool clear_active_id = false;

	mov	BYTE PTR clear_active_id$1$[rsp], 0

; 4206 :     bool select_all = false;

	mov	BYTE PTR tv11299[rsp], 0
	xor	bl, bl
	mov	BYTE PTR user_scroll_active$1$[rsp], bl

; 4207 : 
; 4208 :     float scroll_y = is_multiline ? draw_window->Scroll.y : FLT_MAX;

	mov	edx, DWORD PTR tv11239[rsp]
	test	dl, dl
	je	SHORT $LN245@InputTextE
	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	movss	xmm9, DWORD PTR [rax+188]
	jmp	SHORT $LN246@InputTextE
$LN245@InputTextE:
	mov	BYTE PTR user_scroll_active$1$[rsp], bl
$LN246@InputTextE:

; 4209 : 
; 4210 :     const bool init_changed_specs = (state != NULL && state->Stb.single_line != !is_multiline); // state != NULL means its our state.

	test	rsi, rsi
	je	SHORT $LN247@InputTextE
	movzx	eax, dl
	xor	al, 1
	cmp	BYTE PTR [rsi+107], al
	je	SHORT $LN247@InputTextE
	mov	r14b, 1
	jmp	SHORT $LN248@InputTextE
$LN247@InputTextE:
	xor	r14b, r14b
$LN248@InputTextE:

; 4211 :     const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav || input_requested_by_tabbing);

	test	r12b, r12b
	jne	SHORT $LN249@InputTextE
	test	dil, dil
	jne	SHORT $LN249@InputTextE
	test	r13b, r13b
	jne	SHORT $LN249@InputTextE
	test	r15b, r15b
	jne	SHORT $LN249@InputTextE

; 4212 :     const bool init_state = (init_make_active || user_scroll_active);

	test	bl, bl
	jne	SHORT $LN251@InputTextE
	mov	BYTE PTR init_state$1$[rsp], r13b
	mov	rax, QWORD PTR g$1$[rsp]
	jmp	SHORT $LN1386@InputTextE
$LN249@InputTextE:

; 4211 :     const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav || input_requested_by_tabbing);

	mov	r13b, 1
$LN251@InputTextE:

; 4212 :     const bool init_state = (init_make_active || user_scroll_active);

	mov	BYTE PTR init_state$1$[rsp], 1

; 4213 :     if ((init_state && g.ActiveId != id) || init_changed_specs)

	mov	rax, QWORD PTR g$1$[rsp]
	mov	ecx, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [rax+16504], ecx
	jne	SHORT $LN27@InputTextE
$LN1386@InputTextE:
	test	r14b, r14b
	je	$LN1481@InputTextE
$LN27@InputTextE:

; 4214 :     {
; 4215 :         // Access state even if we don't own it yet.
; 4216 :         state = &g.InputTextState;

	lea	rsi, QWORD PTR [rax+19952]
	mov	QWORD PTR state$1$[rbp-256], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4220 :         InputTextDeactivateHook(state->ID);

	mov	ecx, DWORD PTR [rsi+8]
	call	?InputTextDeactivateHook@ImGui@@YAXI@Z	; ImGui::InputTextDeactivateHook

; 4221 : 
; 4222 :         // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
; 4223 :         // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
; 4224 :         const int buf_len = (int)strlen(buf);

	mov	rdi, -1
	mov	r8, QWORD PTR text_remaining$1$[rbp-256]
	npad	1
$LL1480@InputTextE:
	inc	rdi
	cmp	BYTE PTR [r8+rdi], 0
	jne	SHORT $LL1480@InputTextE

; 4225 :         state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.

	lea	rcx, QWORD PTR [rsi+56]
	lea	ebx, DWORD PTR [rdi+1]
	mov	edx, ebx
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 4226 :         memcpy(state->InitialTextA.Data, buf, buf_len + 1);

	movsxd	r8, ebx
	mov	rbx, QWORD PTR text_remaining$1$[rbp-256]
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rsi+64]
	call	memcpy

; 4227 : 
; 4228 :         // Preserve cursor position and undo/redo stack if we come back to same widget
; 4229 :         // FIXME: Since we reworked this on 2022/06, may want to differenciate recycle_cursor vs recycle_undostate?
; 4230 :         bool recycle_state = (state->ID == id && !init_changed_specs);

	mov	eax, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [rsi+8], eax
	jne	SHORT $LN253@InputTextE
	test	r14b, r14b
	jne	SHORT $LN253@InputTextE
	mov	r14b, 1

; 4231 :         if (recycle_state && (state->CurLenA != buf_len || (state->TextAIsValid && strncmp(state->TextA.Data, buf, buf_len) != 0)))

	cmp	DWORD PTR [rsi+16], edi
	jne	SHORT $LN253@InputTextE
	cmp	BYTE PTR [rsi+72], 0
	je	SHORT $LN29@InputTextE
	movsxd	r8, edi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rsi+48]
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN29@InputTextE
$LN253@InputTextE:

; 4232 :             recycle_state = false;
; 4233 : 
; 4234 :         // Start edition
; 4235 :         const char* buf_end = NULL;

	xor	r14b, r14b
$LN29@InputTextE:
	mov	QWORD PTR buf_end$48[rbp-256], 0

; 4236 :         state->ID = id;

	mov	eax, DWORD PTR id$1$[rsp]
	mov	DWORD PTR [rsi+8], eax

; 4237 :         state->TextW.resize(buf_size + 1);          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.

	lea	rcx, QWORD PTR [rsi+24]
	mov	edi, DWORD PTR buf_size$GSCopy$1$[rbp-256]
	lea	edx, DWORD PTR [rdi+1]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rsi+44]
	test	ecx, ecx
	jns	SHORT $LN683@InputTextE

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	xor	edx, edx
	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rsi+40]
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN683@InputTextE:
	mov	DWORD PTR [rsi+40], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4239 :         state->TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)

	mov	BYTE PTR [rsi+72], 0

; 4240 :         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);

	lea	rax, QWORD PTR buf_end$48[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	rbx, QWORD PTR text_remaining$1$[rbp-256]
	mov	r8, rbx
	mov	edx, edi
	mov	rcx, QWORD PTR [rsi+32]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	r8d, eax
	mov	DWORD PTR [rsi+12], eax

; 4241 :         state->CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

	mov	ecx, DWORD PTR buf_end$48[rbp-256]
	sub	ecx, ebx
	mov	DWORD PTR [rsi+16], ecx

; 4242 : 
; 4243 :         if (recycle_state)

	test	r14b, r14b
	je	SHORT $LN31@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edx, eax
	cmp	DWORD PTR [rsi+84], eax
	cmovl	edx, DWORD PTR [rsi+84]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+84], edx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	ecx, eax
	cmp	DWORD PTR [rsi+88], eax
	cmovl	ecx, DWORD PTR [rsi+88]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+88], ecx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	DWORD PTR [rsi+92], eax
	cmovl	r8d, DWORD PTR [rsi+92]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+92], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4248 :         }

	mov	edx, DWORD PTR tv11239[rsp]
	jmp	SHORT $LN32@InputTextE
$LN31@InputTextE:

; 4249 :         else
; 4250 :         {
; 4251 :             state->ScrollX = 0.0f;

	xor	ecx, ecx
	mov	QWORD PTR [rsi+80], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1360 :    state->undostate.undo_point = 0;

	mov	DWORD PTR [rsi+3698], 6488064		; 00630000H

; 1361 :    state->undostate.undo_char_point = 0;

	mov	DWORD PTR [rsi+3704], ecx

; 1362 :    state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
; 1363 :    state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	DWORD PTR [rsi+3708], 999		; 000003e7H

; 1364 :    state->select_end = state->select_start = 0;

	mov	QWORD PTR [rsi+88], rcx

; 1369 :    state->initialized = 1;

	mov	WORD PTR [rsi+105], 1

; 1365 :    state->cursor = 0;
; 1366 :    state->has_preferred_x = 0;
; 1367 :    state->preferred_x = 0;

	mov	DWORD PTR [rsi+112], ecx

; 1368 :    state->cursor_at_end_of_line = 0;

	mov	BYTE PTR [rsi+104], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4252 :             stb_textedit_initialize_state(&state->Stb, !is_multiline);

	mov	edx, DWORD PTR tv11239[rsp]
	movzx	eax, dl
	xor	al, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1370 :    state->single_line = (unsigned char) is_single_line;

	mov	BYTE PTR [rsi+107], al

; 1371 :    state->insert_mode = 0;

	mov	BYTE PTR [rsi+96], cl

; 1372 :    state->row_count_per_page = 0;

	mov	DWORD PTR [rsi+100], ecx
$LN32@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4255 :         if (!is_multiline)

	test	dl, dl
	jne	SHORT $LN37@InputTextE

; 4256 :         {
; 4257 :             if (flags & ImGuiInputTextFlags_AutoSelectAll)

	mov	r8d, DWORD PTR flags$1$[rsp]
	test	r8b, 16
	mov	eax, DWORD PTR tv11299[rsp]
	movzx	eax, al
	mov	r8d, 1
	cmovne	eax, r8d
	mov	DWORD PTR tv11299[rsp], eax

; 4258 :                 select_all = true;
; 4259 :             if (input_requested_by_nav && (!recycle_state || !(g.NavActivateFlags & ImGuiActivateFlags_TryToPreserveState)))

	mov	rax, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR input_requested_by_nav$1$[rsp], dl
	je	SHORT $LN35@InputTextE
	test	r14b, r14b
	je	SHORT $LN36@InputTextE
	test	BYTE PTR [rax+19124], 4
	jne	SHORT $LN35@InputTextE
$LN36@InputTextE:

; 4260 :                 select_all = true;

	mov	BYTE PTR tv11299[rsp], r8b
$LN35@InputTextE:

; 4261 :             if (input_requested_by_tabbing || (user_clicked && io.KeyCtrl))

	test	r15b, r15b
	jne	SHORT $LN38@InputTextE
	test	r12b, r12b
	je	SHORT $LN37@InputTextE
	cmp	BYTE PTR [rax+3624], r15b
	je	SHORT $LN37@InputTextE
$LN38@InputTextE:

; 4262 :                 select_all = true;

	mov	BYTE PTR tv11299[rsp], r8b
$LN37@InputTextE:

; 4263 :         }
; 4264 : 
; 4265 :         if (flags & ImGuiInputTextFlags_AlwaysOverwrite)

	movzx	ebx, BYTE PTR user_scroll_active$1$[rsp]
	test	DWORD PTR flags$1$[rsp], 8192		; 00002000H
	je	SHORT $LN1481@InputTextE

; 4266 :             state->Stb.insert_mode = 1; // stb field name is indeed incorrect (see #2863)

	mov	BYTE PTR [rsi+96], 1
$LN1481@InputTextE:

; 4267 :     }
; 4268 : 
; 4269 :     const bool is_osx = io.ConfigMacOSXBehaviors;

	mov	rdi, QWORD PTR g$1$[rsp]
	movzx	r15d, BYTE PTR [rdi+97]
	mov	BYTE PTR is_osx$1$[rbp-256], r15b

; 4270 :     if (g.ActiveId != id && init_make_active)

	mov	r14d, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [rdi+16504], r14d
	je	SHORT $LN1560@InputTextE
	test	r13b, r13b
	je	SHORT $LN40@InputTextE

; 4271 :     {
; 4272 :         IM_ASSERT(state && state->ID == id);
; 4273 :         SetActiveID(id, window);

	mov	rdx, QWORD PTR window$1$[rbp-256]
	mov	ecx, r14d
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 4274 :         SetFocusID(id, window);

	mov	rdx, QWORD PTR window$1$[rbp-256]
	mov	ecx, r14d
	call	?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetFocusID

; 4275 :         FocusWindow(window);

	xor	edx, edx
	mov	rcx, QWORD PTR window$1$[rbp-256]
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
	mov	edx, DWORD PTR tv11239[rsp]
$LN40@InputTextE:

; 4277 :     if (g.ActiveId == id)

	cmp	DWORD PTR [rdi+16504], r14d
	jne	$LN1521@InputTextE
$LN1560@InputTextE:

; 4278 :     {
; 4279 :         // Declare some inputs, the other are registered and polled via Shortcut() routing system.
; 4280 :         if (user_clicked)

	test	r12b, r12b
	je	SHORT $LN42@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9667 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+18128], r14d
	mov	DWORD PTR [rax+18124], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+18132], 0
$LN42@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4282 :         g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);

	mov	r12, rdi
	mov	eax, DWORD PTR [rdi+18568]
	or	eax, 3
	mov	DWORD PTR [rdi+18568], eax

; 4283 :         if (is_multiline || (flags & ImGuiInputTextFlags_CallbackHistory))

	mov	ecx, DWORD PTR flags$1$[rsp]
	test	dl, dl
	jne	SHORT $LN44@InputTextE
	test	cl, cl
	jns	SHORT $LN43@InputTextE
$LN44@InputTextE:

; 4284 :             g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);

	or	eax, 12
	mov	DWORD PTR [rdi+18568], eax
$LN43@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9667 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+16664], r14d
	mov	DWORD PTR [rax+16660], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+16668], 0

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+16676], r14d
	mov	DWORD PTR [rax+16672], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+16680], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4287 :         if (is_multiline)

	test	dl, dl
	je	SHORT $LN45@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+16640], r14d
	mov	DWORD PTR [rax+16636], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+16644], 0

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+16652], r14d
	mov	DWORD PTR [rax+16648], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+16656], 0
$LN45@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4292 :         if (is_osx)

	test	r15b, r15b
	je	SHORT $LN46@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+18236], r14d
	mov	DWORD PTR [rax+18232], r14d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+18240], 0
$LN46@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4294 :         if (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput)) // Disable keyboard tabbing out as we will use the \t character.

	test	ecx, 1088				; 00000440H
	je	SHORT $LN790@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8812 :     ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);

	mov	ecx, 512				; 00000200H
	call	?GetShortcutRoutingData@ImGui@@YAPEAUImGuiKeyRoutingData@@H@Z ; ImGui::GetShortcutRoutingData

; 8696 :     ImGuiContext& g = *GImGui;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8697 :     return (owner_id != ImGuiKeyOwner_None && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;

	lea	ecx, DWORD PTR [r14-1]
	cmp	ecx, -3					; fffffffdH
	mov	ecx, r14d
	jbe	SHORT $LN808@InputTextE
	mov	ecx, DWORD PTR [rdx+18580]
$LN808@InputTextE:

; 8815 :     if (score < routing_data->RoutingNextScore)

	cmp	BYTE PTR [rax+4], 0
	jbe	SHORT $LN790@InputTextE

; 8816 :     {
; 8817 :         routing_data->RoutingNext = routing_id;

	mov	DWORD PTR [rax+12], ecx

; 8818 :         routing_data->RoutingNextScore = (ImU8)score;

	mov	BYTE PTR [rax+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4277 :     if (g.ActiveId == id)

	jmp	SHORT $LN790@InputTextE
$LN1521@InputTextE:
	mov	r12, rdi
$LN790@InputTextE:

; 4295 :             SetShortcutRouting(ImGuiKey_Tab, id);
; 4296 :     }
; 4297 : 
; 4298 :     // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
; 4299 :     if (g.ActiveId == id && state == NULL)

	cmp	DWORD PTR [r12+16504], r14d
	jne	SHORT $LN1423@InputTextE
	test	rsi, rsi
	jne	SHORT $LN48@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN48@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4303 :     if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560

	cmp	DWORD PTR [r12+16504], r14d
	jne	SHORT $LN1423@InputTextE
	cmp	BYTE PTR [r12+14160], 0
	je	SHORT $LN1388@InputTextE
	cmp	BYTE PTR init_state$1$[rsp], 0
	jne	SHORT $LN1388@InputTextE
	test	r13b, r13b
	jne	SHORT $LN1388@InputTextE

; 4304 :         clear_active_id = true;

	mov	BYTE PTR clear_active_id$1$[rsp], 1

; 4305 : 
; 4306 :     // Lock the decision of whether we are going to take the path displaying the cursor or selection
; 4307 :     bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);

	mov	cl, 1
	jmp	SHORT $LN1562@InputTextE
$LN1423@InputTextE:
	test	rsi, rsi
	je	SHORT $LN255@InputTextE
	test	bl, bl
	je	SHORT $LN255@InputTextE
$LN1388@InputTextE:
	mov	cl, 1
	jmp	SHORT $LN1562@InputTextE
$LN255@InputTextE:
	xor	cl, cl
$LN1562@InputTextE:

; 4308 :     bool render_selection = state && (state->HasSelection() || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);

	mov	BYTE PTR render_cursor$1$[rsp], cl
	mov	r14d, DWORD PTR tv11299[rsp]
	test	rsi, rsi
	je	SHORT $LN259@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4308 :     bool render_selection = state && (state->HasSelection() || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);

	jne	SHORT $LN258@InputTextE
	test	r14b, r14b
	je	SHORT $LN259@InputTextE
$LN258@InputTextE:
	test	cl, cl
	je	SHORT $LN259@InputTextE
	mov	dl, 1
	jmp	SHORT $LN1563@InputTextE
$LN259@InputTextE:
	xor	dl, dl
$LN1563@InputTextE:

; 4309 :     bool value_changed = false;

	mov	DWORD PTR tv11311[rsp], edx
	movzx	edi, dl
	mov	BYTE PTR value_changed$1$[rsp], 0

; 4310 :     bool validated = false;

	mov	BYTE PTR validated$1$[rsp], 0

; 4311 : 
; 4312 :     // When read-only we always use the live data passed to the function
; 4313 :     // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
; 4314 :     if (is_readonly && state != NULL && (render_cursor || render_selection))

	mov	eax, DWORD PTR tv11237[rsp]
	test	al, al
	je	$LN1524@InputTextE
	test	rsi, rsi
	je	$LN1524@InputTextE
	test	cl, cl
	jne	SHORT $LN51@InputTextE
	test	dl, dl
	je	$LN1522@InputTextE
$LN51@InputTextE:

; 4315 :     {
; 4316 :         const char* buf_end = NULL;

	xor	eax, eax
	mov	QWORD PTR buf_end$47[rbp-256], rax

; 4317 :         state->TextW.resize(buf_size + 1);

	mov	r13d, DWORD PTR buf_size$GSCopy$1$[rbp-256]
	lea	edx, DWORD PTR [r13+1]
	lea	rcx, QWORD PTR [rsi+24]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize

; 4318 :         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);

	lea	rax, QWORD PTR buf_end$47[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR text_remaining$1$[rbp-256]
	mov	edx, DWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rsi+32]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	r8d, eax
	mov	DWORD PTR [rsi+12], eax

; 4319 :         state->CurLenA = (int)(buf_end - buf);

	mov	ecx, DWORD PTR buf_end$47[rbp-256]
	sub	ecx, DWORD PTR text_remaining$1$[rbp-256]
	mov	DWORD PTR [rsi+16], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edx, eax
	cmp	DWORD PTR [rsi+84], eax
	cmovl	edx, DWORD PTR [rsi+84]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+84], edx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	ecx, eax
	cmp	DWORD PTR [rsi+88], eax
	cmovl	ecx, DWORD PTR [rsi+88]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+88], ecx

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	DWORD PTR [rsi+92], eax
	cmovl	r8d, DWORD PTR [rsi+92]

; 1122 :     void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }

	mov	DWORD PTR [rsi+92], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4321 :         render_selection &= state->HasSelection();

	xor	eax, eax
	mov	edx, eax
	cmp	ecx, r8d
	cmovne	edx, edi
	mov	DWORD PTR tv11311[rsp], edx

; 4311 : 
; 4312 :     // When read-only we always use the live data passed to the function
; 4313 :     // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
; 4314 :     if (is_readonly && state != NULL && (render_cursor || render_selection))

	movzx	ecx, BYTE PTR render_cursor$1$[rsp]
	mov	eax, DWORD PTR tv11237[rsp]
	jmp	SHORT $LN50@InputTextE
$LN1524@InputTextE:

; 4322 :     }
; 4323 : 
; 4324 :     // Select the buffer to render.
; 4325 :     const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;

	mov	r13d, DWORD PTR buf_size$GSCopy$1$[rbp-256]
$LN50@InputTextE:
	test	cl, cl
	jne	SHORT $LN1536@InputTextE
	test	dl, dl
	je	SHORT $LN1429@InputTextE
$LN1536@InputTextE:
	mov	edi, DWORD PTR id$1$[rsp]
$LN262@InputTextE:
	test	al, al
	jne	SHORT $LN263@InputTextE
	test	rsi, rsi
	je	SHORT $LN263@InputTextE
	cmp	BYTE PTR [rsi+72], al
	je	SHORT $LN263@InputTextE
	mov	al, 1
	jmp	SHORT $LN1564@InputTextE
$LN1522@InputTextE:

; 4311 : 
; 4312 :     // When read-only we always use the live data passed to the function
; 4313 :     // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
; 4314 :     if (is_readonly && state != NULL && (render_cursor || render_selection))

	mov	r13d, DWORD PTR buf_size$GSCopy$1$[rbp-256]
$LN1429@InputTextE:

; 4322 :     }
; 4323 : 
; 4324 :     // Select the buffer to render.
; 4325 :     const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;

	mov	edi, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [r12+16504], edi
	je	SHORT $LN262@InputTextE
$LN263@InputTextE:
	xor	al, al
$LN1564@InputTextE:

; 4326 :     const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);

	mov	BYTE PTR buf_display_from_state$1$[rbp-256], al
	cmp	QWORD PTR hint$GSCopy$1$[rbp-256], 0
	je	SHORT $LN267@InputTextE
	test	al, al
	je	SHORT $LN265@InputTextE
	mov	rax, QWORD PTR [rsi+48]
	jmp	SHORT $LN266@InputTextE
$LN265@InputTextE:
	mov	rax, QWORD PTR text_remaining$1$[rbp-256]
$LN266@InputTextE:
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN267@InputTextE
	mov	al, 1
	jmp	SHORT $LN1565@InputTextE
$LN267@InputTextE:
	xor	al, al
$LN1565@InputTextE:

; 4327 : 
; 4328 :     // Password pushes a temporary font with only a fallback glyph
; 4329 :     if (is_password && !is_displaying_hint)

	mov	BYTE PTR is_displaying_hint$1$[rsp], al
	cmp	BYTE PTR tv11234[rbp-256], 0
	je	$LN52@InputTextE
	test	al, al
	jne	$LN52@InputTextE

; 4330 :     {
; 4331 :         const ImFontGlyph* glyph = g.Font->FindGlyph('*');

	mov	rdx, QWORD PTR [r12+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3400 :     if (c >= (size_t)IndexLookup.Size)

	cmp	DWORD PTR [rdx+24], 42			; 0000002aH
	ja	SHORT $LN875@InputTextE

; 3401 :         return FallbackGlyph;

	mov	r8, QWORD PTR [rdx+56]
	jmp	SHORT $LN874@InputTextE
$LN875@InputTextE:

; 3402 :     const ImWchar i = IndexLookup.Data[c];

	mov	rax, QWORD PTR [rdx+32]
	movzx	ecx, WORD PTR [rax+84]

; 3403 :     if (i == (ImWchar)-1)

	mov	eax, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN876@InputTextE

; 3404 :         return FallbackGlyph;

	mov	r8, QWORD PTR [rdx+56]
	jmp	SHORT $LN874@InputTextE
$LN876@InputTextE:

; 3405 :     return &Glyphs.Data[i];

	lea	rcx, QWORD PTR [rcx+rcx*4]
	mov	rax, QWORD PTR [rdx+48]
	lea	r8, QWORD PTR [rax+rcx*8]
$LN874@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4332 :         ImFont* password_font = &g.InputTextPasswordFont;

	lea	rcx, QWORD PTR [r12+23704]

; 4333 :         password_font->FontSize = g.Font->FontSize;

	mov	eax, DWORD PTR [rdx+20]
	mov	DWORD PTR [rcx+20], eax

; 4334 :         password_font->Scale = g.Font->Scale;

	mov	rax, QWORD PTR [r12+15688]
	mov	edx, DWORD PTR [rax+100]
	mov	DWORD PTR [rcx+100], edx

; 4335 :         password_font->Ascent = g.Font->Ascent;

	mov	rax, QWORD PTR [r12+15688]
	mov	edx, DWORD PTR [rax+104]
	mov	DWORD PTR [rcx+104], edx

; 4336 :         password_font->Descent = g.Font->Descent;

	mov	rax, QWORD PTR [r12+15688]
	mov	edx, DWORD PTR [rax+108]
	mov	DWORD PTR [rcx+108], edx

; 4337 :         password_font->ContainerAtlas = g.Font->ContainerAtlas;

	mov	rax, QWORD PTR [r12+15688]
	mov	rdx, QWORD PTR [rax+64]
	mov	QWORD PTR [rcx+64], rdx

; 4338 :         password_font->FallbackGlyph = glyph;

	mov	QWORD PTR [rcx+56], r8

; 4339 :         password_font->FallbackAdvanceX = glyph->AdvanceX;

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rcx+16], eax

; 4340 :         IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
; 4341 :         PushFont(password_font);

	call	?PushFont@ImGui@@YAXPEAUImFont@@@Z	; ImGui::PushFont
$LN52@InputTextE:

; 4342 :     }
; 4343 : 
; 4344 :     // Process mouse inputs and character inputs
; 4345 :     int backup_current_text_length = 0;

	xor	eax, eax
	mov	DWORD PTR backup_current_text_length$1$[rbp-256], eax

; 4346 :     if (g.ActiveId == id)

	mov	ebx, 2097164				; 0020000cH
	movss	xmm0, DWORD PTR __real@3f000000
	cmp	DWORD PTR [r12+16504], edi
	jne	$LN74@InputTextE

; 4347 :     {
; 4348 :         IM_ASSERT(state != NULL);
; 4349 :         backup_current_text_length = state->CurLenA;

	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR backup_current_text_length$1$[rbp-256], eax

; 4350 :         state->Edited = false;

	mov	BYTE PTR [rsi+3718], 0

; 4351 :         state->BufCapacityA = buf_size;

	mov	DWORD PTR [rsi+76], r13d

; 4352 :         state->Flags = flags;

	mov	edx, DWORD PTR flags$1$[rsp]
	mov	DWORD PTR [rsi+3720], edx

; 4353 : 
; 4354 :         // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
; 4355 :         // Down the line we should have a cleaner library-wide concept of Selected vs Active.
; 4356 :         g.ActiveIdAllowOverlap = !io.MouseDown[0];

	cmp	BYTE PTR [r12+3600], 0
	sete	al
	mov	BYTE PTR [r12+16517], al

; 4357 : 
; 4358 :         // Edit in progress
; 4359 :         const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->ScrollX;

	movss	xmm6, DWORD PTR [r12+3592]
	subss	xmm6, xmm8
	subss	xmm6, DWORD PTR [r12+14612]
	addss	xmm6, DWORD PTR [rsi+80]

; 4360 :         const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y) : (g.FontSize * 0.5f));

	mov	r13d, DWORD PTR tv11239[rsp]
	test	r13b, r13b
	je	SHORT $LN269@InputTextE
	movss	xmm2, DWORD PTR [r12+3596]
	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	subss	xmm2, DWORD PTR [rax+316]
	jmp	SHORT $LN270@InputTextE
$LN269@InputTextE:
	movss	xmm2, DWORD PTR [r12+15696]
	mulss	xmm2, xmm0
$LN270@InputTextE:

; 4361 : 
; 4362 :         if (select_all)

	test	r14b, r14b
	je	SHORT $LN54@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1128 :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

	xor	ebx, ebx
	mov	DWORD PTR [rsi+88], ebx
	mov	eax, DWORD PTR [rsi+12]
	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+106], bl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4365 :             state->SelectedAllMouseLock = true;

	mov	BYTE PTR [rsi+3717], 1

; 4366 :         }

	jmp	$LN69@InputTextE
$LN54@InputTextE:

; 4367 :         else if (hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift)

	movzx	ecx, BYTE PTR hovered$1$[rsp]
	test	cl, cl
	je	$LN56@InputTextE
	cmp	WORD PTR [r12+14170], 2
	jb	$LN56@InputTextE
	cmp	BYTE PTR [r12+3625], 0
	jne	$LN56@InputTextE

; 4368 :         {
; 4369 :             stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);

	movaps	xmm3, xmm2
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ; ImStb::stb_textedit_click

; 4370 :             const int multiclick_count = (io.MouseClickedCount[0] - 2);

	movzx	eax, WORD PTR [r12+14170]
	sub	eax, 2

; 4371 :             if ((multiclick_count % 2) == 0)

	movsxd	rdx, DWORD PTR [rsi+84]
	test	al, 1
	jne	$LN58@InputTextE

; 4372 :             {
; 4373 :                 // Double-click: Select word
; 4374 :                 // We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
; 4375 :                 // FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
; 4376 :                 const bool is_bol = (state->Stb.cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor - 1) == '\n';

	test	edx, edx
	je	SHORT $LN1438@InputTextE

; 3736 : static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { return obj->TextW[idx]; }

	mov	rax, QWORD PTR [rsi+32]

; 4372 :             {
; 4373 :                 // Double-click: Select word
; 4374 :                 // We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
; 4375 :                 // FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
; 4376 :                 const bool is_bol = (state->Stb.cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor - 1) == '\n';

	cmp	WORD PTR [rax+rdx*2-2], 10
	je	SHORT $LN1438@InputTextE
	xor	cl, cl
	jmp	SHORT $LN272@InputTextE
$LN1438@InputTextE:
	mov	cl, 1
$LN272@InputTextE:

; 4377 :                 if (STB_TEXT_HAS_SELECTION(&state->Stb) || !is_bol)

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
	jne	SHORT $LN61@InputTextE
	test	cl, cl
	jne	SHORT $LN1439@InputTextE
$LN61@InputTextE:

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, ebx
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	mov	edx, DWORD PTR [rsi+84]
$LN1439@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4380 :                 if (!STB_TEXT_HAS_SELECTION(&state->Stb))

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
	jne	SHORT $LN1125@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 681  :    if (!STB_TEXT_HAS_SELECTION(state))

	cmp	DWORD PTR [rsi+88], eax
	jne	SHORT $LN1124@InputTextE

; 682  :       state->select_start = state->select_end = state->cursor;

	mov	DWORD PTR [rsi+92], edx
	mov	DWORD PTR [rsi+88], edx
	jmp	SHORT $LN1125@InputTextE
$LN1124@InputTextE:

; 683  :    else
; 684  :       state->cursor = state->select_end;

	mov	DWORD PTR [rsi+84], eax
	mov	edx, eax
$LN1125@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4382 :                 state->Stb.cursor = ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state->Stb.cursor);

	mov	rcx, rsi
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_MAC@ImStb@@YAHPEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC
	mov	DWORD PTR [rsi+84], eax

; 4383 :                 state->Stb.select_end = state->Stb.cursor;

	mov	DWORD PTR [rsi+92], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	eax, DWORD PTR [rsi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	edx, DWORD PTR [rsi+92]
	mov	ecx, DWORD PTR [rsi+88]
	cmp	ecx, edx
	je	SHORT $LN1106@InputTextE

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	ecx, eax
	jle	SHORT $LN1104@InputTextE
	mov	DWORD PTR [rsi+88], eax
	mov	ecx, eax
$LN1104@InputTextE:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	edx, eax
	jle	SHORT $LN1105@InputTextE
	mov	DWORD PTR [rsi+92], eax
	mov	edx, eax
$LN1105@InputTextE:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	ecx, edx
	jne	SHORT $LN1106@InputTextE

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rsi+84], ecx
$LN1106@InputTextE:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rsi+84], eax
	jle	$LN59@InputTextE
	mov	DWORD PTR [rsi+84], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4401 :         }

	mov	edi, DWORD PTR id$1$[rsp]
	jmp	$LN1584@InputTextE
$LN58@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rcx, QWORD PTR [rsi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3736 : static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { return obj->TextW[idx]; }

	movzx	ebx, WORD PTR [rcx+rdx*2]

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, 2097156				; 00200004H
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, 6291461				; 00600005H
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, 6291457				; 00600001H
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 4384 :                 ImStb::stb_textedit_clamp(state, &state->Stb);
; 4385 :             }
; 4386 :             else
; 4387 :             {
; 4388 :                 // Triple-click: Select line
; 4389 :                 const bool is_eol = ImStb::STB_TEXTEDIT_GETCHAR(state, state->Stb.cursor) == '\n';
; 4390 :                 state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART);
; 4391 :                 state->OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);
; 4392 :                 state->OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);
; 4393 :                 if (!is_eol && is_multiline)

	cmp	bx, 10
	je	SHORT $LN63@InputTextE
	test	r13b, r13b
	je	SHORT $LN63@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	ecx, DWORD PTR [rsi+88]
	mov	eax, DWORD PTR [rsi+92]
	mov	DWORD PTR [rsi+88], eax
	mov	DWORD PTR [rsi+92], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4396 :                     state->Stb.cursor = state->Stb.select_end;

	mov	DWORD PTR [rsi+84], ecx
$LN63@InputTextE:

; 4397 :                 }
; 4398 :                 state->CursorFollow = false;

	mov	BYTE PTR [rsi+3716], 0
$LN59@InputTextE:

; 4401 :         }

	mov	edi, DWORD PTR id$1$[rsp]
	jmp	$LN1584@InputTextE
$LN56@InputTextE:

; 4402 :         else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)

	movzx	eax, BYTE PTR [rsi+3717]
	cmp	BYTE PTR [r12+14160], 0
	je	SHORT $LN64@InputTextE
	test	al, al
	jne	SHORT $LN64@InputTextE

; 4403 :         {
; 4404 :             if (hovered)

	test	cl, cl
	je	$LN1554@InputTextE

; 4405 :             {
; 4406 :                 if (io.KeyShift)

	cmp	BYTE PTR [r12+3625], al
	je	SHORT $LN67@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 485  :    if( state->single_line )

	cmp	BYTE PTR [rsi+107], al
	je	SHORT $LN1112@InputTextE

; 486  :    {
; 487  :       StbTexteditRow r;
; 488  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	mov	rdx, rsi
	lea	rcx, QWORD PTR r$36[rbp-256]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 489  :       y = r.ymin;

	movss	xmm2, DWORD PTR r$36[rbp-244]
$LN1112@InputTextE:

; 490  :    }
; 491  : 
; 492  :    if (state->select_start == state->select_end)

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
	jne	SHORT $LN1113@InputTextE

; 493  :       state->select_start = state->cursor;

	mov	eax, DWORD PTR [rsi+84]
	mov	DWORD PTR [rsi+88], eax
$LN1113@InputTextE:

; 494  : 
; 495  :    p = stb_text_locate_coord(str, x, y);

	movaps	xmm1, xmm6
	mov	rcx, rsi
	call	?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord

; 496  :    state->cursor = state->select_end = p;

	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4407 :                     stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);

	jmp	$LN1584@InputTextE
$LN67@InputTextE:

; 4408 :                 else
; 4409 :                     stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);

	movaps	xmm3, xmm2
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_click@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@MM@Z ; ImStb::stb_textedit_click

; 4410 :                 state->CursorAnimReset();
; 4411 :             }
; 4412 :         }

	jmp	SHORT $LN1584@InputTextE
$LN64@InputTextE:

; 4413 :         else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))

	cmp	BYTE PTR [r12+3600], 0
	je	SHORT $LN1554@InputTextE
	test	al, al
	jne	SHORT $LN1554@InputTextE
	movss	xmm0, DWORD PTR [r12+248]
	ucomiss	xmm0, xmm7
	jp	SHORT $LN1479@InputTextE
	jne	SHORT $LN1479@InputTextE
	movss	xmm0, DWORD PTR [r12+252]
	ucomiss	xmm0, xmm7
	jp	SHORT $LN1479@InputTextE
	je	SHORT $LN1554@InputTextE
$LN1479@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 485  :    if( state->single_line )

	cmp	BYTE PTR [rsi+107], 0
	je	SHORT $LN1049@InputTextE

; 486  :    {
; 487  :       StbTexteditRow r;
; 488  :       STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	xor	r8d, r8d
	mov	rdx, rsi
	lea	rcx, QWORD PTR r$37[rbp-256]
	call	?STB_TEXTEDIT_LAYOUTROW@ImStb@@YAXPEAUStbTexteditRow@1@PEAUImGuiInputTextState@@H@Z ; ImStb::STB_TEXTEDIT_LAYOUTROW

; 489  :       y = r.ymin;

	movss	xmm2, DWORD PTR r$37[rbp-244]
$LN1049@InputTextE:

; 490  :    }
; 491  : 
; 492  :    if (state->select_start == state->select_end)

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
	jne	SHORT $LN1050@InputTextE

; 493  :       state->select_start = state->cursor;

	mov	eax, DWORD PTR [rsi+84]
	mov	DWORD PTR [rsi+88], eax
$LN1050@InputTextE:

; 494  : 
; 495  :    p = stb_text_locate_coord(str, x, y);

	movaps	xmm1, xmm6
	mov	rcx, rsi
	call	?stb_text_locate_coord@ImStb@@YAHPEAUImGuiInputTextState@@MM@Z ; ImStb::stb_text_locate_coord

; 496  :    state->cursor = state->select_end = p;

	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4417 :             state->CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
$LN1584@InputTextE:

; 4418 :         }
; 4419 :         if (state->SelectedAllMouseLock && !io.MouseDown[0])

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	mov	edx, DWORD PTR flags$1$[rsp]
$LN1554@InputTextE:
	xor	ebx, ebx
$LN69@InputTextE:
	cmp	BYTE PTR [rsi+3717], 0
	je	SHORT $LN71@InputTextE
	cmp	BYTE PTR [r12+3600], 0
	jne	SHORT $LN71@InputTextE

; 4420 :             state->SelectedAllMouseLock = false;

	mov	BYTE PTR [rsi+3717], 0
$LN71@InputTextE:

; 4421 : 
; 4422 :         // We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)
; 4423 :         // (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)
; 4424 :         if ((flags & ImGuiInputTextFlags_AllowTabInput) && Shortcut(ImGuiKey_Tab, id) && !is_readonly)

	bt	edx, 10
	jae	$LN1526@InputTextE
	xor	r8d, r8d
	mov	edx, edi
	mov	ecx, 512				; 00000200H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	mov	ecx, DWORD PTR tv11237[rsp]
	mov	r13, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	mov	edx, DWORD PTR flags$1$[rsp]
	test	al, al
	je	SHORT $LN1482@InputTextE
	test	cl, cl
	jne	SHORT $LN1482@InputTextE

; 4425 :         {
; 4426 :             unsigned int c = '\t'; // Insert TAB

	mov	DWORD PTR c$21[rbp-256], 9

; 4427 :             if (InputTextFilterCharacter(&c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))

	mov	DWORD PTR [rsp+32], 2
	mov	r9, r13
	mov	r8, QWORD PTR callback$GSCopy$1$[rbp-256]
	lea	rcx, QWORD PTR c$21[rbp-256]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z ; InputTextFilterCharacter
	test	al, al
	je	SHORT $LN1546@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, DWORD PTR c$21[rbp-256]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
$LN1546@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4433 :         const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);

	mov	edx, DWORD PTR flags$1$[rsp]
$LN1566@InputTextE:
	mov	ecx, DWORD PTR tv11237[rsp]
$LN1482@InputTextE:
	cmp	BYTE PTR [r12+3624], 0
	je	SHORT $LN1440@InputTextE
	cmp	BYTE PTR [r12+3626], 0
	je	SHORT $LN1441@InputTextE
$LN1440@InputTextE:
	test	r15b, r15b
	je	SHORT $LN1442@InputTextE
	cmp	BYTE PTR [r12+3627], 0
	je	SHORT $LN1442@InputTextE
$LN1441@InputTextE:
	mov	al, 1
	jmp	SHORT $LN276@InputTextE
$LN1526@InputTextE:

; 4421 : 
; 4422 :         // We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)
; 4423 :         // (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)
; 4424 :         if ((flags & ImGuiInputTextFlags_AllowTabInput) && Shortcut(ImGuiKey_Tab, id) && !is_readonly)

	mov	r13, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	jmp	SHORT $LN1566@InputTextE
$LN1442@InputTextE:

; 4433 :         const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);

	xor	al, al
$LN276@InputTextE:

; 4434 :         if (io.InputQueueCharacters.Size > 0)

	cmp	DWORD PTR [r12+14320], 0
	jle	$LN74@InputTextE

; 4435 :         {
; 4436 :             if (!ignore_char_inputs && !is_readonly && !input_requested_by_nav)

	test	al, al
	jne	$LN3@InputTextE
	test	cl, cl
	jne	$LN3@InputTextE
	cmp	BYTE PTR input_requested_by_nav$1$[rsp], cl
	jne	SHORT $LN3@InputTextE

; 4437 :                 for (int n = 0; n < io.InputQueueCharacters.Size; n++)

	mov	edi, ebx
	mov	r15, QWORD PTR callback$GSCopy$1$[rbp-256]
	npad	2
$LL4@InputTextE:

; 4438 :                 {
; 4439 :                     // Insert character if they pass filtering
; 4440 :                     unsigned int c = (unsigned int)io.InputQueueCharacters[n];

	mov	rax, QWORD PTR [r12+14328]
	movzx	ecx, WORD PTR [rax+rbx]
	mov	DWORD PTR c$20[rbp-256], ecx
	cmp	ecx, 9

; 4441 :                     if (c == '\t') // Skip Tab, see above.

	je	SHORT $LN2@InputTextE

; 4442 :                         continue;
; 4443 :                     if (InputTextFilterCharacter(&c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))

	mov	DWORD PTR [rsp+32], 2
	mov	r9, r13
	mov	r8, r15
	lea	rcx, QWORD PTR c$20[rbp-256]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z ; InputTextFilterCharacter
	test	al, al
	je	SHORT $LN2@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, DWORD PTR c$20[rbp-256]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
$LN2@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4437 :                 for (int n = 0; n < io.InputQueueCharacters.Size; n++)

	inc	edi
	add	rbx, 2
	cmp	edi, DWORD PTR [r12+14320]
	mov	edx, DWORD PTR flags$1$[rsp]
	jl	SHORT $LL4@InputTextE
	movzx	r15d, BYTE PTR is_osx$1$[rbp-256]
$LN3@InputTextE:

; 4444 :                         state->OnKeyPressed((int)c);
; 4445 :                 }
; 4446 : 
; 4447 :             // Consume characters
; 4448 :             io.InputQueueCharacters.resize(0);

	xor	edx, edx
	lea	rcx, QWORD PTR [r12+14320]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
$LN74@InputTextE:

; 4449 :         }
; 4450 :     }
; 4451 : 
; 4452 :     // Process other shortcuts/key-presses
; 4453 :     bool revert_edit = false;

	xor	dil, dil
	mov	BYTE PTR revert_edit$1$[rbp-256], dil

; 4454 :     if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)

	mov	r14d, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [r12+16504], r14d
	jne	$LN78@InputTextE
	cmp	BYTE PTR [r12+16516], dil
	jne	$LN78@InputTextE
	cmp	BYTE PTR clear_active_id$1$[rsp], dil
	jne	$LN78@InputTextE

; 4455 :     {
; 4456 :         IM_ASSERT(state != NULL);
; 4457 : 
; 4458 :         const int row_count_per_page = ImMax((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);

	movaps	xmm0, xmm11
	subss	xmm0, DWORD PTR [r12+14616]
	divss	xmm0, DWORD PTR [r12+15696]
	cvttss2si eax, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	mov	edi, 1
	mov	ecx, edi
	cmp	eax, edi
	cmovge	ecx, eax
	mov	DWORD PTR row_count_per_page$1$[rbp-256], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4459 :         state->Stb.row_count_per_page = row_count_per_page;

	mov	DWORD PTR [rsi+100], ecx

; 4460 : 
; 4461 :         const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);

	movzx	eax, BYTE PTR [r12+3625]
	neg	al
	sbb	ebx, ebx
	and	ebx, 4194304				; 00400000H

; 4462 :         const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl

	test	r15b, r15b
	je	SHORT $LN277@InputTextE
	movzx	eax, BYTE PTR [r12+3626]
	mov	BYTE PTR is_wordmove_key_down$1$[rsp], al

; 4463 :         const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

	cmp	BYTE PTR [r12+3627], 0
	je	SHORT $LN279@InputTextE
	cmp	BYTE PTR [r12+3624], 0
	jne	SHORT $LN279@InputTextE
	test	al, al
	jne	SHORT $LN279@InputTextE
	mov	BYTE PTR is_startend_key_down$1$[rsp], dil
	jmp	SHORT $LN280@InputTextE
$LN277@InputTextE:

; 4462 :         const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl

	movzx	eax, BYTE PTR [r12+3624]
	mov	BYTE PTR is_wordmove_key_down$1$[rsp], al
$LN279@InputTextE:

; 4463 :         const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

	mov	BYTE PTR is_startend_key_down$1$[rsp], 0
$LN280@InputTextE:

; 4468 :         const bool is_cut   = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_X, id, f_repeat) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, id, f_repeat)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());

	mov	r8d, edi
	mov	edx, r14d
	mov	ecx, 2617				; 00000a39H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN281@InputTextE
	mov	r8d, edi
	mov	edx, r14d
	mov	ecx, 8714				; 0000220aH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	je	SHORT $LN1540@InputTextE
$LN281@InputTextE:
	mov	r12d, DWORD PTR tv11237[rsp]
	mov	r13d, DWORD PTR tv11234[rbp-256]
	mov	edi, DWORD PTR tv11239[rsp]
	test	r12b, r12b
	jne	SHORT $LN282@InputTextE
	test	r13b, r13b
	jne	SHORT $LN282@InputTextE
	test	dil, dil
	je	SHORT $LN1443@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4468 :         const bool is_cut   = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_X, id, f_repeat) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, id, f_repeat)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());

	je	SHORT $LN282@InputTextE
$LN1443@InputTextE:
	mov	BYTE PTR is_cut$1$[rbp-256], 1
	jmp	SHORT $LN284@InputTextE
$LN1540@InputTextE:
	mov	edi, DWORD PTR tv11239[rsp]
	mov	r12d, DWORD PTR tv11237[rsp]
	mov	r13d, DWORD PTR tv11234[rbp-256]
$LN282@InputTextE:
	mov	BYTE PTR is_cut$1$[rbp-256], 0
$LN284@InputTextE:

; 4469 :         const bool is_copy  = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_C, id) || Shortcut(ImGuiMod_Ctrl | ImGuiKey_Insert, id))  && !is_password && (!is_multiline || state->HasSelection());

	xor	r8d, r8d
	mov	edx, r14d
	mov	ecx, 2596				; 00000a24H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN285@InputTextE
	xor	r8d, r8d
	mov	edx, r14d
	mov	ecx, 4617				; 00001209H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	je	SHORT $LN286@InputTextE
$LN285@InputTextE:
	test	r13b, r13b
	jne	SHORT $LN286@InputTextE
	test	dil, dil
	je	SHORT $LN287@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4469 :         const bool is_copy  = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_C, id) || Shortcut(ImGuiMod_Ctrl | ImGuiKey_Insert, id))  && !is_password && (!is_multiline || state->HasSelection());

	je	SHORT $LN286@InputTextE
$LN287@InputTextE:
	mov	BYTE PTR is_copy$1$[rbp-256], 1
	jmp	SHORT $LN288@InputTextE
$LN286@InputTextE:
	mov	BYTE PTR is_copy$1$[rbp-256], 0
$LN288@InputTextE:

; 4470 :         const bool is_paste = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_V, id, f_repeat) || Shortcut(ImGuiMod_Shift | ImGuiKey_Insert, id, f_repeat)) && !is_readonly;

	mov	r13d, 1
	mov	r8d, r13d
	mov	edx, r14d
	mov	ecx, 2615				; 00000a37H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN289@InputTextE
	mov	r8d, r13d
	mov	edx, r14d
	mov	ecx, 8713				; 00002209H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	je	SHORT $LN290@InputTextE
$LN289@InputTextE:
	test	r12b, r12b
	mov	BYTE PTR is_paste$1$[rsp], r13b
	je	SHORT $LN291@InputTextE
$LN290@InputTextE:
	mov	BYTE PTR is_paste$1$[rsp], 0
$LN291@InputTextE:

; 4471 :         const bool is_undo  = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_Z, id, f_repeat)) && !is_readonly && is_undoable;

	mov	r8d, r13d
	mov	edx, r14d
	mov	ecx, 2619				; 00000a3bH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	mov	edi, DWORD PTR tv11232[rbp-256]
	test	al, al
	je	SHORT $LN292@InputTextE
	test	r12b, r12b
	jne	SHORT $LN292@InputTextE
	test	dil, dil
	mov	BYTE PTR is_undo$1$[rbp-256], r13b
	jne	SHORT $LN293@InputTextE
$LN292@InputTextE:
	mov	BYTE PTR is_undo$1$[rbp-256], 0
$LN293@InputTextE:

; 4472 :         const bool is_redo =  (Shortcut(ImGuiMod_Shortcut | ImGuiKey_Y, id, f_repeat) || (is_osx && Shortcut(ImGuiMod_Shortcut | ImGuiMod_Shift | ImGuiKey_Z, id, f_repeat))) && !is_readonly && is_undoable;

	mov	r8d, r13d
	mov	edx, r14d
	mov	ecx, 2618				; 00000a3aH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN295@InputTextE
	test	r15b, r15b
	je	SHORT $LN294@InputTextE
	mov	r8d, r13d
	mov	edx, r14d
	mov	ecx, 10811				; 00002a3bH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	je	SHORT $LN294@InputTextE
$LN295@InputTextE:
	test	r12b, r12b
	jne	SHORT $LN294@InputTextE
	test	dil, dil
	je	SHORT $LN294@InputTextE
	movzx	r12d, r13b
	jmp	SHORT $LN296@InputTextE
$LN294@InputTextE:
	xor	r12b, r12b
$LN296@InputTextE:

; 4473 :         const bool is_select_all = Shortcut(ImGuiMod_Shortcut | ImGuiKey_A, id);

	xor	r8d, r8d
	mov	edx, r14d
	mov	ecx, 2594				; 00000a22H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	movzx	r13d, al

; 4474 : 
; 4475 :         // We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.
; 4476 :         const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;

	mov	rax, QWORD PTR g$1$[rsp]
	test	BYTE PTR [rax+8], 2
	je	SHORT $LN297@InputTextE
	test	BYTE PTR [rax+12], 1
	je	SHORT $LN297@InputTextE
	mov	dil, 1
	jmp	SHORT $LN298@InputTextE
$LN297@InputTextE:
	xor	dil, dil
$LN298@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	mov	r14d, 1
	mov	r8d, r14d
	xor	edx, edx
	mov	ecx, 525				; 0000020dH
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4477 :         const bool is_enter_pressed = IsKeyPressed(ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey_KeypadEnter, true);

	test	al, al
	jne	SHORT $LN299@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	mov	r8d, r14d
	xor	edx, edx
	mov	ecx, 615				; 00000267H
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4477 :         const bool is_enter_pressed = IsKeyPressed(ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey_KeypadEnter, true);

	test	al, al
	jne	SHORT $LN299@InputTextE
	xor	r15b, r15b
	jmp	SHORT $LN300@InputTextE
$LN299@InputTextE:
	movzx	r15d, r14b
$LN300@InputTextE:

; 4478 :         const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));

	test	dil, dil
	je	SHORT $LN302@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 622				; 0000026eH
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4478 :         const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));

	test	al, al
	jne	SHORT $LN303@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 621				; 0000026dH
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4478 :         const bool is_gamepad_validate = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate, false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false));

	test	al, al
	jne	SHORT $LN303@InputTextE
$LN302@InputTextE:
	xor	r14b, r14b
$LN303@InputTextE:

; 4479 :         const bool is_cancel = Shortcut(ImGuiKey_Escape, id, f_repeat) || (nav_gamepad_active && Shortcut(ImGuiKey_NavGamepadCancel, id, f_repeat));

	mov	r8d, 1
	mov	edx, DWORD PTR id$1$[rsp]
	mov	ecx, 526				; 0000020eH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN305@InputTextE
	test	dil, dil
	je	SHORT $LN304@InputTextE
	mov	r8d, 1
	mov	edx, DWORD PTR id$1$[rsp]
	mov	ecx, 620				; 0000026cH
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	jne	SHORT $LN305@InputTextE
$LN304@InputTextE:
	xor	dil, dil
	jmp	SHORT $LN306@InputTextE
$LN305@InputTextE:
	mov	dil, 1
$LN306@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 513				; 00000201H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4482 :         if (IsKeyPressed(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }

	test	al, al
	je	SHORT $LN79@InputTextE
	cmp	BYTE PTR is_startend_key_down$1$[rsp], 0
	je	SHORT $LN307@InputTextE
	mov	eax, 2097156				; 00200004H
	jmp	SHORT $LN308@InputTextE
$LN307@InputTextE:
	mov	eax, 2097152				; 00200000H
	cmp	BYTE PTR is_wordmove_key_down$1$[rsp], 0
	mov	ecx, 2097164				; 0020000cH
	cmovne	eax, ecx
$LN308@InputTextE:
	or	ebx, eax
$LN1570@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, ebx
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key
$LN1586@InputTextE:
	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	mov	BYTE PTR [rsi+3716], 1
$LN1571@InputTextE:
	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1567@InputTextE
$LN79@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 514				; 00000202H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4483 :         else if (IsKeyPressed(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }

	test	al, al
	je	SHORT $LN81@InputTextE
	cmp	BYTE PTR is_startend_key_down$1$[rsp], 0
	je	SHORT $LN309@InputTextE
	mov	ecx, 2097157				; 00200005H
	or	ebx, ecx
	jmp	SHORT $LN1570@InputTextE
$LN309@InputTextE:
	mov	ecx, 2097153				; 00200001H
	mov	eax, 2097165				; 0020000dH
	cmp	BYTE PTR is_wordmove_key_down$1$[rsp], 0
	cmovne	ecx, eax
	or	ebx, ecx
	jmp	SHORT $LN1570@InputTextE
$LN81@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 515				; 00000203H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4484 :         else if (IsKeyPressed(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }

	test	al, al
	je	$LN83@InputTextE
	cmp	BYTE PTR tv11239[rsp], 0
	je	SHORT $LN83@InputTextE
	mov	r12, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR [r12+3624], 0
	je	SHORT $LN85@InputTextE
	mov	r8, QWORD PTR draw_window$1$[rbp-256]
	movss	xmm0, DWORD PTR [r8+188]
	subss	xmm0, DWORD PTR [r12+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10723:     window->ScrollTarget.y = scroll_y;

	movss	DWORD PTR [r8+204], xmm0

; 10724:     window->ScrollTargetCenterRatio.y = 0.0f;

	xor	eax, eax
	mov	DWORD PTR [r8+212], eax

; 10725:     window->ScrollTargetEdgeSnapDist.y = 0.0f;

	mov	DWORD PTR [r8+220], eax

; 10726: }

	jmp	$LN1567@InputTextE
$LN85@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4484 :         else if (IsKeyPressed(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }

	movzx	eax, BYTE PTR is_startend_key_down$1$[rsp]
	lea	r8d, DWORD PTR [rax*4+2097154]
$LN1572@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	or	r8d, ebx
$LN1574@InputTextE:
	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key
	mov	BYTE PTR [rsi+3716], 1
	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	jmp	$LN1567@InputTextE
$LN83@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 516				; 00000204H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4485 :         else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

	test	al, al
	je	SHORT $LN87@InputTextE
	cmp	BYTE PTR tv11239[rsp], 0
	je	SHORT $LN87@InputTextE
	mov	r12, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR [r12+3624], 0
	je	SHORT $LN89@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10710:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4485 :         else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

	movss	xmm0, DWORD PTR [r12+15696]
	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	addss	xmm0, DWORD PTR [rax+188]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, DWORD PTR [rcx+196]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10723:     window->ScrollTarget.y = scroll_y;

	movss	DWORD PTR [rax+204], xmm0

; 10724:     window->ScrollTargetCenterRatio.y = 0.0f;

	xor	ecx, ecx
	mov	DWORD PTR [rax+212], ecx

; 10725:     window->ScrollTargetEdgeSnapDist.y = 0.0f;

	mov	DWORD PTR [rax+220], ecx

; 10726: }

	jmp	$LN1567@InputTextE
$LN89@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4485 :         else if (IsKeyPressed(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

	movzx	eax, BYTE PTR is_startend_key_down$1$[rsp]
	lea	r8d, DWORD PTR [rax*4+2097155]
	jmp	$LN1572@InputTextE
$LN87@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 517				; 00000205H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4486 :         else if (IsKeyPressed(ImGuiKey_PageUp) && is_multiline)      { state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= row_count_per_page * g.FontSize; }

	test	al, al
	je	SHORT $LN91@InputTextE
	cmp	BYTE PTR tv11239[rsp], 0
	je	SHORT $LN91@InputTextE
	or	ebx, 2097166				; 0020000eH

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, ebx
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	movd	xmm0, DWORD PTR row_count_per_page$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4486 :         else if (IsKeyPressed(ImGuiKey_PageUp) && is_multiline)      { state->OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= row_count_per_page * g.FontSize; }

	cvtdq2ps xmm0, xmm0
	mov	r12, QWORD PTR g$1$[rsp]
	mulss	xmm0, DWORD PTR [r12+15696]
	subss	xmm9, xmm0
	jmp	$LN1567@InputTextE
$LN91@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 518				; 00000206H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4487 :         else if (IsKeyPressed(ImGuiKey_PageDown) && is_multiline)    { state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += row_count_per_page * g.FontSize; }

	test	al, al
	je	SHORT $LN93@InputTextE
	cmp	BYTE PTR tv11239[rsp], 0
	je	SHORT $LN93@InputTextE
	or	ebx, 2097167				; 0020000fH

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, ebx
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
	movd	xmm0, DWORD PTR row_count_per_page$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4487 :         else if (IsKeyPressed(ImGuiKey_PageDown) && is_multiline)    { state->OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += row_count_per_page * g.FontSize; }

	cvtdq2ps xmm0, xmm0
	mov	r12, QWORD PTR g$1$[rsp]
	mulss	xmm0, DWORD PTR [r12+15696]
	addss	xmm9, xmm0
	jmp	$LN1567@InputTextE
$LN93@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 519				; 00000207H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4488 :         else if (IsKeyPressed(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }

	test	al, al
	je	SHORT $LN95@InputTextE
	mov	eax, ebx
	or	eax, 2097158				; 00200006H
	or	ebx, 2097156				; 00200004H
	mov	r12, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR [r12+3624], 0
	cmovne	ebx, eax

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, ebx

; 4488 :         else if (IsKeyPressed(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }

	jmp	$LN1574@InputTextE
$LN95@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 520				; 00000208H
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4489 :         else if (IsKeyPressed(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }

	test	al, al
	je	SHORT $LN97@InputTextE
	mov	eax, ebx
	or	eax, 2097159				; 00200007H
	mov	r8d, 2097157				; 00200005H
	or	r8d, ebx
	mov	r12, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR [r12+3624], 0
	cmovne	r8d, eax
	jmp	$LN1574@InputTextE
$LN97@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 522				; 0000020aH
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4490 :         else if (IsKeyPressed(ImGuiKey_Delete) && !is_readonly && !is_cut)

	test	al, al
	je	SHORT $LN99@InputTextE
	cmp	BYTE PTR tv11237[rsp], 0
	jne	SHORT $LN99@InputTextE
	cmp	BYTE PTR is_cut$1$[rbp-256], 0
	jne	SHORT $LN99@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4492 :             if (!state->HasSelection())

	jne	SHORT $LN102@InputTextE

; 4493 :             {
; 4494 :                 // OSX doesn't seem to have Super+Delete to delete until end-of-line, so we don't emulate that (as opposed to Super+Backspace)
; 4495 :                 if (is_wordmove_key_down)

	cmp	BYTE PTR is_wordmove_key_down$1$[rsp], 0
	je	SHORT $LN102@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, 6291469				; 0060000dH
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
$LN102@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4498 :             state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask);

	or	ebx, 2097160				; 00200008H

; 4499 :         }

	jmp	$LN1570@InputTextE
$LN99@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	xor	edx, edx
	mov	ecx, 523				; 0000020bH
	lea	r8d, QWORD PTR [rdx+1]
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4500 :         else if (IsKeyPressed(ImGuiKey_Backspace) && !is_readonly)

	mov	r8d, DWORD PTR tv11237[rsp]
	test	al, al
	je	$LN103@InputTextE
	test	r8b, r8b
	jne	$LN103@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4502 :             if (!state->HasSelection())

	jne	SHORT $LN1520@InputTextE

; 4503 :             {
; 4504 :                 if (is_wordmove_key_down)

	cmp	BYTE PTR is_wordmove_key_down$1$[rsp], r8b
	je	SHORT $LN106@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, 6291468				; 0060000cH
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
$LN1520@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4509 :             state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);

	mov	r12, QWORD PTR g$1$[rsp]
$LN108@InputTextE:
	or	ebx, 2097161				; 00200009H

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, ebx

; 4510 :         }

	jmp	$LN1574@InputTextE
$LN106@InputTextE:

; 4505 :                     state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
; 4506 :                 else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)

	cmp	BYTE PTR is_osx$1$[rbp-256], 0
	je	SHORT $LN1520@InputTextE
	mov	r12, QWORD PTR g$1$[rsp]
	cmp	BYTE PTR [r12+3627], 0
	je	SHORT $LN108@InputTextE
	cmp	BYTE PTR [r12+3626], 0
	jne	SHORT $LN108@InputTextE
	cmp	BYTE PTR [r12+3624], 0
	jne	SHORT $LN108@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	r8d, 6291460				; 00600004H
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key

; 3882 :     CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4509 :             state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);

	or	ebx, 2097161				; 00200009H

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, ebx

; 4510 :         }

	jmp	$LN1574@InputTextE
$LN103@InputTextE:

; 4511 :         else if (is_enter_pressed || is_gamepad_validate)

	test	r15b, r15b
	jne	$LN111@InputTextE
	test	r14b, r14b
	jne	$LN111@InputTextE

; 4527 :                     state->OnKeyPressed((int)c);
; 4528 :             }
; 4529 :         }
; 4530 :         else if (is_cancel)

	test	dil, dil
	je	SHORT $LN120@InputTextE

; 4531 :         {
; 4532 :             if (flags & ImGuiInputTextFlags_EscapeClearsAll)

	test	DWORD PTR flags$1$[rsp], 1048576	; 00100000H
	je	SHORT $LN122@InputTextE

; 4533 :             {
; 4534 :                 if (buf[0] != 0)

	mov	rax, QWORD PTR text_remaining$1$[rbp-256]
	movzx	eax, BYTE PTR [rax]
	test	al, al
	jne	SHORT $LN1568@InputTextE

; 4535 :                 {
; 4536 :                     revert_edit = true;
; 4537 :                 }
; 4538 :                 else
; 4539 :                 {
; 4540 :                     render_cursor = render_selection = false;

	xor	cl, cl
	mov	DWORD PTR tv11311[rsp], ecx
	mov	BYTE PTR render_cursor$1$[rsp], cl

; 4541 :                     clear_active_id = true;

	mov	BYTE PTR clear_active_id$1$[rsp], 1

; 4542 :                 }
; 4543 :             }

	test	al, al
$LN1568@InputTextE:
	setne	dil
	mov	BYTE PTR revert_edit$1$[rbp-256], dil
	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1569@InputTextE
$LN122@InputTextE:

; 4544 :             else
; 4545 :             {
; 4546 :                 clear_active_id = revert_edit = true;

	mov	dil, 1
	mov	BYTE PTR revert_edit$1$[rbp-256], dil
	mov	BYTE PTR clear_active_id$1$[rsp], dil

; 4547 :                 render_cursor = render_selection = false;

	xor	cl, cl
	xor	dl, dl
	mov	BYTE PTR render_cursor$1$[rsp], dl

; 4548 :             }
; 4549 :         }

	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN117@InputTextE
$LN120@InputTextE:

; 4550 :         else if (is_undo || is_redo)

	movzx	eax, BYTE PTR is_undo$1$[rbp-256]
	test	al, al
	jne	$LN128@InputTextE
	test	r12b, r12b
	jne	$LN128@InputTextE

; 4555 :         else if (is_select_all)

	test	r13b, r13b
	je	SHORT $LN129@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1128 :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

	xor	eax, eax
	mov	DWORD PTR [rsi+88], eax
	mov	eax, DWORD PTR [rsi+12]
	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+106], r12b

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	BYTE PTR [rsi+3716], 1
	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1567@InputTextE
$LN129@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4560 :         else if (is_cut || is_copy)

	movzx	r12d, BYTE PTR is_cut$1$[rbp-256]
	test	r12b, r12b
	jne	$LN133@InputTextE
	cmp	BYTE PTR is_copy$1$[rbp-256], r12b
	jne	$LN133@InputTextE

; 4578 :                 stb_textedit_cut(state, &state->Stb);
; 4579 :             }
; 4580 :         }
; 4581 :         else if (is_paste)

	cmp	BYTE PTR is_paste$1$[rsp], r12b
	je	$LN1571@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4319 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4320 :     return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";

	mov	rax, QWORD PTR [rcx+176]
	test	rax, rax
	je	SHORT $LN1309@InputTextE
	mov	rcx, QWORD PTR [rcx+192]
	call	rax
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4583 :             if (const char* clipboard = GetClipboardText())

	test	rax, rax
	je	$LN1571@InputTextE
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN1430@InputTextE
$LN1309@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4320 :     return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";

	lea	rbx, OFFSET FLAT:??_C@_00CNPNBAHC@@
$LN1430@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4586 :                 const int clipboard_len = (int)strlen(clipboard);

	mov	rax, -1
	npad	2
$LL1478@InputTextE:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL1478@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rcx, rcx
	je	SHORT $LN1312@InputTextE

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rcx+244]
$LN1312@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4587 :                 ImWchar* clipboard_filtered = (ImWchar*)IM_ALLOC((clipboard_len + 1) * sizeof(ImWchar));

	inc	eax
	movsxd	rcx, eax
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	r15, rax
	mov	QWORD PTR clipboard_filtered$1$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4588 :                 int clipboard_filtered_len = 0;

	xor	r12d, r12d
	mov	r14d, r12d

; 4589 :                 for (const char* s = clipboard; *s != 0; )

	cmp	BYTE PTR [rbx], r12b
	je	SHORT $LN6@InputTextE

; 4468 :         const bool is_cut   = (Shortcut(ImGuiMod_Shortcut | ImGuiKey_X, id, f_repeat) || Shortcut(ImGuiMod_Shift | ImGuiKey_Delete, id, f_repeat)) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());

	mov	rdi, rax
	mov	r13, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	mov	r15, QWORD PTR callback$GSCopy$1$[rbp-256]
	mov	esi, DWORD PTR flags$1$[rsp]
	npad	13
$LL5@InputTextE:

; 4590 :                 {
; 4591 :                     unsigned int c;
; 4592 :                     s += ImTextCharFromUtf8(&c, s, NULL);

	xor	r8d, r8d
	mov	rdx, rbx
	lea	rcx, QWORD PTR c$18[rbp-256]
	call	?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z	; ImTextCharFromUtf8
	movsxd	rcx, eax
	add	rbx, rcx

; 4593 :                     if (!InputTextFilterCharacter(&c, flags, callback, callback_user_data, ImGuiInputSource_Clipboard))

	mov	DWORD PTR [rsp+32], 4
	mov	r9, r13
	mov	r8, r15
	mov	edx, esi
	lea	rcx, QWORD PTR c$18[rbp-256]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z ; InputTextFilterCharacter
	test	al, al
	je	SHORT $LN1356@InputTextE

; 4594 :                         continue;
; 4595 :                     clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;

	movzx	eax, WORD PTR c$18[rbp-256]
	mov	WORD PTR [rdi], ax
	inc	r14d
	add	rdi, 2
$LN1356@InputTextE:

; 4589 :                 for (const char* s = clipboard; *s != 0; )

	cmp	BYTE PTR [rbx], r12b
	jne	SHORT $LL5@InputTextE
	mov	rsi, QWORD PTR state$1$[rbp-256]
	mov	r15, QWORD PTR clipboard_filtered$1$[rbp-256]
$LN6@InputTextE:

; 4596 :                 }
; 4597 :                 clipboard_filtered[clipboard_filtered_len] = 0;

	movsxd	rax, r14d
	mov	WORD PTR [r15+rax*2], r12w

; 4598 :                 if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation

	test	r14d, r14d
	jle	$LN140@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rsi+12]

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rsi+92]
	mov	eax, DWORD PTR [rsi+88]
	cmp	eax, r8d
	je	SHORT $LN1290@InputTextE

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, eax
	cmp	eax, ecx
	jle	SHORT $LN1288@InputTextE
	mov	DWORD PTR [rsi+88], ecx
	mov	edx, ecx
$LN1288@InputTextE:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r9d, r8d
	cmp	r8d, ecx
	jle	SHORT $LN1446@InputTextE
	mov	DWORD PTR [rsi+92], ecx
	mov	r9d, ecx
$LN1446@InputTextE:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	r8d, r9d
	mov	eax, edx
	cmp	edx, r9d
	jne	SHORT $LN1290@InputTextE

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rsi+84], edx
$LN1290@InputTextE:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	mov	r9d, DWORD PTR [rsi+84]
	cmp	r9d, ecx
	jle	SHORT $LN1291@InputTextE
	mov	DWORD PTR [rsi+84], ecx
	mov	r9d, ecx
$LN1291@InputTextE:

; 572  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	eax, r8d
	je	SHORT $LN1302@InputTextE

; 573  :       if (state->select_start > n) state->select_start = n;

	mov	edx, eax
	cmp	eax, ecx
	jle	SHORT $LN1445@InputTextE
	mov	DWORD PTR [rsi+88], ecx
	mov	edx, ecx
$LN1445@InputTextE:

; 574  :       if (state->select_end   > n) state->select_end = n;

	mov	r10d, r8d
	cmp	r8d, ecx
	jle	SHORT $LN1444@InputTextE
	mov	DWORD PTR [rsi+92], ecx
	mov	r10d, ecx
$LN1444@InputTextE:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	mov	r8d, r10d
	mov	eax, edx
	cmp	edx, r10d
	jne	SHORT $LN1302@InputTextE

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rsi+84], edx
	mov	r9d, edx
$LN1302@InputTextE:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	r9d, ecx
	jle	SHORT $LN1303@InputTextE
	mov	DWORD PTR [rsi+84], ecx
$LN1303@InputTextE:

; 594  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	eax, r8d
	je	SHORT $LN1447@InputTextE

; 595  :       if (state->select_start < state->select_end) {

	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	jge	SHORT $LN1295@InputTextE

; 596  :          stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

	sub	r8d, eax
	mov	r9d, r8d
	mov	r8d, eax
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 597  :          state->select_end = state->cursor = state->select_start;

	mov	eax, DWORD PTR [rsi+88]
	mov	DWORD PTR [rsi+92], eax

; 598  :       } else {

	jmp	SHORT $LN1296@InputTextE
$LN1295@InputTextE:

; 599  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	sub	eax, r8d
	mov	r9d, eax
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 600  :          state->select_start = state->cursor = state->select_end;

	mov	eax, DWORD PTR [rsi+92]
	mov	DWORD PTR [rsi+88], eax
$LN1296@InputTextE:

; 601  :       }
; 602  :       state->has_preferred_x = 0;

	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+106], r12b
$LN1447@InputTextE:

; 705  :    if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

	mov	r9d, r14d
	mov	r8, r15
	mov	edx, DWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?STB_TEXTEDIT_INSERTCHARS@ImStb@@YA_NPEAUImGuiInputTextState@@HPEBGH@Z ; ImStb::STB_TEXTEDIT_INSERTCHARS
	test	al, al
	je	SHORT $LN1284@InputTextE

; 1334 :    stb_text_createundo(&state->undostate, where, 0, length);

	lea	rcx, QWORD PTR [rsi+116]
	mov	r9d, r14d
	xor	r8d, r8d
	mov	edx, DWORD PTR [rsi+84]
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo

; 707  :       state->cursor += len;

	add	DWORD PTR [rsi+84], r14d

; 708  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rsi+106], r12b
$LN1284@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4601 :                     state->CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
$LN140@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	r15, r15
	je	SHORT $LN1269@InputTextE

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN1269@InputTextE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN1269@InputTextE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, r15
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1567@InputTextE
$LN133@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4563 :             if (io.SetClipboardTextFn)

	mov	rax, QWORD PTR g$1$[rsp]
	cmp	QWORD PTR [rax+184], 0
	je	$LN1549@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	mov	ecx, DWORD PTR [rsi+88]
	cmp	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4565 :                 const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;

	je	SHORT $LN315@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	edx, eax
	cmovl	edx, ecx

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmovge	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4566 :                 const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;

	xor	r13d, r13d
	jmp	SHORT $LN318@InputTextE
$LN315@InputTextE:

; 4565 :                 const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;

	xor	r13d, r13d
	mov	edx, r13d

; 4566 :                 const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;

	mov	eax, DWORD PTR [rsi+12]
$LN318@InputTextE:

; 4567 :                 const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;

	movsxd	r14, eax
	mov	rax, QWORD PTR [rsi+32]
	lea	r8, QWORD PTR [rax+r14*2]
	movsxd	r15, edx
	lea	rdx, QWORD PTR [rax+r15*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	ecx, r13d
	mov	r9d, 2048				; 00000800H
	mov	r10d, 128				; 00000080H
$LL1244@InputTextE:

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	r8, r8
	je	SHORT $LN1246@InputTextE
	cmp	rdx, r8
	jae	SHORT $LN1245@InputTextE
$LN1246@InputTextE:
	movzx	eax, WORD PTR [rdx]
	test	ax, ax
	je	SHORT $LN1245@InputTextE

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	rdx, 2

; 2318 :         if (c < 0x80)

	cmp	ax, r10w
	jae	SHORT $LN1250@InputTextE

; 2319 :             bytes_count++;

	inc	ecx
	jmp	SHORT $LL1244@InputTextE
$LN1250@InputTextE:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r9w
	sbb	eax, eax
	add	eax, 3
	add	ecx, eax

; 2322 :     }

	jmp	SHORT $LL1244@InputTextE
$LN1245@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4567 :                 const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;

	lea	edi, DWORD PTR [rcx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN1257@InputTextE

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN1257@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4568 :                 char* clipboard_data = (char*)IM_ALLOC(clipboard_data_len * sizeof(char));

	movsxd	rcx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4569 :                 ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);

	mov	rcx, QWORD PTR [rsi+32]
	lea	r9, QWORD PTR [rcx+r14*2]
	lea	r8, QWORD PTR [rcx+r15*2]
	mov	edx, edi
	mov	rcx, rax
	call	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z	; ImTextStrToUtf8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4325 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4326 :     if (g.IO.SetClipboardTextFn)

	mov	rax, QWORD PTR [r9+184]
	test	rax, rax
	je	SHORT $LN1237@InputTextE

; 4327 :         g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);

	mov	rdx, rbx
	mov	rcx, QWORD PTR [r9+192]
	call	rax
	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN1237@InputTextE:

; 4311 :     if (ptr)

	test	rbx, rbx
	je	SHORT $LN1230@InputTextE

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	r9, r9
	je	SHORT $LN1230@InputTextE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [r9+244]
$LN1230@InputTextE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4563 :             if (io.SetClipboardTextFn)

	jmp	SHORT $LN1232@InputTextE
$LN1549@InputTextE:
	xor	r13d, r13d
$LN1232@InputTextE:

; 4570 :                 SetClipboardText(clipboard_data);
; 4571 :                 MemFree(clipboard_data);
; 4572 :             }
; 4573 :             if (is_cut)

	test	r12b, r12b
	je	$LN1571@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4575 :                 if (!state->HasSelection())

	jne	SHORT $LN1448@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1128 :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

	mov	DWORD PTR [rsi+88], r13d
	mov	eax, DWORD PTR [rsi+12]
	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+106], 0
$LN1448@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4577 :                 state->CursorFollow = true;

	mov	BYTE PTR [rsi+3716], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 690  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	r8d, DWORD PTR [rsi+92]
	mov	eax, DWORD PTR [rsi+88]
	cmp	eax, r8d
	je	$LN1571@InputTextE

; 571  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR [rsi+12]

; 573  :       if (state->select_start > n) state->select_start = n;

	cmp	eax, ecx
	jle	SHORT $LN1221@InputTextE
	mov	DWORD PTR [rsi+88], ecx
	mov	eax, ecx
$LN1221@InputTextE:

; 574  :       if (state->select_end   > n) state->select_end = n;

	cmp	r8d, ecx
	jle	SHORT $LN1222@InputTextE
	mov	DWORD PTR [rsi+92], ecx
	mov	r8d, ecx
$LN1222@InputTextE:

; 575  :       // if clamping forced them to be equal, move the cursor to match
; 576  :       if (state->select_start == state->select_end)

	cmp	eax, r8d
	jne	SHORT $LN1449@InputTextE

; 577  :          state->cursor = state->select_start;

	mov	DWORD PTR [rsi+84], eax
$LN1449@InputTextE:

; 578  :    }
; 579  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [rsi+84], ecx
	jle	SHORT $LN1224@InputTextE
	mov	DWORD PTR [rsi+84], ecx
$LN1224@InputTextE:

; 594  :    if (STB_TEXT_HAS_SELECTION(state)) {

	cmp	eax, r8d
	je	SHORT $LN1450@InputTextE

; 595  :       if (state->select_start < state->select_end) {

	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	jge	SHORT $LN1216@InputTextE

; 596  :          stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

	sub	r8d, eax
	mov	r9d, r8d
	mov	r8d, eax
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 597  :          state->select_end = state->cursor = state->select_start;

	mov	eax, DWORD PTR [rsi+88]
	mov	DWORD PTR [rsi+92], eax

; 601  :       }
; 602  :       state->has_preferred_x = 0;

	mov	DWORD PTR [rsi+84], eax

; 692  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rsi+106], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1567@InputTextE
$LN1216@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 599  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	sub	eax, r8d
	mov	r9d, eax
	call	?stb_textedit_delete@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@HH@Z ; ImStb::stb_textedit_delete

; 600  :          state->select_start = state->cursor = state->select_end;

	mov	eax, DWORD PTR [rsi+92]
	mov	DWORD PTR [rsi+88], eax

; 601  :       }
; 602  :       state->has_preferred_x = 0;

	mov	DWORD PTR [rsi+84], eax
$LN1450@InputTextE:

; 692  :       state->has_preferred_x = 0;

	mov	BYTE PTR [rsi+106], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	mov	r12, QWORD PTR g$1$[rsp]
	jmp	$LN1567@InputTextE
$LN128@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4552 :             state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);

	mov	r8d, eax
	xor	r8d, 1
	add	r8d, 2097162				; 0020000aH

; 3881 :     stb_textedit_key(this, &Stb, key);

	lea	rdx, QWORD PTR [rsi+84]
	mov	rcx, rsi
	call	?stb_textedit_key@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@H@Z ; ImStb::stb_textedit_key
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1124 :     void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }

	mov	eax, DWORD PTR [rsi+84]
	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4554 :         }

	jmp	$LN1586@InputTextE
$LN111@InputTextE:

; 4512 :         {
; 4513 :             // Determine if we turn Enter into a \n character
; 4514 :             bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;

	mov	edx, DWORD PTR flags$1$[rsp]
	mov	eax, edx
	shr	eax, 11
	and	al, 1

; 4515 :             if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	mov	ecx, DWORD PTR tv11239[rsp]
	mov	r12, QWORD PTR g$1$[rsp]
	test	cl, cl
	je	SHORT $LN114@InputTextE
	test	r14b, r14b
	jne	SHORT $LN114@InputTextE
	test	al, al
	je	SHORT $LN1422@InputTextE
	cmp	BYTE PTR [r12+3624], r14b
	jne	SHORT $LN112@InputTextE
$LN114@InputTextE:

; 4516 :             {
; 4517 :                 validated = true;

	mov	BYTE PTR validated$1$[rsp], 1

; 4518 :                 if (io.ConfigInputTextEnterKeepActive && !is_multiline)

	cmp	BYTE PTR [r12+100], 0
	je	SHORT $LN116@InputTextE
	test	cl, cl
	jne	SHORT $LN116@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1128 :     void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }

	xor	eax, eax
	mov	DWORD PTR [rsi+88], eax
	mov	eax, DWORD PTR [rsi+12]
	mov	DWORD PTR [rsi+92], eax
	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+106], cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4519 :                     state->SelectAll(); // No need to scroll

	jmp	SHORT $LN1567@InputTextE
$LN1422@InputTextE:

; 4515 :             if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	cmp	BYTE PTR [r12+3624], 0
	jne	SHORT $LN114@InputTextE
$LN112@InputTextE:

; 4522 :             }
; 4523 :             else if (!is_readonly)

	test	r8b, r8b
	jne	$LN1571@InputTextE

; 4524 :             {
; 4525 :                 unsigned int c = '\n'; // Insert new line

	mov	DWORD PTR c$19[rbp-256], 10

; 4526 :                 if (InputTextFilterCharacter(&c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))

	mov	DWORD PTR [rsp+32], 2
	mov	r9, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	mov	r8, QWORD PTR callback$GSCopy$1$[rbp-256]
	lea	rcx, QWORD PTR c$19[rbp-256]
	call	?InputTextFilterCharacter@@YA_NPEAIHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAXW4ImGuiInputSource@@@Z ; InputTextFilterCharacter
	test	al, al
	je	$LN1571@InputTextE

; 3881 :     stb_textedit_key(this, &Stb, key);

	mov	r8d, DWORD PTR c$19[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	jmp	$LN1574@InputTextE
$LN116@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4521 :                     clear_active_id = true;

	mov	BYTE PTR clear_active_id$1$[rsp], 1
$LN1567@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1123 :     bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }

	xor	dil, dil
$LN1569@InputTextE:
	mov	ecx, DWORD PTR tv11311[rsp]
	movzx	edx, BYTE PTR render_cursor$1$[rsp]
$LN117@InputTextE:
	mov	eax, DWORD PTR [rsi+92]
	cmp	DWORD PTR [rsi+88], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4608 :         render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);

	je	SHORT $LN320@InputTextE
	test	dl, dl
	je	SHORT $LN320@InputTextE
	mov	al, 1
	jmp	SHORT $LN321@InputTextE
$LN320@InputTextE:
	xor	al, al
$LN321@InputTextE:
	or	cl, al
	mov	DWORD PTR tv11311[rsp], ecx
	mov	r14d, DWORD PTR id$1$[rsp]
$LN78@InputTextE:

; 4609 :     }
; 4610 : 
; 4611 :     // Process callbacks and apply result back to user's buffer.
; 4612 :     const char* apply_new_text = NULL;

	xor	r10d, r10d
	mov	QWORD PTR apply_new_text$1$[rbp-256], r10

; 4613 :     int apply_new_text_length = 0;

	mov	DWORD PTR apply_new_text_length$1$[rbp-256], r10d

; 4614 :     if (g.ActiveId == id)

	cmp	DWORD PTR [r12+16504], r14d
	jne	$LN1510@InputTextE

; 4615 :     {
; 4616 :         IM_ASSERT(state != NULL);
; 4617 :         if (revert_edit && !is_readonly)

	mov	r15d, DWORD PTR tv11237[rsp]
	test	r15b, r15b
	jne	$LN147@InputTextE
	test	dil, dil
	je	$LN1022@InputTextE

; 4618 :         {
; 4619 :             if (flags & ImGuiInputTextFlags_EscapeClearsAll)

	test	DWORD PTR flags$1$[rsp], 1048576	; 00100000H
	je	SHORT $LN143@InputTextE

; 4620 :             {
; 4621 :                 // Clear input
; 4622 :                 IM_ASSERT(buf[0] != 0);
; 4623 :                 apply_new_text = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR apply_new_text$1$[rbp-256], rax

; 4624 :                 apply_new_text_length = 0;

	mov	DWORD PTR apply_new_text_length$1$[rbp-256], r10d

; 4625 :                 value_changed = true;

	mov	BYTE PTR value_changed$1$[rsp], 1

; 3863 :     stb_text_makeundo_replace(str, state, 0, str->CurLenW, text_len);

	movsxd	rbx, DWORD PTR [rsi+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1350 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	lea	rcx, QWORD PTR [rsi+116]
	xor	r9d, r9d
	mov	r8d, ebx
	xor	edx, edx
	call	?stb_text_createundo@ImStb@@YAPEAGPEAUStbUndoState@1@HHH@Z ; ImStb::stb_text_createundo
	mov	r9, rax

; 1351 :    if (p) {

	test	rax, rax
	je	SHORT $LN962@InputTextE

; 1352 :       for (i=0; i < old_length; ++i)

	test	ebx, ebx
	jle	SHORT $LN962@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4515 :             if (!is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	xor	eax, eax
	mov	edx, eax
	npad	13
$LL963@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imstb_textedit.h

; 1353 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	mov	rcx, QWORD PTR [rsi+32]
	movzx	eax, WORD PTR [rcx+rdx*2]
	mov	WORD PTR [r9+rdx*2], ax

; 1352 :       for (i=0; i < old_length; ++i)

	inc	rdx
	cmp	rdx, rbx
	jl	SHORT $LL963@InputTextE
$LN962@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3864 :     ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str->CurLenW);

	mov	r8d, DWORD PTR [rsi+12]
	xor	edx, edx
	mov	rcx, rsi
	call	?STB_TEXTEDIT_DELETECHARS@ImStb@@YAXPEAUImGuiInputTextState@@HH@Z ; ImStb::STB_TEXTEDIT_DELETECHARS

; 3865 :     state->cursor = state->select_start = state->select_end = 0;

	xor	eax, eax
	mov	QWORD PTR [rsi+88], rax
	mov	DWORD PTR [rsi+84], eax

; 4626 :                 STB_TEXTEDIT_CHARTYPE empty_string;
; 4627 :                 stb_textedit_replace(state, &state->Stb, &empty_string, 0);
; 4628 :             }

	jmp	$LN1022@InputTextE
$LN143@InputTextE:

; 4629 :             else if (strcmp(buf, state->InitialTextA.Data) != 0)

	mov	r9, QWORD PTR [rsi+64]
	mov	rax, QWORD PTR text_remaining$1$[rbp-256]
	mov	r8, r9
	sub	r8, rax
	npad	1
$LL1476@InputTextE:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1477@InputTextE
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1476@InputTextE
$LN1477@InputTextE:
	test	edx, edx
	je	$LN1022@InputTextE

; 4630 :             {
; 4631 :                 // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
; 4632 :                 // Push records into the undo stack so we can CTRL+Z the revert operation itself
; 4633 :                 apply_new_text = state->InitialTextA.Data;

	mov	r12, r9
	mov	QWORD PTR apply_new_text$1$[rbp-256], r9

; 4634 :                 apply_new_text_length = state->InitialTextA.Size - 1;

	mov	r13d, DWORD PTR [rsi+56]
	dec	r13d
	mov	DWORD PTR apply_new_text_length$1$[rbp-256], r13d

; 4635 :                 value_changed = true;

	mov	BYTE PTR value_changed$1$[rsp], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR w_text$29[rbp-252], r10d
	mov	ebx, r10d
	mov	DWORD PTR w_text$29[rbp-256], ebx
	mov	rdi, r10
	mov	QWORD PTR w_text$29[rbp-248], r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4637 :                 if (apply_new_text_length > 0)

	test	r13d, r13d
	jle	SHORT $LN146@InputTextE

; 4638 :                 {
; 4639 :                     w_text.resize(ImTextCountCharsFromUtf8(apply_new_text, apply_new_text + apply_new_text_length) + 1);

	movsxd	r15, r13d
	add	r15, r9
	mov	rdx, r15
	mov	rcx, r9
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	lea	ebx, DWORD PTR [rax+1]
	test	ebx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	jle	SHORT $LN1067@InputTextE

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r14d, ebx
	cmp	ebx, 8
	mov	eax, 8
	cmovl	r14d, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	r14d, r14d

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN1537@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN1072@InputTextE

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN1072@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, r14d
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR w_text$29[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR w_text$29[rbp-252], r14d
$LN1537@InputTextE:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	r14d, DWORD PTR id$1$[rsp]
$LN1067@InputTextE:
	mov	DWORD PTR w_text$29[rbp-256], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4640 :                     ImTextStrFromUtf8(w_text.Data, w_text.Size, apply_new_text, apply_new_text + apply_new_text_length);

	xor	eax, eax
	mov	QWORD PTR [rsp+32], rax
	mov	r9, r15
	mov	r8, r12
	mov	edx, ebx
	mov	rcx, rdi
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	r15d, DWORD PTR tv11237[rsp]
	xor	r10d, r10d
$LN146@InputTextE:

; 4641 :                 }
; 4642 :                 stb_textedit_replace(state, &state->Stb, w_text.Data, (apply_new_text_length > 0) ? (w_text.Size - 1) : 0);

	lea	r9d, DWORD PTR [rbx-1]
	test	r13d, r13d
	cmovle	r9d, r10d
	lea	rdx, QWORD PTR [rsi+84]
	mov	r8, rdi
	mov	rcx, rsi
	call	?stb_textedit_replace@ImStb@@YAXPEAUImGuiInputTextState@@PEAUSTB_TexteditState@1@PEBGH@Z ; ImStb::stb_textedit_replace
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rdi, rdi
	je	SHORT $LN1028@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN1026@InputTextE

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN1026@InputTextE:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN1028@InputTextE:
	movzx	edi, BYTE PTR revert_edit$1$[rbp-256]
	mov	r12, QWORD PTR g$1$[rsp]
$LN1022@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4649 :             state->TextAIsValid = true;

	mov	BYTE PTR [rsi+72], 1

; 4650 :             state->TextA.resize(state->TextW.Size * 4 + 1);

	mov	edx, DWORD PTR [rsi+24]
	lea	edx, DWORD PTR [rdx*4+1]
	lea	rcx, QWORD PTR [rsi+40]
	call	?resize@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::resize

; 4651 :             ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);

	xor	r9d, r9d
	mov	r8, QWORD PTR [rsi+32]
	mov	edx, DWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [rsi+48]
	call	?ImTextStrToUtf8@@YAHPEADHPEBG1@Z	; ImTextStrToUtf8
$LN147@InputTextE:

; 4652 :         }
; 4653 : 
; 4654 :         // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
; 4655 :         // before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
; 4656 :         // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
; 4657 :         // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
; 4658 :         // (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
; 4659 :         // unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
; 4660 :         const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);

	test	dil, dil
	je	$LN1545@InputTextE
	cmp	BYTE PTR validated$1$[rsp], 0
	je	SHORT $LN1508@InputTextE
	mov	edi, DWORD PTR flags$1$[rsp]
	test	dil, 32					; 00000020H
	jne	$LN325@InputTextE
$LN1508@InputTextE:

; 4753 :             }
; 4754 :         }
; 4755 :     }
; 4756 : 
; 4757 :     // Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
; 4758 :     if (g.InputTextDeactivatedState.ID == id)

	mov	ebx, DWORD PTR tv11229[rbp-256]
	mov	r12, QWORD PTR text_remaining$1$[rbp-256]
	mov	r8d, DWORD PTR tv11237[rsp]
$LN1512@InputTextE:
	mov	r11, QWORD PTR apply_new_text$1$[rbp-256]
	mov	r10d, DWORD PTR apply_new_text_length$1$[rbp-256]
$LN168@InputTextE:
	mov	r13, QWORD PTR g$1$[rsp]
	mov	r15d, DWORD PTR id$1$[rsp]
	cmp	DWORD PTR [r13+23680], r15d
	jne	$LN1550@InputTextE

; 4759 :     {
; 4760 :         if (g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly && strcmp(g.InputTextDeactivatedState.TextA.Data, buf) != 0)

	cmp	DWORD PTR [r13+16504], r15d
	je	SHORT $LN170@InputTextE
	call	?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ ; ImGui::IsItemDeactivatedAfterEdit
	test	al, al
	je	SHORT $LN170@InputTextE
	test	r8b, r8b
	jne	SHORT $LN170@InputTextE
	mov	r9, QWORD PTR [r13+23696]
	mov	rax, r9
	mov	r8, r12
	sub	r8, r9
$LL1472@InputTextE:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1473@InputTextE
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1472@InputTextE
$LN1473@InputTextE:
	test	edx, edx
	je	SHORT $LN170@InputTextE

; 4761 :         {
; 4762 :             apply_new_text = g.InputTextDeactivatedState.TextA.Data;

	mov	r11, r9
	mov	QWORD PTR apply_new_text$1$[rbp-256], r9

; 4763 :             apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1;

	mov	r10d, DWORD PTR [r13+23688]
	dec	r10d

; 4764 :             value_changed = true;

	mov	BYTE PTR value_changed$1$[rsp], 1
$LN170@InputTextE:

; 4765 :             //IMGUI_DEBUG_LOG("InputText(): apply Deactivated data for 0x%08X: \"%.*s\".\n", id, apply_new_text_length, apply_new_text);
; 4766 :         }
; 4767 :         g.InputTextDeactivatedState.ID = 0;

	xor	eax, eax
	mov	DWORD PTR [r13+23680], eax

; 4753 :             }
; 4754 :         }
; 4755 :     }
; 4756 : 
; 4757 :     // Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
; 4758 :     if (g.InputTextDeactivatedState.ID == id)

	jmp	$LN169@InputTextE
$LN1545@InputTextE:

; 4652 :         }
; 4653 : 
; 4654 :         // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
; 4655 :         // before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
; 4656 :         // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
; 4657 :         // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
; 4658 :         // (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
; 4659 :         // unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
; 4660 :         const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);

	mov	edi, DWORD PTR flags$1$[rsp]
$LN325@InputTextE:

; 4669 :             if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0)

	test	edi, 524736				; 000801c0H
	je	$LN1532@InputTextE

; 4670 :             {
; 4671 :                 IM_ASSERT(callback != NULL);
; 4672 : 
; 4673 :                 // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
; 4674 :                 ImGuiInputTextFlags event_flag = 0;
; 4675 :                 ImGuiKey event_key = ImGuiKey_None;

	xor	r13d, r13d
	mov	ebx, r13d

; 4676 :                 if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && Shortcut(ImGuiKey_Tab, id))

	test	dil, 64					; 00000040H
	je	SHORT $LN1484@InputTextE
	xor	r8d, r8d
	mov	edx, r14d
	mov	ecx, 512				; 00000200H
	call	?Shortcut@ImGui@@YA_NHIH@Z		; ImGui::Shortcut
	test	al, al
	je	SHORT $LN1484@InputTextE

; 4677 :                 {
; 4678 :                     event_flag = ImGuiInputTextFlags_CallbackCompletion;

	lea	eax, QWORD PTR [r13+64]

; 4679 :                     event_key = ImGuiKey_Tab;

	mov	ebx, 512				; 00000200H

; 4680 :                 }

	jmp	SHORT $LN1575@InputTextE
$LN1484@InputTextE:

; 4681 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_UpArrow))

	test	dil, dil
	jns	SHORT $LN154@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	mov	r14d, 1
	mov	r8d, r14d
	xor	edx, edx
	mov	ecx, 515				; 00000203H
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4681 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_UpArrow))

	test	al, al
	je	SHORT $LN152@InputTextE

; 4682 :                 {
; 4683 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	r10d, 128				; 00000080H
	mov	eax, r10d

; 4684 :                     event_key = ImGuiKey_UpArrow;

	mov	ebx, 515				; 00000203H

; 4685 :                 }

	jmp	SHORT $LN158@InputTextE
$LN152@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8853 :     return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);

	mov	r8d, r14d
	xor	edx, edx
	mov	ecx, 516				; 00000204H
	call	?IsKeyPressed@ImGui@@YA_NW4ImGuiKey@@IH@Z ; ImGui::IsKeyPressed
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4686 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressed(ImGuiKey_DownArrow))

	test	al, al
	je	SHORT $LN154@InputTextE

; 4687 :                 {
; 4688 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	r10d, 128				; 00000080H
	mov	eax, r10d

; 4689 :                     event_key = ImGuiKey_DownArrow;

	mov	ebx, 516				; 00000204H

; 4690 :                 }

	jmp	SHORT $LN158@InputTextE
$LN154@InputTextE:

; 4691 :                 else if ((flags & ImGuiInputTextFlags_CallbackEdit) && state->Edited)

	mov	eax, 524288				; 00080000H
	test	edi, eax
	je	SHORT $LN156@InputTextE
	cmp	BYTE PTR [rsi+3718], bl
	jne	SHORT $LN1575@InputTextE
$LN156@InputTextE:

; 4692 :                 {
; 4693 :                     event_flag = ImGuiInputTextFlags_CallbackEdit;
; 4694 :                 }
; 4695 :                 else if (flags & ImGuiInputTextFlags_CallbackAlways)

	mov	ecx, 256				; 00000100H
	test	edi, ecx
	mov	eax, r13d
	cmovne	eax, ecx
$LN1575@InputTextE:

; 4696 :                 {
; 4697 :                     event_flag = ImGuiInputTextFlags_CallbackAlways;
; 4698 :                 }
; 4699 : 
; 4700 :                 if (event_flag)

	mov	r10d, 128				; 00000080H
$LN158@InputTextE:
	test	eax, eax
	je	$LN1532@InputTextE

; 3888 :     memset(this, 0, sizeof(*this));

	mov	DWORD PTR callback_data$38[rbp-232], r13d
	mov	QWORD PTR callback_data$38[rbp-207], r13
	mov	DWORD PTR callback_data$38[rbp-199], r13d
	mov	WORD PTR callback_data$38[rbp-195], r13w
	mov	BYTE PTR callback_data$38[rbp-193], r13b

; 4701 :                 {
; 4702 :                     ImGuiInputTextCallbackData callback_data;
; 4703 :                     callback_data.Ctx = &g;

	mov	QWORD PTR callback_data$38[rbp-256], r12

; 4704 :                     callback_data.EventFlag = event_flag;

	mov	DWORD PTR callback_data$38[rbp-248], eax

; 4705 :                     callback_data.Flags = flags;

	mov	DWORD PTR callback_data$38[rbp-244], edi

; 4706 :                     callback_data.UserData = callback_user_data;

	mov	rax, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	mov	QWORD PTR callback_data$38[rbp-240], rax

; 4707 : 
; 4708 :                     char* callback_buf = is_readonly ? buf : state->TextA.Data;

	test	r15b, r15b
	mov	rax, QWORD PTR text_remaining$1$[rbp-256]
	jne	SHORT $LN328@InputTextE
	mov	rax, QWORD PTR [rsi+48]
$LN328@InputTextE:

; 4709 :                     callback_data.EventKey = event_key;

	mov	DWORD PTR callback_data$38[rbp-228], ebx

; 4710 :                     callback_data.Buf = callback_buf;

	mov	QWORD PTR callback_data$38[rbp-224], rax

; 4711 :                     callback_data.BufTextLen = state->CurLenA;

	mov	eax, DWORD PTR [rsi+16]
	mov	DWORD PTR callback_data$38[rbp-216], eax

; 4712 :                     callback_data.BufSize = state->BufCapacityA;

	mov	eax, DWORD PTR [rsi+76]
	mov	DWORD PTR callback_data$38[rbp-212], eax

; 4713 :                     callback_data.BufDirty = false;

	mov	BYTE PTR callback_data$38[rbp-208], r13b

; 4714 : 
; 4715 :                     // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
; 4716 :                     ImWchar* text = state->TextW.Data;

	mov	rdx, QWORD PTR [rsi+32]

; 4717 :                     const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);

	movsxd	rax, DWORD PTR [rsi+84]
	lea	r8, QWORD PTR [rdx+rax*2]
	mov	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	r15d, r13d
	mov	r9d, 2048				; 00000800H
	npad	7
$LL973@InputTextE:

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	r8, r8
	je	SHORT $LN975@InputTextE
	cmp	rcx, r8
	jae	SHORT $LN974@InputTextE
$LN975@InputTextE:
	movzx	eax, WORD PTR [rcx]
	test	ax, ax
	je	SHORT $LN974@InputTextE

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	rcx, 2

; 2318 :         if (c < 0x80)

	cmp	ax, r10w
	jae	SHORT $LN979@InputTextE

; 2319 :             bytes_count++;

	inc	r15d
	jmp	SHORT $LL973@InputTextE
$LN979@InputTextE:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r9w
	sbb	eax, eax
	add	eax, 3
	add	r15d, eax

; 2322 :     }

	jmp	SHORT $LL973@InputTextE
$LN974@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4717 :                     const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);

	mov	DWORD PTR callback_data$38[rbp-204], r15d

; 4718 :                     const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);

	movsxd	rax, DWORD PTR [rsi+88]
	lea	r8, QWORD PTR [rdx+rax*2]
	mov	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	edi, r13d
$LL944@InputTextE:

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	r8, r8
	je	SHORT $LN946@InputTextE
	cmp	rcx, r8
	jae	SHORT $LN945@InputTextE
$LN946@InputTextE:
	movzx	eax, WORD PTR [rcx]
	test	ax, ax
	je	SHORT $LN945@InputTextE

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	rcx, 2

; 2318 :         if (c < 0x80)

	cmp	ax, r10w
	jae	SHORT $LN950@InputTextE

; 2319 :             bytes_count++;

	inc	edi
	jmp	SHORT $LL944@InputTextE
$LN950@InputTextE:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r9w
	sbb	eax, eax
	add	eax, 3
	add	edi, eax

; 2322 :     }

	jmp	SHORT $LL944@InputTextE
$LN945@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4718 :                     const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);

	mov	DWORD PTR callback_data$38[rbp-200], edi

; 4719 :                     const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

	movsxd	rax, DWORD PTR [rsi+92]
	lea	rcx, QWORD PTR [rdx+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2314 :     int bytes_count = 0;

	mov	ebx, r13d
	npad	4
$LL986@InputTextE:

; 2315 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	rcx, rcx
	je	SHORT $LN988@InputTextE
	cmp	rdx, rcx
	jae	SHORT $LN987@InputTextE
$LN988@InputTextE:
	movzx	eax, WORD PTR [rdx]
	test	ax, ax
	je	SHORT $LN987@InputTextE

; 2316 :     {
; 2317 :         unsigned int c = (unsigned int)(*in_text++);

	add	rdx, 2

; 2318 :         if (c < 0x80)

	cmp	ax, r10w
	jae	SHORT $LN992@InputTextE

; 2319 :             bytes_count++;

	inc	ebx
	jmp	SHORT $LL986@InputTextE
$LN992@InputTextE:

; 2320 :         else
; 2321 :             bytes_count += ImTextCountUtf8BytesFromChar(c);

	cmp	ax, r9w
	sbb	eax, eax
	add	eax, 3
	add	ebx, eax

; 2322 :     }

	jmp	SHORT $LL986@InputTextE
$LN987@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4719 :                     const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);

	mov	DWORD PTR callback_data$38[rbp-196], ebx

; 4720 : 
; 4721 :                     // Call user code
; 4722 :                     callback(&callback_data);

	lea	rcx, QWORD PTR callback_data$38[rbp-256]
	call	QWORD PTR callback$GSCopy$1$[rbp-256]

; 4723 : 
; 4724 :                     // Read back what user may have modified
; 4725 :                     callback_buf = is_readonly ? buf : state->TextA.Data; // Pointer may have been invalidated by a resize callback
; 4726 :                     IM_ASSERT(callback_data.Buf == callback_buf);         // Invalid to modify those fields
; 4727 :                     IM_ASSERT(callback_data.BufSize == state->BufCapacityA);
; 4728 :                     IM_ASSERT(callback_data.Flags == flags);
; 4729 :                     const bool buf_dirty = callback_data.BufDirty;
; 4730 :                     if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty)            { state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state->CursorFollow = true; }

	mov	r14, QWORD PTR callback_data$38[rbp-224]
	movzx	r13d, BYTE PTR callback_data$38[rbp-208]
	movsxd	r12, DWORD PTR callback_data$38[rbp-204]
	cmp	r12d, r15d
	jne	SHORT $LN161@InputTextE
	test	r13b, r13b
	je	SHORT $LN1451@InputTextE
$LN161@InputTextE:
	lea	rdx, QWORD PTR [r14+r12]
	mov	rcx, r14
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
	mov	DWORD PTR [rsi+84], eax
	mov	BYTE PTR [rsi+3716], 1
$LN1451@InputTextE:

; 4731 :                     if (callback_data.SelectionStart != utf8_selection_start || buf_dirty)  { state->Stb.select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state->Stb.cursor : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }

	movsxd	r15, DWORD PTR callback_data$38[rbp-200]
	cmp	r15d, edi
	jne	SHORT $LN163@InputTextE
	test	r13b, r13b
	je	SHORT $LN1452@InputTextE
$LN163@InputTextE:
	cmp	r15d, r12d
	jne	SHORT $LN331@InputTextE
	mov	eax, DWORD PTR [rsi+84]
	jmp	SHORT $LN332@InputTextE
$LN331@InputTextE:
	lea	rdx, QWORD PTR [r14+r15]
	mov	rcx, r14
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
$LN332@InputTextE:
	mov	DWORD PTR [rsi+88], eax
$LN1452@InputTextE:

; 4732 :                     if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty)      { state->Stb.select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state->Stb.select_start : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }

	movsxd	rax, DWORD PTR callback_data$38[rbp-196]
	cmp	eax, ebx
	jne	SHORT $LN165@InputTextE
	test	r13b, r13b
	je	SHORT $LN1532@InputTextE
$LN165@InputTextE:
	cmp	eax, r15d
	jne	SHORT $LN333@InputTextE
	mov	eax, DWORD PTR [rsi+88]
	jmp	SHORT $LN334@InputTextE
$LN333@InputTextE:
	lea	rdx, QWORD PTR [r14+rax]
	mov	rcx, r14
	call	?ImTextCountCharsFromUtf8@@YAHPEBD0@Z	; ImTextCountCharsFromUtf8
$LN334@InputTextE:
	mov	DWORD PTR [rsi+92], eax

; 4733 :                     if (buf_dirty)

	test	r13b, r13b
	je	SHORT $LN1532@InputTextE

; 4734 :                     {
; 4735 :                         IM_ASSERT((flags & ImGuiInputTextFlags_ReadOnly) == 0);
; 4736 :                         IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
; 4737 :                         InputTextReconcileUndoStateAfterUserCallback(state, callback_data.Buf, callback_data.BufTextLen); // FIXME: Move the rest of this block inside function and rename to InputTextReconcileStateAfterUserCallback() ?

	mov	r8d, DWORD PTR callback_data$38[rbp-216]
	mov	rdx, r14
	mov	rcx, rsi
	call	?InputTextReconcileUndoStateAfterUserCallback@@YAXPEAUImGuiInputTextState@@PEBDH@Z ; InputTextReconcileUndoStateAfterUserCallback

; 4738 :                         if (callback_data.BufTextLen > backup_current_text_length && is_resizable)

	mov	edx, DWORD PTR callback_data$38[rbp-216]
	mov	eax, DWORD PTR backup_current_text_length$1$[rbp-256]
	mov	ebx, DWORD PTR tv11229[rbp-256]
	cmp	edx, eax
	jle	SHORT $LN167@InputTextE
	test	bl, bl
	je	SHORT $LN167@InputTextE

; 4739 :                             state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length)); // Worse case scenario resize

	lea	rcx, QWORD PTR [rsi+24]
	sub	edx, eax
	add	edx, DWORD PTR [rcx]
	call	?resize@?$ImVector@G@@QEAAXH@Z		; ImVector<unsigned short>::resize
$LN167@InputTextE:

; 4740 :                         state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);

	xor	eax, eax
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR callback_data$38[rbp-224]
	mov	edx, DWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rsi+32]
	call	?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z ; ImTextStrFromUtf8
	mov	DWORD PTR [rsi+12], eax

; 4741 :                         state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()

	mov	eax, DWORD PTR callback_data$38[rbp-216]
	mov	DWORD PTR [rsi+16], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1121 :     void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [rsi+3712], -1097229926	; be99999aH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4669 :             if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0)

	jmp	SHORT $LN1485@InputTextE
$LN1532@InputTextE:

; 4742 :                         state->CursorAnimReset();
; 4743 :                     }
; 4744 :                 }
; 4745 :             }
; 4746 : 
; 4747 :             // Will copy result string if modified
; 4748 :             if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)

	mov	ebx, DWORD PTR tv11229[rbp-256]
$LN1485@InputTextE:
	mov	r8d, DWORD PTR tv11237[rsp]
	mov	r12, QWORD PTR text_remaining$1$[rbp-256]
	test	r8b, r8b
	jne	$LN1512@InputTextE
	mov	r9, QWORD PTR [rsi+48]
	mov	rax, r9
	mov	r8, r12
	sub	r8, r9
	npad	9
$LL1474@InputTextE:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1475@InputTextE
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1474@InputTextE
$LN1475@InputTextE:
	mov	r8d, DWORD PTR tv11237[rsp]
	test	edx, edx
	je	$LN1512@InputTextE

; 4749 :             {
; 4750 :                 apply_new_text = state->TextA.Data;

	mov	r11, r9
	mov	QWORD PTR apply_new_text$1$[rbp-256], r9

; 4751 :                 apply_new_text_length = state->CurLenA;

	mov	r10d, DWORD PTR [rsi+16]

; 4752 :                 value_changed = true;

	mov	BYTE PTR value_changed$1$[rsp], 1

; 4652 :         }
; 4653 : 
; 4654 :         // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
; 4655 :         // before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
; 4656 :         // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
; 4657 :         // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
; 4658 :         // (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
; 4659 :         // unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
; 4660 :         const bool apply_edit_back_to_user_buffer = !revert_edit || (validated && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);

	jmp	$LN168@InputTextE
$LN1510@InputTextE:

; 4614 :     if (g.ActiveId == id)

	mov	r11, r10
	mov	ebx, DWORD PTR tv11229[rbp-256]
	mov	r12, QWORD PTR text_remaining$1$[rbp-256]
	mov	r8d, DWORD PTR tv11237[rsp]
	jmp	$LN168@InputTextE
$LN1550@InputTextE:

; 4753 :             }
; 4754 :         }
; 4755 :     }
; 4756 : 
; 4757 :     // Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
; 4758 :     if (g.InputTextDeactivatedState.ID == id)

	xor	eax, eax
$LN169@InputTextE:

; 4768 :     }
; 4769 : 
; 4770 :     // Copy result to user buffer. This can currently only happen when (g.ActiveId == id)
; 4771 :     if (apply_new_text != NULL)

	test	r11, r11
	je	$LN707@InputTextE

; 4777 :         if (is_resizable)

	test	bl, bl
	je	SHORT $LN1525@InputTextE

; 3888 :     memset(this, 0, sizeof(*this));

	mov	QWORD PTR callback_data$39[rbp-232], rax
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR callback_data$39[rbp-208], xmm0

; 4778 :         {
; 4779 :             ImGuiInputTextCallbackData callback_data;
; 4780 :             callback_data.Ctx = &g;

	mov	QWORD PTR callback_data$39[rbp-256], r13

; 4781 :             callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;

	mov	DWORD PTR callback_data$39[rbp-248], 262144 ; 00040000H

; 4782 :             callback_data.Flags = flags;

	mov	eax, DWORD PTR flags$1$[rsp]
	mov	DWORD PTR callback_data$39[rbp-244], eax

; 4783 :             callback_data.Buf = buf;

	mov	QWORD PTR callback_data$39[rbp-224], r12

; 4784 :             callback_data.BufTextLen = apply_new_text_length;

	mov	DWORD PTR callback_data$39[rbp-216], r10d

; 4785 :             callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);

	lea	eax, DWORD PTR [r10+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR buf_size$GSCopy$1$[rbp-256], eax
	cmovge	eax, DWORD PTR buf_size$GSCopy$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4785 :             callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);

	mov	DWORD PTR callback_data$39[rbp-212], eax

; 4786 :             callback_data.UserData = callback_user_data;

	mov	rax, QWORD PTR callback_user_data$GSCopy$1$[rbp-256]
	mov	QWORD PTR callback_data$39[rbp-240], rax

; 4787 :             callback(&callback_data);

	lea	rcx, QWORD PTR callback_data$39[rbp-256]
	call	QWORD PTR callback$GSCopy$1$[rbp-256]

; 4788 :             buf = callback_data.Buf;

	mov	r12, QWORD PTR callback_data$39[rbp-224]

; 4789 :             buf_size = callback_data.BufSize;

	mov	ecx, DWORD PTR callback_data$39[rbp-212]
	lea	r10d, DWORD PTR [rcx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	DWORD PTR callback_data$39[rbp-216], r10d
	cmovl	r10d, DWORD PTR callback_data$39[rbp-216]
	mov	r11, QWORD PTR apply_new_text$1$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4777 :         if (is_resizable)

	jmp	SHORT $LN172@InputTextE
$LN1525@InputTextE:
	mov	ecx, DWORD PTR buf_size$GSCopy$1$[rbp-256]
$LN172@InputTextE:

; 4796 :         ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));

	lea	eax, DWORD PTR [r10+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	eax, ecx
	cmovl	ecx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4796 :         ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));

	movsxd	rbx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1809 :     if (count < 1)

	cmp	rbx, 1
	jb	SHORT $LN707@InputTextE

; 1810 :         return;
; 1811 :     if (count > 1)

	jbe	SHORT $LN709@InputTextE

; 1812 :         strncpy(dst, src, count - 1);

	lea	r8, QWORD PTR [rbx-1]
	mov	rdx, r11
	mov	rcx, r12
	call	QWORD PTR __imp_strncpy
$LN709@InputTextE:

; 1813 :     dst[count - 1] = 0;

	mov	BYTE PTR [rbx+r12-1], 0
$LN707@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4801 :     if (g.ActiveId == id && clear_active_id)

	cmp	DWORD PTR [r13+16504], r15d
	jne	SHORT $LN1555@InputTextE
	cmp	BYTE PTR clear_active_id$1$[rsp], 0
	je	$LN173@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3996 :     SetActiveID(0, NULL); // g.ActiveId = 0;

	xor	edx, edx
	xor	ecx, ecx
	call	?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN1555@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4807 :     if (!is_multiline)

	mov	eax, 1
$LN175@InputTextE:
	mov	r11d, DWORD PTR tv11239[rsp]
	test	r11b, r11b
	jne	$LN176@InputTextE

; 4808 :     {
; 4809 :         RenderNavHighlight(frame_bb, id);

	mov	r8d, eax
	mov	edx, r15d
	lea	rcx, QWORD PTR frame_bb$[rbp-256]
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+14888]
	movups	XMMWORD PTR c$23[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$23[rbp-244], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$23[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4810 :         RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	movss	xmm0, DWORD PTR [r13+14620]
	movss	DWORD PTR [rsp+32], xmm0
	mov	r9b, 1
	mov	rdx, QWORD PTR frame_bb$[rbp-248]
	movaps	xmm0, xmm8
	unpcklps xmm0, xmm12
	movq	rcx, xmm0
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	movaps	xmm15, xmm10
	addss	xmm15, xmm8
	movss	DWORD PTR clip_rect$[rbp-248], xmm15
	movaps	xmm14, xmm12
	addss	xmm14, xmm11
	movss	DWORD PTR clip_rect$[rbp-244], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm0, xmm8
	addss	xmm0, DWORD PTR [r13+14612]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T27[rbp-256], xmm0

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movaps	xmm1, xmm12
	addss	xmm1, DWORD PTR [r13+14616]

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T27[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4814 :     ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;

	movss	DWORD PTR tv10770[rbp-256], xmm15
	movss	DWORD PTR tv10808[rbp-256], xmm14
	mov	r11d, DWORD PTR tv11239[rsp]
	mov	r8, QWORD PTR draw_window$1$[rbp-256]
	jmp	SHORT $LN1577@InputTextE
$LN173@InputTextE:

; 4802 :         ClearActiveID();
; 4803 :     else if (g.ActiveId == id)
; 4804 :         g.WantTextInputNextFrame = 1;

	mov	eax, 1
	mov	DWORD PTR [r13+24708], eax

; 4801 :     if (g.ActiveId == id && clear_active_id)

	jmp	$LN175@InputTextE
$LN176@InputTextE:

; 4813 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size

	movaps	xmm2, xmm8
	addss	xmm2, xmm10
	movss	DWORD PTR tv10770[rbp-256], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm15, xmm2
	movss	DWORD PTR clip_rect$[rbp-248], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4813 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size

	movaps	xmm1, xmm11
	addss	xmm1, xmm12
	movss	DWORD PTR tv10808[rbp-256], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm14, xmm1
	movss	DWORD PTR clip_rect$[rbp-244], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4814 :     ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;

	mov	r8, QWORD PTR draw_window$1$[rbp-256]
	movsd	xmm0, QWORD PTR [r8+312]
	movsd	QWORD PTR $T28[rbp-256], xmm0
$LN1577@InputTextE:
	lea	rax, QWORD PTR $T28[rbp-256]
	movss	DWORD PTR clip_rect$[rbp-252], xmm12
	movss	DWORD PTR clip_rect$[rbp-256], xmm8
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR draw_pos$[rbp-256], xmm0
	xorps	xmm5, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR text_size$$sroa$6550$1$[rbp-256], xmm5
	xorps	xmm8, xmm8
	movss	DWORD PTR text_size$$sroa$6551$1$[rbp-256], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4821 :     const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595

	cmp	BYTE PTR buf_display_from_state$1$[rbp-256], 0
	je	SHORT $LN338@InputTextE
	mov	r12, QWORD PTR [rsi+48]
$LN338@InputTextE:

; 4822 :     const char* buf_display_end = NULL; // We have specialized paths below for setting the length

	xor	r10d, r10d
	mov	edi, r10d

; 4823 :     if (is_displaying_hint)

	movzx	r14d, BYTE PTR is_displaying_hint$1$[rsp]
	test	r14b, r14b
	je	SHORT $LN177@InputTextE

; 4824 :     {
; 4825 :         buf_display = hint;

	mov	rax, QWORD PTR hint$GSCopy$1$[rbp-256]
	mov	r12, rax

; 4826 :         buf_display_end = hint + strlen(hint);

	mov	rdi, -1
	npad	1
$LL1471@InputTextE:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], r10b
	jne	SHORT $LL1471@InputTextE
	add	rdi, rax
$LN177@InputTextE:

; 4827 :     }
; 4828 : 
; 4829 :     // Render text. We currently only render selection when the widget is active or while scrolling.
; 4830 :     // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
; 4831 :     if (render_cursor || render_selection)

	movzx	eax, BYTE PTR render_cursor$1$[rsp]
	mov	ecx, DWORD PTR tv11311[rsp]
	test	al, al
	jne	$LN180@InputTextE
	test	cl, cl
	jne	$LN180@InputTextE

; 4993 :             }
; 4994 :         }
; 4995 :     }
; 4996 :     else
; 4997 :     {
; 4998 :         // Render text only (no selection, no cursor)
; 4999 :         if (is_multiline)

	test	r11b, r11b
	je	SHORT $LN215@InputTextE

; 3674 :     int line_count = 0;

	mov	ecx, r10d

; 3675 :     const char* s = text_begin;
; 3676 :     while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding

	movzx	edx, BYTE PTR [r12]
	lea	rdi, QWORD PTR [r12+1]
	test	dl, dl
	je	SHORT $LN922@InputTextE
	npad	5
$LL921@InputTextE:
	lea	eax, DWORD PTR [rcx+1]
	cmp	dl, 10
	cmovne	eax, ecx
	mov	ecx, eax
	movzx	edx, BYTE PTR [rdi]
	inc	rdi
	test	dl, dl
	jne	SHORT $LL921@InputTextE
$LN922@InputTextE:

; 3677 :         if (c == '\n')
; 3678 :             line_count++;
; 3679 :     s--;

	dec	rdi

; 3680 :     if (s[0] != '\n' && s[0] != '\r')

	movzx	eax, BYTE PTR [rdi]
	cmp	al, 10
	je	SHORT $LN924@InputTextE
	cmp	al, 13
	je	SHORT $LN924@InputTextE

; 3681 :         line_count++;

	inc	ecx
$LN924@InputTextE:

; 5000 :             text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width

	movaps	xmm6, xmm10
	movd	xmm8, ecx
	cvtdq2ps xmm8, xmm8
	mulss	xmm8, DWORD PTR [r13+15696]
	movss	DWORD PTR text_size$$sroa$6551$1$[rbp-256], xmm8
	jmp	SHORT $LN221@InputTextE
$LN215@InputTextE:

; 5001 :         else if (!is_displaying_hint && g.ActiveId == id)

	test	r14b, r14b
	jne	SHORT $LN1433@InputTextE
	cmp	DWORD PTR [r13+16504], r15d
	jne	SHORT $LN1434@InputTextE

; 5002 :             buf_display_end = buf_display + state->CurLenA;

	movsxd	rdi, DWORD PTR [rsi+16]
	jmp	SHORT $LN1578@InputTextE
$LN1434@InputTextE:

; 5003 :         else if (!is_displaying_hint)
; 5004 :             buf_display_end = buf_display + strlen(buf_display);

	mov	rdi, -1
	npad	2
$LL1470@InputTextE:
	inc	rdi
	cmp	BYTE PTR [r12+rdi], r10b
	jne	SHORT $LL1470@InputTextE
$LN1578@InputTextE:

; 5005 : 
; 5006 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

	add	rdi, r12
$LN1433@InputTextE:
	mov	rax, rdi
	sub	rax, r12
	movss	xmm6, DWORD PTR text_size$$sroa$6550$1$[rbp-256]
	cmp	rax, 2097152				; 00200000H
	jge	$LN1495@InputTextE
$LN221@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	lea	rax, QWORD PTR [r14+14]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$41[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]
	movss	DWORD PTR c$41[rbp-244], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$41[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5009 :             draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);

	mov	r8, QWORD PTR [r8+728]
	lea	rdx, QWORD PTR clip_rect$[rbp-256]
	test	r11b, r11b
	cmovne	rdx, r10
	mov	rcx, rdi
	movss	xmm2, DWORD PTR [r13+15696]
	mov	r10, QWORD PTR [r13+15688]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	$LN1495@InputTextE

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)

	test	rdi, rdi
	jne	SHORT $LN884@InputTextE

; 1582 :         text_end = text_begin + strlen(text_begin);

	mov	rcx, -1
$LL1469@InputTextE:
	inc	rcx
	cmp	BYTE PTR [r12+rcx], 0
	jne	SHORT $LL1469@InputTextE
	add	rcx, r12
$LN884@InputTextE:

; 1583 :     if (text_begin == text_end)

	cmp	r12, rcx
	je	$LN1495@InputTextE

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)

	test	r10, r10
	jne	SHORT $LN1453@InputTextE

; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [r8+56]
	mov	r10, QWORD PTR [rax+8]
$LN1453@InputTextE:
	xorps	xmm9, xmm9

; 1589 :     if (font_size == 0.0f)

	ucomiss	xmm2, xmm9
	jp	SHORT $LN887@InputTextE
	jne	SHORT $LN887@InputTextE

; 1590 :         font_size = _Data->FontSize;

	mov	rax, QWORD PTR [r8+56]
	movss	xmm2, DWORD PTR [rax+16]
$LN887@InputTextE:

; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

	movups	xmm1, XMMWORD PTR [r8+136]
	movups	XMMWORD PTR clip_rect$40[rbp-256], xmm1

; 1595 :     if (cpu_fine_clip_rect)

	test	rdx, rdx
	je	SHORT $LN1579@InputTextE

; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

	movss	xmm0, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm0
	jae	SHORT $LN893@InputTextE
	movss	DWORD PTR clip_rect$40[rbp-256], xmm0
$LN893@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

	movss	xmm1, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR clip_rect$40[rbp-252]
	comiss	xmm0, xmm1
	jae	SHORT $LN897@InputTextE
	movss	DWORD PTR clip_rect$40[rbp-252], xmm1
$LN897@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

	movss	xmm0, DWORD PTR [rdx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$40[rbp-248]
	ja	SHORT $LN901@InputTextE
	movss	DWORD PTR clip_rect$40[rbp-248], xmm0
$LN901@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

	movss	xmm0, DWORD PTR [rdx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$40[rbp-244]
	ja	SHORT $LN905@InputTextE
	movss	DWORD PTR clip_rect$40[rbp-244], xmm0
$LN905@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	test	rdx, rdx
$LN1579@InputTextE:
	setne	al
	mov	BYTE PTR [rsp+72], al
	movss	DWORD PTR [rsp+64], xmm9
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], r12
	lea	rax, QWORD PTR clip_rect$40[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r9d
	lea	r9, QWORD PTR draw_pos$[rbp-256]
	mov	rdx, r8
	mov	rcx, r10
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
	movss	xmm8, DWORD PTR __real@3f800000
	jmp	$LN214@InputTextE
$LN180@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4834 :         if (!is_displaying_hint)

	test	r14b, r14b
	jne	SHORT $LN181@InputTextE

; 4835 :             buf_display_end = buf_display + state->CurLenA;

	movsxd	rdi, DWORD PTR [rsi+16]
	add	rdi, r12
$LN181@InputTextE:

; 4836 : 
; 4837 :         // Render text (with cursor and selection)
; 4838 :         // This is going to be messy. We need to:
; 4839 :         // - Display the text (this alone can be more easily clipped)
; 4840 :         // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
; 4841 :         // - Measure text height (for scrollbar)
; 4842 :         // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
; 4843 :         // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
; 4844 :         const ImWchar* text_begin = state->TextW.Data;

	mov	r15, QWORD PTR [rsi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 269  :     constexpr ImVec2()                      : x(0.0f), y(0.0f) { }

	movaps	xmm7, xmm5
	movaps	xmm6, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4849 :             const ImWchar* searches_input_ptr[2] = { NULL, NULL };

	mov	r9, r10
	mov	r14, r10

; 4850 :             int searches_result_line_no[2] = { -1000, -1000 };

	mov	r8d, -1000				; fffffffffffffc18H
	mov	ebx, r8d

; 4851 :             int searches_remaining = 0;

	mov	edx, r10d

; 4852 :             if (render_cursor)

	test	al, al
	je	SHORT $LN182@InputTextE

; 4853 :             {
; 4854 :                 searches_input_ptr[0] = text_begin + state->Stb.cursor;

	movsxd	rax, DWORD PTR [rsi+84]
	lea	r9, QWORD PTR [r15+rax*2]

; 4856 :                 searches_remaining++;

	mov	edx, 1

; 4855 :                 searches_result_line_no[0] = -1;

	lea	r8d, QWORD PTR [rdx-2]
$LN182@InputTextE:

; 4857 :             }
; 4858 :             if (render_selection)

	test	cl, cl
	je	SHORT $LN183@InputTextE

; 4860 :                 searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

	mov	ecx, DWORD PTR [rsi+92]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	DWORD PTR [rsi+88], ecx
	cmovl	ecx, DWORD PTR [rsi+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4860 :                 searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

	movsxd	rax, ecx
	lea	r14, QWORD PTR [r15+rax*2]

; 4861 :                 searches_result_line_no[1] = -1;

	mov	ebx, -1

; 4862 :                 searches_remaining++;

	inc	edx
$LN183@InputTextE:

; 4863 :             }
; 4864 : 
; 4865 :             // Iterate all lines to find our line numbers
; 4866 :             // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
; 4867 :             searches_remaining += is_multiline ? 1 : 0;

	movzx	eax, r11b
	add	edx, eax

; 4868 :             int line_count = 0;
; 4869 :             //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 4870 :             for (const ImWchar* s = text_begin; *s != 0; s++)

	mov	rax, r15
	movzx	ecx, WORD PTR [r15]
	test	cx, cx
	je	SHORT $LN1345@InputTextE
	npad	4
$LL10@InputTextE:

; 4871 :                 if (*s == '\n')

	cmp	cx, 10
	jne	SHORT $LN8@InputTextE

; 4872 :                 {
; 4873 :                     line_count++;

	inc	r10d

; 4874 :                     if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining <= 0) break; }

	cmp	r8d, -1
	jne	SHORT $LN186@InputTextE
	cmp	rax, r9
	jb	SHORT $LN186@InputTextE
	mov	r8d, r10d
	dec	edx
	test	edx, edx
	jle	SHORT $LN1345@InputTextE
$LN186@InputTextE:

; 4875 :                     if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining <= 0) break; }

	cmp	ebx, -1
	jne	SHORT $LN8@InputTextE
	cmp	rax, r14
	jb	SHORT $LN8@InputTextE
	mov	ebx, r10d
	dec	edx
	test	edx, edx
	jle	SHORT $LN1345@InputTextE
$LN8@InputTextE:

; 4868 :             int line_count = 0;
; 4869 :             //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 4870 :             for (const ImWchar* s = text_begin; *s != 0; s++)

	add	rax, 2
	movzx	ecx, WORD PTR [rax]
	test	cx, cx
	jne	SHORT $LL10@InputTextE
$LN1345@InputTextE:

; 4876 :                 }
; 4877 :             line_count++;

	inc	r10d

; 4878 :             if (searches_result_line_no[0] == -1)
; 4879 :                 searches_result_line_no[0] = line_count;
; 4880 :             if (searches_result_line_no[1] == -1)

	mov	r11d, r10d
	cmp	r8d, -1
	cmovne	r11d, r8d
	cmp	ebx, -1
	cmove	ebx, r10d

; 4881 :                 searches_result_line_no[1] = line_count;
; 4882 : 
; 4883 :             // Calculate 2d position by finding the beginning of the line and measuring distance
; 4884 :             cursor_offset.x = InputTextCalcTextSizeW(&g, ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;

	mov	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1860 :     while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	cmp	r9, r15
	jbe	SHORT $LN473@InputTextE
	npad	7
$LL472@InputTextE:
	lea	rax, QWORD PTR [rdx-2]
	cmp	WORD PTR [rax], 10
	je	SHORT $LN473@InputTextE

; 1861 :         buf_mid_line--;

	mov	rdx, rax

; 1860 :     while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	cmp	rax, r15
	ja	SHORT $LL472@InputTextE
$LN473@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3689 :     ImFont* font = g.Font;

	mov	r8, QWORD PTR [r13+15688]

; 3690 :     const float line_height = g.FontSize;

	movss	xmm4, DWORD PTR [r13+15696]

; 3691 :     const float scale = line_height / font->FontSize;

	movaps	xmm3, xmm4
	divss	xmm3, DWORD PTR [r8+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3694 :     float line_width = 0.0f;

	movaps	xmm12, xmm5

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	rdx, r9
	jae	SHORT $LN1347@InputTextE
	npad	9
$LL446@InputTextE:

; 3698 :     {
; 3699 :         unsigned int c = (unsigned int)(*s++);

	movzx	ecx, WORD PTR [rdx]
	add	rdx, 2

; 3700 :         if (c == '\n')

	cmp	ecx, 10
	jne	SHORT $LN448@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3704 :             line_width = 0.0f;

	movaps	xmm12, xmm5

; 3705 :             if (stop_on_new_line)
; 3706 :                 break;
; 3707 :             continue;

	jmp	SHORT $LN1360@InputTextE
$LN448@InputTextE:

; 3708 :         }
; 3709 :         if (c == '\r')

	cmp	ecx, 13
	je	SHORT $LN1360@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [r8]
	jge	SHORT $LN465@InputTextE
	mov	rax, QWORD PTR [r8+8]
	movss	xmm0, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN466@InputTextE
$LN465@InputTextE:
	movss	xmm0, DWORD PTR [r8+16]
$LN466@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	mulss	xmm0, xmm3

; 3713 :         line_width += char_width;

	addss	xmm12, xmm0
$LN1360@InputTextE:

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	rdx, r9
	jb	SHORT $LL446@InputTextE
$LN1347@InputTextE:

; 3714 :     }
; 3715 : 
; 3716 :     if (text_size.x < line_width)

	maxss	xmm12, xmm1
	movd	xmm13, r11d

; 4885 :             cursor_offset.y = searches_result_line_no[0] * g.FontSize;

	cvtdq2ps xmm13, xmm13
	mulss	xmm13, xmm4

; 4886 :             if (searches_result_line_no[1] >= 0)

	test	ebx, ebx
	js	SHORT $LN191@InputTextE

; 4887 :             {
; 4888 :                 select_start_offset.x = InputTextCalcTextSizeW(&g, ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;

	mov	rdx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1860 :     while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	cmp	r14, r15
	jbe	SHORT $LN601@InputTextE
	npad	1
$LL600@InputTextE:
	lea	rax, QWORD PTR [rdx-2]
	cmp	WORD PTR [rax], 10
	je	SHORT $LN601@InputTextE

; 1861 :         buf_mid_line--;

	mov	rdx, rax

; 1860 :     while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	cmp	rax, r15
	ja	SHORT $LL600@InputTextE
$LN601@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3694 :     float line_width = 0.0f;

	movaps	xmm7, xmm5

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	rdx, r14
	jae	SHORT $LN1348@InputTextE
	npad	3
$LL570@InputTextE:

; 3698 :     {
; 3699 :         unsigned int c = (unsigned int)(*s++);

	movzx	ecx, WORD PTR [rdx]
	add	rdx, 2

; 3700 :         if (c == '\n')

	cmp	ecx, 10
	jne	SHORT $LN572@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3704 :             line_width = 0.0f;

	movaps	xmm7, xmm5

; 3705 :             if (stop_on_new_line)
; 3706 :                 break;
; 3707 :             continue;

	jmp	SHORT $LN1362@InputTextE
$LN572@InputTextE:

; 3708 :         }
; 3709 :         if (c == '\r')

	cmp	ecx, 13
	je	SHORT $LN1362@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [r8]
	jge	SHORT $LN589@InputTextE
	mov	rax, QWORD PTR [r8+8]
	movss	xmm1, DWORD PTR [rax+rcx*4]
	jmp	SHORT $LN590@InputTextE
$LN589@InputTextE:
	movss	xmm1, DWORD PTR [r8+16]
$LN590@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm1

; 3713 :         line_width += char_width;

	addss	xmm7, xmm0
$LN1362@InputTextE:

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	cmp	rdx, r14
	jb	SHORT $LL570@InputTextE
$LN1348@InputTextE:
	movd	xmm6, ebx

; 4889 :                 select_start_offset.y = searches_result_line_no[1] * g.FontSize;

	cvtdq2ps xmm6, xmm6
	mulss	xmm6, xmm4

; 3716 :     if (text_size.x < line_width)

	maxss	xmm7, xmm2
$LN191@InputTextE:

; 4890 :             }
; 4891 : 
; 4892 :             // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
; 4893 :             if (is_multiline)

	mov	r11d, DWORD PTR tv11239[rsp]
	test	r11b, r11b
	je	SHORT $LN1398@InputTextE

; 4894 :                 text_size = ImVec2(inner_size.x, line_count * g.FontSize);

	movss	DWORD PTR text_size$$sroa$6550$1$[rbp-256], xmm10
	movd	xmm8, r10d
	cvtdq2ps xmm8, xmm8
	mulss	xmm8, xmm4
	movss	DWORD PTR text_size$$sroa$6551$1$[rbp-256], xmm8
$LN1398@InputTextE:

; 4895 :         }
; 4896 : 
; 4897 :         // Scroll
; 4898 :         if (render_cursor && state->CursorFollow)

	movzx	r8d, BYTE PTR render_cursor$1$[rsp]
	test	r8b, r8b
	je	$LN193@InputTextE
	cmp	BYTE PTR [rsi+3716], 0
	je	$LN193@InputTextE

; 4899 :         {
; 4900 :             // Horizontal scroll in chunks of quarter width
; 4901 :             if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))

	test	DWORD PTR flags$1$[rsp], 4096		; 00001000H
	jne	SHORT $LN194@InputTextE

; 4902 :             {
; 4903 :                 const float scroll_increment_x = inner_size.x * 0.25f;

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR __real@3e800000

; 4904 :                 const float visible_width = inner_size.x - style.FramePadding.x;

	subss	xmm10, DWORD PTR [r13+14612]

; 4905 :                 if (cursor_offset.x < state->ScrollX)

	movss	xmm2, DWORD PTR [rsi+80]
	movaps	xmm1, xmm12
	comiss	xmm2, xmm12
	jbe	SHORT $LN196@InputTextE

; 4906 :                     state->ScrollX = IM_FLOOR(ImMax(0.0f, cursor_offset.x - scroll_increment_x));

	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm5
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4906 :                     state->ScrollX = IM_FLOOR(ImMax(0.0f, cursor_offset.x - scroll_increment_x));

	jmp	SHORT $LN1580@InputTextE
$LN196@InputTextE:

; 4907 :                 else if (cursor_offset.x - visible_width >= state->ScrollX)

	subss	xmm1, xmm10
	comiss	xmm1, xmm2
	jb	SHORT $LN195@InputTextE

; 4908 :                     state->ScrollX = IM_FLOOR(cursor_offset.x - visible_width + scroll_increment_x);

	addss	xmm0, xmm1
$LN1580@InputTextE:

; 4913 :             }
; 4914 : 
; 4915 :             // Vertical scroll
; 4916 :             if (is_multiline)

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsi+80], xmm0
	jmp	SHORT $LN195@InputTextE
$LN194@InputTextE:

; 4909 :             }
; 4910 :             else
; 4911 :             {
; 4912 :                 state->ScrollX = 0.0f;

	xor	eax, eax
	mov	DWORD PTR [rsi+80], eax
$LN195@InputTextE:

; 4913 :             }
; 4914 : 
; 4915 :             // Vertical scroll
; 4916 :             if (is_multiline)

	test	r11b, r11b
	je	$LN199@InputTextE

; 4917 :             {
; 4918 :                 // Test if cursor is vertically visible
; 4919 :                 if (cursor_offset.y - g.FontSize < scroll_y)

	movaps	xmm0, xmm13
	subss	xmm0, DWORD PTR [r13+15696]
	comiss	xmm9, xmm0
	jbe	SHORT $LN200@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm9, xmm5
	maxss	xmm9, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4920 :                     scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);

	jmp	SHORT $LN202@InputTextE
$LN200@InputTextE:

; 4921 :                 else if (cursor_offset.y - (inner_size.y - style.FramePadding.y * 2.0f) >= scroll_y)

	movss	xmm2, DWORD PTR [r13+14616]
	addss	xmm2, xmm2
	movaps	xmm1, xmm11
	subss	xmm1, xmm2
	movaps	xmm0, xmm13
	subss	xmm0, xmm1
	comiss	xmm0, xmm9
	jb	SHORT $LN202@InputTextE

; 4922 :                     scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;

	movaps	xmm9, xmm13
	subss	xmm9, xmm11
	addss	xmm9, xmm2
$LN202@InputTextE:

; 4923 :                 const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);

	movss	xmm2, DWORD PTR [r13+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm5, xmm9
	jbe	SHORT $LN699@InputTextE
	movaps	xmm2, xmm5
	jmp	SHORT $LN697@InputTextE
$LN699@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4923 :                 const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);

	addss	xmm2, xmm2
	addss	xmm2, xmm8
	subss	xmm2, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm5

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	minss	xmm2, xmm9
$LN697@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4925 :                 draw_pos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag

	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	movss	xmm0, DWORD PTR [rax+188]
	subss	xmm0, xmm2
	movss	xmm1, DWORD PTR draw_pos$[rbp-252]
	addss	xmm1, xmm0
	movss	DWORD PTR draw_pos$[rbp-252], xmm1

; 4926 :                 draw_window->Scroll.y = scroll_y;

	movss	DWORD PTR [rax+188], xmm2
$LN199@InputTextE:

; 4927 :             }
; 4928 : 
; 4929 :             state->CursorFollow = false;

	mov	BYTE PTR [rsi+3716], 0
$LN193@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm11, DWORD PTR [rsi+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4934 :         if (render_selection)

	cmp	BYTE PTR tv11311[rsp], 0
	je	$LN1487@InputTextE

; 4936 :             const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

	mov	edx, DWORD PTR [rsi+92]
	mov	ecx, DWORD PTR [rsi+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	mov	eax, edx
	cmp	ecx, edx
	cmovl	eax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4936 :             const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);

	cdqe
	lea	rbx, QWORD PTR [r15+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmovge	edx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4937 :             const ImWchar* text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);

	movsxd	rax, edx
	lea	r14, QWORD PTR [r15+rax*2]

; 4938 : 
; 4939 :             ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.

	test	r8b, r8b
	je	SHORT $LN339@InputTextE
	movss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN340@InputTextE
$LN339@InputTextE:
	movss	xmm1, DWORD PTR __real@3f19999a
$LN340@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+15560]
	movups	XMMWORD PTR c$42[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	mulss	xmm1, DWORD PTR [rax+14552]
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR c$42[rbp-244], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$42[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4940 :             float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.

	test	r11b, r11b
	je	SHORT $LN341@InputTextE
	xorps	xmm9, xmm9
	movss	DWORD PTR bg_offy_up$1$[rbp-256], xmm9
	xorps	xmm10, xmm10

; 4941 :             float bg_offy_dn = is_multiline ? 0.0f : 2.0f;

	jmp	SHORT $LN344@InputTextE
$LN341@InputTextE:
	movss	xmm10, DWORD PTR __real@40000000
$LN344@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm9, DWORD PTR draw_pos$[rbp-256]
	addss	xmm7, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm7, xmm11

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm8, DWORD PTR draw_pos$[rbp-252]
	addss	xmm8, xmm6
	xorps	xmm6, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	subss	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4943 :             for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

	cmp	rbx, r14
	jae	$LN1351@InputTextE
	movss	xmm1, DWORD PTR $T22[rbp-256]
	npad	5
$LL11@InputTextE:

; 4944 :             {
; 4945 :                 if (rect_pos.y > clip_rect.w + g.FontSize)

	movss	xmm5, DWORD PTR [r13+15696]
	movaps	xmm0, xmm14
	addss	xmm0, xmm5
	comiss	xmm8, xmm0
	ja	$LN1486@InputTextE

; 4946 :                     break;
; 4947 :                 if (rect_pos.y < clip_rect.y)

	comiss	xmm1, xmm8
	jbe	SHORT $LN205@InputTextE

; 4948 :                 {
; 4949 :                     //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 4950 :                     //p = p ? p + 1 : text_selected_end;
; 4951 :                     while (p < text_selected_end)

	cmp	rbx, r14
	jae	$LN481@InputTextE
	npad	6
$LL14@InputTextE:

; 4952 :                         if (*p++ == '\n')

	movzx	eax, WORD PTR [rbx]
	add	rbx, 2
	cmp	ax, 10
	je	$LN481@InputTextE

; 4948 :                 {
; 4949 :                     //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
; 4950 :                     //p = p ? p + 1 : text_selected_end;
; 4951 :                     while (p < text_selected_end)

	cmp	rbx, r14
	jb	SHORT $LL14@InputTextE

; 4953 :                             break;
; 4954 :                 }

	jmp	$LN481@InputTextE
$LN205@InputTextE:

; 3689 :     ImFont* font = g.Font;

	mov	rdx, QWORD PTR [r13+15688]

; 3691 :     const float scale = line_height / font->FontSize;

	movaps	xmm3, xmm5
	divss	xmm3, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm4, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3694 :     float line_width = 0.0f;

	movaps	xmm2, xmm6
$LN1454@InputTextE:

; 3698 :     {
; 3699 :         unsigned int c = (unsigned int)(*s++);

	cmp	rbx, r14
	jae	SHORT $LN1350@InputTextE
	movzx	ecx, WORD PTR [rbx]
	add	rbx, 2

; 3700 :         if (c == '\n')

	cmp	ecx, 10
	je	SHORT $LN1435@InputTextE

; 3708 :         }
; 3709 :         if (c == '\r')

	cmp	ecx, 13
	je	SHORT $LN1454@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	ecx, DWORD PTR [rdx]
	jge	SHORT $LN531@InputTextE
	mov	rax, QWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rax+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm1

; 3713 :         line_width += char_width;

	addss	xmm2, xmm0

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	jmp	SHORT $LN1454@InputTextE
$LN531@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	movss	xmm1, DWORD PTR [rdx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3712 :         const float char_width = font->GetCharAdvance((ImWchar)c) * scale;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm1

; 3713 :         line_width += char_width;

	addss	xmm2, xmm0

; 3695 : 
; 3696 :     const ImWchar* s = text_begin;
; 3697 :     while (s < text_end)

	jmp	SHORT $LN1454@InputTextE
$LN1435@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm4, xmm6
	maxss	xmm4, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 3704 :             line_width = 0.0f;

	movaps	xmm2, xmm6
$LN1350@InputTextE:

; 3714 :     }
; 3715 : 
; 3716 :     if (text_size.x < line_width)

	maxss	xmm2, xmm4

; 4958 :                     if (rect_size.x <= 0.0f) rect_size.x = IM_FLOOR(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines

	comiss	xmm6, xmm2
	jb	SHORT $LN1399@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 3116 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }

	cmp	DWORD PTR [rdx], 32			; 00000020H
	jle	SHORT $LN654@InputTextE
	mov	rax, QWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR [rax+128]
	jmp	SHORT $LN655@InputTextE
$LN654@InputTextE:
	movss	xmm0, DWORD PTR [rdx+16]
$LN655@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4958 :                     if (rect_size.x <= 0.0f) rect_size.x = IM_FLOOR(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines

	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
$LN1399@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm2, xmm7
	movaps	xmm0, xmm10
	addss	xmm0, xmm8
	addss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4959 :                     ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));

	movss	xmm1, DWORD PTR bg_offy_up$1$[rbp-256]
	subss	xmm1, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm3, DWORD PTR frame_bb$1$[rbp-256]
	maxss	xmm7, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	maxss	xmm1, DWORD PTR $T22[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR rect$46[rbp-256], xmm7
	movss	DWORD PTR rect$46[rbp-252], xmm1

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm2, xmm15

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	minss	xmm0, xmm14
	movss	DWORD PTR rect$46[rbp-248], xmm2
	movss	DWORD PTR rect$46[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	comiss	xmm0, DWORD PTR $T22[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN1503@InputTextE
	comiss	xmm14, xmm1
	jbe	SHORT $LN1503@InputTextE
	comiss	xmm2, xmm3
	jbe	SHORT $LN1503@InputTextE
	comiss	xmm15, xmm7
	jbe	SHORT $LN1503@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4962 :                         draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);

	xor	eax, eax
	mov	DWORD PTR [rsp+40], eax
	movss	DWORD PTR [rsp+32], xmm6
	mov	r9d, r15d
	lea	r8, QWORD PTR rect$46[rbp-248]
	lea	rdx, QWORD PTR rect$46[rbp-256]
	mov	rax, QWORD PTR draw_window$1$[rbp-256]
	mov	rcx, QWORD PTR [rax+728]
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	movss	xmm0, DWORD PTR tv10770[rbp-256]
	movss	DWORD PTR tv10770[rbp-256], xmm0
	movss	xmm0, DWORD PTR tv10808[rbp-256]
	movss	DWORD PTR tv10808[rbp-256], xmm0
	movss	xmm9, DWORD PTR draw_pos$[rbp-256]
$LN1503@InputTextE:

; 4963 :                 }
; 4964 :                 rect_pos.x = draw_pos.x - draw_scroll.x;

	movss	xmm1, DWORD PTR $T22[rbp-256]
$LN481@InputTextE:
	movaps	xmm7, xmm9
	subss	xmm7, xmm11

; 4965 :                 rect_pos.y += g.FontSize;

	addss	xmm8, DWORD PTR [r13+15696]

; 4943 :             for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

	cmp	rbx, r14
	jb	$LL11@InputTextE
$LN1486@InputTextE:

; 4970 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

	mov	r11d, DWORD PTR tv11239[rsp]
	jmp	SHORT $LN1351@InputTextE
$LN1487@InputTextE:

; 4934 :         if (render_selection)

	movss	xmm9, DWORD PTR draw_pos$[rbp-256]
	xorps	xmm6, xmm6
$LN1351@InputTextE:

; 4970 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

	test	r11b, r11b
	jne	SHORT $LN211@InputTextE
	mov	rax, rdi
	sub	rax, r12
	cmp	rax, 2097152				; 00200000H
	jge	$LN1542@InputTextE
$LN211@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4972 :             ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);

	movzx	r14d, BYTE PTR is_displaying_hint$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	lea	rax, QWORD PTR [r14+14]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$44[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]
	movss	DWORD PTR c$44[rbp-244], xmm0

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$44[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4973 :             draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);

	mov	rbx, QWORD PTR draw_window$1$[rbp-256]
	mov	r8, QWORD PTR [rbx+728]
	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm9, xmm11

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T35[rbp-256], xmm9

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm0, DWORD PTR draw_pos$[rbp-252]
	subss	xmm0, xmm6

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T35[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4973 :             draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);

	movss	xmm2, DWORD PTR [r13+15696]
	mov	r10, QWORD PTR [r13+15688]
	lea	rdx, QWORD PTR clip_rect$[rbp-256]
	test	r11b, r11b
	mov	eax, 0
	cmovne	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r9d, -16777216				; ff000000H
	je	$LN350@InputTextE

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)

	test	rdi, rdi
	jne	SHORT $LN352@InputTextE

; 1582 :         text_end = text_begin + strlen(text_begin);

	mov	rcx, -1
	npad	2
$LL1468@InputTextE:
	inc	rcx
	cmp	BYTE PTR [r12+rcx], al
	jne	SHORT $LL1468@InputTextE
	add	rcx, r12
$LN352@InputTextE:

; 1583 :     if (text_begin == text_end)

	cmp	r12, rcx
	je	$LN350@InputTextE

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)

	test	r10, r10
	jne	SHORT $LN1455@InputTextE

; 1588 :         font = _Data->Font;

	mov	rax, QWORD PTR [r8+56]
	mov	r10, QWORD PTR [rax+8]
$LN1455@InputTextE:

; 1589 :     if (font_size == 0.0f)

	ucomiss	xmm2, xmm6
	jp	SHORT $LN355@InputTextE
	jne	SHORT $LN355@InputTextE

; 1590 :         font_size = _Data->FontSize;

	mov	rax, QWORD PTR [r8+56]
	movss	xmm2, DWORD PTR [rax+16]
$LN355@InputTextE:

; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

	movups	xmm1, XMMWORD PTR [r8+136]
	movups	XMMWORD PTR clip_rect$43[rbp-256], xmm1

; 1595 :     if (cpu_fine_clip_rect)

	test	rdx, rdx
	je	SHORT $LN1582@InputTextE

; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

	movss	xmm0, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm0
	jae	SHORT $LN361@InputTextE
	movss	DWORD PTR clip_rect$43[rbp-256], xmm0
$LN361@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

	movss	xmm1, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR clip_rect$43[rbp-252]
	comiss	xmm0, xmm1
	jae	SHORT $LN365@InputTextE
	movss	DWORD PTR clip_rect$43[rbp-252], xmm1
$LN365@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

	movss	xmm0, DWORD PTR [rdx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$43[rbp-248]
	ja	SHORT $LN369@InputTextE
	movss	DWORD PTR clip_rect$43[rbp-248], xmm0
$LN369@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

	movss	xmm0, DWORD PTR [rdx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR clip_rect$43[rbp-244]
	ja	SHORT $LN373@InputTextE
	movss	DWORD PTR clip_rect$43[rbp-244], xmm0
$LN373@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	test	rdx, rdx
$LN1582@InputTextE:
	setne	al
	mov	BYTE PTR [rsp+72], al
	movss	DWORD PTR [rsp+64], xmm6
	mov	QWORD PTR [rsp+56], rcx
	mov	QWORD PTR [rsp+48], r12
	lea	rax, QWORD PTR clip_rect$43[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r9d
	lea	r9, QWORD PTR $T35[rbp-256]
	mov	rdx, r8
	mov	rcx, r10
	call	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MAEBUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4970 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

	jmp	SHORT $LN350@InputTextE
$LN1542@InputTextE:
	mov	rbx, QWORD PTR draw_window$1$[rbp-256]
	movzx	r14d, BYTE PTR is_displaying_hint$1$[rsp]
$LN350@InputTextE:

; 4974 :         }
; 4975 : 
; 4976 :         // Draw blinking cursor
; 4977 :         if (render_cursor)

	cmp	BYTE PTR render_cursor$1$[rsp], 0
	je	$LN1498@InputTextE

; 4978 :         {
; 4979 :             state->CursorAnim += io.DeltaTime;

	movss	xmm0, DWORD PTR [r13+24]
	addss	xmm0, DWORD PTR [rsi+3712]
	movss	DWORD PTR [rsi+3712], xmm0

; 4980 :             bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;

	cmp	BYTE PTR [r13+99], 0
	je	SHORT $LN345@InputTextE
	comiss	xmm6, xmm0
	jae	SHORT $LN345@InputTextE
	movss	xmm1, DWORD PTR __real@3f99999a
	call	fmodf
	movss	xmm1, DWORD PTR __real@3f4ccccd
	comiss	xmm1, xmm0
	jae	SHORT $LN345@InputTextE
	xor	cl, cl
	jmp	SHORT $LN346@InputTextE
$LN345@InputTextE:
	mov	cl, 1
$LN346@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm12, DWORD PTR draw_pos$[rbp-256]

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm12, xmm11

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	cvttss2si eax, xmm12
	movd	xmm6, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvtdq2ps xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	movss	xmm0, DWORD PTR draw_pos$[rbp-252]
	addss	xmm0, xmm13
	xorps	xmm9, xmm9

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	cvttss2si eax, xmm0
	movd	xmm7, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 474  : static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }

	cvtdq2ps xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR cursor_screen_rect$45[rbp-256], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4982 :             ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);

	movaps	xmm0, xmm7
	subss	xmm0, DWORD PTR [r13+15696]
	addss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR cursor_screen_rect$45[rbp-252], xmm0
	movaps	xmm2, xmm6
	movss	xmm8, DWORD PTR __real@3f800000
	addss	xmm2, xmm8
	movss	DWORD PTR cursor_screen_rect$45[rbp-248], xmm2
	movaps	xmm1, xmm7
	subss	xmm1, DWORD PTR __real@3fc00000
	movss	DWORD PTR cursor_screen_rect$45[rbp-244], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4983 :             if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))

	movss	xmm12, DWORD PTR $T22[rbp-256]
	test	cl, cl
	je	SHORT $LN213@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	comiss	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 538  :     bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }

	jbe	SHORT $LN213@InputTextE
	movss	xmm3, DWORD PTR tv10808[rbp-256]
	comiss	xmm3, xmm0
	jbe	SHORT $LN213@InputTextE
	comiss	xmm2, DWORD PTR frame_bb$1$[rbp-256]
	jbe	SHORT $LN213@InputTextE
	movss	xmm0, DWORD PTR tv10770[rbp-256]
	comiss	xmm0, xmm6
	jbe	SHORT $LN213@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+14776]
	movups	XMMWORD PTR c$26[rbp-256], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rax+14552]
	movss	DWORD PTR c$26[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T34[rbp-256], xmm6
	movss	DWORD PTR $T34[rbp-252], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$26[rbp-256]
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 4984 :                 draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

	movss	DWORD PTR [rsp+32], xmm8
	lea	r8, QWORD PTR $T34[rbp-256]
	lea	rdx, QWORD PTR cursor_screen_rect$45[rbp-256]
	mov	rcx, QWORD PTR [rbx+728]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN213@InputTextE:

; 4985 : 
; 4986 :             // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
; 4987 :             if (!is_readonly)

	movss	xmm13, DWORD PTR $T32[rbp-256]
	mov	r15d, DWORD PTR id$1$[rsp]
	cmp	BYTE PTR tv11237[rsp], 0
	jne	SHORT $LN1499@InputTextE

; 4988 :             {
; 4989 :                 g.PlatformImeData.WantVisible = true;

	mov	BYTE PTR [r13+23984], 1

; 4990 :                 g.PlatformImeData.InputPos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);

	subss	xmm6, xmm8
	movss	xmm0, DWORD PTR [r13+15696]
	subss	xmm7, xmm0
	movss	DWORD PTR [r13+23988], xmm6
	movss	DWORD PTR [r13+23992], xmm7

; 4991 :                 g.PlatformImeData.InputLineHeight = g.FontSize;

	movss	DWORD PTR [r13+23996], xmm0

; 4992 :                 g.PlatformImeViewport = window->Viewport->ID;

	mov	rax, QWORD PTR window$1$[rbp-256]
	mov	rax, QWORD PTR [rax+56]
	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR [r13+24016], ecx

; 5005 : 
; 5006 :         if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)

	jmp	SHORT $LN1499@InputTextE
$LN1495@InputTextE:

; 5010 :         }
; 5011 :     }
; 5012 : 
; 5013 :     if (is_password && !is_displaying_hint)

	movss	xmm8, DWORD PTR __real@3f800000
	xorps	xmm9, xmm9
	jmp	SHORT $LN214@InputTextE
$LN1498@InputTextE:

; 4974 :         }
; 4975 : 
; 4976 :         // Draw blinking cursor
; 4977 :         if (render_cursor)

	movss	xmm8, DWORD PTR __real@3f800000
	xorps	xmm9, xmm9
	movss	xmm12, DWORD PTR $T22[rbp-256]
	movss	xmm13, DWORD PTR $T32[rbp-256]
	mov	r15d, DWORD PTR id$1$[rsp]
$LN1499@InputTextE:

; 5010 :         }
; 5011 :     }
; 5012 : 
; 5013 :     if (is_password && !is_displaying_hint)

	movss	xmm6, DWORD PTR text_size$$sroa$6550$1$[rbp-256]
$LN214@InputTextE:
	mov	ebx, DWORD PTR tv11234[rbp-256]
	test	bl, bl
	je	SHORT $LN222@InputTextE
	test	r14b, r14b
	jne	SHORT $LN222@InputTextE

; 5014 :         PopFont();

	call	?PopFont@ImGui@@YAXXZ			; ImGui::PopFont
$LN222@InputTextE:

; 5015 : 
; 5016 :     if (is_multiline)

	cmp	BYTE PTR tv11239[rsp], 0
	je	SHORT $LN1489@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T33[rbp-256], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5019 :         Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));

	movss	xmm0, DWORD PTR text_size$$sroa$6551$1$[rbp-256]
	addss	xmm0, DWORD PTR [r13+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T33[rbp-252], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5019 :         Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));

	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 5020 :         g.NextItemData.ItemFlags |= ImGuiItemFlags_Inputable | ImGuiItemFlags_NoTabStop;

	or	DWORD PTR [r13+18596], 1025		; 00000401H

; 5021 :         EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 5022 :         item_data_backup.StatusFlags |= (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredWindow);

	mov	eax, DWORD PTR [r13+18624]
	and	eax, 128				; 00000080H
	mov	ebx, DWORD PTR item_data_backup$[rbp-248]
	or	ebx, eax

; 5023 : 
; 5024 :         // ...and then we need to undo the group overriding last item data, which gets a bit messy as EndGroup() tries to forward scrollbar being active...
; 5025 :         // FIXME: This quite messy/tricky, should attempt to get rid of the child window.
; 5026 :         EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 5027 :         if (g.LastItemData.ID == 0)

	cmp	DWORD PTR [r13+18616], 0
	jne	SHORT $LN1548@InputTextE

; 5028 :         {
; 5029 :             g.LastItemData.ID = id;

	mov	DWORD PTR [r13+18616], r15d

; 5030 :             g.LastItemData.InFlags = item_data_backup.InFlags;

	mov	eax, DWORD PTR item_data_backup$[rbp-252]
	mov	DWORD PTR [r13+18620], eax

; 5031 :             g.LastItemData.StatusFlags = item_data_backup.StatusFlags;

	mov	DWORD PTR [r13+18624], ebx
$LN1548@InputTextE:

; 5032 :         }
; 5033 :     }
; 5034 : 
; 5035 :     // Log as text
; 5036 :     if (g.LogEnabled && (!is_password || is_displaying_hint))

	mov	ebx, DWORD PTR tv11234[rbp-256]
$LN1489@InputTextE:
	cmp	BYTE PTR [r13+24256], 0
	je	$LN413@InputTextE
	test	bl, bl
	je	SHORT $LN226@InputTextE
	test	r14b, r14b
	je	$LN413@InputTextE
$LN226@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13373:     ImGuiWindow* window = g.CurrentWindow;

	mov	r14, QWORD PTR [rsi+16408]

; 13374: 
; 13375:     const char* prefix = g.LogNextPrefix;
; 13376:     const char* suffix = g.LogNextSuffix;
; 13377:     g.LogNextPrefix = g.LogNextSuffix = NULL;

	xor	eax, eax
	mov	QWORD PTR [rsi+24296], rax
	mov	QWORD PTR [rsi+24288], rax

; 13378: 
; 13379:     if (!text_end)

	test	rdi, rdi
	jne	SHORT $LN404@InputTextE

; 3327 :     const char* text_display_end = text;

	mov	rdi, r12

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r12, -1
	jae	SHORT $LN404@InputTextE
	npad	7
$LL420@InputTextE:
	movzx	ecx, BYTE PTR [rdi]
	test	cl, cl
	je	SHORT $LN404@InputTextE
	lea	rax, QWORD PTR [rdi+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN1456@InputTextE
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN404@InputTextE
$LN1456@InputTextE:

; 3332 :         text_display_end++;

	mov	rdi, rax

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rax, -1
	jb	SHORT $LL420@InputTextE
$LN404@InputTextE:

; 13382:     const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);

	movss	xmm0, DWORD PTR [rsi+14616]
	addss	xmm0, DWORD PTR [rsi+24304]
	addss	xmm0, xmm8
	movss	xmm1, DWORD PTR draw_pos$[rbp-252]
	movss	DWORD PTR [rsi+24304], xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN1457@InputTextE

; 13383:     if (ref_pos)
; 13384:         g.LogLinePosY = ref_pos->y;
; 13385:     if (log_new_line)
; 13386:     {
; 13387:         LogText(IM_NEWLINE);

	lea	rcx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText

; 13388:         g.LogLineFirstItem = true;

	mov	BYTE PTR [rsi+24308], 1
$LN1457@InputTextE:

; 13389:     }
; 13390: 
; 13391:     if (prefix)
; 13392:         LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.

	lea	r8, OFFSET FLAT:??_C@_01HCONENDN@?$HL@+1
	lea	rdx, OFFSET FLAT:??_C@_01HCONENDN@?$HL@
	lea	rcx, QWORD PTR draw_pos$[rbp-256]
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText

; 13393: 
; 13394:     // Re-adjust padding if we have popped out of our starting depth
; 13395:     if (g.LogDepthRef > window->DC.TreeDepth)

	mov	eax, DWORD PTR [r14+448]
	mov	ecx, DWORD PTR [rsi+24312]
	cmp	ecx, eax
	jle	SHORT $LN408@InputTextE

; 13396:         g.LogDepthRef = window->DC.TreeDepth;

	mov	DWORD PTR [rsi+24312], eax
	mov	ecx, eax
$LN408@InputTextE:

; 13397:     const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

	mov	r14d, DWORD PTR [r14+448]
	sub	r14d, ecx

; 13398: 
; 13399:     const char* text_remaining = text;

	mov	r15d, 1
	npad	3
$LL401@InputTextE:

; 1854 :     const char* p = (const char*)memchr(str, '\n', str_end - str);

	mov	r8, rdi
	sub	r8, r12
	mov	edx, 10
	mov	rcx, r12
	call	memchr

; 1855 :     return p ? p : str_end;

	mov	rbx, rdi
	test	rax, rax
	cmovne	rbx, rax

; 13407:         if (line_start != line_end || !is_last_line)

	cmp	r12, rbx
	jne	SHORT $LN410@InputTextE
	cmp	rbx, rdi
	je	SHORT $LN1352@InputTextE
$LN410@InputTextE:

; 13408:         {
; 13409:             const int line_length = (int)(line_end - line_start);

	mov	r9d, ebx
	sub	r9d, r12d

; 13410:             const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;

	cmp	BYTE PTR [rsi+24308], 0
	lea	edx, DWORD PTR [r14*4]
	jne	SHORT $LN418@InputTextE
	mov	edx, r15d
$LN418@InputTextE:

; 13411:             LogText("%*s%.*s", indentation, "", line_length, line_start);

	mov	QWORD PTR [rsp+32], r12
	lea	r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, OFFSET FLAT:??_C@_07LFDEMEGD@?$CF?$CKs?$CF?4?$CKs@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText

; 13412:             g.LogLineFirstItem = false;

	mov	BYTE PTR [rsi+24308], 0

; 13413:             if (*line_end == '\n')

	cmp	BYTE PTR [rbx], 10
	jne	SHORT $LN411@InputTextE

; 13414:             {
; 13415:                 LogText(IM_NEWLINE);

	lea	rcx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText

; 13416:                 g.LogLineFirstItem = true;

	mov	BYTE PTR [rsi+24308], r15b
$LN411@InputTextE:

; 13417:             }
; 13418:         }
; 13419:         if (is_last_line)

	cmp	rbx, rdi
	je	SHORT $LN1352@InputTextE

; 13420:             break;
; 13421:         text_remaining = line_end + 1;

	lea	r12, QWORD PTR [rbx+1]

; 13422:     }

	jmp	$LL401@InputTextE
$LN1352@InputTextE:

; 13423: 
; 13424:     if (suffix)
; 13425:         LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));

	lea	r8, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@+1
	lea	rdx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN@
	lea	rcx, QWORD PTR draw_pos$[rbp-256]
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
	mov	r15d, DWORD PTR id$1$[rsp]
$LN413@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5042 :     if (label_size.x > 0)

	movss	xmm0, DWORD PTR label_size$$sroa$6543$1$[rbp-256]
	comiss	xmm0, xmm9
	jbe	SHORT $LN227@InputTextE

; 5043 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	addss	xmm13, DWORD PTR [r13+14636]
	addss	xmm12, DWORD PTR [r13+14616]
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR label$GSCopy$1$[rbp-256]
	movaps	xmm0, xmm13
	unpcklps xmm0, xmm12
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN227@InputTextE:

; 5044 : 
; 5045 :     if (value_changed && !(flags & ImGuiInputTextFlags_NoMarkEdited))

	movzx	edx, BYTE PTR value_changed$1$[rsp]
	mov	r8d, DWORD PTR flags$1$[rsp]
	test	dl, dl
	je	SHORT $LN228@InputTextE
	bt	r8d, 27
	jb	SHORT $LN228@InputTextE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4029 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4030 :     if (g.ActiveId == id || g.ActiveId == 0)

	mov	ecx, DWORD PTR [rax+16504]
	cmp	ecx, r15d
	je	SHORT $LN431@InputTextE
	test	ecx, ecx
	jne	SHORT $LN430@InputTextE
$LN431@InputTextE:

; 4031 :     {
; 4032 :         g.ActiveIdHasBeenEditedThisFrame = true;
; 4033 :         g.ActiveIdHasBeenEditedBefore = true;

	mov	WORD PTR [rax+16520], 257		; 00000101H
$LN430@InputTextE:

; 4034 :     }
; 4035 : 
; 4036 :     // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
; 4037 :     // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
; 4038 :     IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id);
; 4039 : 
; 4040 :     //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
; 4041 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;

	or	DWORD PTR [rax+18624], 4
$LN228@InputTextE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5049 :     if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)

	test	r8b, 32					; 00000020H
	mov	eax, edx
	movzx	ecx, BYTE PTR validated$1$[rsp]
	cmovne	eax, ecx
	jmp	$LN230@InputTextE
?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ENDP ; ImGui::InputTextEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
render_cursor$1$ = 80
user_scroll_active$1$ = 81
value_changed$1$ = 81
is_wordmove_key_down$1$ = 82
input_requested_by_nav$1$ = 82
tv11311 = 84
tv11299 = 84
clear_active_id$1$ = 88
validated$1$ = 89
init_state$1$ = 89
flags$1$ = 92
is_startend_key_down$1$ = 96
tv11239 = 100
tv11237 = 104
is_displaying_hint$1$ = 108
hovered$1$ = 109
is_paste$1$ = 109
id$1$ = 112
g$1$ = 120
is_cut$1$ = 128
revert_edit$1$ = 129
buf_display_from_state$1$ = 130
tv11229 = 132
tv10770 = 132
text_size$$sroa$6550$1$ = 136
buf_size$GSCopy$1$ = 136
text_size$$sroa$6551$1$ = 144
apply_new_text$1$ = 144
row_count_per_page$1$ = 144
c$18 = 144
c$19 = 144
c$20 = 144
c$21 = 144
$T22 = 152
is_osx$1$ = 156
is_undo$1$ = 157
is_copy$1$ = 158
state$1$ = 160
c$23 = 160
$T24 = 160
text_size$25 = 160
c$26 = 160
$T27 = 160
$T28 = 160
w_text$29 = 160
$T30 = 160
$T31 = 160
frame_size$ = 160
apply_new_text_length$1$ = 176
clipboard_filtered$1$ = 176
tv11232 = 176
tv10808 = 176
tv11234 = 184
text_remaining$1$ = 192
draw_window$1$ = 200
$T32 = 208
hint$GSCopy$1$ = 216
$T33 = 216
$T34 = 216
$T35 = 216
frame_bb$1$ = 224
callback_user_data$GSCopy$1$ = 232
callback$GSCopy$1$ = 240
bg_offy_up$1$ = 248
label_size$$sroa$6543$1$ = 252
window$1$ = 256
label$GSCopy$1$ = 264
r$36 = 272
r$37 = 272
callback_data$38 = 304
callback_data$39 = 368
clip_rect$40 = 432
c$41 = 432
c$42 = 432
clip_rect$43 = 432
c$44 = 432
cursor_screen_rect$45 = 432
rect$46 = 432
frame_bb$ = 432
draw_pos$ = 448
backup_current_text_length$1$ = 456
buf_end$47 = 456
buf_end$48 = 456
total_bb$ = 456
clip_rect$ = 472
item_data_backup$ = 488
__$ArrayPad$ = 552
label$ = 800
hint$ = 808
buf$ = 816
buf_size$ = 824
size_arg$ = 832
flags$ = 840
callback$ = 848
callback_user_data$ = 856
?dtor$0@?0??InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z@4HA PROC ; `ImGui::InputTextEx'::`1'::dtor$0
	lea	rcx, QWORD PTR w_text$29[rdx]
	jmp	??1?$ImVector@G@@QEAA@XZ		; ImVector<unsigned short>::~ImVector<unsigned short>
?dtor$0@?0??InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z@4HA ENDP ; `ImGui::InputTextEx'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEditRestoreH@@YAXPEBMPEAM@Z
_TEXT	SEGMENT
$T1 = 32
col$ = 64
H$ = 72
?ColorEditRestoreH@@YAXPEBMPEAM@Z PROC			; ColorEditRestoreH, COMDAT

; 5112 : {

	sub	rsp, 56					; 00000038H

; 5113 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r9, rdx

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	mov	eax, DWORD PTR [r8+23832]
	cmp	DWORD PTR [r8+23836], eax
	jne	SHORT $LN3@ColorEditR
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR $T1[rsp], xmm0
	movss	xmm0, DWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	lea	rcx, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR $T1[rsp+8], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm1
	mov	DWORD PTR $T1[rsp+12], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5115 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	cmp	DWORD PTR [r8+23848], eax
	jne	SHORT $LN3@ColorEditR

; 5116 :         return;
; 5117 :     *H = g.ColorEditSavedHue;

	mov	eax, DWORD PTR [r8+23840]
	mov	DWORD PTR [r9], eax
$LN3@ColorEditR:

; 5118 : }

	add	rsp, 56					; 00000038H
	ret	0
?ColorEditRestoreH@@YAXPEBMPEAM@Z ENDP			; ColorEditRestoreH
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEditRestoreHS@@YAXPEBMPEAM11@Z
_TEXT	SEGMENT
$T1 = 32
col$ = 80
H$ = 88
S$ = 96
V$ = 104
?ColorEditRestoreHS@@YAXPEBMPEAM11@Z PROC		; ColorEditRestoreHS, COMDAT

; 5123 : {

	sub	rsp, 72					; 00000048H

; 5124 :     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r11, rdx

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	mov	eax, DWORD PTR [r10+23832]
	cmp	DWORD PTR [r10+23836], eax
	jne	$LN3@ColorEditR
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR $T1[rsp], xmm0
	movss	xmm0, DWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	lea	rcx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR [rsp+48], xmm6
	xorps	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR $T1[rsp+8], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm1
	mov	DWORD PTR $T1[rsp+12], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5126 :     if (g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	cmp	DWORD PTR [r10+23848], eax
	jne	SHORT $LN21@ColorEditR

; 5127 :         return;
; 5128 : 
; 5129 :     // When S == 0, H is undefined.
; 5130 :     // When H == 1 it wraps around to 0.
; 5131 :     if (*S == 0.0f || (*H == 0.0f && g.ColorEditSavedHue == 1))

	movss	xmm0, DWORD PTR [r8]
	ucomiss	xmm0, xmm6
	jp	SHORT $LN12@ColorEditR
	je	SHORT $LN10@ColorEditR
$LN12@ColorEditR:
	movss	xmm0, DWORD PTR [r11]
	ucomiss	xmm0, xmm6
	jp	SHORT $LN4@ColorEditR
	jne	SHORT $LN4@ColorEditR
	movss	xmm0, DWORD PTR [r10+23840]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	jp	SHORT $LN4@ColorEditR
	jne	SHORT $LN4@ColorEditR
$LN10@ColorEditR:

; 5132 :         *H = g.ColorEditSavedHue;

	mov	eax, DWORD PTR [r10+23840]
	mov	DWORD PTR [r11], eax
$LN4@ColorEditR:

; 5133 : 
; 5134 :     // When V == 0, S is undefined.
; 5135 :     if (*V == 0.0f)

	movss	xmm0, DWORD PTR [r9]
	ucomiss	xmm0, xmm6
	jp	SHORT $LN21@ColorEditR
	jne	SHORT $LN21@ColorEditR

; 5136 :         *S = g.ColorEditSavedSat;

	mov	eax, DWORD PTR [r10+23844]
	mov	DWORD PTR [r8], eax
$LN21@ColorEditR:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN3@ColorEditR:

; 5137 : }

	add	rsp, 72					; 00000048H
	ret	0
?ColorEditRestoreHS@@YAXPEBMPEAM11@Z ENDP		; ColorEditRestoreHS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z
_TEXT	SEGMENT
$T4 = 48
$T5 = 48
half_sz$ = 56
pos$ = 64
$T6 = 64
pos$ = 64
$T7 = 72
pos$ = 72
__$ArrayPad$ = 80
draw_list$ = 288
bar_w$ = 312
alpha$ = 320
?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z PROC ; RenderArrowsForVerticalBar, COMDAT

; 5398 : {

	mov	r11, rsp
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 256				; 00000100H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm1, DWORD PTR alpha$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5398 : {

	mov	QWORD PTR [r11-40], r14
	mov	rdi, rcx
	mov	QWORD PTR pos$[rsp], rdx
	movaps	XMMWORD PTR [r11-56], xmm6
	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [r11-120], xmm10
	movaps	XMMWORD PTR [r11-136], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm11, DWORD PTR __real@3f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5398 : {

	movaps	XMMWORD PTR [r11-152], xmm12
	movq	xmm12, r8
	movaps	XMMWORD PTR [rsp+112], xmm13
	movaps	XMMWORD PTR [rsp+96], xmm15
	movaps	xmm15, xmm3
	movsd	QWORD PTR half_sz$[rsp], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	ja	SHORT $LN6@RenderArro
	movaps	xmm0, xmm11
	minss	xmm0, xmm1
$LN6@RenderArro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5399 :     ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);

	mulss	xmm0, DWORD PTR __real@437f0000

; 5400 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0,0,0,alpha8));

	mov	r9d, 1
	mov	QWORD PTR [rsp+248], rbx
	movss	xmm13, DWORD PTR half_sz$[rsp]
	movss	xmm9, DWORD PTR pos$[rsp]
	movaps	xmm7, xmm13
	addss	xmm0, DWORD PTR __real@3f000000
	addss	xmm7, DWORD PTR __real@40000000
	movss	xmm8, DWORD PTR half_sz$[rsp+4]
	movaps	xmm6, xmm9
	movss	xmm10, DWORD PTR pos$[rsp+4]
	addss	xmm6, xmm13
	addss	xmm8, xmm11
	cvttss2si r14d, xmm0
	movaps	xmm1, xmm6
	movaps	xmm0, xmm7
	addss	xmm1, xmm11
	unpcklps xmm0, xmm8
	shl	r14d, 24
	movq	r8, xmm0
	mov	DWORD PTR [rsp+32], r14d
	unpcklps xmm1, xmm10
	movq	rdx, xmm1
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt

; 5401 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32(255,255,255,alpha8));

	movaps	xmm0, xmm6
	mov	ebp, r14d
	unpcklps xmm0, xmm10
	or	ebp, 16777215				; 00ffffffH
	movq	rdx, xmm0
	mov	DWORD PTR [rsp+32], ebp
	mov	r9d, 1
	movq	r8, xmm12
	mov	rcx, rdi
	call	?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z ; ImGui::RenderArrowPointingAt
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm12, XMMWORD PTR [rsp+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5402 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

	addss	xmm9, xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm15, XMMWORD PTR [rsp+96]

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	movaps	xmm0, xmm8

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm6, XMMWORD PTR [rsp+224]

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	addss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5402 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

	movss	DWORD PTR pos$[rsp+4], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	mov	esi, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5402 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

	subss	xmm9, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5402 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

	movaps	xmm1, xmm9
	subss	xmm1, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm11, XMMWORD PTR [rsp+144]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5402 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));

	movss	DWORD PTR pos$[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	addss	xmm1, xmm7

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm7, XMMWORD PTR [rsp+208]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm1
	movss	DWORD PTR $T6[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	movaps	xmm1, xmm10
	subss	xmm1, xmm8

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	movaps	xmm8, XMMWORD PTR [rsp+192]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	r14d, r14d
	je	SHORT $LN312@RenderArro

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, rdi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rdi
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rdi+120]

; 2805 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	rbx, QWORD PTR [rdi+120]

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rbx+4]
	cmp	r8d, ecx
	jne	SHORT $LN39@RenderArro
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN43@RenderArro
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN44@RenderArro
$LN43@RenderArro:
	mov	eax, esi
$LN44@RenderArro:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN39@RenderArro:
	movsxd	rdx, DWORD PTR [rbx]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, r14d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rdi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [rbx]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx], 0
	jmp	SHORT $LN311@RenderArro
$LN312@RenderArro:
	lea	rbx, QWORD PTR [rdi+120]
$LN311@RenderArro:

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	r14, QWORD PTR [rsp+240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5403 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));

	movaps	xmm0, xmm9
	movss	DWORD PTR pos$[rsp], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm1, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5403 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));

	movss	DWORD PTR pos$[rsp+4], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3881 :     case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;

	addss	xmm9, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5403 :     ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));

	addss	xmm0, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm13, XMMWORD PTR [rsp+112]
	subss	xmm10, DWORD PTR half_sz$[rsp+4]
	addss	xmm1, DWORD PTR half_sz$[rsp+4]
	movss	DWORD PTR $T7[rsp], xmm9
	movaps	xmm9, XMMWORD PTR [rsp+176]
	movss	DWORD PTR $T7[rsp+4], xmm10
	movaps	xmm10, XMMWORD PTR [rsp+160]
	movss	DWORD PTR $T4[rsp], xmm0
	movss	DWORD PTR $T4[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	ebp, -16777216				; ff000000H
	je	$LN171@RenderArro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [rbx]
	mov	ecx, DWORD PTR [rbx+4]
	cmp	r8d, ecx
	jne	SHORT $LN177@RenderArro
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN181@RenderArro
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN182@RenderArro
$LN181@RenderArro:
	mov	eax, esi
$LN182@RenderArro:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN177@RenderArro:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx]
	inc	ecx
	mov	DWORD PTR [rbx], ecx
	mov	r8d, DWORD PTR [rbx+4]
	cmp	ecx, r8d
	jne	SHORT $LN186@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN190@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN191@RenderArro
$LN190@RenderArro:
	mov	eax, esi
$LN191@RenderArro:
	cmp	eax, ecx
	cmovg	ecx, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN186@RenderArro:
	movsxd	rdx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax
	mov	ecx, DWORD PTR [rbx]
	inc	ecx
	mov	DWORD PTR [rbx], ecx
	mov	r8d, DWORD PTR [rbx+4]
	cmp	ecx, r8d
	jne	SHORT $LN195@RenderArro
	inc	ecx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN199@RenderArro
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [r8+rax]
$LN199@RenderArro:
	cmp	esi, ecx
	cmovg	ecx, esi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, ecx
	mov	rcx, rbx
	call	?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z	; ImVector<ImVec2>::reserve
$LN195@RenderArro:
	movsxd	r8, DWORD PTR [rbx]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, ebp

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rdx, QWORD PTR [rbx+8]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	rcx, rdi

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rax, QWORD PTR pos$[rsp]
	mov	QWORD PTR [rdx+r8*8], rax
	inc	DWORD PTR [rbx]

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r8d, DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	DWORD PTR [rbx], 0
$LN171@RenderArro:
	mov	rbx, QWORD PTR [rsp+248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5404 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 256				; 00000100H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?RenderArrowsForVerticalBar@@YAXPEAUImDrawList@@UImVec2@@1MM@Z ENDP ; RenderArrowsForVerticalBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z
_TEXT	SEGMENT
sz$ = 112
cf$ = 120
__$ArrayPad$ = 136
text$ = 240
col$ = 248
flags$ = 256
?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z PROC		; ImGui::ColorTooltip, COMDAT

; 5883 : {

$LN159:
	push	rbx
	push	rsi
	push	rdi
	push	r12
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5884 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdi, rcx

; 5885 : 
; 5886 :     if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))

	mov	ecx, 2
	mov	r12d, r8d
	mov	rbx, rdx
	call	?BeginTooltipEx@ImGui@@YA_NHH@Z		; ImGui::BeginTooltipEx
	test	al, al
	je	$LN1@ColorToolt
	mov	QWORD PTR [rsp+184], r14
	mov	QWORD PTR [rsp+176], r15
	movaps	XMMWORD PTR [rsp+160], xmm6

; 5887 :         return;
; 5888 :     const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;

	movss	xmm6, DWORD PTR __real@3f800000
	movaps	XMMWORD PTR [rsp+144], xmm7
	test	rdi, rdi
	je	SHORT $LN25@ColorToolt
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rdx, rdi

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdi, -1
	jae	SHORT $LN139@ColorToolt
$LL20@ColorToolt:
	movzx	ecx, BYTE PTR [rdx]
	test	cl, cl
	je	SHORT $LN139@ColorToolt
	lea	rax, QWORD PTR [rdx+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN138@ColorToolt
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN139@ColorToolt
$LN138@ColorToolt:

; 3332 :         text_display_end++;

	mov	rdx, rax
	cmp	rax, -1
	jb	SHORT $LL20@ColorToolt
$LN139@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5889 :     if (text_end > text)

	cmp	rdx, rdi
	jbe	SHORT $LN25@ColorToolt

; 5890 :     {
; 5891 :         TextEx(text, text_end);

	xor	r8d, r8d
	mov	rcx, rdi
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN25@ColorToolt

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]

; 1473 :     SeparatorEx(flags, 1.0f);

	movaps	xmm1, xmm6
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN25@ColorToolt:

; 5892 :         Separator();
; 5893 :     }
; 5894 : 
; 5895 :     ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);

	movss	xmm0, DWORD PTR [rsi+14616]

; 5896 :     ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	mov	edi, r12d
	movss	xmm1, DWORD PTR [rsi+15696]
	addss	xmm0, xmm0
	mulss	xmm1, DWORD PTR __real@40400000
	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR sz$[rsp], xmm1
	movss	DWORD PTR sz$[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5896 :     ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	and	edi, 2
	je	SHORT $LN15@ColorToolt
	movaps	xmm0, xmm6
	jmp	SHORT $LN16@ColorToolt
$LN15@ColorToolt:
	movss	xmm0, DWORD PTR [rbx+12]
$LN16@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm1, DWORD PTR [rbx]
	xorps	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm7, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm2, DWORD PTR [rbx+4]
	movss	xmm4, DWORD PTR [rbx+8]
	movss	DWORD PTR cf$[rsp], xmm1
	movss	DWORD PTR cf$[rsp+4], xmm2
	movss	DWORD PTR cf$[rsp+8], xmm4
	movss	DWORD PTR cf$[rsp+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN36@ColorToolt
	xorps	xmm0, xmm0
	jmp	SHORT $LN37@ColorToolt
$LN36@ColorToolt:
	movaps	xmm0, xmm6
	minss	xmm0, xmm1
$LN37@ColorToolt:
	comiss	xmm7, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5897 :     int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	movss	xmm1, DWORD PTR __real@437f0000
	movss	xmm3, DWORD PTR __real@3f000000
	mulss	xmm0, xmm1
	addss	xmm0, xmm3
	cvttss2si r15d, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN42@ColorToolt
	xorps	xmm0, xmm0
	jmp	SHORT $LN43@ColorToolt
$LN42@ColorToolt:
	movaps	xmm0, xmm6
	minss	xmm0, xmm2
$LN43@ColorToolt:
	comiss	xmm7, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5897 :     int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm0, xmm1
	addss	xmm0, xmm3
	cvttss2si r14d, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN48@ColorToolt
	xorps	xmm0, xmm0
	jmp	SHORT $LN49@ColorToolt
$LN48@ColorToolt:
	movaps	xmm0, xmm6
	minss	xmm0, xmm4
$LN49@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5897 :     int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm0, xmm1
	mov	QWORD PTR [rsp+192], rbp
	addss	xmm0, xmm3
	cvttss2si esi, xmm0
	test	edi, edi
	je	SHORT $LN17@ColorToolt
	mov	ebp, 255				; 000000ffH
	jmp	SHORT $LN18@ColorToolt
$LN17@ColorToolt:
	movss	xmm0, DWORD PTR [rbx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm7, xmm0
	jbe	SHORT $LN54@ColorToolt
	xorps	xmm6, xmm6
	jmp	SHORT $LN55@ColorToolt
$LN54@ColorToolt:
	minss	xmm6, xmm0
$LN55@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5897 :     int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm6, xmm1
	addss	xmm6, xmm3
	cvttss2si ebp, xmm6
$LN18@ColorToolt:

; 5898 :     ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);

	mov	r8d, r12d
	lea	r9, QWORD PTR sz$[rsp]
	and	r8d, 403046402				; 18060002H
	lea	rdx, QWORD PTR cf$[rsp]
	or	r8d, 64					; 00000040H
	lea	rcx, OFFSET FLAT:??_C@_09JCCDBEFL@?$CD?$CDpreview@
	call	?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HAEBUImVec2@@@Z ; ImGui::ColorButton

; 5899 :     SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movaps	xmm7, XMMWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [rsp+160]

; 5900 :     if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags_InputMask_))

	bt	r12d, 27
	jb	SHORT $LN6@ColorToolt
	test	r12d, 402653184				; 18000000H
	je	SHORT $LN6@ColorToolt

; 5906 :     }
; 5907 :     else if (flags & ImGuiColorEditFlags_InputHSV)

	bt	r12d, 28
	jae	$LN8@ColorToolt

; 5908 :     {
; 5909 :         if (flags & ImGuiColorEditFlags_NoAlpha)

	movss	xmm3, DWORD PTR [rbx+8]
	movss	xmm2, DWORD PTR [rbx+4]
	movss	xmm1, DWORD PTR [rbx]
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm2, xmm2
	movq	r9, xmm3
	movq	r8, xmm2
	cvtps2pd xmm1, xmm1
	movq	rdx, xmm1
	test	edi, edi
	je	SHORT $LN10@ColorToolt

; 5910 :             Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);

	lea	rcx, OFFSET FLAT:??_C@_0BK@HKNBICJE@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	jmp	$LN8@ColorToolt
$LN10@ColorToolt:
	movss	xmm0, DWORD PTR [rbx+12]

; 5911 :         else
; 5912 :             Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);

	lea	rcx, OFFSET FLAT:??_C@_0CD@EEDEAEPG@H?3?5?$CF?43f?0?5S?3?5?$CF?43f?0?5V?3?5?$CF?43f?0?5A?3?5?$CF@
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [rsp+32], xmm0
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	jmp	$LN8@ColorToolt
$LN6@ColorToolt:

; 5901 :     {
; 5902 :         if (flags & ImGuiColorEditFlags_NoAlpha)

	mov	r9d, esi
	mov	r8d, r14d
	mov	edx, r15d
	test	edi, edi
	je	SHORT $LN7@ColorToolt

; 5903 :             Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);

	movss	xmm0, DWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:??_C@_0DF@FAPNKOHO@?$CD?$CF02X?$CF02X?$CF02X?6R?3?5?$CFd?0?5G?3?5?$CFd?0?5B?3?5@
	movss	xmm1, DWORD PTR [rbx+4]
	movss	xmm2, DWORD PTR [rbx]
	cvtps2pd xmm0, xmm0
	cvtps2pd xmm1, xmm1
	movsd	QWORD PTR [rsp+72], xmm0
	movsd	QWORD PTR [rsp+64], xmm1
	cvtps2pd xmm2, xmm2
	movsd	QWORD PTR [rsp+56], xmm2
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r15d
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	jmp	SHORT $LN8@ColorToolt
$LN7@ColorToolt:
	movss	xmm0, DWORD PTR [rbx+12]

; 5904 :         else
; 5905 :             Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);

	lea	rcx, OFFSET FLAT:??_C@_0EC@EBPMGCGK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X?6R?3?$CFd?0?5G?3?$CFd?0?5B@
	movss	xmm1, DWORD PTR [rbx+8]
	movss	xmm2, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx]
	cvtps2pd xmm0, xmm0
	cvtps2pd xmm1, xmm1
	movsd	QWORD PTR [rsp+96], xmm0
	movsd	QWORD PTR [rsp+88], xmm1
	cvtps2pd xmm2, xmm2
	cvtps2pd xmm3, xmm3
	movsd	QWORD PTR [rsp+80], xmm2
	movsd	QWORD PTR [rsp+72], xmm3
	mov	DWORD PTR [rsp+64], ebp
	mov	DWORD PTR [rsp+56], esi
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], ebp
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
$LN8@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10862:     End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	mov	r15, QWORD PTR [rsp+176]
	mov	r14, QWORD PTR [rsp+184]
	mov	rbp, QWORD PTR [rsp+192]
$LN1@ColorToolt:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5915 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z ENDP		; ImGui::ColorTooltip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
g$1$ = 72
buf$6 = 80
__$ArrayPad$ = 144
col$ = 240
flags$ = 248
?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z PROC		; ImGui::ColorEditOptionsPopup, COMDAT

; 5918 : {

$LN181:
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax

; 5919 :     bool allow_opt_inputs = !(flags & ImGuiColorEditFlags_DisplayMask_);
; 5920 :     bool allow_opt_datatype = !(flags & ImGuiColorEditFlags_DataTypeMask_);

	mov	esi, edx
	mov	edi, edx
	and	esi, 25165824				; 01800000H
	mov	r13d, edx
	mov	r12, rcx
	and	edi, 7340032				; 00700000H

; 5921 :     if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))

	je	SHORT $LN4@ColorEditO
	test	esi, esi
	jne	$LN1@ColorEditO
$LN4@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11170:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11171:     if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	eax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jg	SHORT $LN28@ColorEditO

; 11172:     {
; 11173:         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	mov	DWORD PTR [rcx+18680], 0

; 11174:         return false;

	jmp	$LN1@ColorEditO
$LN28@ColorEditO:

; 11175:     }
; 11176:     flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
; 11177:     ImGuiID id = g.CurrentWindow->GetID(str_id);

	mov	r10, QWORD PTR [rcx+16408]

; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@+1
	mov	QWORD PTR [rsp+248], rbx
	mov	r8b, 99					; 00000063H
	mov	QWORD PTR [rsp+256], r14
	lea	r14, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [r10+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	rax, QWORD PTR [r10+304]
	mov	r9d, DWORD PTR [rax+rcx*4-4]
	not	r9d

; 2050 :     ImU32 crc = seed;

	mov	ebx, r9d
$LL40@ColorEditO:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN45@ColorEditO
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN45@ColorEditO
	cmp	BYTE PTR [rdx+1], r8b
	cmove	ebx, r9d
$LN45@ColorEditO:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, bl
	movzx	eax, r8b
	movzx	r8d, BYTE PTR [rdx]
	xor	rcx, rax
	shr	ebx, 8
	inc	rdx
	xor	ebx, DWORD PTR [r14+rcx*4]
	test	r8b, r8b
	jne	SHORT $LL40@ColorEditO

; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rax, QWORD PTR [r10]

; 2072 :     return ~crc;

	not	ebx

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], ebx
	jne	SHORT $LN31@ColorEditO

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	edx, 11
	mov	ecx, ebx
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN31@ColorEditO:

; 11178:     return BeginPopupEx(id, flags);

	mov	edx, 321				; 00000141H
	mov	ecx, ebx
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5921 :     if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))

	test	al, al
	je	$LN179@ColorEditO

; 5922 :         return;
; 5923 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+176], xmm6
	movaps	XMMWORD PTR [rsp+160], xmm7
	mov	QWORD PTR g$1$[rbp-137], rax

; 5924 :     ImGuiColorEditFlags opts = g.ColorEditOptions;

	mov	ebx, DWORD PTR [rax+23828]

; 5925 :     if (allow_opt_inputs)

	test	edi, edi
	jne	SHORT $LN138@ColorEditO

; 5926 :     {
; 5927 :         if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayRGB;

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_03ICFFBAI@RGB@
	shr	edx, 20
	and	dl, 1
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	test	al, al
	je	SHORT $LN6@ColorEditO
	and	ebx, -6291457				; ffffffffff9fffffH
	bts	ebx, 20
$LN6@ColorEditO:

; 5928 :         if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHSV;

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_03CAADKAK@HSV@
	shr	edx, 21
	and	dl, 1
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	test	al, al
	je	SHORT $LN7@ColorEditO
	and	ebx, -5242881				; ffffffffffafffffH
	bts	ebx, 21
$LN7@ColorEditO:

; 5929 :         if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHex;

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_03CJOBKKAE@Hex@
	shr	edx, 22
	and	dl, 1
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	test	al, al
	je	SHORT $LN138@ColorEditO
	and	ebx, -3145729				; ffffffffffcfffffH
	bts	ebx, 22
$LN138@ColorEditO:

; 5930 :     }
; 5931 :     if (allow_opt_datatype)

	test	esi, esi
	jne	SHORT $LN139@ColorEditO

; 5932 :     {
; 5933 :         if (allow_opt_inputs) Separator();

	test	edi, edi
	jne	SHORT $LN10@ColorEditO
	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator
$LN10@ColorEditO:

; 5934 :         if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Uint8;

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_06FDBEKFBH@0?4?4255@
	shr	edx, 23
	and	dl, 1
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	test	al, al
	je	SHORT $LN11@ColorEditO
	btr	ebx, 24
	bts	ebx, 23
$LN11@ColorEditO:

; 5935 :         if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Float;

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_0L@MDNPBJBM@0?400?4?41?400@
	shr	edx, 24
	and	dl, 1
	call	?RadioButton@ImGui@@YA_NPEBD_N@Z	; ImGui::RadioButton
	test	al, al
	je	SHORT $LN139@ColorEditO
	btr	ebx, 23
	bts	ebx, 24
$LN139@ColorEditO:

; 5936 :     }
; 5937 : 
; 5938 :     if (allow_opt_inputs || allow_opt_datatype)

	movss	xmm7, DWORD PTR __real@3f800000
	test	edi, edi
	je	SHORT $LN14@ColorEditO
	test	esi, esi
	jne	SHORT $LN71@ColorEditO
$LN14@ColorEditO:

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN71@ColorEditO

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]

; 1473 :     SeparatorEx(flags, 1.0f);

	movaps	xmm1, xmm7
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN71@ColorEditO:

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T5[rbp-137], -1082130432	; bf800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	lea	rdx, QWORD PTR $T5[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T5[rbp-133], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	lea	rcx, OFFSET FLAT:??_C@_09NMCCFHEI@Copy?5as?4?4@
	xorps	xmm6, xmm6
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx

; 5939 :         Separator();
; 5940 :     if (Button("Copy as..", ImVec2(-1, 0)))

	test	al, al
	je	SHORT $LN15@ColorEditO

; 5941 :         OpenPopup("Copy");

	lea	rcx, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup
$LN15@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11170:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11171:     if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	eax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jg	SHORT $LN52@ColorEditO

; 11172:     {
; 11173:         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	mov	DWORD PTR [rcx+18680], 0

; 11174:         return false;

	jmp	$LN16@ColorEditO
$LN52@ColorEditO:

; 11175:     }
; 11176:     flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
; 11177:     ImGuiID id = g.CurrentWindow->GetID(str_id);

	mov	r11, QWORD PTR [rcx+16408]

; 2065 :         while (unsigned char c = *data++)

	lea	r9, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@+1
	mov	dl, 67					; 00000043H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [r11+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	rax, QWORD PTR [r11+304]
	mov	r10d, DWORD PTR [rax+rcx*4-4]
	not	r10d

; 2050 :     ImU32 crc = seed;

	mov	edi, r10d
$LL64@ColorEditO:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	dl, 35					; 00000023H
	jne	SHORT $LN69@ColorEditO
	cmp	BYTE PTR [r9], dl
	jne	SHORT $LN69@ColorEditO
	cmp	BYTE PTR [r9+1], dl
	cmove	edi, r10d
$LN69@ColorEditO:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, dil
	movzx	eax, dl
	movzx	edx, BYTE PTR [r9]
	xor	rcx, rax
	shr	edi, 8
	inc	r9
	xor	edi, DWORD PTR [r14+rcx*4]
	test	dl, dl
	jne	SHORT $LL64@ColorEditO

; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rax, QWORD PTR [r11]

; 2072 :     return ~crc;

	not	edi

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], edi
	jne	SHORT $LN55@ColorEditO

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_04OPMHGHMB@Copy@
	mov	edx, 11
	mov	ecx, edi
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN55@ColorEditO:

; 11178:     return BeginPopupEx(id, flags);

	mov	edx, 321				; 00000141H
	mov	ecx, edi
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5942 :     if (BeginPopup("Copy"))

	test	al, al
	je	$LN16@ColorEditO

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	movss	xmm3, DWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5942 :     if (BeginPopup("Copy"))

	mov	QWORD PTR [rsp+264], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN78@ColorEditO
	movaps	xmm0, xmm6
	jmp	SHORT $LN79@ColorEditO
$LN78@ColorEditO:
	movaps	xmm0, xmm7
	minss	xmm0, xmm3
$LN79@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	movss	xmm1, DWORD PTR __real@437f0000
	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR [r12+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	cvttss2si r15d, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN84@ColorEditO
	movaps	xmm0, xmm6
	jmp	SHORT $LN85@ColorEditO
$LN84@ColorEditO:
	movaps	xmm0, xmm7
	minss	xmm0, xmm4
$LN85@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	movss	xmm5, DWORD PTR [r12+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	cvttss2si r14d, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	jbe	SHORT $LN90@ColorEditO
	movaps	xmm0, xmm6
	jmp	SHORT $LN91@ColorEditO
$LN90@ColorEditO:
	movaps	xmm0, xmm7
	minss	xmm0, xmm5
$LN91@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	cvttss2si esi, xmm0
	and	r13d, 2
	je	SHORT $LN23@ColorEditO
	mov	edi, 255				; 000000ffH

; 5945 :         char buf[64];
; 5946 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	jmp	SHORT $LN26@ColorEditO
$LN23@ColorEditO:

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	movss	xmm0, DWORD PTR [r12+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 468  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm6, xmm0
	ja	SHORT $LN103@ColorEditO
	minss	xmm7, xmm0
	movaps	xmm6, xmm7
$LN103@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5944 :         int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);

	mulss	xmm6, xmm1

; 5945 :         char buf[64];
; 5946 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);

	movaps	xmm7, xmm0
	addss	xmm6, xmm2
	cvttss2si edi, xmm6
$LN26@ColorEditO:
	xorps	xmm0, xmm0
	lea	r8, OFFSET FLAT:??_C@_0BN@GKCJMPCH@?$CI?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?0?5?$CF?43ff?$CJ@
	cvtss2sd xmm0, xmm7
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$6[rbp-137]
	cvtps2pd xmm1, xmm5
	movsd	QWORD PTR [rsp+48], xmm0
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm2, xmm4
	movsd	QWORD PTR [rsp+40], xmm1
	movq	r9, xmm3
	movsd	QWORD PTR [rsp+32], xmm2
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 5947 :         if (Selectable(buf))

	lea	r9, QWORD PTR $T4[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T4[rbp-137], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5947 :         if (Selectable(buf))

	xor	r8d, r8d
	lea	rcx, QWORD PTR buf$6[rbp-137]
	xor	edx, edx
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN105@ColorEditO
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4325 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4326 :     if (g.IO.SetClipboardTextFn)

	mov	rax, QWORD PTR [rcx+184]
	test	rax, rax
	je	SHORT $LN105@ColorEditO

; 4327 :         g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);

	mov	rcx, QWORD PTR [rcx+192]
	lea	rdx, QWORD PTR buf$6[rbp-137]
	call	rax
$LN105@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5949 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);

	mov	DWORD PTR [rsp+48], edi
	lea	r8, OFFSET FLAT:??_C@_0O@EJHNAHBL@?$CI?$CFd?0?$CFd?0?$CFd?0?$CFd?$CJ@
	mov	DWORD PTR [rsp+40], esi
	lea	rcx, QWORD PTR buf$6[rbp-137]
	mov	r9d, r15d
	mov	DWORD PTR [rsp+32], r14d
	mov	edx, 64					; 00000040H
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 5950 :         if (Selectable(buf))

	lea	r9, QWORD PTR $T3[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T3[rbp-137], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5950 :         if (Selectable(buf))

	xor	r8d, r8d
	lea	rcx, QWORD PTR buf$6[rbp-137]
	xor	edx, edx
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN108@ColorEditO
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4325 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4326 :     if (g.IO.SetClipboardTextFn)

	mov	rax, QWORD PTR [rcx+184]
	test	rax, rax
	je	SHORT $LN108@ColorEditO

; 4327 :         g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);

	mov	rcx, QWORD PTR [rcx+192]
	lea	rdx, QWORD PTR buf$6[rbp-137]
	call	rax
$LN108@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5952 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", cr, cg, cb);

	mov	DWORD PTR [rsp+40], esi
	lea	r8, OFFSET FLAT:??_C@_0O@MBPBDFLP@?$CD?$CF02X?$CF02X?$CF02X@
	mov	r9d, r15d
	mov	DWORD PTR [rsp+32], r14d
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$6[rbp-137]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 5953 :         if (Selectable(buf))

	lea	r9, QWORD PTR $T2[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T2[rbp-137], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5953 :         if (Selectable(buf))

	xor	r8d, r8d
	lea	rcx, QWORD PTR buf$6[rbp-137]
	xor	edx, edx
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN111@ColorEditO
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4325 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4326 :     if (g.IO.SetClipboardTextFn)

	mov	rax, QWORD PTR [rcx+184]
	test	rax, rax
	je	SHORT $LN111@ColorEditO

; 4327 :         g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);

	mov	rcx, QWORD PTR [rcx+192]
	lea	rdx, QWORD PTR buf$6[rbp-137]
	call	rax
$LN111@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5955 :         if (!(flags & ImGuiColorEditFlags_NoAlpha))

	test	r13d, r13d
	jne	SHORT $LN116@ColorEditO

; 5956 :         {
; 5957 :             ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", cr, cg, cb, ca);

	mov	DWORD PTR [rsp+48], edi
	lea	r8, OFFSET FLAT:??_C@_0BC@CKPCOFBK@?$CD?$CF02X?$CF02X?$CF02X?$CF02X@
	mov	DWORD PTR [rsp+40], esi
	lea	edx, QWORD PTR [r13+64]
	mov	r9d, r15d
	mov	DWORD PTR [rsp+32], r14d
	lea	rcx, QWORD PTR buf$6[rbp-137]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 5958 :             if (Selectable(buf))

	lea	r9, QWORD PTR $T1[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T1[rbp-137], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5958 :             if (Selectable(buf))

	xor	r8d, r8d
	lea	rcx, QWORD PTR buf$6[rbp-137]
	xor	edx, edx
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN116@ColorEditO
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4325 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 4326 :     if (g.IO.SetClipboardTextFn)

	mov	rax, QWORD PTR [rcx+184]
	test	rax, rax
	je	SHORT $LN116@ColorEditO

; 4327 :         g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);

	mov	rcx, QWORD PTR [rcx+192]
	lea	rdx, QWORD PTR buf$6[rbp-137]
	call	rax
$LN116@ColorEditO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5961 :         EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	mov	r15, QWORD PTR [rsp+264]
$LN16@ColorEditO:

; 5962 :     }
; 5963 : 
; 5964 :     g.ColorEditOptions = opts;

	mov	rax, QWORD PTR g$1$[rbp-137]
	mov	DWORD PTR [rax+23828], ebx

; 5965 :     EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	movaps	xmm7, XMMWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [rsp+176]
$LN179@ColorEditO:
	mov	rbx, QWORD PTR [rsp+248]
	mov	r14, QWORD PTR [rsp+256]
$LN1@ColorEditO:

; 5966 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z ENDP		; ImGui::ColorEditOptionsPopup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z
_TEXT	SEGMENT
all_on$2 = 32
tv1112 = 36
picker_size$3 = 40
previewing_ref_col$4 = 48
__$ArrayPad$ = 64
ref_col$ = 192
flags$ = 200
?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z PROC		; ImGui::ColorPickerOptionsPopup, COMDAT

; 5969 : {

$LN130:
	push	rbp
	push	r12
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15d, edx

; 5970 :     bool allow_opt_picker = !(flags & ImGuiColorEditFlags_PickerMask_);

	mov	r14d, edx
	and	r15d, 65538				; 00010002H
	mov	ebp, edx
	mov	DWORD PTR tv1112[rsp], r15d
	mov	r12, rcx
	and	r14d, 100663296				; 06000000H

; 5972 :     if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))

	je	SHORT $LN7@ColorPicke
	test	r15d, r15d
	jne	$LN1@ColorPicke
$LN7@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11170:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+136], rdi

; 11171:     if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance

	mov	eax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jg	SHORT $LN39@ColorPicke

; 11172:     {
; 11173:         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	xor	edi, edi
	mov	DWORD PTR [rcx+18680], edi

; 11174:         return false;

	jmp	$LN126@ColorPicke
$LN39@ColorPicke:

; 11175:     }
; 11176:     flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
; 11177:     ImGuiID id = g.CurrentWindow->GetID(str_id);

	mov	r10, QWORD PTR [rcx+16408]

; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_07JKKCBBMM@context@+1
	mov	QWORD PTR [rsp+208], rbx
	lea	r11, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
	mov	r8b, 99					; 00000063H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [r10+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	rax, QWORD PTR [r10+304]
	mov	r9d, DWORD PTR [rax+rcx*4-4]
	not	r9d

; 2050 :     ImU32 crc = seed;

	mov	ebx, r9d
	npad	6
$LL51@ColorPicke:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN56@ColorPicke
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN56@ColorPicke
	cmp	BYTE PTR [rdx+1], r8b
	cmove	ebx, r9d
$LN56@ColorPicke:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, bl
	movzx	eax, r8b
	movzx	r8d, BYTE PTR [rdx]
	xor	rcx, rax
	shr	ebx, 8
	inc	rdx
	xor	ebx, DWORD PTR [r11+rcx*4]
	test	r8b, r8b
	jne	SHORT $LL51@ColorPicke

; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rax, QWORD PTR [r10]

; 2072 :     return ~crc;

	not	ebx

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], ebx
	jne	SHORT $LN42@ColorPicke

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_07JKKCBBMM@context@
	mov	edx, 11
	mov	ecx, ebx
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN42@ColorPicke:

; 11178:     return BeginPopupEx(id, flags);

	mov	edx, 321				; 00000141H
	mov	ecx, ebx
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5972 :     if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))

	test	al, al
	je	$LN127@ColorPicke
	mov	QWORD PTR [rsp+144], rsi

; 5973 :         return;
; 5974 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [rsp+112], xmm6
	mov	r9, rsi

; 5975 :     if (allow_opt_picker)

	movss	xmm6, DWORD PTR __real@3f800000
	test	r14d, r14d
	jne	$LN8@ColorPicke

; 5977 :         ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function

	movss	xmm1, DWORD PTR [rsi+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	movss	xmm2, DWORD PTR [rsi+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5977 :         ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@41000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm2, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5975 :     if (allow_opt_picker)

	mov	QWORD PTR [rsp+128], r13
	movaps	XMMWORD PTR [rsp+96], xmm7
	movaps	XMMWORD PTR [rsp+80], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR picker_size$3[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10421:     return g.FontSize + g.Style.FramePadding.y * 2.0f;

	addss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5977 :         ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function

	movaps	xmm1, xmm0
	addss	xmm2, DWORD PTR [rsi+14636]
	subss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR picker_size$3[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5978 :         PushItemWidth(picker_size.x);

	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	r15d, QWORD PTR [r14+12]
	xor	edi, edi
	mov	r13d, 424				; 000001a8H
	and	ebp, 2
	npad	4
$LL4@ColorPicke:

; 5980 :         {
; 5981 :             // Draw small/thumbnail version of each picker type (over an invisible button for selection)
; 5982 :             if (picker_type > 0) Separator();

	test	edi, edi
	je	SHORT $LN67@ColorPicke

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR [r9+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN67@ColorPicke

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]

; 1473 :     SeparatorEx(flags, 1.0f);

	movaps	xmm1, xmm6
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN67@ColorPicke:

; 5983 :             PushID(picker_type);

	mov	ecx, edi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 5984 :             ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);
; 5985 :             if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
; 5986 :             if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;

	test	edi, edi
	mov	ebx, 33554856				; 020001a8H
	cmovne	ebx, r13d
	or	ebx, ebp
	cmp	edi, 1
	jne	SHORT $LN11@ColorPicke
	bts	ebx, 26
$LN11@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10240:     return window->DC.CursorPos;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5988 :             if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup

	lea	r9, QWORD PTR picker_size$3[rsp]
	xor	r8d, r8d
	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10240:     return window->DC.CursorPos;

	mov	rcx, QWORD PTR [rax+16408]
	movss	xmm7, DWORD PTR [rcx+312]
	movss	xmm8, DWORD PTR [rcx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5988 :             if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup

	lea	rcx, OFFSET FLAT:??_C@_0N@KFBFGFJL@?$CD?$CDselectable@
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	je	SHORT $LN107@ColorPicke

; 5989 :                 g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags_PickerMask_) | (picker_flags & ImGuiColorEditFlags_PickerMask_);

	mov	eax, ebx
	xor	eax, DWORD PTR [rsi+23828]
	and	eax, -100663297				; fffffffff9ffffffH
	xor	eax, ebx
	mov	DWORD PTR [rsi+23828], eax
$LN107@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5992 :             memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));

	test	bl, 2
	mov	r8d, 16
	mov	rdx, r12
	cmovne	r8, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5992 :             memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));

	lea	rcx, QWORD PTR previewing_ref_col$4[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10249:     window->DC.CursorPos = pos;

	movss	DWORD PTR [rax+312], xmm7
	movss	DWORD PTR [rax+316], xmm8

; 10250:     //window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
; 10251:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	movups	XMMWORD PTR previewing_ref_col$4[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5992 :             memcpy(&previewing_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));

	call	memcpy

; 5993 :             ColorPicker4("##previewing_picker", &previewing_ref_col.x, picker_flags);

	xor	r9d, r9d
	lea	rdx, QWORD PTR previewing_ref_col$4[rsp]
	mov	r8d, ebx
	lea	rcx, OFFSET FLAT:??_C@_0BE@ENPGBMIC@?$CD?$CDpreviewing_picker@
	call	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5979 :         for (int picker_type = 0; picker_type < 2; picker_type++)

	inc	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5979 :         for (int picker_type = 0; picker_type < 2; picker_type++)

	cmp	edi, 2
	jl	$LL4@ColorPicke
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5979 :         for (int picker_type = 0; picker_type < 2; picker_type++)

	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+128]
	mov	r15d, DWORD PTR tv1112[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r9+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
$LN8@ColorPicke:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 5998 :     if (allow_opt_alpha_bar)

	test	r15d, r15d
	jne	SHORT $LN65@ColorPicke

; 5999 :     {
; 6000 :         if (allow_opt_picker) Separator();

	test	r14d, r14d
	jne	SHORT $LN70@ColorPicke

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR [r9+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], r14b
	jne	SHORT $LN70@ColorPicke

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]

; 1473 :     SeparatorEx(flags, 1.0f);

	movaps	xmm1, xmm6
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN70@ColorPicke:

; 1161 :     bool all_on = (*flags & flags_value) == flags_value;

	movzx	eax, BYTE PTR [rsi+23830]

; 1162 :     bool any_on = (*flags & flags_value) != 0;
; 1163 :     bool pressed;
; 1164 :     if (!all_on && any_on)
; 1165 :     {
; 1166 :         ImGuiContext& g = *GImGui;
; 1167 :         g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
; 1168 :         pressed = Checkbox(label, &all_on);
; 1169 :     }
; 1170 :     else
; 1171 :     {
; 1172 :         pressed = Checkbox(label, &all_on);
; 1173 : 
; 1174 :     }
; 1175 :     if (pressed)

	lea	rdx, QWORD PTR all_on$2[rsp]
	and	al, 1
	lea	rcx, OFFSET FLAT:??_C@_09KEDLMDJL@Alpha?5Bar@
	mov	BYTE PTR all_on$2[rsp], al
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox
	test	al, al
	je	SHORT $LN65@ColorPicke

; 1176 :     {
; 1177 :         if (all_on)

	cmp	BYTE PTR all_on$2[rsp], 0
	mov	eax, DWORD PTR [rsi+23828]
	je	SHORT $LN64@ColorPicke

; 1178 :             *flags |= flags_value;

	bts	eax, 16
	jmp	SHORT $LN128@ColorPicke
$LN64@ColorPicke:

; 1179 :         else
; 1180 :             *flags &= ~flags_value;

	btr	eax, 16
$LN128@ColorPicke:

; 6001 :         CheckboxFlags("Alpha Bar", &g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
; 6002 :     }
; 6003 :     EndPopup();

	mov	DWORD PTR [rsi+23828], eax
$LN65@ColorPicke:
	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	movaps	xmm6, XMMWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+144]
$LN127@ColorPicke:
	mov	rbx, QWORD PTR [rsp+208]
$LN126@ColorPicke:
	mov	rdi, QWORD PTR [rsp+136]
$LN1@ColorPicke:

; 6004 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r12
	pop	rbp
	ret	0
?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z ENDP		; ImGui::ColorPickerOptionsPopup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeSetOpen@ImGui@@YAXI_N@Z
_TEXT	SEGMENT
id$ = 8
open$ = 16
?TreeNodeSetOpen@ImGui@@YAXI_N@Z PROC			; ImGui::TreeNodeSetOpen, COMDAT

; 6108 :     ImGuiContext& g = *GImGui;
; 6109 :     ImGuiStorage* storage = g.CurrentWindow->DC.StateStorage;
; 6110 :     storage->SetInt(id, open ? 1 : 0);

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r9d, ecx
	movzx	r8d, dl
	mov	edx, r9d
	mov	rcx, QWORD PTR [rax+16408]
	mov	rcx, QWORD PTR [rcx+472]
	jmp	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt
?TreeNodeSetOpen@ImGui@@YAXI_N@Z ENDP			; ImGui::TreeNodeSetOpen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z
_TEXT	SEGMENT
id$ = 48
flags$ = 56
?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z PROC		; ImGui::TreeNodeUpdateNextOpen, COMDAT

; 6114 : {

$LN22:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	esi, edx
	mov	ebp, ecx

; 6115 :     if (flags & ImGuiTreeNodeFlags_Leaf)

	bt	edx, 8
	jae	SHORT $LN2@TreeNodeUp

; 6116 :         return true;

	mov	al, 1

; 6157 : }

	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@TreeNodeUp:
	mov	QWORD PTR [rsp+48], rbx

; 6117 : 
; 6118 :     // We only write to the tree storage if the user clicks (or explicitly use the SetNextItemOpen function)
; 6119 :     ImGuiContext& g = *GImGui;
; 6120 :     ImGuiWindow* window = g.CurrentWindow;
; 6121 :     ImGuiStorage* storage = window->DC.StateStorage;
; 6122 : 
; 6123 :     bool is_open;
; 6124 :     if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasOpen)

	mov	edx, ebp
	mov	QWORD PTR [rsp+56], rdi
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+64], r14
	test	BYTE PTR [rdi+18592], 2
	mov	r14, QWORD PTR [rdi+16408]
	mov	rcx, QWORD PTR [r14+472]
	je	SHORT $LN3@TreeNodeUp

; 6125 :     {
; 6126 :         if (g.NextItemData.OpenCond & ImGuiCond_Always)

	test	BYTE PTR [rdi+18608], 1
	je	SHORT $LN5@TreeNodeUp

; 6127 :         {
; 6128 :             is_open = g.NextItemData.OpenVal;

	movzx	ebx, BYTE PTR [rdi+18612]

; 6110 :     storage->SetInt(id, open ? 1 : 0);

	xor	r8d, r8d
	test	bl, bl
	setne	r8b
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt

; 6129 :             TreeNodeSetOpen(id, is_open);
; 6130 :         }

	jmp	SHORT $LN4@TreeNodeUp
$LN5@TreeNodeUp:

; 6131 :         else
; 6132 :         {
; 6133 :             // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
; 6134 :             const int stored_value = storage->GetInt(id, -1);

	mov	r8d, -1
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt

; 6135 :             if (stored_value == -1)

	cmp	eax, r8d
	jne	SHORT $LN7@TreeNodeUp

; 6136 :             {
; 6137 :                 is_open = g.NextItemData.OpenVal;

	movzx	ebx, BYTE PTR [rdi+18612]

; 6110 :     storage->SetInt(id, open ? 1 : 0);

	xor	r8d, r8d
	mov	rcx, QWORD PTR [r14+472]
	test	bl, bl
	mov	edx, ebp
	setne	r8b
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt

; 6138 :                 TreeNodeSetOpen(id, is_open);
; 6139 :             }

	jmp	SHORT $LN4@TreeNodeUp
$LN3@TreeNodeUp:

; 6140 :             else
; 6141 :             {
; 6142 :                 is_open = stored_value != 0;
; 6143 :             }
; 6144 :         }
; 6145 :     }
; 6146 :     else
; 6147 :     {
; 6148 :         is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;

	mov	r8d, esi
	shr	r8d, 5
	and	r8d, 1
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt
$LN7@TreeNodeUp:

; 6149 :     }
; 6150 : 
; 6151 :     // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
; 6152 :     // NB- If we are above max depth we still allow manually opened nodes to be logged.
; 6153 :     if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)

	test	eax, eax
	setne	bl
$LN4@TreeNodeUp:
	cmp	BYTE PTR [rdi+24256], 0
	je	SHORT $LN9@TreeNodeUp
	test	sil, 16
	jne	SHORT $LN9@TreeNodeUp
	mov	ecx, DWORD PTR [r14+448]
	mov	eax, 1
	sub	ecx, DWORD PTR [rdi+24312]
	cmp	ecx, DWORD PTR [rdi+24316]
	movzx	ebx, bl
	cmovl	ebx, eax
$LN9@TreeNodeUp:

; 6154 :         is_open = true;
; 6155 : 
; 6156 :     return is_open;

	mov	r14, QWORD PTR [rsp+64]
	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 6157 : }

	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?TreeNodeUpdateNextOpen@ImGui@@YA_NIH@Z ENDP		; ImGui::TreeNodeUpdateNextOpen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z
_TEXT	SEGMENT
item_add$1$ = 64
held$ = 64
id$GSCopy$1$ = 68
hovered$ = 72
selected$1$ = 73
padding$$sroa$1493$1$ = 80
new_size$1$ = 80
window$1$ = 80
tv2628 = 80
$T5 = 80
text_col$1$ = 88
tv2503 = 88
text_size$6 = 88
tv2681 = 96
$T7 = 100
label$GSCopy$1$ = 112
$T8 = 120
new_data$1$ = 128
text_pos$ = 136
window$1$ = 144
p_min$ = 144
$T9 = 144
p_max$ = 152
label_size$ = 152
c$10 = 160
c$11 = 160
c$12 = 160
interact_bb$ = 160
frame_bb$ = 176
__$ArrayPad$ = 192
id$ = 432
flags$ = 440
label$ = 448
label_end$dead$ = 456
?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z PROC		; ImGui::TreeNodeBehavior, COMDAT

; 6160 : {

$LN345:
	push	rbp
	push	rbx
	push	r12
	push	r15
	lea	rbp, QWORD PTR [rsp-136]
	sub	rsp, 392				; 00000188H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6160 : {

	mov	r12d, edx
	mov	QWORD PTR label$GSCopy$1$[rsp], r8
	mov	r9d, ecx
	mov	DWORD PTR id$GSCopy$1$[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r15, QWORD PTR [rbx+16408]
	mov	QWORD PTR window$1$[rbp-256], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6162 :     if (window->SkipItems)

	cmp	BYTE PTR [r15+240], 0
	je	SHORT $LN2@TreeNodeBe

; 6163 :         return false;

	xor	al, al
	jmp	$LN1@TreeNodeBe
$LN2@TreeNodeBe:
	mov	QWORD PTR [rsp+440], rsi

; 6164 : 
; 6165 :     ImGuiContext& g = *GImGui;
; 6166 :     const ImGuiStyle& style = g.Style;
; 6167 :     const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;

	mov	r10d, r12d
	mov	QWORD PTR [rsp+384], rdi
	mov	QWORD PTR [rsp+376], r13
	mov	QWORD PTR [rsp+368], r14
	movaps	XMMWORD PTR [rsp+352], xmm6
	movaps	XMMWORD PTR [rsp+336], xmm7
	movaps	XMMWORD PTR [rsp+304], xmm9
	movaps	XMMWORD PTR [rsp+288], xmm10
	movaps	XMMWORD PTR [rsp+272], xmm11
	movaps	XMMWORD PTR [rsp+256], xmm12
	shr	r10d, 1
	movaps	XMMWORD PTR [rsp+240], xmm13
	and	r10b, 1
	movaps	XMMWORD PTR [rsp+224], xmm14
	movaps	XMMWORD PTR [rsp+208], xmm15
	mov	DWORD PTR tv2681[rsp], r10d

; 6168 :     const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

	jne	SHORT $LN48@TreeNodeBe
	bt	r12d, 10
	jb	SHORT $LN48@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR [r15+368]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6168 :     const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

	lea	r13, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm1, DWORD PTR [rbx+14616]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+14612]
	movss	DWORD PTR $T7[rsp], xmm0
	movss	DWORD PTR $T7[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6168 :     const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

	jmp	SHORT $LN49@TreeNodeBe
$LN48@TreeNodeBe:
	movsd	xmm0, QWORD PTR [rbx+14612]
	lea	r13, QWORD PTR $T8[rsp]
	movsd	QWORD PTR $T8[rsp], xmm0
$LN49@TreeNodeBe:
	movss	xmm4, DWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	r14, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6168 :     const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window->DC.CurrLineTextBaseOffset, style.FramePadding.y));

	movss	xmm7, DWORD PTR [r13+4]
	movss	DWORD PTR padding$$sroa$1493$1$[rsp], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r8, -1
	jae	SHORT $LN240@TreeNodeBe
$LL120@TreeNodeBe:
	movzx	ecx, BYTE PTR [r14]
	test	cl, cl
	je	SHORT $LN240@TreeNodeBe
	lea	rax, QWORD PTR [r14+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN235@TreeNodeBe
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN240@TreeNodeBe
$LN235@TreeNodeBe:

; 3332 :         text_display_end++;

	mov	r14, rax
	cmp	rax, -1
	jb	SHORT $LL120@TreeNodeBe
$LN240@TreeNodeBe:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm1, DWORD PTR [rbx+15696]
	xorps	xmm14, xmm14

; 5418 :     if (text == text_display_end)

	cmp	r8, r14
	jne	SHORT $LN73@TreeNodeBe
	xorps	xmm2, xmm2

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN339@TreeNodeBe
$LN73@TreeNodeBe:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	lea	rdx, QWORD PTR text_size$6[rsp]
	movss	xmm3, DWORD PTR __real@7f7fffff
	movaps	xmm2, xmm1
	mov	rcx, QWORD PTR [rbx+15688]
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$6[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm1, DWORD PTR text_size$6[rsp+4]
	movss	xmm4, DWORD PTR padding$$sroa$1493$1$[rsp]
	mov	r9d, DWORD PTR id$GSCopy$1$[rsp]
	mov	r10d, DWORD PTR tv2681[rsp]

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
$LN339@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6175 :     const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);

	movss	xmm0, DWORD PTR [rbx+14616]
	movss	xmm6, DWORD PTR [rbx+15696]
	addss	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm3, DWORD PTR [r15+356]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6175 :     const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);

	movss	DWORD PTR label_size$[rbp-252], xmm1
	movss	DWORD PTR label_size$[rbp-256], xmm2
	addss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6175 :     const float frame_height = ImMax(ImMin(window->DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);

	movaps	xmm0, xmm7
	addss	xmm0, xmm7
	addss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6177 :     frame_bb.Min.x = (flags & ImGuiTreeNodeFlags_SpanFullWidth) ? window->WorkRect.Min.x : window->DC.CursorPos.x;

	bt	r12d, 12
	jae	SHORT $LN50@TreeNodeBe
	movss	xmm10, DWORD PTR [r15+592]
	jmp	SHORT $LN340@TreeNodeBe
$LN50@TreeNodeBe:
	movss	xmm10, DWORD PTR [r15+312]
$LN340@TreeNodeBe:

; 6178 :     frame_bb.Min.y = window->DC.CursorPos.y;

	movss	xmm13, DWORD PTR [r15+316]

; 6179 :     frame_bb.Max.x = window->WorkRect.Max.x;

	movss	xmm11, DWORD PTR [r15+600]

; 6180 :     frame_bb.Max.y = window->DC.CursorPos.y + frame_height;

	movaps	xmm12, xmm13

; 6181 :     if (display_frame)

	movss	xmm15, DWORD PTR __real@3f000000
	addss	xmm12, xmm3
	movss	DWORD PTR frame_bb$[rbp-256], xmm10
	movss	DWORD PTR frame_bb$[rbp-252], xmm13
	movss	DWORD PTR frame_bb$[rbp-248], xmm11
	movaps	XMMWORD PTR [rsp+320], xmm8
	movss	DWORD PTR frame_bb$[rbp-244], xmm12
	test	r10b, r10b
	je	SHORT $LN52@TreeNodeBe

; 6182 :     {
; 6183 :         // Framed header expand a little outside the default padding, to the edge of InnerClipRect
; 6184 :         // (FIXME: May remove this at some point and make InnerClipRect align with WindowPadding.x instead of WindowPadding.x*0.5f)
; 6185 :         frame_bb.Min.x -= IM_FLOOR(window->WindowPadding.x * 0.5f - 1.0f);

	movss	xmm1, DWORD PTR [r15+128]

; 6189 :     const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2);           // Collapser arrow width + Spacing

	movaps	xmm8, xmm4
	mulss	xmm1, xmm15
	addss	xmm8, xmm4
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm1
	subss	xmm10, xmm0
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR __real@40400000
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR frame_bb$[rbp-256], xmm10
	addss	xmm0, xmm11
	movss	DWORD PTR frame_bb$[rbp-248], xmm0
	movaps	xmm11, xmm0
	jmp	SHORT $LN53@TreeNodeBe
$LN52@TreeNodeBe:
	movaps	xmm1, xmm4
	addss	xmm1, xmm4
	movaps	xmm8, xmm1
$LN53@TreeNodeBe:

; 6190 :     const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset);                    // Latch before ItemSize changes it
; 6191 :     const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x * 2 : 0.0f);  // Include collapser

	comiss	xmm2, xmm14
	movaps	xmm9, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm4, xmm7
	maxss	xmm4, DWORD PTR [r15+368]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6189 :     const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2);           // Collapser arrow width + Spacing

	addss	xmm9, xmm1

; 6190 :     const float text_offset_y = ImMax(padding.y, window->DC.CurrLineTextBaseOffset);                    // Latch before ItemSize changes it
; 6191 :     const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x * 2 : 0.0f);  // Include collapser

	jbe	SHORT $LN54@TreeNodeBe
	movaps	xmm0, xmm8
	addss	xmm0, xmm2
	jmp	SHORT $LN55@TreeNodeBe
$LN54@TreeNodeBe:
	xorps	xmm0, xmm0
$LN55@TreeNodeBe:
	addss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6192 :     ImVec2 text_pos(window->DC.CursorPos.x + text_offset_x, window->DC.CursorPos.y + text_offset_y);

	movaps	xmm0, xmm9

; 6193 :     ItemSize(ImVec2(text_width, frame_height), padding.y);

	lea	rcx, QWORD PTR $T5[rsp]
	addss	xmm0, DWORD PTR [r15+312]
	movaps	xmm2, xmm13
	movaps	xmm1, xmm7
	addss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm6
	movss	DWORD PTR text_pos$[rbp-256], xmm0
	movss	DWORD PTR text_pos$[rbp-252], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6193 :     ItemSize(ImVec2(text_width, frame_height), padding.y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 6194 : 
; 6195 :     // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
; 6196 :     ImRect interact_bb = frame_bb;

	movss	DWORD PTR interact_bb$[rbp-256], xmm10
	movss	DWORD PTR interact_bb$[rbp-252], xmm13
	movss	DWORD PTR interact_bb$[rbp-248], xmm11
	movss	DWORD PTR interact_bb$[rbp-244], xmm12

; 6197 :     if (!display_frame && (flags & (ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth)) == 0)

	test	r10b, r10b
	jne	SHORT $LN5@TreeNodeBe
	test	r12d, 6144				; 00001800H
	jne	SHORT $LN5@TreeNodeBe

; 6198 :         interact_bb.Max.x = frame_bb.Min.x + text_width + style.ItemSpacing.x * 2.0f;

	movss	xmm0, DWORD PTR [rbx+14628]
	addss	xmm6, xmm10
	addss	xmm0, xmm0
	addss	xmm0, xmm6
	movss	DWORD PTR interact_bb$[rbp-248], xmm0
$LN5@TreeNodeBe:

; 6115 :     if (flags & ImGuiTreeNodeFlags_Leaf)

	mov	edi, 1
	bt	r12d, 8
	jae	SHORT $LN106@TreeNodeBe

; 6116 :         return true;

	movzx	esi, dil
	jmp	$LN105@TreeNodeBe
$LN106@TreeNodeBe:

; 6117 : 
; 6118 :     // We only write to the tree storage if the user clicks (or explicitly use the SetNextItemOpen function)
; 6119 :     ImGuiContext& g = *GImGui;

	mov	r15, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 6120 :     ImGuiWindow* window = g.CurrentWindow;
; 6121 :     ImGuiStorage* storage = window->DC.StateStorage;
; 6122 : 
; 6123 :     bool is_open;
; 6124 :     if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasOpen)

	mov	edx, r9d
	test	BYTE PTR [r15+18592], 2
	mov	rax, QWORD PTR [r15+16408]
	mov	QWORD PTR window$1$[rsp], rax
	mov	rcx, QWORD PTR [rax+472]
	je	SHORT $LN107@TreeNodeBe

; 6125 :     {
; 6126 :         if (g.NextItemData.OpenCond & ImGuiCond_Always)

	test	BYTE PTR [r15+18608], dil
	je	SHORT $LN109@TreeNodeBe

; 6127 :         {
; 6128 :             is_open = g.NextItemData.OpenVal;

	movzx	esi, BYTE PTR [r15+18612]

; 6110 :     storage->SetInt(id, open ? 1 : 0);

	xor	r8d, r8d
	test	sil, sil
	setne	r8b
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt

; 6130 :         }

	jmp	SHORT $LN108@TreeNodeBe
$LN109@TreeNodeBe:

; 6131 :         else
; 6132 :         {
; 6133 :             // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
; 6134 :             const int stored_value = storage->GetInt(id, -1);

	mov	r8d, -1
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt

; 6135 :             if (stored_value == -1)

	cmp	eax, r8d
	jne	SHORT $LN111@TreeNodeBe

; 6136 :             {
; 6137 :                 is_open = g.NextItemData.OpenVal;

	movzx	esi, BYTE PTR [r15+18612]

; 6110 :     storage->SetInt(id, open ? 1 : 0);

	xor	r8d, r8d
	mov	rcx, QWORD PTR [r15+16408]
	test	sil, sil
	mov	edx, DWORD PTR id$GSCopy$1$[rsp]
	setne	r8b
	mov	rcx, QWORD PTR [rcx+472]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt

; 6139 :             }

	jmp	SHORT $LN108@TreeNodeBe
$LN107@TreeNodeBe:

; 6140 :             else
; 6141 :             {
; 6142 :                 is_open = stored_value != 0;
; 6143 :             }
; 6144 :         }
; 6145 :     }
; 6146 :     else
; 6147 :     {
; 6148 :         is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;

	mov	r8d, r12d
	shr	r8d, 5
	and	r8d, edi
	call	?GetInt@ImGuiStorage@@QEBAHIH@Z		; ImGuiStorage::GetInt
$LN111@TreeNodeBe:

; 6149 :     }
; 6150 : 
; 6151 :     // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
; 6152 :     // NB- If we are above max depth we still allow manually opened nodes to be logged.
; 6153 :     if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)

	test	eax, eax
	setne	sil
$LN108@TreeNodeBe:
	cmp	BYTE PTR [r15+24256], 0
	je	SHORT $LN113@TreeNodeBe
	test	r12b, 16
	jne	SHORT $LN113@TreeNodeBe
	mov	rax, QWORD PTR window$1$[rsp]
	movzx	esi, sil
	mov	eax, DWORD PTR [rax+448]
	sub	eax, DWORD PTR [r15+24312]
	cmp	eax, DWORD PTR [r15+24316]
	cmovl	esi, edi
$LN113@TreeNodeBe:
	mov	r15, QWORD PTR window$1$[rbp-256]
$LN105@TreeNodeBe:

; 6199 : 
; 6200 :     // Compute open and multi-select states before ItemAdd() as it clear NextItem data.
; 6201 :     bool is_open = TreeNodeUpdateNextOpen(id, flags);
; 6202 :     bool item_add = ItemAdd(interact_bb, id);

	mov	edx, DWORD PTR id$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR interact_bb$[rbp-256]
	xor	r9d, r9d
	xor	r8d, r8d
	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd

; 6203 :     g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
; 6204 :     g.LastItemData.DisplayRect = frame_bb;

	movups	xmm7, XMMWORD PTR frame_bb$[rbp-256]
	or	DWORD PTR [rbx+18624], 2
	movzx	r10d, al
	mov	BYTE PTR item_add$1$[rsp], al
	movups	XMMWORD PTR [rbx+18660], xmm7

; 6205 : 
; 6206 :     // If a NavLeft request is happening and ImGuiTreeNodeFlags_NavLeftJumpsBackHere enabled:
; 6207 :     // Store data for the current depth to allow returning to this node from any child item.
; 6208 :     // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
; 6209 :     // It will become tempting to enable ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default or move it to ImGuiStyle.
; 6210 :     // Currently only supports 32 level deep and we are fine with (1 << Depth) overflowing into a zero, easy to increase.
; 6211 :     if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	test	sil, sil
	je	$LN250@TreeNodeBe
	cmp	BYTE PTR [rbx+19156], 0
	jne	$LN250@TreeNodeBe
	mov	eax, r12d
	and	eax, 8200				; 00002008H
	cmp	eax, 8192				; 00002000H
	jne	$LN250@TreeNodeBe

; 6212 :         if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())

	cmp	DWORD PTR [rbx+19232], 0
	jne	$LN250@TreeNodeBe
	cmp	QWORD PTR [rbx+19096], r15
	jne	$LN250@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11829:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 11830:     return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;

	cmp	BYTE PTR [rcx+19217], 0
	je	$LN250@TreeNodeBe
	cmp	DWORD PTR [rcx+19296], 0
	jne	$LN250@TreeNodeBe
	cmp	DWORD PTR [rcx+19392], 0
	jne	$LN250@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6214 :             g.NavTreeNodeStack.resize(g.NavTreeNodeStack.Size + 1);

	mov	edx, DWORD PTR [rbx+18952]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	r8d, DWORD PTR [rbx+18956]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6214 :             g.NavTreeNodeStack.resize(g.NavTreeNodeStack.Size + 1);

	mov	DWORD PTR tv2503[rsp], edx
	lea	r9d, DWORD PTR [rdx+1]
	mov	DWORD PTR new_size$1$[rsp], r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	r9d, r8d
	jle	$LN203@TreeNodeBe

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	r8d, r8d
	je	SHORT $LN201@TreeNodeBe
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	jmp	SHORT $LN202@TreeNodeBe
$LN201@TreeNodeBe:
	mov	eax, 8
$LN202@TreeNodeBe:
	cmp	eax, r9d
	mov	r15d, r9d
	cmovg	r15d, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	r15d, r8d
	jle	$LN242@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rcx, rcx
	je	SHORT $LN208@TreeNodeBe

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rcx+244]
$LN208@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, r15d
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+18960]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	QWORD PTR new_data$1$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN218@TreeNodeBe
	movsxd	rcx, DWORD PTR [rbx+18952]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+18960]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN216@TreeNodeBe

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN216@TreeNodeBe

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN216@TreeNodeBe:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR new_data$1$[rbp-256]
$LN218@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	r9d, DWORD PTR new_size$1$[rsp]
	movzx	r10d, BYTE PTR item_add$1$[rsp]
	mov	QWORD PTR [rbx+18960], rax
	mov	DWORD PTR [rbx+18956], r15d
$LN242@TreeNodeBe:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	r15, QWORD PTR window$1$[rbp-256]
$LN203@TreeNodeBe:

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR tv2503[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6216 :             nav_tree_node_data->ID = id;

	mov	r11d, DWORD PTR id$GSCopy$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx+18952], r9d

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [rbx+18960]
	lea	rdx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6216 :             nav_tree_node_data->ID = id;

	mov	DWORD PTR [rcx+rdx*8], r11d

; 6217 :             nav_tree_node_data->InFlags = g.LastItemData.InFlags;

	mov	eax, DWORD PTR [rbx+18620]
	mov	DWORD PTR [rcx+rdx*8+4], eax

; 6218 :             nav_tree_node_data->NavRect = g.LastItemData.NavRect;
; 6219 :             window->DC.TreeJumpToParentOnPopMask |= (1 << window->DC.TreeDepth);

	mov	eax, edi
	movups	xmm0, XMMWORD PTR [rbx+18644]
	movups	XMMWORD PTR [rcx+rdx*8+8], xmm0
	mov	ecx, DWORD PTR [r15+448]
	shl	eax, cl
	or	DWORD PTR [r15+452], eax
	jmp	SHORT $LN194@TreeNodeBe
$LN250@TreeNodeBe:

; 6220 :         }
; 6221 : 
; 6222 :     const bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;

	mov	r11d, DWORD PTR id$GSCopy$1$[rsp]
$LN194@TreeNodeBe:
	mov	edx, r12d
	shr	edx, 8
	and	dl, dil
	mov	DWORD PTR tv2628[rsp], edx

; 6223 :     if (!item_add)

	test	r10b, r10b
	jne	SHORT $LN8@TreeNodeBe

; 6224 :     {
; 6225 :         if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	test	sil, sil
	je	$LN46@TreeNodeBe
	test	r12b, 8
	jne	$LN46@TreeNodeBe

; 6226 :             TreePushOverrideID(id);

	mov	ecx, r11d

; 6227 :         IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
; 6228 :         return is_open;

	jmp	$LN342@TreeNodeBe
$LN8@TreeNodeBe:

; 6229 :     }
; 6230 : 
; 6231 :     ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;

	xor	ecx, ecx

; 6232 :     if ((flags & ImGuiTreeNodeFlags_AllowOverlap) || (g.LastItemData.InFlags & ImGuiItemFlags_AllowOverlap))

	test	r12b, 4
	jne	SHORT $LN11@TreeNodeBe
	test	DWORD PTR [rbx+18620], 512		; 00000200H
	je	SHORT $LN10@TreeNodeBe
$LN11@TreeNodeBe:

; 6233 :         button_flags |= ImGuiButtonFlags_AllowOverlap;

	mov	ecx, 4096				; 00001000H
$LN10@TreeNodeBe:

; 6234 :     if (!is_leaf)
; 6235 :         button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
; 6236 : 
; 6237 :     // We allow clicking on the arrow section with keyboard modifiers held, in order to easily
; 6238 :     // allow browsing a tree while preserving selection with code implementing multi-selection patterns.
; 6239 :     // When clicking on the rest of the tree node we always disallow keyboard modifiers.
; 6240 :     const float arrow_hit_x1 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;

	movss	xmm1, DWORD PTR text_pos$[rbp-256]

; 6242 :     const bool is_mouse_x_over_arrow = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);

	mov	eax, ecx
	movss	xmm3, DWORD PTR [rbx+14652]
	subss	xmm1, xmm9
	movss	xmm2, DWORD PTR [rbx+3592]
	bts	eax, 9
	test	dl, dl
	cmovne	eax, ecx
	movaps	xmm0, xmm1
	subss	xmm0, xmm3
	comiss	xmm2, xmm0
	jb	SHORT $LN56@TreeNodeBe

; 6241 :     const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + style.TouchExtraPadding.x;

	addss	xmm8, DWORD PTR [rbx+15696]
	addss	xmm8, xmm1
	addss	xmm8, xmm3

; 6242 :     const bool is_mouse_x_over_arrow = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2);

	comiss	xmm8, xmm2
	jbe	SHORT $LN56@TreeNodeBe
	movzx	r15d, dil
	jmp	SHORT $LN57@TreeNodeBe
$LN56@TreeNodeBe:
	xor	r15b, r15b
$LN57@TreeNodeBe:

; 6243 :     if (window != g.HoveredWindow || !is_mouse_x_over_arrow)

	mov	rcx, QWORD PTR window$1$[rbp-256]
	cmp	rcx, QWORD PTR [rbx+16416]
	jne	SHORT $LN14@TreeNodeBe
	test	r15b, r15b
	jne	SHORT $LN233@TreeNodeBe
$LN14@TreeNodeBe:

; 6244 :         button_flags |= ImGuiButtonFlags_NoKeyModifiers;

	bts	eax, 16

; 6245 : 
; 6246 :     // Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
; 6247 :     // Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
; 6248 :     // - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
; 6249 :     // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
; 6250 :     // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
; 6251 :     // - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
; 6252 :     // - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
; 6253 :     // It is rather standard that arrow click react on Down rather than Up.
; 6254 :     // We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
; 6255 :     if (is_mouse_x_over_arrow)

	test	r15b, r15b
	je	SHORT $LN15@TreeNodeBe
$LN233@TreeNodeBe:

; 6256 :         button_flags |= ImGuiButtonFlags_PressedOnClick;

	or	eax, 16
	jmp	SHORT $LN18@TreeNodeBe
$LN15@TreeNodeBe:

; 6257 :     else if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

	test	r12b, 64				; 00000040H
	je	SHORT $LN17@TreeNodeBe

; 6258 :         button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;

	or	eax, 288				; 00000120H
	jmp	SHORT $LN18@TreeNodeBe
$LN17@TreeNodeBe:

; 6259 :     else
; 6260 :         button_flags |= ImGuiButtonFlags_PressedOnClickRelease;

	or	eax, 32					; 00000020H
$LN18@TreeNodeBe:

; 6261 : 
; 6262 :     bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;

	movzx	ecx, r12b

; 6263 :     const bool was_selected = selected;
; 6264 : 
; 6265 :     bool hovered, held;
; 6266 :     bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);

	mov	DWORD PTR [rsp+32], eax
	and	cl, dil
	lea	r9, QWORD PTR held$[rsp]
	mov	BYTE PTR selected$1$[rsp], cl
	lea	r8, QWORD PTR hovered$[rsp]
	lea	rcx, QWORD PTR interact_bb$[rbp-256]
	mov	edx, r11d
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 6267 :     bool toggled = false;

	xor	r8b, r8b

; 6268 :     if (!is_leaf)

	cmp	BYTE PTR tv2628[rsp], r8b
	jne	$LN239@TreeNodeBe

; 6269 :     {
; 6270 :         if (pressed && g.DragDropHoldJustPressedId != id)

	mov	r9d, DWORD PTR id$GSCopy$1$[rsp]
	test	al, al
	je	SHORT $LN27@TreeNodeBe
	cmp	DWORD PTR [rbx+19664], r9d
	je	SHORT $LN238@TreeNodeBe

; 6271 :         {
; 6272 :             if ((flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) == 0 || (g.NavActivateId == id))

	test	r12b, 192				; 000000c0H
	je	SHORT $LN23@TreeNodeBe
	cmp	DWORD PTR [rbx+19112], r9d
	jne	SHORT $LN22@TreeNodeBe
$LN23@TreeNodeBe:

; 6273 :                 toggled = true;

	movzx	r8d, dil
$LN22@TreeNodeBe:

; 6274 :             if (flags & ImGuiTreeNodeFlags_OpenOnArrow)

	test	r12b, r12b
	jns	SHORT $LN24@TreeNodeBe

; 6275 :                 toggled |= is_mouse_x_over_arrow && !g.NavDisableMouseHover; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job

	test	r15b, r15b
	je	SHORT $LN58@TreeNodeBe
	cmp	BYTE PTR [rbx+19159], 0
	jne	SHORT $LN58@TreeNodeBe
	movzx	eax, dil
	jmp	SHORT $LN59@TreeNodeBe
$LN58@TreeNodeBe:
	xor	al, al
$LN59@TreeNodeBe:
	or	r8b, al
$LN24@TreeNodeBe:

; 6276 :             if ((flags & ImGuiTreeNodeFlags_OpenOnDoubleClick) && g.IO.MouseClickedCount[0] == 2)

	test	r12b, 64				; 00000040H
	je	SHORT $LN27@TreeNodeBe
	cmp	WORD PTR [rbx+14170], 2
	jne	SHORT $LN27@TreeNodeBe

; 6277 :                 toggled = true;

	movzx	r8d, dil

; 6278 :         }

	jmp	SHORT $LN27@TreeNodeBe
$LN238@TreeNodeBe:

; 6279 :         else if (pressed && g.DragDropHoldJustPressedId == id)
; 6280 :         {
; 6281 :             IM_ASSERT(button_flags & ImGuiButtonFlags_PressedOnDragDropHold);
; 6282 :             if (!is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.

	test	sil, sil
	movzx	r8d, r8b
	cmove	r8d, edi
$LN27@TreeNodeBe:

; 6283 :                 toggled = true;
; 6284 :         }
; 6285 : 
; 6286 :         if (g.NavId == id && g.NavMoveDir == ImGuiDir_Left && is_open)

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	DWORD PTR [rbx+19104], r9d
	jne	$LN173@TreeNodeBe
	cmp	DWORD PTR [rbx+19232], 0
	jne	SHORT $LN184@TreeNodeBe
	test	sil, sil
	je	SHORT $LN184@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11474:     g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;

	mov	rax, QWORD PTR [r10+19096]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6288 :             toggled = true;

	movzx	r8d, dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11474:     g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;

	movsxd	rdx, DWORD PTR [r10+19152]
	mov	rcx, QWORD PTR [rax+984]
	mov	DWORD PTR [rcx+rdx*8+1040], 2139095039	; 7f7fffffH

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r10+19161], 0

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r10+19216], 0

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al
	mov	BYTE PTR [r10+19160], al
$LN184@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6292 :         if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?

	cmp	DWORD PTR [rbx+19104], r9d
	jne	SHORT $LN173@TreeNodeBe
	cmp	DWORD PTR [rbx+19232], edi
	jne	SHORT $LN173@TreeNodeBe
	test	sil, sil
	jne	SHORT $LN173@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11474:     g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;

	mov	rax, QWORD PTR [r10+19096]
	movsxd	rdx, DWORD PTR [r10+19152]
	mov	rcx, QWORD PTR [rax+984]
	mov	DWORD PTR [rcx+rdx*8+1040], 2139095039	; 7f7fffffH

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r10+19161], sil

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r10+19216], 0

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al
	mov	BYTE PTR [r10+19160], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6299 :         if (toggled)

	jmp	SHORT $LN234@TreeNodeBe
$LN173@TreeNodeBe:
	test	r8b, r8b
	je	SHORT $LN241@TreeNodeBe
$LN234@TreeNodeBe:

; 6300 :         {
; 6301 :             is_open = !is_open;
; 6302 :             window->DC.StateStorage->SetInt(id, is_open);

	mov	r15, QWORD PTR window$1$[rbp-256]
	test	sil, sil
	mov	edx, r9d
	sete	sil
	movzx	r8d, sil
	mov	rcx, QWORD PTR [r15+472]
	call	?SetInt@ImGuiStorage@@QEAAXIH@Z		; ImGuiStorage::SetInt

; 6303 :             g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledOpen;

	or	DWORD PTR [rbx+18624], 16
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN30@TreeNodeBe
$LN239@TreeNodeBe:

; 6268 :     if (!is_leaf)

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN241@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	mov	r15, QWORD PTR window$1$[rbp-256]
$LN30@TreeNodeBe:
	movups	xmm0, XMMWORD PTR [r10+14776]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$12[rbp-256]
	movss	xmm6, DWORD PTR [r10+14552]
	movups	XMMWORD PTR c$12[rbp-256], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$12[rbp-244], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6314 :     if (display_frame)

	cmp	BYTE PTR tv2681[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	DWORD PTR text_col$1$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6314 :     if (display_frame)

	je	$LN32@TreeNodeBe

; 6315 :     {
; 6316 :         // Framed type
; 6317 :         const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	cmp	BYTE PTR held$[rsp], 0
	movzx	edx, BYTE PTR hovered$[rsp]
	je	SHORT $LN60@TreeNodeBe
	test	dl, dl
	je	SHORT $LN60@TreeNodeBe
	mov	ecx, 26
	jmp	SHORT $LN61@TreeNodeBe
$LN60@TreeNodeBe:
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	add	rcx, 24
$LN61@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	add	rcx, rcx

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r10+rcx*8+14776]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$11[rbp-256]
	movups	XMMWORD PTR c$11[rbp-256], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$11[rbp-244], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6318 :         RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);

	movss	xmm0, DWORD PTR [rbx+14620]
	movaps	xmm1, xmm7
	unpckhpd xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6318 :         RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);

	movq	rdx, xmm1
	movss	DWORD PTR [rsp+32], xmm0
	movzx	r9d, dil
	movq	rcx, xmm7
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 6319 :         RenderNavHighlight(frame_bb, id, nav_highlight_flags);

	mov	edx, DWORD PTR id$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rbp-256]
	mov	r8d, 2
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 6320 :         if (flags & ImGuiTreeNodeFlags_Bullet)

	bt	r12d, 9
	jae	SHORT $LN34@TreeNodeBe

; 6321 :             RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);

	movss	xmm0, DWORD PTR text_pos$[rbp-256]
	movss	xmm1, DWORD PTR [rbx+15696]
	mulss	xmm9, DWORD PTR __real@3f19999a
	mov	r8d, DWORD PTR text_col$1$[rsp]
	mov	rcx, QWORD PTR [r15+728]
	mulss	xmm1, xmm15
	subss	xmm0, xmm9
	addss	xmm1, DWORD PTR text_pos$[rbp-252]
	unpcklps xmm0, xmm1
	movq	rdx, xmm0
	call	?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
	jmp	SHORT $LN37@TreeNodeBe
$LN34@TreeNodeBe:

; 6322 :         else if (!is_leaf)

	cmp	BYTE PTR tv2628[rsp], 0
	jne	SHORT $LN36@TreeNodeBe

; 6323 :             RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 1.0f);

	test	sil, sil
	je	SHORT $LN62@TreeNodeBe
	mov	edi, r12d
	shr	edi, 21
	not	edi
	and	edi, 1
	or	edi, 2
$LN62@TreeNodeBe:
	movss	xmm0, DWORD PTR text_pos$[rbp-256]
	mov	r9d, edi
	movss	xmm1, DWORD PTR text_pos$[rbp-252]
	subss	xmm0, xmm9
	movss	xmm2, DWORD PTR __real@3f800000
	mov	r8d, DWORD PTR text_col$1$[rsp]
	mov	rcx, QWORD PTR [r15+728]
	movss	DWORD PTR [rsp+32], xmm2
	addss	xmm0, DWORD PTR [r13]
	unpcklps xmm0, xmm1
	movq	rdx, xmm0
	call	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
	jmp	SHORT $LN37@TreeNodeBe
$LN36@TreeNodeBe:

; 6324 :         else // Leaf without bullet, left-adjusted text
; 6325 :             text_pos.x -= text_offset_x -padding.x;

	movss	xmm0, DWORD PTR text_pos$[rbp-256]
	subss	xmm9, DWORD PTR [r13]
	subss	xmm0, xmm9
	movss	DWORD PTR text_pos$[rbp-256], xmm0
$LN37@TreeNodeBe:

; 6326 :         if (flags & ImGuiTreeNodeFlags_ClipLabelForTrailingButton)

	bt	r12d, 20
	jae	SHORT $LN38@TreeNodeBe

; 6327 :             frame_bb.Max.x -= g.FontSize + style.FramePadding.x;

	movss	xmm0, DWORD PTR [rbx+14612]
	addss	xmm0, DWORD PTR [rbx+15696]
	subss	xmm11, xmm0
	movss	DWORD PTR frame_bb$[rbp-248], xmm11
$LN38@TreeNodeBe:

; 6328 : 
; 6329 :         if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	je	SHORT $LN39@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_03OIJOKPOL@?$CD?$CD?$CD@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	mov	QWORD PTR [rax+24296], rcx
$LN39@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6331 :         RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);

	mov	r8, QWORD PTR label$GSCopy$1$[rsp]
	lea	rax, QWORD PTR $T9[rbp-256]
	mov	QWORD PTR [rsp+48], 0
	lea	rdx, QWORD PTR frame_bb$[rbp-248]
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR text_pos$[rbp-256]
	lea	rax, QWORD PTR label_size$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T9[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6331 :         RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);

	mov	r9, r14
	mov	QWORD PTR [rsp+32], rax
	call	?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z ; ImGui::RenderTextClipped

; 6332 :     }

	jmp	$LN33@TreeNodeBe
$LN32@TreeNodeBe:

; 6333 :     else
; 6334 :     {
; 6335 :         // Unframed typed for tree nodes
; 6336 :         if (hovered || selected)

	movzx	eax, BYTE PTR hovered$[rsp]
	test	al, al
	jne	SHORT $LN41@TreeNodeBe
	cmp	BYTE PTR selected$1$[rsp], al
	je	$LN140@TreeNodeBe
$LN41@TreeNodeBe:

; 6337 :         {
; 6338 :             const ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	cmp	BYTE PTR held$[rsp], 0
	je	SHORT $LN64@TreeNodeBe
	test	al, al
	je	SHORT $LN64@TreeNodeBe
	mov	ecx, 26
	jmp	SHORT $LN65@TreeNodeBe
$LN64@TreeNodeBe:
	xor	ecx, ecx
	test	al, al
	setne	cl
	add	rcx, 24
$LN65@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6339 :             RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);

	movss	DWORD PTR p_max$[rbp-256], xmm11
	movss	DWORD PTR p_max$[rbp-252], xmm12
	movss	DWORD PTR p_min$[rbp-256], xmm10
	movss	DWORD PTR p_min$[rbp-252], xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [r10+rcx*8+14776]

; 3491 :     ImGuiWindow* window = g.CurrentWindow;

	mov	r10, QWORD PTR [r10+16408]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$10[rbp-256]
	movups	XMMWORD PTR c$10[rbp-256], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, xmm6
	movss	DWORD PTR c$10[rbp-244], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32

; 3492 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	mov	rcx, QWORD PTR [r10+728]
	lea	rdx, QWORD PTR p_min$[rbp-256]

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax

; 3492 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	mov	DWORD PTR [rsp+40], 0
	lea	r8, QWORD PTR p_max$[rbp-256]
	movss	DWORD PTR [rsp+32], xmm14
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN140@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6341 :         RenderNavHighlight(frame_bb, id, nav_highlight_flags);

	mov	edx, DWORD PTR id$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR frame_bb$[rbp-256]
	mov	r8d, 2
	call	?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z ; ImGui::RenderNavHighlight

; 6342 :         if (flags & ImGuiTreeNodeFlags_Bullet)

	bt	r12d, 9
	jae	SHORT $LN42@TreeNodeBe

; 6343 :             RenderBullet(window->DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);

	movss	xmm0, DWORD PTR text_pos$[rbp-256]
	movss	xmm1, DWORD PTR [rbx+15696]
	mov	r8d, DWORD PTR text_col$1$[rsp]
	mov	rcx, QWORD PTR [r15+728]
	mulss	xmm1, xmm15
	mulss	xmm9, xmm15
	addss	xmm1, DWORD PTR text_pos$[rbp-252]
	subss	xmm0, xmm9
	unpcklps xmm0, xmm1
	movq	rdx, xmm0
	call	?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
	jmp	SHORT $LN44@TreeNodeBe
$LN42@TreeNodeBe:

; 6344 :         else if (!is_leaf)

	cmp	BYTE PTR tv2628[rsp], 0
	jne	SHORT $LN44@TreeNodeBe

; 6345 :             RenderArrow(window->DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ((flags & ImGuiTreeNodeFlags_UpsideDownArrow) ? ImGuiDir_Up : ImGuiDir_Down) : ImGuiDir_Right, 0.70f);

	test	sil, sil
	je	SHORT $LN66@TreeNodeBe
	mov	edi, r12d
	shr	edi, 21
	not	edi
	and	edi, 1
	or	edi, 2
$LN66@TreeNodeBe:
	movss	xmm2, DWORD PTR text_pos$[rbp-256]
	mov	r9d, edi
	movss	xmm0, DWORD PTR __real@3f333333
	subss	xmm2, xmm9
	movss	xmm1, DWORD PTR [rbx+15696]
	mulss	xmm1, DWORD PTR __real@3e19999a
	mov	r8d, DWORD PTR text_col$1$[rsp]
	mov	rcx, QWORD PTR [r15+728]
	addss	xmm2, DWORD PTR [r13]
	addss	xmm1, DWORD PTR text_pos$[rbp-252]
	movss	DWORD PTR [rsp+32], xmm0
	movaps	xmm0, xmm2
	unpcklps xmm0, xmm1
	movq	rdx, xmm0
	call	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
$LN44@TreeNodeBe:

; 6346 :         if (g.LogEnabled)

	cmp	BYTE PTR [rbx+24256], 0
	je	SHORT $LN45@TreeNodeBe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13448:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13449:     g.LogNextPrefix = prefix;

	lea	rcx, OFFSET FLAT:??_C@_01PPODPGHN@?$DO@
	mov	QWORD PTR [rax+24288], rcx

; 13450:     g.LogNextSuffix = suffix;

	mov	QWORD PTR [rax+24296], 0
$LN45@TreeNodeBe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6348 :         RenderText(text_pos, label, label_end, false);

	mov	rdx, QWORD PTR label$GSCopy$1$[rsp]
	xor	r9d, r9d
	mov	rcx, QWORD PTR text_pos$[rbp-256]
	mov	r8, r14
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN33@TreeNodeBe:

; 6349 :     }
; 6350 : 
; 6351 :     if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	test	sil, sil
	je	SHORT $LN46@TreeNodeBe
	test	r12b, 8
	jne	SHORT $LN46@TreeNodeBe

; 6352 :         TreePushOverrideID(id);

	mov	ecx, DWORD PTR id$GSCopy$1$[rsp]
$LN342@TreeNodeBe:
	call	?TreePushOverrideID@ImGui@@YAXI@Z	; ImGui::TreePushOverrideID
$LN46@TreeNodeBe:
	movaps	xmm8, XMMWORD PTR [rsp+320]

; 6353 :     IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
; 6354 :     return is_open;

	movzx	eax, sil
	mov	rsi, QWORD PTR [rsp+440]
	movaps	xmm13, XMMWORD PTR [rsp+240]
	movaps	xmm12, XMMWORD PTR [rsp+256]
	movaps	xmm11, XMMWORD PTR [rsp+272]
	movaps	xmm10, XMMWORD PTR [rsp+288]
	movaps	xmm9, XMMWORD PTR [rsp+304]
	movaps	xmm14, XMMWORD PTR [rsp+224]
	movaps	xmm7, XMMWORD PTR [rsp+336]
	movaps	xmm6, XMMWORD PTR [rsp+352]
	mov	r14, QWORD PTR [rsp+368]
	mov	r13, QWORD PTR [rsp+376]
	mov	rdi, QWORD PTR [rsp+384]
	movaps	xmm15, XMMWORD PTR [rsp+208]
$LN1@TreeNodeBe:

; 6355 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 392				; 00000188H
	pop	r15
	pop	r12
	pop	rbx
	pop	rbp
	ret	0
?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z ENDP		; ImGui::TreeNodeBehavior
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TreePushOverrideID@ImGui@@YAXI@Z
_TEXT	SEGMENT
id$ = 8
?TreePushOverrideID@ImGui@@YAXI@Z PROC			; ImGui::TreePushOverrideID, COMDAT

; 6375 :     ImGuiContext& g = *GImGui;
; 6376 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r8, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [r8+237], 1
	mov	rax, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10308:     window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR [rdx+14660]
	addss	xmm0, DWORD PTR [rax+380]
	movss	DWORD PTR [rax+380], xmm0

; 10309:     window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;

	addss	xmm0, DWORD PTR [rax+80]
	addss	xmm0, DWORD PTR [rax+384]
	movss	DWORD PTR [rax+312], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6378 :     window->DC.TreeDepth++;

	inc	DWORD PTR [r8+448]

; 6379 :     PushOverrideID(id);

	jmp	?PushOverrideID@ImGui@@YAXI@Z		; ImGui::PushOverrideID
?TreePushOverrideID@ImGui@@YAXI@Z ENDP			; ImGui::TreePushOverrideID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?Plot_ArrayGetter@@YAMPEAXH@Z
_TEXT	SEGMENT
data$ = 8
idx$ = 16
?Plot_ArrayGetter@@YAMPEAXH@Z PROC			; Plot_ArrayGetter, COMDAT

; 6883 :     ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
; 6884 :     const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);

	movsxd	r8, DWORD PTR [rcx+8]
	movsxd	rax, edx
	imul	r8, rax

; 6885 :     return v;

	mov	rax, QWORD PTR [rcx]
	movss	xmm0, DWORD PTR [r8+rax]

; 6886 : }

	ret	0
?Plot_ArrayGetter@@YAMPEAXH@Z ENDP			; Plot_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
update_offsets$ = 16
?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z PROC	; ImGuiMenuColumns::CalcNextTotalWidth, COMDAT

; 6973 : {

$LN60:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 6974 :     ImU16 offset = 0;

	xor	eax, eax
	movzx	edi, dl

; 6975 :     bool want_spacing = false;

	xor	r10b, r10b
	mov	r9d, eax

; 6980 :             offset += Spacing;

	mov	r11d, eax
	mov	r8, rcx
	npad	5
$LL4@CalcNextTo:

; 6979 :         if (want_spacing && width > 0)

	movzx	ebx, WORD PTR [r8+r11*2+18]
	test	r10b, r10b
	je	SHORT $LN5@CalcNextTo
	test	bx, bx
	je	SHORT $LN55@CalcNextTo

; 6980 :             offset += Spacing;

	add	ax, WORD PTR [r8+8]
$LN5@CalcNextTo:

; 6981 :         want_spacing |= (width > 0);

	test	bx, bx
$LN55@CalcNextTo:
	setne	cl
	or	r10b, cl

; 6982 :         if (update_offsets)

	test	dil, dil
	je	SHORT $LN9@CalcNextTo

; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r11, 1
	jne	SHORT $LN7@CalcNextTo
	mov	WORD PTR [r8+12], ax

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN9@CalcNextTo
$LN7@CalcNextTo:
	cmp	r11, 2
	jne	SHORT $LN8@CalcNextTo
	mov	WORD PTR [r8+14], ax

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN9@CalcNextTo
$LN8@CalcNextTo:
	cmp	r11, 3
	jne	SHORT $LN9@CalcNextTo
	mov	WORD PTR [r8+16], ax
$LN9@CalcNextTo:

; 6976 :     for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
; 6977 :     {
; 6978 :         ImU16 width = Widths[i];

	movzx	edx, WORD PTR [r8+r11*2+20]

; 6987 :         }
; 6988 :         offset += width;

	add	ax, bx
	test	r10b, r10b
	je	SHORT $LN14@CalcNextTo

; 6979 :         if (want_spacing && width > 0)

	test	dx, dx
	je	SHORT $LN56@CalcNextTo

; 6980 :             offset += Spacing;

	add	ax, WORD PTR [r8+8]
$LN14@CalcNextTo:

; 6981 :         want_spacing |= (width > 0);

	test	dx, dx
$LN56@CalcNextTo:
	setne	cl
	or	r10b, cl

; 6982 :         if (update_offsets)

	test	dil, dil
	je	SHORT $LN17@CalcNextTo

; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	test	r9d, r9d
	jne	SHORT $LN15@CalcNextTo
	mov	WORD PTR [r8+12], ax

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN17@CalcNextTo
$LN15@CalcNextTo:
	cmp	r9d, 1
	jne	SHORT $LN16@CalcNextTo
	mov	WORD PTR [r8+14], ax

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN17@CalcNextTo
$LN16@CalcNextTo:
	cmp	r9d, 2
	jne	SHORT $LN17@CalcNextTo
	mov	WORD PTR [r8+16], ax
$LN17@CalcNextTo:

; 6987 :         }
; 6988 :         offset += width;

	add	ax, dx
	movzx	edx, WORD PTR [r8+r11*2+22]
	test	r10b, r10b
	je	SHORT $LN19@CalcNextTo

; 6979 :         if (want_spacing && width > 0)

	test	dx, dx
	je	SHORT $LN57@CalcNextTo

; 6980 :             offset += Spacing;

	add	ax, WORD PTR [r8+8]
$LN19@CalcNextTo:

; 6981 :         want_spacing |= (width > 0);

	test	dx, dx
$LN57@CalcNextTo:
	setne	cl
	or	r10b, cl

; 6982 :         if (update_offsets)

	test	dil, dil
	je	SHORT $LN22@CalcNextTo

; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r9d, -1
	jne	SHORT $LN20@CalcNextTo
	mov	WORD PTR [r8+12], ax

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN22@CalcNextTo
$LN20@CalcNextTo:
	test	r9d, r9d
	jne	SHORT $LN21@CalcNextTo
	mov	WORD PTR [r8+14], ax

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN22@CalcNextTo
$LN21@CalcNextTo:
	cmp	r9d, 1
	jne	SHORT $LN22@CalcNextTo
	mov	WORD PTR [r8+16], ax
$LN22@CalcNextTo:

; 6987 :         }
; 6988 :         offset += width;

	add	ax, dx
	movzx	edx, WORD PTR [r8+r11*2+24]
	test	r10b, r10b
	je	SHORT $LN24@CalcNextTo

; 6979 :         if (want_spacing && width > 0)

	test	dx, dx
	je	SHORT $LN58@CalcNextTo

; 6980 :             offset += Spacing;

	add	ax, WORD PTR [r8+8]
$LN24@CalcNextTo:

; 6981 :         want_spacing |= (width > 0);

	test	dx, dx
$LN58@CalcNextTo:
	setne	cl
	or	r10b, cl

; 6982 :         if (update_offsets)

	test	dil, dil
	je	SHORT $LN27@CalcNextTo

; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }

	cmp	r9d, -2
	jne	SHORT $LN25@CalcNextTo
	mov	WORD PTR [r8+12], ax

; 6985 :             if (i == 2) { OffsetShortcut = offset; }

	jmp	SHORT $LN27@CalcNextTo
$LN25@CalcNextTo:
	cmp	r9d, -1
	jne	SHORT $LN26@CalcNextTo
	mov	WORD PTR [r8+14], ax

; 6986 :             if (i == 3) { OffsetMark = offset; }

	jmp	SHORT $LN27@CalcNextTo
$LN26@CalcNextTo:
	test	r9d, r9d
	jne	SHORT $LN27@CalcNextTo
	mov	WORD PTR [r8+16], ax
$LN27@CalcNextTo:

; 6987 :         }
; 6988 :         offset += width;

	add	ax, dx
	add	r9d, 4
	add	r11, 4
	cmp	r11, 4
	jl	$LL4@CalcNextTo

; 6989 :     }
; 6990 :     NextTotalWidth = offset;
; 6991 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	movzx	ecx, ax
	mov	DWORD PTR [r8+4], ecx
	ret	0
?CalcNextTotalWidth@ImGuiMenuColumns@@QEAAX_N@Z ENDP	; ImGuiMenuColumns::CalcNextTotalWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z
_TEXT	SEGMENT
this$ = 8
w_icon$ = 16
w_label$ = 24
w_shortcut$ = 32
w_mark$ = 40
?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z PROC		; ImGuiMenuColumns::DeclColumns, COMDAT

; 6998 :     Widths[3] = ImMax(Widths[3], (ImU16)w_mark);

	cvttss2si r10d, DWORD PTR w_mark$[rsp]
	mov	r8, rcx
	cvttss2si edx, xmm1
	cvttss2si r9d, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	WORD PTR [rcx+18], dx
	cmovae	dx, WORD PTR [rcx+18]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6995 :     Widths[0] = ImMax(Widths[0], (ImU16)w_icon);

	mov	WORD PTR [rcx+18], dx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	WORD PTR [rcx+20], r9w
	cmovae	r9w, WORD PTR [rcx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6996 :     Widths[1] = ImMax(Widths[1], (ImU16)w_label);

	mov	WORD PTR [rcx+20], r9w

; 6997 :     Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);

	cvttss2si ecx, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	WORD PTR [r8+22], cx
	cmovae	cx, WORD PTR [r8+22]
	cmp	WORD PTR [r8+24], r10w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6997 :     Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);

	mov	WORD PTR [r8+22], cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmovae	r10w, WORD PTR [r8+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6981 :         want_spacing |= (width > 0);

	test	dx, dx

; 6998 :     Widths[3] = ImMax(Widths[3], (ImU16)w_mark);

	mov	WORD PTR [r8+24], r10w

; 6981 :         want_spacing |= (width > 0);

	setne	r11b
	test	dx, dx
	je	SHORT $LN26@DeclColumn

; 6979 :         if (want_spacing && width > 0)

	test	r9w, r9w
	je	SHORT $LN42@DeclColumn

; 6980 :             offset += Spacing;

	add	dx, WORD PTR [r8+8]
$LN26@DeclColumn:

; 6981 :         want_spacing |= (width > 0);

	test	r9w, r9w
$LN42@DeclColumn:
	setne	al

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }
; 6985 :             if (i == 2) { OffsetShortcut = offset; }
; 6986 :             if (i == 3) { OffsetMark = offset; }
; 6987 :         }
; 6988 :         offset += width;

	add	dx, r9w
	or	al, r11b
	je	SHORT $LN31@DeclColumn

; 6979 :         if (want_spacing && width > 0)

	test	cx, cx
	je	SHORT $LN31@DeclColumn

; 6980 :             offset += Spacing;

	add	dx, WORD PTR [r8+8]
$LN31@DeclColumn:

; 6981 :         want_spacing |= (width > 0);

	test	cx, cx
	movzx	eax, al
	mov	r9d, 1
	cmovne	eax, r9d

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }
; 6985 :             if (i == 2) { OffsetShortcut = offset; }
; 6986 :             if (i == 3) { OffsetMark = offset; }
; 6987 :         }
; 6988 :         offset += width;

	add	dx, cx
	test	al, al
	je	SHORT $LN36@DeclColumn

; 6979 :         if (want_spacing && width > 0)

	test	r10w, r10w
	je	SHORT $LN36@DeclColumn

; 6980 :             offset += Spacing;

	add	dx, WORD PTR [r8+8]
$LN36@DeclColumn:

; 6982 :         if (update_offsets)
; 6983 :         {
; 6984 :             if (i == 1) { OffsetLabel = offset; }
; 6985 :             if (i == 2) { OffsetShortcut = offset; }
; 6986 :             if (i == 3) { OffsetMark = offset; }
; 6987 :         }
; 6988 :         offset += width;

	add	dx, r10w
	xorps	xmm0, xmm0

; 6990 :     NextTotalWidth = offset;

	movzx	ecx, dx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [r8], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6990 :     NextTotalWidth = offset;

	mov	DWORD PTR [r8+4], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmovae	ecx, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7000 :     return (float)ImMax(TotalWidth, NextTotalWidth);

	mov	eax, ecx
	cvtsi2ss xmm0, rax

; 7001 : }

	ret	0
?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z ENDP		; ImGuiMenuColumns::DeclColumns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z
_TEXT	SEGMENT
$T3 = 32
name$dead$ = 64
viewport_p$ = 72
dir$dead$ = 80
axis_size$ = 88
window_flags$dead$ = 96
?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z PROC ; ImGui::BeginViewportSideBar, COMDAT

; 7082 : {

$LN81:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	movaps	xmm4, xmm3

; 7083 :     IM_ASSERT(dir != ImGuiDir_None);
; 7084 : 
; 7085 :     ImGuiWindow* bar_window = FindWindowByName(name);

	lea	rcx, OFFSET FLAT:??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@
	mov	rbx, rdx
	call	?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z ; ImGui::FindWindowByName

; 7086 :     ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)(viewport_p ? viewport_p : GetMainViewport());

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, rax
	test	rbx, rbx
	jne	SHORT $LN13@BeginViewp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+18984]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13999:     return g.Viewports[0];

	mov	rbx, QWORD PTR [rax]
$LN13@BeginViewp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7087 :     if (bar_window == NULL || bar_window->BeginCount == 0)

	xor	edi, edi
	test	rdx, rdx
	je	SHORT $LN3@BeginViewp
	cmp	WORD PTR [rdx+248], di
	jne	$LN9@BeginViewp
$LN3@BeginViewp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movss	xmm1, DWORD PTR [rbx+304]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	movss	xmm0, DWORD PTR [rbx+16]

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	movaps	xmm3, xmm1
	addss	xmm3, DWORD PTR [rbx+8]
	movss	xmm2, DWORD PTR [rbx+308]

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	subss	xmm0, xmm1

; 1799 :     ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }

	addss	xmm2, DWORD PTR [rbx+12]
	xorps	xmm1, xmm1

; 1800 :     ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }

	addss	xmm0, DWORD PTR [rbx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	or	DWORD PTR [rcx+18680], 3

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	mov	QWORD PTR [rcx+18708], rdi

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rcx+18684], 1

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [rcx+18740], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8128 :     g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rcx+18688], 1

; 8116 :     g.NextWindowData.PosVal = pos;

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rcx+18700], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8127 :     g.NextWindowData.SizeVal = size;

	movaps	xmm0, xmm1
	unpcklps xmm0, xmm4
	movsd	QWORD PTR [rcx+18716], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7102 :             viewport->BuildWorkOffsetMin[axis] += axis_size;

	addss	xmm4, DWORD PTR [rbx+308]
	movss	DWORD PTR [rbx+308], xmm4
$LN9@BeginViewp:

; 7103 :         else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)
; 7104 :             viewport->BuildWorkOffsetMax[axis] -= axis_size;
; 7105 :     }
; 7106 : 
; 7107 :     window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
; 7108 :     SetNextWindowViewport(viewport->ID); // Enforce viewport so we don't create our own viewport when ImGuiConfigFlags_ViewportsNoMerge is set.

	mov	eax, DWORD PTR [rbx]
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8181 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;

	or	DWORD PTR [rcx+18680], 256		; 00000100H

; 8182 :     g.NextWindowData.ViewportId = id;

	mov	DWORD PTR [rcx+18780], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7109 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	mov	ecx, 3
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3219 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T3[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T3[rsp], 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm1, DWORD PTR [rbx+14576]
	lea	rcx, QWORD PTR [rbx+18840]
	movss	xmm0, DWORD PTR [rbx+14580]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T3[rsp+4], xmm1
	movss	DWORD PTR $T3[rsp+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7111 :     bool is_open = Begin(name, NULL, window_flags);

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	mov	QWORD PTR [rbx+14576], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7111 :     bool is_open = Begin(name, NULL, window_flags);

	mov	r8d, 2098447				; 0020050fH
	lea	rcx, OFFSET FLAT:??_C@_0O@BKOLOJFE@?$CD?$CDMainMenuBar@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 7112 :     PopStyleVar(2);

	mov	ecx, 2
	movzx	ebx, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 7113 : 
; 7114 :     return is_open;

	movzx	eax, bl

; 7115 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z ENDP ; ImGui::BeginViewportSideBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?IsRootOfOpenMenuSet@@YA_NXZ
_TEXT	SEGMENT
?IsRootOfOpenMenuSet@@YA_NXZ PROC			; IsRootOfOpenMenuSet, COMDAT

; 7156 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 7157 :     ImGuiWindow* window = g.CurrentWindow;
; 7158 :     if ((g.OpenPopupStack.Size <= g.BeginPopupStack.Size) || (window->Flags & ImGuiWindowFlags_ChildMenu))

	movsxd	rax, DWORD PTR [rcx+18936]
	cmp	DWORD PTR [rcx+18920], eax
	jle	SHORT $LN3@IsRootOfOp
	mov	r8, QWORD PTR [rcx+16408]
	test	DWORD PTR [r8+20], 268435456		; 10000000H
	jne	SHORT $LN3@IsRootOfOp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rdx, rax, 56				; 00000038H
	add	rdx, QWORD PTR [rcx+18928]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7173 :     if (window->DC.NavLayerCurrent != upper_popup->ParentNavLayer)

	mov	eax, DWORD PTR [rdx+24]
	cmp	DWORD PTR [r8+400], eax
	jne	SHORT $LN3@IsRootOfOp

; 7174 :         return false;
; 7175 :     return upper_popup->Window && (upper_popup->Window->Flags & ImGuiWindowFlags_ChildMenu) && ImGui::IsWindowChildOf(upper_popup->Window, window, true, false);

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN3@IsRootOfOp
	test	DWORD PTR [rax+20], 268435456		; 10000000H
	je	SHORT $LN3@IsRootOfOp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7813 :     ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy);

	mov	rcx, rax
$LL18@IsRootOfOp:

; 7801 :         last_window = window;

	mov	rdx, rcx

; 7802 :         window = window->RootWindow;

	mov	rcx, QWORD PTR [rcx+952]

; 7803 :         if (popup_hierarchy)
; 7804 :             window = window->RootWindowPopupTree;

	mov	rcx, QWORD PTR [rcx+960]
	cmp	rdx, rcx
	jne	SHORT $LL18@IsRootOfOp

; 7814 :     if (window_root == potential_parent)

	cmp	rcx, r8
	je	SHORT $LN32@IsRootOfOp
	npad	2
$LL11@IsRootOfOp:

; 7815 :         return true;
; 7816 :     while (window != NULL)
; 7817 :     {
; 7818 :         if (window == potential_parent)

	cmp	rax, r8
	je	SHORT $LN32@IsRootOfOp

; 7819 :             return true;
; 7820 :         if (window == window_root) // end of chain

	cmp	rax, rcx
	je	SHORT $LN3@IsRootOfOp

; 7821 :             return false;
; 7822 :         window = window->ParentWindow;

	mov	rax, QWORD PTR [rax+936]
	test	rax, rax
	jne	SHORT $LL11@IsRootOfOp
$LN3@IsRootOfOp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7176 : }

	xor	al, al
	ret	0
$LN32@IsRootOfOp:

; 7174 :         return false;
; 7175 :     return upper_popup->Window && (upper_popup->Window->Flags & ImGuiWindowFlags_ChildMenu) && ImGui::IsWindowChildOf(upper_popup->Window, window, true, false);

	mov	al, 1

; 7176 : }

	ret	0
?IsRootOfOpenMenuSet@@YA_NXZ ENDP			; IsRootOfOpenMenuSet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z
_TEXT	SEGMENT
pressed$1$ = 64
menuset_is_open$1$ = 65
$T8 = 72
text_size$9 = 72
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 80
c$14 = 80
$T15 = 80
$T16 = 80
tv3198 = 96
$T17 = 100
$T18 = 108
label$ = 336
icon$dead$ = 344
enabled$dead$ = 352
?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z PROC			; ImGui::BeginMenuEx, COMDAT

; 7179 : {

$LN419:
	push	rbp
	push	rbx
	push	rdi
	push	r12
	lea	rbp, QWORD PTR [rsp-40]
	sub	rsp, 296				; 00000128H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7179 : {

	mov	r12, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rdi, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7181 :     if (window->SkipItems)

	cmp	BYTE PTR [rdi+240], 0
	je	SHORT $LN2@BeginMenuE

; 7182 :         return false;

	xor	al, al

; 7373 : }

	add	rsp, 296				; 00000128H
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
$LN2@BeginMenuE:
	mov	QWORD PTR [rsp+344], rsi

; 7186 :     const ImGuiID id = window->GetID(label);

	mov	rdx, r12
	mov	QWORD PTR [rsp+360], r14
	mov	rcx, rdi
	mov	QWORD PTR [rsp+288], r15
	call	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10906:     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7186 :     const ImGuiID id = window->GetID(label);

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	movsxd	rax, DWORD PTR [r8+18936]
	cmp	DWORD PTR [r8+18920], eax
	jle	SHORT $LN66@BeginMenuE
	mov	rcx, QWORD PTR [r8+18928]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	cmp	DWORD PTR [rdx+rcx], r14d
	jne	SHORT $LN66@BeginMenuE
	mov	sil, 1
	jmp	SHORT $LN67@BeginMenuE
$LN66@BeginMenuE:
	xor	sil, sil
$LN67@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7192 :     if (window->Flags & ImGuiWindowFlags_ChildMenu)

	mov	r9d, DWORD PTR [rdi+20]

; 7193 :         window_flags |= ImGuiWindowFlags_ChildWindow;
; 7194 : 
; 7195 :     // If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
; 7196 :     // We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
; 7197 :     // If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.
; 7198 :     if (g.MenusIdSubmittedThisFrame.contains(id))

	lea	r15, QWORD PTR [rbx+23968]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1945 :     inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }

	mov	rcx, QWORD PTR [r15+8]
	movsxd	r10, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7192 :     if (window->Flags & ImGuiWindowFlags_ChildMenu)

	shr	r9d, 4
	and	r9d, 16777216				; 01000000H
	mov	QWORD PTR [rsp+352], r13
	or	r9d, 268960069				; 10080145H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1945 :     inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }

	lea	rdx, QWORD PTR [rcx+r10*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7192 :     if (window->Flags & ImGuiWindowFlags_ChildMenu)

	mov	DWORD PTR tv3198[rsp], r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1945 :     inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }

	cmp	rcx, rdx
	jae	SHORT $LN4@BeginMenuE
	npad	7
$LL73@BeginMenuE:
	mov	eax, DWORD PTR [rcx]
	add	rcx, 4
	cmp	eax, r14d
	je	SHORT $LN347@BeginMenuE
	cmp	rcx, rdx
	jb	SHORT $LL73@BeginMenuE
$LN4@BeginMenuE:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [r15+4]
	movaps	XMMWORD PTR [rsp+224], xmm9
	movaps	XMMWORD PTR [rsp+208], xmm10
	movaps	XMMWORD PTR [rsp+192], xmm11
	movaps	XMMWORD PTR [rsp+176], xmm12
	movaps	XMMWORD PTR [rsp+160], xmm13
	movaps	XMMWORD PTR [rsp+144], xmm14
	cmp	r10d, ecx
	jne	SHORT $LN80@BeginMenuE
	lea	r8d, DWORD PTR [r10+1]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN84@BeginMenuE
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN85@BeginMenuE
$LN347@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7200 :         if (menu_is_open)

	test	sil, sil
	je	SHORT $LN5@BeginMenuE

; 7201 :             menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	mov	edx, r9d
	mov	ecx, r14d
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx
	movzx	esi, al
	jmp	$LN6@BeginMenuE
$LN5@BeginMenuE:

; 7202 :         else
; 7203 :             g.NextWindowData.ClearFlags();          // we behave like Begin() and need to consume those values

	xor	r13d, r13d
	mov	DWORD PTR [rbx+18680], r13d

; 7204 :         return menu_is_open;

	jmp	$LN6@BeginMenuE
$LN84@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN85@BeginMenuE:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, r15

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@I@@QEAAXH@Z		; ImVector<unsigned int>::reserve
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN80@BeginMenuE:
	movsxd	rcx, DWORD PTR [r15]
	mov	rax, QWORD PTR [r15+8]
	mov	DWORD PTR [rax+rcx*4], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rcx, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	inc	DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r12, -1
	jae	SHORT $LN356@BeginMenuE
	npad	2
$LL92@BeginMenuE:
	movzx	edx, BYTE PTR [rcx]
	test	dl, dl
	je	SHORT $LN356@BeginMenuE
	lea	rax, QWORD PTR [rcx+1]
	cmp	dl, 35					; 00000023H
	jne	SHORT $LN352@BeginMenuE
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN356@BeginMenuE
$LN352@BeginMenuE:

; 3332 :         text_display_end++;

	mov	rcx, rax
	cmp	rax, -1
	jb	SHORT $LL92@BeginMenuE
$LN356@BeginMenuE:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm12, DWORD PTR [r8+15696]

; 5418 :     if (text == text_display_end)

	xor	r13d, r13d
	movss	xmm13, DWORD PTR __real@bf800000
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+240], xmm8
	cmp	r12, rcx
	jne	SHORT $LN89@BeginMenuE
	xorps	xmm8, xmm8

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN86@BeginMenuE
$LN89@BeginMenuE:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm3, DWORD PTR __real@7f7fffff
	lea	rdx, QWORD PTR text_size$9[rsp]
	mov	QWORD PTR [rsp+56], r13
	movaps	xmm2, xmm12
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR [r8+15688]
	mov	QWORD PTR [rsp+40], r12
	movss	DWORD PTR [rsp+32], xmm13
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$9[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm12, DWORD PTR text_size$9[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm8, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm8, xmm8
$LN86@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7214 :     const bool menuset_is_open = IsRootOfOpenMenuSet();

	call	?IsRootOfOpenMenuSet@@YA_NXZ		; IsRootOfOpenMenuSet
	mov	BYTE PTR menuset_is_open$1$[rsp], al
	movzx	r15d, al

; 7215 :     if (menuset_is_open)

	test	al, al
	je	SHORT $LN7@BeginMenuE

; 7216 :         PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);

	mov	ecx, 256				; 00000100H
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
$LN7@BeginMenuE:

; 7217 : 
; 7218 :     // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
; 7219 :     // However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
; 7220 :     // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
; 7221 :     ImVec2 popup_pos, pos = window->DC.CursorPos;

	movss	xmm14, DWORD PTR [rdi+312]

; 7222 :     PushID(label);

	mov	rcx, r12
	movss	xmm10, DWORD PTR [rdi+316]
	movaps	XMMWORD PTR [rsp+272], xmm6
	movaps	XMMWORD PTR [rsp+256], xmm7
	movaps	XMMWORD PTR [rsp+128], xmm15
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 7223 :     if (!enabled)
; 7224 :         BeginDisabled();
; 7225 :     const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;

	lea	rcx, QWORD PTR [rdi+420]

; 7226 :     bool pressed;
; 7227 : 
; 7228 :     // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
; 7229 :     const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_DontClosePopups;
; 7230 :     if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	movss	xmm11, DWORD PTR __real@3f800000
	cmp	DWORD PTR [rdi+492], r13d
	jne	$LN9@BeginMenuE

; 7231 :     {
; 7232 :         // Menu inside an horizontal menu bar
; 7233 :         // Selectable extend their highlight by half ItemSpacing in each direction.
; 7234 :         // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
; 7235 :         popup_pos = ImVec2(pos.x - 1.0f - IM_FLOOR(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());

	movss	xmm0, DWORD PTR [rbx+14628]
	subss	xmm14, xmm11
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	rcx, rdi
	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	subss	xmm14, xmm2
	call	?MenuBarHeight@ImGuiWindow@@QEBAMXZ	; ImGuiWindow::MenuBarHeight
	subss	xmm10, DWORD PTR [rbx+14616]

; 7236 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);

	addss	xmm2, DWORD PTR [rdi+312]
	movaps	xmm15, xmm0

; 7237 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

	lea	rdx, QWORD PTR $T12[rsp]
	mov	ecx, 14
	addss	xmm15, xmm10
	movss	DWORD PTR [rdi+312], xmm2
	movss	xmm1, DWORD PTR [rbx+14628]
	addss	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T12[rsp], xmm1
	movss	xmm1, DWORD PTR [rbx+14632]
	movss	DWORD PTR $T12[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7237 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

	call	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z	; ImGui::PushStyleVar

; 7239 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	movzx	eax, WORD PTR [rdi+432]

; 7240 :         pressed = Selectable("", menu_is_open, selectable_flags, ImVec2(w, label_size.y));

	lea	r9, QWORD PTR $T11[rsp]
	movss	xmm6, DWORD PTR [rdi+368]
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	addss	xmm6, DWORD PTR [rdi+316]
	mov	r8d, 139460609				; 08500001H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T11[rsp], xmm8
	movd	xmm7, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7240 :         pressed = Selectable("", menu_is_open, selectable_flags, ImVec2(w, label_size.y));

	movzx	edx, sil
	cvtdq2ps xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T11[rsp+4], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7239 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	addss	xmm7, DWORD PTR [rdi+312]

; 7240 :         pressed = Selectable("", menu_is_open, selectable_flags, ImVec2(w, label_size.y));

	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable

; 7241 :         RenderText(text_pos, label);

	movaps	xmm0, xmm7
	mov	BYTE PTR pressed$1$[rsp], al
	unpcklps xmm0, xmm6
	mov	r9b, 1
	movq	rcx, xmm0
	xor	r8d, r8d
	mov	rdx, r12
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 7242 :         PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 7243 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

	movss	xmm0, DWORD PTR [rbx+14628]
	movss	xmm2, DWORD PTR [rdi+312]
	mulss	xmm0, DWORD PTR __real@3f000000

; 7244 :     }

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cvttss2si ecx, xmm0
	movd	xmm1, ecx
	cvtdq2ps xmm1, xmm1
	subss	xmm2, xmm1
	movss	DWORD PTR [rdi+312], xmm2
	jmp	$LN12@BeginMenuE
$LN9@BeginMenuE:

; 7245 :     else
; 7246 :     {
; 7247 :         // Menu inside a regular/vertical menu
; 7248 :         // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
; 7249 :         //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
; 7250 :         popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
; 7251 :         float icon_w = (icon && icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
; 7252 :         float checkmark_w = IM_FLOOR(g.FontSize * 1.20f);

	movss	xmm0, DWORD PTR [rbx+15696]
	movaps	xmm15, xmm10
	mulss	xmm0, DWORD PTR __real@3f99999a
	xorps	xmm3, xmm3
	subss	xmm15, DWORD PTR [rbx+14564]

; 7253 :         float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame

	movaps	xmm2, xmm8
	xorps	xmm1, xmm1
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	call	?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z ; ImGuiMenuColumns::DeclColumns
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10452:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7253 :         float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame

	movaps	xmm4, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10452:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rdx, QWORD PTR [rcx+16408]

; 10445:     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, rdx

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	cmp	QWORD PTR [rdx+480], r13
	jne	SHORT $LN117@BeginMenuE
	cmp	QWORD PTR [rcx+19728], r13
	jne	SHORT $LN117@BeginMenuE
	add	rax, 648				; 00000288H
	jmp	SHORT $LN118@BeginMenuE
$LN117@BeginMenuE:
	add	rax, 600				; 00000258H
$LN118@BeginMenuE:
	movss	xmm0, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7256 :         pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	lea	r9, QWORD PTR $T10[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, DWORD PTR [rdx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7255 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	movzx	eax, WORD PTR [rdi+432]

; 7256 :         pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	movss	xmm6, DWORD PTR [rdi+368]
	xorps	xmm8, xmm8
	addss	xmm6, DWORD PTR [rdi+316]
	mov	r8d, 156237825				; 09500001H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T10[rsp], xmm4
	movd	xmm7, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7254 :         float extra_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);

	subss	xmm0, xmm4

; 7255 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	cvtdq2ps xmm7, xmm7

; 7256 :         pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	movzx	edx, sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T10[rsp+4], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm8, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7255 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	addss	xmm7, DWORD PTR [rdi+312]

; 7256 :         pressed = Selectable("", menu_is_open, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable

; 7257 :         RenderText(text_pos, label);

	movaps	xmm0, xmm7
	mov	BYTE PTR pressed$1$[rsp], al
	unpcklps xmm0, xmm6
	mov	r9b, 1
	movq	rcx, xmm0
	xor	r8d, r8d
	mov	rdx, r12
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$14[rsp]
	movups	xmm0, XMMWORD PTR [r8+14776]
	movups	XMMWORD PTR c$14[rsp], xmm0
	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [r8+14552]
	movss	DWORD PTR c$14[rsp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7260 :         RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);

	movss	xmm0, DWORD PTR [rbx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7260 :         RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);

	mulss	xmm0, DWORD PTR __real@3e99999a
	mov	r15, QWORD PTR [rdi+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	DWORD PTR $T8[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3826 :     const float h = draw_list->_Data->FontSize * 1.00f;

	mov	rcx, QWORD PTR [r15+56]
	movss	xmm1, DWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movzx	ecx, WORD PTR [rdi+436]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3827 :     float r = h * 0.40f * scale;

	movaps	xmm4, xmm1

; 3828 :     ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm4, DWORD PTR __real@3ecccccd
	movd	xmm3, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm10, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7260 :         RenderArrow(window->DrawList, pos + ImVec2(offsets->OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);

	cvtdq2ps xmm3, xmm3
	addss	xmm3, xmm8
	addss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2536 : static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f400000

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm3, xmm14
	addss	xmm3, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 3845 :         c = ImVec2(-0.750f, -0.866f) * r;

	movaps	xmm1, xmm3
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@bf5db22d
	movss	DWORD PTR $T13[rsp], xmm1
	addss	xmm0, xmm10
	movss	DWORD PTR $T18[rsp], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR __real@3f5db22d
	movss	DWORD PTR $T13[rsp+4], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f400000
	addss	xmm1, xmm10
	mulss	xmm4, xmm9
	addss	xmm0, xmm3
	movss	DWORD PTR $T18[rsp+4], xmm1
	addss	xmm4, xmm10
	movss	DWORD PTR $T17[rsp], xmm0
	movss	DWORD PTR $T17[rsp+4], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_draw.cpp

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

	test	eax, -16777216				; ff000000H
	je	SHORT $LN357@BeginMenuE

; 1474 :         return;
; 1475 : 
; 1476 :     PathLineTo(p1);

	lea	rdx, QWORD PTR $T17[rsp]
	mov	rcx, r15
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1477 :     PathLineTo(p2);

	lea	rdx, QWORD PTR $T18[rsp]
	mov	rcx, r15
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo

; 1478 :     PathLineTo(p3);

	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, r15
	call	?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z ; ImDrawList::PathLineTo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2807 :     inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }

	mov	r9d, DWORD PTR $T8[rsp]
	mov	rcx, r15
	mov	r8d, DWORD PTR [r15+120]
	mov	rdx, QWORD PTR [r15+128]
	call	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	DWORD PTR [r15+120], r13d
$LN357@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7265 :     const bool hovered = (g.HoveredId == id) && enabled && !g.NavDisableMouseHover;

	movzx	r15d, BYTE PTR menuset_is_open$1$[rsp]
$LN12@BeginMenuE:
	cmp	DWORD PTR [rbx+16484], r14d
	jne	SHORT $LN40@BeginMenuE
	cmp	BYTE PTR [rbx+19159], r13b
	jne	SHORT $LN40@BeginMenuE
	mov	dl, 1
	jmp	SHORT $LN41@BeginMenuE
$LN40@BeginMenuE:
	xor	dl, dl
$LN41@BeginMenuE:

; 7266 :     if (menuset_is_open)

	test	r15b, r15b
	je	SHORT $LN13@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [r8+18888]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [r8+18888], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7725 :     g.CurrentItemFlags = g.ItemFlagsStack.back();

	mov	rax, QWORD PTR [r8+18896]
	mov	ecx, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR [r8+18584], ecx
$LN13@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7269 :     bool want_open = false;

	xor	r15b, r15b

; 7270 :     bool want_close = false;

	xor	r10b, r10b

; 7271 :     if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))

	cmp	DWORD PTR [rdi+492], 1
	jne	$LN14@BeginMenuE

; 7272 :     {
; 7273 :         // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
; 7274 :         // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
; 7275 :         bool moving_toward_child_menu = false;
; 7276 :         ImGuiPopupData* child_popup = (g.BeginPopupStack.Size < g.OpenPopupStack.Size) ? &g.OpenPopupStack[g.BeginPopupStack.Size] : NULL; // Popup candidate (testing below)

	movsxd	rax, DWORD PTR [rbx+18936]
	xor	cl, cl
	cmp	eax, DWORD PTR [rbx+18920]
	jge	SHORT $LN44@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rax, rax, 56				; 00000038H
	add	rax, QWORD PTR [rbx+18928]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7277 :         ImGuiWindow* child_menu_window = (child_popup && child_popup->Window && child_popup->Window->ParentWindow == window) ? child_popup->Window : NULL;

	je	SHORT $LN44@BeginMenuE
	mov	rax, QWORD PTR [rax+8]
	test	rax, rax
	je	SHORT $LN44@BeginMenuE
	cmp	QWORD PTR [rax+936], rdi
	je	SHORT $LN45@BeginMenuE
$LN44@BeginMenuE:
	mov	rax, r13
$LN45@BeginMenuE:

; 7278 :         if (g.HoveredWindow == window && child_menu_window != NULL)

	mov	r9, QWORD PTR [rbx+16416]
	cmp	r9, rdi
	jne	$LN278@BeginMenuE
	test	rax, rax
	je	$LN278@BeginMenuE

; 7279 :         {
; 7280 :             float ref_unit = g.FontSize; // FIXME-DPI
; 7281 :             float child_dir = (window->Pos.x < child_menu_window->Pos.x) ? 1.0f : -1.0f;

	movss	xmm2, DWORD PTR [rax+80]
	comiss	xmm2, DWORD PTR [rdi+80]
	movss	xmm3, DWORD PTR [rbx+15696]
	ja	SHORT $LN47@BeginMenuE
	movaps	xmm11, xmm13
$LN47@BeginMenuE:

; 7284 :             ImVec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	comiss	xmm11, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm7, DWORD PTR [rax+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	movaps	xmm5, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm6, DWORD PTR [rbx+3592]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	movaps	xmm4, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm12, DWORD PTR [rbx+3596]
	movaps	xmm8, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	addss	xmm4, DWORD PTR [rax+92]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm8, DWORD PTR [rbx+248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2653 :     ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }

	addss	xmm5, DWORD PTR [rax+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movaps	xmm10, xmm12
	subss	xmm10, DWORD PTR [rbx+252]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7284 :             ImVec2 tb = (child_dir > 0.0f) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	jbe	SHORT $LN48@BeginMenuE
	movaps	xmm13, xmm2
	jmp	SHORT $LN49@BeginMenuE
$LN48@BeginMenuE:
	movaps	xmm1, xmm5
	unpcklps xmm1, xmm7
	movaps	xmm0, xmm1
	movsd	QWORD PTR $T15[rsp], xmm1
	movss	xmm13, DWORD PTR $T15[rsp]
	shufps	xmm0, xmm0, 85				; 00000055H
	movaps	xmm7, xmm0
$LN49@BeginMenuE:

; 7285 :             ImVec2 tc = (child_dir > 0.0f) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	jbe	SHORT $LN50@BeginMenuE
	movaps	xmm0, xmm2
	unpcklps xmm0, xmm4
	movaps	xmm4, xmm0
	movsd	QWORD PTR $T16[rsp], xmm0
	movss	xmm5, DWORD PTR $T16[rsp]
	shufps	xmm4, xmm4, 85				; 00000055H
$LN50@BeginMenuE:

; 7286 :             float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f);   // add a bit of extra slack.

	movss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm0, xmm8
	subss	xmm0, xmm13
	movaps	xmm2, xmm3
	mulss	xmm2, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7286 :             float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f);   // add a bit of extra slack.

	mulss	xmm0, DWORD PTR __real@3e99999a
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm0
	ja	SHORT $LN301@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7286 :             float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f);   // add a bit of extra slack.

	movaps	xmm2, xmm3
	mulss	xmm2, DWORD PTR __real@40200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	minss	xmm2, xmm0
$LN301@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7290 :             tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -ref_unit * 8.0f);                           // triangle has maximum height to limit the slope and the bias toward large sub-menus

	subss	xmm7, xmm2
	movaps	xmm0, xmm11
	mulss	xmm0, xmm1

; 7291 :             tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +ref_unit * 8.0f);

	addss	xmm4, xmm2
	mulss	xmm11, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movaps	xmm1, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7287 :             ta.x += child_dir * -0.5f;

	subss	xmm8, xmm0

; 7290 :             tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -ref_unit * 8.0f);                           // triangle has maximum height to limit the slope and the bias toward large sub-menus

	movaps	xmm0, xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm7, xmm10
	mulss	xmm0, DWORD PTR __real@41000000
	addss	xmm13, xmm11

; 7291 :             tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +ref_unit * 8.0f);

	mulss	xmm3, DWORD PTR __real@41000000
	subss	xmm4, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm7, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7289 :             tc.x += child_dir * ref_unit;

	addss	xmm5, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm4, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1755 :     bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;

	movaps	xmm3, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	addss	xmm7, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	subss	xmm0, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	addss	xmm4, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1755 :     bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;

	subss	xmm3, xmm7

; 1756 :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	movaps	xmm2, xmm7
	subss	xmm1, xmm4
	subss	xmm2, xmm4
	mulss	xmm2, xmm0
	movaps	xmm0, xmm13
	subss	xmm0, xmm5
	mulss	xmm1, xmm0
	movaps	xmm0, xmm6
	subss	xmm0, xmm13
	subss	xmm2, xmm1
	movaps	xmm1, xmm12
	subss	xmm1, xmm7
	mulss	xmm3, xmm0
	movaps	xmm0, xmm8
	comiss	xmm9, xmm2
	subss	xmm0, xmm13
	seta	cl
	mulss	xmm1, xmm0
	subss	xmm3, xmm1
	comiss	xmm9, xmm3
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	al, cl
	jne	SHORT $LN277@BeginMenuE

; 1757 :     bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;

	subss	xmm6, xmm8
	subss	xmm4, xmm10
	subss	xmm5, xmm8
	subss	xmm12, xmm10
	mulss	xmm6, xmm4
	mulss	xmm5, xmm12
	subss	xmm6, xmm5
	comiss	xmm9, xmm6
	seta	al

; 1758 :     return ((b1 == b2) && (b2 == b3));

	cmp	cl, al
	jne	SHORT $LN277@BeginMenuE
	mov	cl, 1
	jmp	SHORT $LN278@BeginMenuE
$LN277@BeginMenuE:
	xor	cl, cl
$LN278@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7299 :         if (menu_is_open && !hovered && g.HoveredWindow == window && !moving_toward_child_menu && !g.NavDisableMouseHover)

	test	sil, sil
	je	SHORT $LN346@BeginMenuE
	test	dl, dl
	jne	SHORT $LN20@BeginMenuE
	cmp	r9, rdi
	jne	SHORT $LN20@BeginMenuE
	test	cl, cl
	jne	SHORT $LN20@BeginMenuE
	cmp	BYTE PTR [rbx+19159], r10b
	jne	SHORT $LN20@BeginMenuE

; 7300 :             want_close = true;

	mov	r10b, 1

; 7301 : 
; 7302 :         // Open
; 7303 :         if (!menu_is_open && pressed) // Click/activate to open

	jmp	SHORT $LN20@BeginMenuE
$LN346@BeginMenuE:
	cmp	BYTE PTR pressed$1$[rsp], r10b
	je	SHORT $LN355@BeginMenuE

; 7304 :             want_open = true;

	mov	r15b, 1
	jmp	SHORT $LN20@BeginMenuE
$LN355@BeginMenuE:

; 7305 :         else if (!menu_is_open && hovered && !moving_toward_child_menu) // Hover to open

	test	dl, dl
	je	SHORT $LN20@BeginMenuE
	test	cl, cl
	movzx	r15d, r15b
	mov	eax, 1
	cmove	r15d, eax
$LN20@BeginMenuE:

; 7306 :             want_open = true;
; 7307 :         if (g.NavId == id && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open

	cmp	DWORD PTR [rbx+19104], r14d
	jne	SHORT $LN28@BeginMenuE
	cmp	DWORD PTR [rbx+19232], 1
	jne	SHORT $LN28@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r8+19161], r13b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7309 :             want_open = true;

	mov	r15b, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r8+19216], r13w

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	setne	al
	mov	BYTE PTR [r8+19160], al
$LN28@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7334 :     if (want_close && IsPopupOpen(id, ImGuiPopupFlags_None))

	test	r10b, r10b
	jne	SHORT $LN349@BeginMenuE
$LN29@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rax+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7340 :     if (want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)

	test	r15b, r15b
	jne	$LN353@BeginMenuE

; 7349 :     }
; 7350 : 
; 7351 :     if (menu_is_open)

	test	sil, sil
	je	$LN33@BeginMenuE
	jmp	$LN351@BeginMenuE
$LN14@BeginMenuE:

; 7310 :             NavMoveRequestCancel();
; 7311 :         }
; 7312 :     }
; 7313 :     else
; 7314 :     {
; 7315 :         // Menu bar
; 7316 :         if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it

	test	sil, sil
	je	SHORT $LN22@BeginMenuE
	cmp	BYTE PTR pressed$1$[rsp], r10b
	je	SHORT $LN345@BeginMenuE
	cmp	BYTE PTR menuset_is_open$1$[rsp], r10b
	je	$LN26@BeginMenuE

; 7317 :         {
; 7318 :             want_close = true;
; 7319 :             want_open = menu_is_open = false;

	xor	sil, sil
$LN349@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	movsxd	rax, DWORD PTR [r8+18936]
	cmp	DWORD PTR [r8+18920], eax
	jle	SHORT $LN29@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10930:             return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;

	mov	rax, QWORD PTR [r8+18928]
	cmp	DWORD PTR [rcx+rax], r14d
	jne	SHORT $LN29@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7335 :         ClosePopupToLevel(g.BeginPopupStack.Size, true);

	mov	ecx, DWORD PTR [rbx+18936]
	mov	dl, 1
	call	?ClosePopupToLevel@ImGui@@YAXH_N@Z	; ImGui::ClosePopupToLevel
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN29@BeginMenuE
$LN22@BeginMenuE:

; 7320 :         }
; 7321 :         else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others

	cmp	BYTE PTR pressed$1$[rsp], r10b
	jne	SHORT $LN26@BeginMenuE
$LN345@BeginMenuE:
	test	dl, dl
	je	SHORT $LN24@BeginMenuE
	cmp	BYTE PTR menuset_is_open$1$[rsp], r10b
	je	SHORT $LN24@BeginMenuE
	test	sil, sil
	je	SHORT $LN26@BeginMenuE
$LN24@BeginMenuE:

; 7322 :         {
; 7323 :             want_open = true;
; 7324 :         }
; 7325 :         else if (g.NavId == id && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open

	cmp	DWORD PTR [rbx+19104], r14d
	jne	$LN29@BeginMenuE
	cmp	DWORD PTR [rbx+19232], 3
	jne	$LN29@BeginMenuE
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11882:     g.NavMoveSubmitted = g.NavMoveScoringItems = false;

	mov	WORD PTR [r8+19216], r13w

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	cmp	BYTE PTR [r8+19161], r10b
	jne	SHORT $LN321@BeginMenuE
	mov	BYTE PTR [r8+19160], r10b
$LN26@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7340 :     if (want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)

	mov	rax, QWORD PTR [r8+16408]
	dec	DWORD PTR [rax+296]
$LN353@BeginMenuE:
	test	sil, sil
	jne	SHORT $LN30@BeginMenuE
	mov	eax, DWORD PTR [rbx+18936]
	cmp	DWORD PTR [rbx+18920], eax
	jle	SHORT $LN30@BeginMenuE

; 7341 :     {
; 7342 :         // Don't reopen/recycle same menu level in the same frame, first close the other menu and yield for a frame.
; 7343 :         OpenPopup(label);

	mov	rcx, r12
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup
$LN33@BeginMenuE:

; 7365 :         }
; 7366 :     }
; 7367 :     else
; 7368 :     {
; 7369 :         g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values

	mov	DWORD PTR [rbx+18680], r13d
	jmp	$LN34@BeginMenuE
$LN321@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11967:     g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);

	mov	BYTE PTR [r8+19160], 1

; 11968:     if (g.NavAnyRequest)

	jmp	SHORT $LN26@BeginMenuE
$LN30@BeginMenuE:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7348 :         OpenPopup(label);

	mov	rcx, r12
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup
	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN351@BeginMenuE:

; 7353 :         ImGuiLastItemData last_item_in_parent = g.LastItemData;

	movups	xmm6, XMMWORD PTR [rbx+18616]
	mov	r15d, DWORD PTR [rbx+18672]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	r12d, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7353 :         ImGuiLastItemData last_item_in_parent = g.LastItemData;

	movups	xmm7, XMMWORD PTR [rbx+18632]
	movups	xmm8, XMMWORD PTR [rbx+18648]

; 7355 :         PushStyleVar(ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding

	lea	ecx, QWORD PTR [r12+6]
	movsd	xmm9, QWORD PTR [rbx+18664]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8115 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;

	or	DWORD PTR [r8+18680], 1

; 8116 :     g.NextWindowData.PosVal = pos;

	movss	DWORD PTR [r8+18700], xmm14
	movss	DWORD PTR [r8+18704], xmm15

; 8117 :     g.NextWindowData.PosPivotVal = pivot;

	mov	QWORD PTR [r8+18708], r13

; 8118 :     g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [r8+18684], r12d

; 8119 :     g.NextWindowData.PosUndock = true;

	mov	BYTE PTR [r8+18740], r12b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7355 :         PushStyleVar(ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding

	movss	xmm1, DWORD PTR [rbx+14604]
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 7356 :         menu_is_open = BeginPopupEx(id, window_flags);                  // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	mov	edx, DWORD PTR tv3198[rsp]
	mov	ecx, r14d
	call	?BeginPopupEx@ImGui@@YA_NIH@Z		; ImGui::BeginPopupEx

; 7357 :         PopStyleVar();

	mov	ecx, r12d
	movzx	esi, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 7358 :         if (menu_is_open)

	test	sil, sil
	je	SHORT $LN34@BeginMenuE

; 7359 :         {
; 7360 :             // Restore LastItemData so IsItemXXXX functions can work after BeginMenu()/EndMenu()
; 7361 :             // (This fixes using IsItemClicked() and IsItemHovered(), but IsItemHovered() also relies on its support for ImGuiItemFlags_NoWindowHoverableCheck)
; 7362 :             g.LastItemData = last_item_in_parent;

	movups	XMMWORD PTR [rbx+18616], xmm6
	movups	XMMWORD PTR [rbx+18632], xmm7
	movups	XMMWORD PTR [rbx+18648], xmm8
	movsd	QWORD PTR [rbx+18664], xmm9
	mov	DWORD PTR [rbx+18672], r15d

; 7363 :             if (g.HoveredWindow == window)

	cmp	QWORD PTR [rbx+16416], rdi
	jne	SHORT $LN34@BeginMenuE

; 7364 :                 g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;

	or	DWORD PTR [rbx+18624], 128		; 00000080H
$LN34@BeginMenuE:

; 7370 :     }
; 7371 : 
; 7372 :     return menu_is_open;

	movaps	xmm15, XMMWORD PTR [rsp+128]
	movaps	xmm14, XMMWORD PTR [rsp+144]
	movaps	xmm13, XMMWORD PTR [rsp+160]
	movaps	xmm12, XMMWORD PTR [rsp+176]
	movaps	xmm11, XMMWORD PTR [rsp+192]
	movaps	xmm10, XMMWORD PTR [rsp+208]
	movaps	xmm9, XMMWORD PTR [rsp+224]
	movaps	xmm8, XMMWORD PTR [rsp+240]
	movaps	xmm7, XMMWORD PTR [rsp+256]
	movaps	xmm6, XMMWORD PTR [rsp+272]
$LN6@BeginMenuE:
	mov	r13, QWORD PTR [rsp+352]
	movzx	eax, sil
	mov	rsi, QWORD PTR [rsp+344]
	mov	r14, QWORD PTR [rsp+360]
	mov	r15, QWORD PTR [rsp+288]

; 7373 : }

	add	rsp, 296				; 00000128H
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z ENDP			; ImGui::BeginMenuEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z
_TEXT	SEGMENT
c$4 = 64
$T5 = 64
label$ = 240
icon$dead$ = 248
text_size$6 = 248
text_size$7 = 248
$T8 = 248
$T9 = 248
shortcut$ = 256
selected$ = 264
enabled$dead$ = 272
?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z PROC			; ImGui::MenuItemEx, COMDAT

; 7399 : {

$LN158:
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	sub	rsp, 192				; 000000c0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7399 : {

	movzx	r13d, r9b
	mov	r14, r8
	mov	rbp, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rdi, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7401 :     if (window->SkipItems)

	cmp	BYTE PTR [rdi+240], 0
	je	SHORT $LN2@MenuItemEx

; 7402 :         return false;

	xor	al, al

; 7472 : }

	add	rsp, 192				; 000000c0H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@MenuItemEx:
	mov	QWORD PTR [rsp+240], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rax, rbp
	mov	QWORD PTR [rsp+256], r12
	mov	QWORD PTR [rsp+264], r15
	movaps	XMMWORD PTR [rsp+176], xmm6
	movaps	XMMWORD PTR [rsp+160], xmm7
	movaps	XMMWORD PTR [rsp+144], xmm8
	movaps	XMMWORD PTR [rsp+128], xmm9
	movaps	XMMWORD PTR [rsp+96], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7406 :     ImVec2 pos = window->DC.CursorPos;

	movss	xmm12, DWORD PTR [rdi+312]
	movaps	XMMWORD PTR [rsp+80], xmm13
	movss	xmm13, DWORD PTR [rdi+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rbp, -1
	jae	SHORT $LN140@MenuItemEx
$LL27@MenuItemEx:
	movzx	ecx, BYTE PTR [rax]
	test	cl, cl
	je	SHORT $LN140@MenuItemEx
	cmp	cl, 35					; 00000023H
	lea	rcx, QWORD PTR [rax+1]
	jne	SHORT $LN30@MenuItemEx
	cmp	BYTE PTR [rcx], 35			; 00000023H
	je	SHORT $LN140@MenuItemEx
$LN30@MenuItemEx:

; 3332 :         text_display_end++;

	mov	rax, rcx
	cmp	rcx, -1
	jb	SHORT $LL27@MenuItemEx
$LN140@MenuItemEx:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm7, DWORD PTR [rsi+15696]
	xorps	xmm6, xmm6

; 5418 :     if (text == text_display_end)

	movss	xmm8, DWORD PTR __real@bf800000
	movss	xmm9, DWORD PTR __real@7f7fffff
	movaps	XMMWORD PTR [rsp+112], xmm11
	cmp	rbp, rax
	jne	SHORT $LN24@MenuItemEx
	xorps	xmm11, xmm11

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN21@MenuItemEx
$LN24@MenuItemEx:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	rcx, QWORD PTR [rsi+15688]
	lea	rdx, QWORD PTR text_size$7[rsp]
	mov	QWORD PTR [rsp+56], 0
	movaps	xmm3, xmm9
	mov	QWORD PTR [rsp+48], rax
	movaps	xmm2, xmm7
	mov	QWORD PTR [rsp+40], rbp
	movss	DWORD PTR [rsp+32], xmm8
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$7[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm7, DWORD PTR text_size$7[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm11, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm11, xmm11
$LN21@MenuItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7410 :     const bool menuset_is_open = IsRootOfOpenMenuSet();

	call	?IsRootOfOpenMenuSet@@YA_NXZ		; IsRootOfOpenMenuSet
	movzx	r15d, al

; 7411 :     if (menuset_is_open)

	test	al, al
	je	SHORT $LN3@MenuItemEx

; 7412 :         PushItemFlag(ImGuiItemFlags_NoWindowHoverableCheck, true);

	mov	ecx, 256				; 00000100H
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
$LN3@MenuItemEx:

; 7413 : 
; 7414 :     // We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
; 7415 :     // but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
; 7416 :     bool pressed;
; 7417 :     PushID(label);

	mov	rcx, rbp
	call	?PushID@ImGui@@YAXPEBD@Z		; ImGui::PushID

; 7418 :     if (!enabled)
; 7419 :         BeginDisabled();
; 7420 : 
; 7421 :     // We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
; 7422 :     const ImGuiSelectableFlags selectable_flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlags_SetNavIdOnHover;
; 7423 :     const ImGuiMenuColumns* offsets = &window->DC.MenuColumns;
; 7424 :     if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	cmp	DWORD PTR [rdi+492], 0
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jne	$LN15@MenuItemEx

; 7429 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);

	movss	xmm0, DWORD PTR [rsi+14628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rcx, QWORD PTR [rbx+18840]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7429 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);

	mulss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T5[rsp], 14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7430 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	movss	xmm9, DWORD PTR [rdi+368]
	addss	xmm9, DWORD PTR [rdi+316]
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	addss	xmm1, DWORD PTR [rdi+312]
	movss	DWORD PTR [rdi+312], xmm1
	movzx	eax, WORD PTR [rdi+432]

; 7431 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

	movss	xmm7, DWORD PTR [rsi+14628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm0, DWORD PTR [rbx+14632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7431 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));

	addss	xmm7, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm6, DWORD PTR [rsi+14632]
	movd	xmm8, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7430 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	cvtdq2ps xmm8, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T5[rsp+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7430 :         ImVec2 text_pos(window->DC.CursorPos.x + offsets->OffsetLabel, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);

	addss	xmm8, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	movss	xmm1, DWORD PTR [rbx+14628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1034 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T5[rsp+4], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3224 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7432 :         pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));

	lea	r9, QWORD PTR $T9[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	movss	DWORD PTR [rbx+14628], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7432 :         pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));

	mov	r8d, 176160768				; 0a800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3225 :         *pvar = val;

	movss	DWORD PTR [rbx+14632], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7432 :         pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));

	movzx	edx, r13b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp], xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7432 :         pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));

	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T9[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7432 :         pressed = Selectable("", selected, selectable_flags, ImVec2(w, 0.0f));

	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable

; 7433 :         PopStyleVar();

	mov	ecx, 1
	movzx	ebx, al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 7434 :         if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)

	test	DWORD PTR [rsi+18624], 512		; 00000200H
	je	SHORT $LN7@MenuItemEx

; 7435 :             RenderText(text_pos, label);

	movaps	xmm0, xmm8
	mov	r9b, 1
	unpcklps xmm0, xmm9
	xor	r8d, r8d
	movq	rcx, xmm0
	mov	rdx, rbp
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText
$LN7@MenuItemEx:

; 7436 :         window->DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().

	movss	xmm0, DWORD PTR [rsi+14628]
	movss	xmm2, DWORD PTR [rdi+312]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	subss	xmm2, xmm1
	movss	DWORD PTR [rdi+312], xmm2

; 7437 :     }

	jmp	$LN12@MenuItemEx
$LN15@MenuItemEx:

; 7444 :         float shortcut_w = (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;

	test	r14, r14
	je	SHORT $LN17@MenuItemEx
	cmp	BYTE PTR [r14], 0
	je	SHORT $LN17@MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$6[rsp]
	mov	rcx, QWORD PTR [rbx+15688]
	xor	eax, eax
	mov	QWORD PTR [rsp+56], rax
	movaps	xmm3, xmm9
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], r14
	movss	DWORD PTR [rsp+32], xmm8
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$6[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm8, eax
	cvtdq2ps xmm8, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7444 :         float shortcut_w = (shortcut && shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;

	jmp	SHORT $LN18@MenuItemEx
$LN17@MenuItemEx:
	xorps	xmm8, xmm8
$LN18@MenuItemEx:

; 7445 :         float checkmark_w = IM_FLOOR(g.FontSize * 1.20f);

	movss	xmm0, DWORD PTR [rsi+15696]

; 7446 :         float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame

	lea	rcx, QWORD PTR [rdi+420]
	mulss	xmm0, DWORD PTR __real@3f99999a
	movaps	xmm3, xmm8
	movaps	xmm2, xmm11
	xorps	xmm1, xmm1
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsp+32], xmm0
	call	?DeclColumns@ImGuiMenuColumns@@QEAAMMMMM@Z ; ImGuiMenuColumns::DeclColumns
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10452:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rdx, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7446 :         float min_w = window->DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame

	movaps	xmm4, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	cmp	QWORD PTR [rdx+480], 0
	jne	SHORT $LN63@MenuItemEx
	cmp	QWORD PTR [rbx+19728], 0
	mov	eax, 648				; 00000288H
	je	SHORT $LN64@MenuItemEx
$LN63@MenuItemEx:
	mov	eax, 600				; 00000258H
$LN64@MenuItemEx:
	movss	xmm0, DWORD PTR [rdx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7448 :         pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	lea	r9, QWORD PTR $T8[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, DWORD PTR [rdx+312]
	xorps	xmm9, xmm9

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7448 :         pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7448 :         pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	mov	r8d, 192937984				; 0b800000H
	lea	rcx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	subss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm9, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7448 :         pressed = Selectable("", false, selectable_flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, label_size.y));

	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable

; 7449 :         if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible)

	test	DWORD PTR [rsi+18624], 512		; 00000200H
	movzx	ebx, al
	je	$LN12@MenuItemEx

; 7451 :             RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);

	movzx	eax, WORD PTR [rdi+432]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm7, xmm13
	addss	xmm7, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7451 :             RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);

	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, rbp
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7451 :             RenderText(pos + ImVec2(offsets->OffsetLabel, 0.0f), label);

	unpcklps xmm0, xmm7
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 7452 :             if (icon_w > 0.0f)
; 7453 :                 RenderText(pos + ImVec2(offsets->OffsetIcon, 0.0f), icon);
; 7454 :             if (shortcut_w > 0.0f)

	comiss	xmm8, xmm6
	jbe	SHORT $LN10@MenuItemEx

; 7455 :             {
; 7456 :                 PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);

	lea	rdx, QWORD PTR [rsi+14792]
	xor	ecx, ecx
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 7457 :                 RenderText(pos + ImVec2(offsets->OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);

	movzx	eax, WORD PTR [rdi+434]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, r14
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm0, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7457 :                 RenderText(pos + ImVec2(offsets->OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);

	unpcklps xmm0, xmm7
	movq	rcx, xmm0
	call	?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z ; ImGui::RenderText

; 7458 :                 PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
$LN10@MenuItemEx:

; 7459 :             }
; 7460 :             if (selected)

	test	r13b, r13b
	je	$LN12@MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$4[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	movss	xmm8, DWORD PTR [rsi+15696]
	movaps	xmm6, xmm8
	mulss	xmm6, DWORD PTR __real@3e09374c
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rax+14776]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	mulss	xmm6, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$4[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm6, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	mulss	xmm0, DWORD PTR [rax+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	movzx	eax, WORD PTR [rdi+436]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3092 :     c.w *= style.Alpha * alpha_mul;

	movss	DWORD PTR c$4[rsp+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	movaps	xmm0, xmm8
	mulss	xmm0, DWORD PTR __real@3ecccccd
	mulss	xmm8, DWORD PTR __real@3f5db22d
	movd	xmm7, eax
	cvtdq2ps xmm7, xmm7
	addss	xmm7, xmm9
	addss	xmm7, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	addss	xmm7, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	mov	rcx, QWORD PTR [rdi+728]
	movaps	xmm0, xmm7
	unpcklps xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7461 :                 RenderCheckMark(window->DrawList, pos + ImVec2(offsets->OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize * 0.866f);

	movq	rdx, xmm0
	movaps	xmm3, xmm8
	call	?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z ; ImGui::RenderCheckMark
$LN12@MenuItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movaps	xmm13, XMMWORD PTR [rsp+80]
	movaps	xmm12, XMMWORD PTR [rsp+96]
	movaps	xmm11, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rax, QWORD PTR [rdx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movaps	xmm9, XMMWORD PTR [rsp+128]
	movaps	xmm8, XMMWORD PTR [rsp+144]
	movaps	xmm7, XMMWORD PTR [rsp+160]
	dec	DWORD PTR [rax+296]
	movaps	xmm6, XMMWORD PTR [rsp+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7468 :     if (menuset_is_open)

	test	r15b, r15b
	mov	r15, QWORD PTR [rsp+264]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	r12, QWORD PTR [rsp+256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7468 :     if (menuset_is_open)

	je	SHORT $LN13@MenuItemEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rdx+18888]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rdx+18888], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7725 :     g.CurrentItemFlags = g.ItemFlagsStack.back();

	mov	rax, QWORD PTR [rdx+18896]
	mov	ecx, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR [rdx+18584], ecx
$LN13@MenuItemEx:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7471 :     return pressed;

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+240]

; 7472 : }

	add	rsp, 192				; 000000c0H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z ENDP			; ImGui::MenuItemEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??0ImGuiTabBarSection@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTabBarSection@@QEAA@XZ PROC			; ImGuiTabBarSection::ImGuiTabBarSection, COMDAT

; 7523 :     ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx
	ret	0
??0ImGuiTabBarSection@@QEAA@XZ ENDP			; ImGuiTabBarSection::ImGuiTabBarSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemGetSectionIdx@@YAHPEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
tab$ = 8
?TabItemGetSectionIdx@@YAHPEBUImGuiTabItem@@@Z PROC	; TabItemGetSectionIdx, COMDAT

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rcx+4]
	test	al, 64					; 00000040H
	je	SHORT $LN3@TabItemGet
	xor	eax, eax

; 7547 : }

	ret	0
$LN3@TabItemGet:

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	eax

; 7547 : }

	ret	0
?TabItemGetSectionIdx@@YAHPEBUImGuiTabItem@@@Z ENDP	; TabItemGetSectionIdx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemComparerBySection@@YAHPEBX0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?TabItemComparerBySection@@YAHPEBX0@Z PROC		; TabItemComparerBySection, COMDAT

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rcx+4]

; 7550 : {

	mov	r9, rcx

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN6@TabItemCom
	xor	eax, eax
	mov	r8d, eax
	jmp	SHORT $LN7@TabItemCom
$LN6@TabItemCom:
	test	al, 128					; 00000080H
	mov	eax, 0
	mov	r8d, eax
	setne	r8b
	inc	r8d
$LN7@TabItemCom:
	mov	ecx, DWORD PTR [rdx+4]
	test	cl, 64					; 00000040H
	jne	SHORT $LN11@TabItemCom
	test	cl, 128					; 00000080H
	setne	al
	inc	eax
$LN11@TabItemCom:

; 7551 :     const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
; 7552 :     const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
; 7553 :     const int a_section = TabItemGetSectionIdx(a);
; 7554 :     const int b_section = TabItemGetSectionIdx(b);
; 7555 :     if (a_section != b_section)

	cmp	r8d, eax
	je	SHORT $LN2@TabItemCom

; 7556 :         return a_section - b_section;

	sub	r8d, eax
	mov	eax, r8d

; 7558 : }

	ret	0
$LN2@TabItemCom:

; 7557 :     return (int)(a->IndexDuringLayout - b->IndexDuringLayout);

	movsx	eax, WORD PTR [r9+46]
	movsx	ecx, WORD PTR [rdx+46]
	sub	eax, ecx

; 7558 : }

	ret	0
?TabItemComparerBySection@@YAHPEBX0@Z ENDP		; TabItemComparerBySection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemComparerByBeginOrder@@YAHPEBX0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
?TabItemComparerByBeginOrder@@YAHPEBX0@Z PROC		; TabItemComparerByBeginOrder, COMDAT

; 7562 :     const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
; 7563 :     const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
; 7564 :     return (int)(a->BeginOrder - b->BeginOrder);

	movsx	eax, WORD PTR [rcx+44]
	movsx	ecx, WORD PTR [rdx+44]
	sub	eax, ecx

; 7565 : }

	ret	0
?TabItemComparerByBeginOrder@@YAHPEBX0@Z ENDP		; TabItemComparerByBeginOrder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?GetTabBarFromTabBarRef@@YAPEAUImGuiTabBar@@AEBUImGuiPtrOrIndex@@@Z
_TEXT	SEGMENT
ref$ = 8
?GetTabBarFromTabBarRef@@YAPEAUImGuiTabBar@@AEBUImGuiPtrOrIndex@@@Z PROC ; GetTabBarFromTabBarRef, COMDAT

; 7569 :     ImGuiContext& g = *GImGui;
; 7570 :     return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	jne	SHORT $LN4@GetTabBarF
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rcx+8]
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	imul	rax, rax, 152				; 00000098H
	add	rax, QWORD PTR [rcx+19848]
$LN4@GetTabBarF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7571 : }

	ret	0
?GetTabBarFromTabBarRef@@YAPEAUImGuiTabBar@@AEBUImGuiPtrOrIndex@@@Z ENDP ; GetTabBarFromTabBarRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
tab_bar$ = 16
?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PEAUImGuiTabBar@@@Z PROC ; GetTabBarRefFromTabBar, COMDAT

; 7575 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 674  :     bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }

	mov	r10, QWORD PTR [r9+19848]
	cmp	rdx, r10
	jb	SHORT $LN6@GetTabBarR
	movsxd	rax, DWORD PTR [r9+19840]
	imul	r8, rax, 152				; 00000098H
	add	r8, r10
	cmp	rdx, r8
	jae	SHORT $LN6@GetTabBarR

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sub	rdx, r10

; 1271 :     ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }

	mov	QWORD PTR [rcx], 0

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	mov	rax, 485440633518672411			; 06bca1af286bca1bH
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7579 : }

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1271 :     ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }

	mov	DWORD PTR [rcx+8], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7579 : }

	ret	0
$LN6@GetTabBarR:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1270 :     ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }

	mov	QWORD PTR [rcx], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7579 : }

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1270 :     ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }

	mov	DWORD PTR [rcx+8], -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7579 : }

	ret	0
?GetTabBarRefFromTabBar@@YA?AUImGuiPtrOrIndex@@PEAUImGuiTabBar@@@Z ENDP ; GetTabBarRefFromTabBar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCalcScrollableWidth@@YAMPEAUImGuiTabBar@@PEAUImGuiTabBarSection@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
sections$ = 16
?TabBarCalcScrollableWidth@@YAMPEAUImGuiTabBar@@PEAUImGuiTabBarSection@@@Z PROC ; TabBarCalcScrollableWidth, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [rcx+52]
	subss	xmm0, DWORD PTR [rcx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm0, DWORD PTR [rdx+4]
	subss	xmm0, DWORD PTR [rdx+28]
	subss	xmm0, DWORD PTR [rdx+20]

; 7706 : }

	ret	0
?TabBarCalcScrollableWidth@@YAMPEAUImGuiTabBar@@PEAUImGuiTabBarSection@@@Z ENDP ; TabBarCalcScrollableWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tv5522 = 32
most_recently_selected_tab$1$ = 40
$T1 = 40
shrink_buffer_indexes$ = 48
$T2 = 64
sections$ = 72
__$ArrayPad$ = 112
tab_bar$ = 256
?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z PROC	; ImGui::TabBarLayout, COMDAT

; 7711 : {

	mov	r11, rsp
	push	rbp
	push	rbx
	push	rsi
	push	r13
	push	r15
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 208				; 000000d0H
	movaps	XMMWORD PTR [r11-72], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-153], rax

; 7712 :     ImGuiContext& g = *GImGui;

	mov	r13, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 7523 :     ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }

	xor	eax, eax

; 7711 : {

	mov	QWORD PTR [r11+16], rdi

; 7713 :     tab_bar->WantLayout = false;
; 7714 : 
; 7715 :     // Garbage collect by compacting list
; 7716 :     // Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
; 7717 :     int tab_dst_n = 0;

	xor	r15d, r15d
	mov	QWORD PTR [r11+24], r12

; 7718 :     bool need_sort_by_section = false;

	xor	sil, sil
	mov	QWORD PTR [r11+32], r14
	mov	rbx, rcx

; 7523 :     ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR sections$[rbp-153], rax

; 7713 :     tab_bar->WantLayout = false;
; 7714 : 
; 7715 :     // Garbage collect by compacting list
; 7716 :     // Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
; 7717 :     int tab_dst_n = 0;

	mov	edi, r15d

; 7523 :     ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }

	mov	DWORD PTR sections$[rbp-145], eax

; 7719 :     ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
; 7720 :     for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)

	lea	r14d, QWORD PTR [r15+1]

; 7523 :     ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR sections$[rbp-141], rax
	mov	DWORD PTR sections$[rbp-133], eax
	mov	QWORD PTR sections$[rbp-129], rax
	mov	DWORD PTR sections$[rbp-121], eax

; 7719 :     ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
; 7720 :     for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)

	mov	eax, DWORD PTR [rcx]
	movaps	XMMWORD PTR [r11-56], xmm6
	mov	r11d, r15d
	mov	BYTE PTR [rcx+107], 0
	test	eax, eax
	jle	$LN479@TabBarLayo
	mov	edx, r15d
	npad	5
$LL4@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7723 :         if (tab->LastFrameVisible < tab_bar->PrevFrameVisible || tab->WantClose)

	mov	eax, DWORD PTR [rbx+40]
	cmp	DWORD PTR [rcx+rdx+16], eax
	jl	$LN448@TabBarLayo
	cmp	BYTE PTR [rcx+rdx+48], r15b
	jne	$LN448@TabBarLayo

; 7729 :             continue;
; 7730 :         }
; 7731 :         if (tab_dst_n != tab_src_n)

	movsxd	r8, edi
	cmp	edi, r11d
	je	SHORT $LN449@TabBarLayo

; 7732 :             tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

	movups	xmm1, XMMWORD PTR [rcx+rdx]
	movups	xmm2, XMMWORD PTR [rcx+rdx+16]
	movups	xmm3, XMMWORD PTR [rcx+rdx+32]
	movsd	xmm0, QWORD PTR [rcx+rdx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rax, r8, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7732 :             tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];

	movups	XMMWORD PTR [rax+rcx], xmm1
	movups	XMMWORD PTR [rax+rcx+16], xmm2
	movups	XMMWORD PTR [rax+rcx+32], xmm3
	movsd	QWORD PTR [rax+rcx+48], xmm0
$LN449@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	ecx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	r10, r8, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	r8, r15
	mov	r9d, DWORD PTR [r10+rax+4]

; 7733 : 
; 7734 :         tab = &tab_bar->Tabs[tab_dst_n];
; 7735 :         tab->IndexDuringLayout = (ImS16)tab_dst_n;

	mov	WORD PTR [r10+rax+46], di

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	r9b, 64					; 00000040H
	jne	SHORT $LN355@TabBarLayo
	bt	r9d, 7
	setb	cl
	inc	ecx
	bt	r9d, 7
	setb	r8b
	inc	r8
$LN355@TabBarLayo:

; 7736 : 
; 7737 :         // We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)
; 7738 :         int curr_tab_section_n = TabItemGetSectionIdx(tab);
; 7739 :         if (tab_dst_n > 0)

	test	edi, edi
	jle	SHORT $LN28@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	rax, QWORD PTR [rbx+8]
	mov	r9d, DWORD PTR [r10+rax-52]
	mov	eax, r15d
	test	r9b, 64					; 00000040H
	jne	SHORT $LN369@TabBarLayo
	test	r9b, 128				; 00000080H
	setne	al
	inc	eax
$LN369@TabBarLayo:

; 7740 :         {
; 7741 :             ImGuiTabItem* prev_tab = &tab_bar->Tabs[tab_dst_n - 1];
; 7742 :             int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);
; 7743 :             if (curr_tab_section_n == 0 && prev_tab_section_n != 0)

	test	ecx, ecx
	jne	SHORT $LN27@TabBarLayo
	test	eax, eax
	je	SHORT $LN28@TabBarLayo

; 7744 :                 need_sort_by_section = true;

	movzx	esi, r14b
$LN27@TabBarLayo:

; 7745 :             if (prev_tab_section_n == 2 && curr_tab_section_n != 2)

	cmp	eax, 2
	jne	SHORT $LN28@TabBarLayo
	cmp	ecx, eax
	movzx	esi, sil
	cmovne	esi, r14d
$LN28@TabBarLayo:

; 7746 :                 need_sort_by_section = true;
; 7747 :         }
; 7748 : 
; 7749 :         sections[curr_tab_section_n].TabCount++;

	lea	rax, QWORD PTR [r8+r8*2]
	inc	DWORD PTR sections$[rbp+rax*4-153]

; 7750 :         tab_dst_n++;

	inc	edi

; 7751 :     }

	jmp	SHORT $LN2@TabBarLayo
$LN448@TabBarLayo:

; 7724 :         {
; 7725 :             // Remove tab
; 7726 :             if (tab_bar->VisibleTabId == tab->ID) { tab_bar->VisibleTabId = 0; }

	mov	eax, DWORD PTR [rcx+rdx]
	cmp	DWORD PTR [rbx+32], eax
	jne	SHORT $LN22@TabBarLayo
	mov	DWORD PTR [rbx+32], r15d
$LN22@TabBarLayo:

; 7727 :             if (tab_bar->SelectedTabId == tab->ID) { tab_bar->SelectedTabId = 0; }

	mov	eax, DWORD PTR [rcx+rdx]
	cmp	DWORD PTR [rbx+24], eax
	jne	SHORT $LN23@TabBarLayo
	mov	DWORD PTR [rbx+24], r15d
$LN23@TabBarLayo:

; 7728 :             if (tab_bar->NextSelectedTabId == tab->ID) { tab_bar->NextSelectedTabId = 0; }

	mov	eax, DWORD PTR [rcx+rdx]
	cmp	DWORD PTR [rbx+28], eax
	jne	SHORT $LN2@TabBarLayo
	mov	DWORD PTR [rbx+28], r15d
$LN2@TabBarLayo:

; 7719 :     ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
; 7720 :     for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)

	mov	eax, DWORD PTR [rbx]
	inc	r11d
	add	rdx, 56					; 00000038H
	cmp	r11d, eax
	jl	$LL4@TabBarLayo
$LN479@TabBarLayo:

; 7752 :     if (tab_bar->Tabs.Size != tab_dst_n)

	mov	r14d, 8
	cmp	eax, edi
	je	SHORT $LN29@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+4]
	cmp	edi, ecx
	jle	SHORT $LN308@TabBarLayo

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN312@TabBarLayo
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN313@TabBarLayo
$LN312@TabBarLayo:
	mov	eax, r14d
$LN313@TabBarLayo:
	cmp	eax, edi
	mov	edx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN308@TabBarLayo:
	mov	DWORD PTR [rbx], edi
	mov	eax, edi
$LN29@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7755 :     if (need_sort_by_section)

	test	sil, sil
	je	SHORT $LN350@TabBarLayo

; 7756 :         ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerBySection);

	movsxd	rdx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 349  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

	cmp	rdx, 1
	jbe	SHORT $LN350@TabBarLayo
	mov	rcx, QWORD PTR [rbx+8]
	lea	r9, OFFSET FLAT:?TabItemComparerBySection@@YAHPEBX0@Z ; TabItemComparerBySection
	mov	r8d, 56					; 00000038H
	call	QWORD PTR __imp_qsort
$LN350@TabBarLayo:
	xorps	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7759 :     sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount + sections[2].TabCount) > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;

	cmp	DWORD PTR sections$[rbp-153], r15d
	jle	SHORT $LN450@TabBarLayo
	mov	ecx, DWORD PTR sections$[rbp-129]
	add	ecx, DWORD PTR sections$[rbp-141]
	test	ecx, ecx
	jle	SHORT $LN450@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN61@TabBarLayo
$LN450@TabBarLayo:
	xorps	xmm0, xmm0
$LN61@TabBarLayo:
	movss	DWORD PTR sections$[rbp-145], xmm0

; 7760 :     sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0 ? g.Style.ItemInnerSpacing.x : 0.0f;

	cmp	DWORD PTR sections$[rbp-141], r15d
	jle	SHORT $LN451@TabBarLayo
	cmp	DWORD PTR sections$[rbp-129], r15d
	jle	SHORT $LN451@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN63@TabBarLayo
$LN451@TabBarLayo:
	xorps	xmm0, xmm0
$LN63@TabBarLayo:

; 7761 : 
; 7762 :     // Setup next selected tab
; 7763 :     ImGuiID scroll_to_tab_id = 0;
; 7764 :     if (tab_bar->NextSelectedTabId)

	mov	eax, DWORD PTR [rbx+28]
	mov	r12d, r15d
	movss	DWORD PTR sections$[rbp-133], xmm0
	test	eax, eax
	je	SHORT $LN480@TabBarLayo

; 7765 :     {
; 7766 :         tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;

	mov	r12d, eax
	mov	DWORD PTR [rbx+24], eax

; 7767 :         tab_bar->NextSelectedTabId = 0;

	mov	DWORD PTR [rbx+28], r15d
$LN480@TabBarLayo:

; 7769 :     }
; 7770 : 
; 7771 :     // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
; 7772 :     if (tab_bar->ReorderRequestTabId != 0)

	mov	edx, DWORD PTR [rbx+100]
	test	edx, edx
	je	$LN32@TabBarLayo

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	r8d, DWORD PTR [rbx]
	mov	eax, r15d
	test	r8d, r8d
	jle	$LN34@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [rbx+8]
	mov	rcx, r10
$LL332@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rcx], edx
	je	SHORT $LN386@TabBarLayo

; 7955 : 
; 7956 : // Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.
; 7957 : static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window)
; 7958 : {
; 7959 :     if (docked_window != NULL)
; 7960 :     {
; 7961 :         IM_UNUSED(tab_bar);
; 7962 :         IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
; 7963 :         ImGuiID id = docked_window->TabId;
; 7964 :         KeepAliveID(id);
; 7965 :         return id;
; 7966 :     }
; 7967 :     else
; 7968 :     {
; 7969 :         ImGuiWindow* window = GImGui->CurrentWindow;
; 7970 :         return window->GetID(label);
; 7971 :     }
; 7972 : }
; 7973 : 
; 7974 : static float ImGui::TabBarCalcMaxTabWidth()
; 7975 : {
; 7976 :     ImGuiContext& g = *GImGui;
; 7977 :     return g.FontSize * 20.0f;
; 7978 : }
; 7979 : 
; 7980 : ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
; 7981 : {
; 7982 :     if (tab_id != 0)
; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	rcx, 56					; 00000038H
	cmp	eax, r8d
	jl	SHORT $LL332@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7833 :         if (window == potential_parent)

	jmp	$LN34@TabBarLayo
$LN386@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	r9, rax, 56				; 00000038H
	add	r9, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8176 :     if (tab1 == NULL || (tab1->Flags & ImGuiTabItemFlags_NoReorder))

	je	$LN34@TabBarLayo
	mov	r11d, DWORD PTR [r9+4]
	test	r11b, 32				; 00000020H
	jne	$LN34@TabBarLayo

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	movsx	esi, WORD PTR [rbx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, r9
	mov	rdi, QWORD PTR [rbx+8]
	mov	rax, 5270498306774157605		; 4924924924924925H
	sub	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	mov	r10d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	add	edx, esi

; 8181 :     if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)

	js	$LN34@TabBarLayo
	cmp	edx, r8d
	jge	$LN34@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rcx, rax, 56				; 00000038H
	add	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8187 :     if (tab2->Flags & ImGuiTabItemFlags_NoReorder)

	mov	eax, DWORD PTR [rdi+4]
	test	al, 32					; 00000020H
	jne	$LN34@TabBarLayo

; 8188 :         return false;
; 8189 :     if ((tab1->Flags & ImGuiTabItemFlags_SectionMask_) != (tab2->Flags & ImGuiTabItemFlags_SectionMask_))

	xor	eax, r11d
	test	al, 192					; 000000c0H
	jne	$LN34@TabBarLayo

; 8190 :         return false;
; 8191 : 
; 8192 :     ImGuiTabItem item_tmp = *tab1;

	movups	xmm7, XMMWORD PTR [r9]

; 8193 :     ImGuiTabItem* src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;
; 8194 :     ImGuiTabItem* dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;

	lea	rdx, QWORD PTR [r9+56]
	test	si, si
	movaps	XMMWORD PTR [rsp+160], xmm8

; 8195 :     const int move_count = (tab_bar->ReorderRequestOffset > 0) ? tab_bar->ReorderRequestOffset : -tab_bar->ReorderRequestOffset;

	lea	rax, QWORD PTR [rdi+56]
	movups	xmm8, XMMWORD PTR [r9+16]
	cmovle	rdx, rdi
	movaps	XMMWORD PTR [rsp+144], xmm9
	movups	xmm9, XMMWORD PTR [r9+32]
	movaps	XMMWORD PTR [rsp+128], xmm10
	movsd	xmm10, QWORD PTR [r9+48]
	cmovle	r9, rax
	jg	SHORT $LN328@TabBarLayo
	neg	r10d
$LN328@TabBarLayo:

; 8196 :     memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));

	movsxd	rax, r10d
	mov	rcx, r9
	imul	r8, rax, 56				; 00000038H
	call	memmove

; 8197 :     *tab2 = item_tmp;

	movups	XMMWORD PTR [rdi], xmm7
	movups	XMMWORD PTR [rdi+16], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+160]
	movups	XMMWORD PTR [rdi+32], xmm9
	movaps	xmm9, XMMWORD PTR [rsp+144]
	movsd	QWORD PTR [rdi+48], xmm10

; 8198 : 
; 8199 :     if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)

	test	DWORD PTR [rbx+16], 4194304		; 00400000H
	movaps	xmm10, XMMWORD PTR [rsp+128]
	je	SHORT $LN472@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13620:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 13621:     if (g.SettingsDirtyTimer <= 0.0f)

	comiss	xmm6, DWORD PTR [rcx+24092]
	jb	SHORT $LN472@TabBarLayo

; 13622:         g.SettingsDirtyTimer = g.IO.IniSavingRate;

	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [rcx+24092], eax
$LN472@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7775 :             if (tab_bar->ReorderRequestTabId == tab_bar->SelectedTabId)

	mov	eax, DWORD PTR [rbx+100]
	cmp	eax, DWORD PTR [rbx+24]
	cmove	r12d, eax
$LN34@TabBarLayo:

; 7776 :                 scroll_to_tab_id = tab_bar->ReorderRequestTabId;
; 7777 :         tab_bar->ReorderRequestTabId = 0;

	mov	DWORD PTR [rbx+100], r15d
$LN32@TabBarLayo:

; 7778 :     }
; 7779 : 
; 7780 :     // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
; 7781 :     const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;

	mov	eax, DWORD PTR [rbx+16]
	shr	eax, 2
	test	al, 1

; 7782 :     if (tab_list_popup_button)

	je	SHORT $LN491@TabBarLayo

; 7783 :         if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!

	mov	rcx, rbx
	call	?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ; ImGui::TabBarTabListPopupButton
	test	rax, rax
	je	SHORT $LN491@TabBarLayo

; 7784 :             scroll_to_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;

	mov	r12d, DWORD PTR [rax]
	mov	DWORD PTR [rbx+24], r12d
$LN491@TabBarLayo:

; 7788 :     int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };

	mov	edx, DWORD PTR sections$[rbp-153]
	mov	ecx, DWORD PTR sections$[rbp-129]

; 7789 :     g.ShrinkWidthBuffer.resize(tab_bar->Tabs.Size);

	mov	esi, DWORD PTR [rbx]
	add	ecx, edx
	mov	DWORD PTR shrink_buffer_indexes$[rbp-149], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [r13+19900]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7788 :     int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };

	mov	DWORD PTR shrink_buffer_indexes$[rbp-153], r15d
	mov	DWORD PTR shrink_buffer_indexes$[rbp-145], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	esi, ecx
	jle	$LN288@TabBarLayo

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN286@TabBarLayo
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	r14d, DWORD PTR [rcx+rax]
$LN286@TabBarLayo:
	cmp	r14d, esi
	mov	edi, esi
	cmovg	edi, r14d

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN288@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN293@TabBarLayo

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN293@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, edi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN303@TabBarLayo
	movsxd	rcx, DWORD PTR [r13+19896]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 2
	call	memcpy
	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN301@TabBarLayo

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN301@TabBarLayo

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN301@TabBarLayo:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN303@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [r13+19904], r14
	mov	DWORD PTR [r13+19900], edi
$LN288@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7795 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	movss	xmm7, DWORD PTR __real@3f800000
	xor	dl, dl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [r13+19896], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7792 :     ImGuiTabItem* most_recently_selected_tab = NULL;

	mov	rcx, r15

; 7795 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	eax, DWORD PTR [rbx]
	mov	r14d, -1
	mov	QWORD PTR most_recently_selected_tab$1$[rbp-153], rcx
	mov	DWORD PTR tv5522[rbp-153], edx
	test	eax, eax
	jle	$LN6@TabBarLayo

; 7768 :         scroll_to_tab_id = tab_bar->SelectedTabId;

	xor	esi, esi
	npad	3
$LL7@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rdi, QWORD PTR [rbx+8]
	add	rdi, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7800 :         if ((most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected) && !(tab->Flags & ImGuiTabItemFlags_Button))

	test	rcx, rcx
	je	SHORT $LN38@TabBarLayo
	mov	eax, DWORD PTR [rdi+20]
	cmp	DWORD PTR [rcx+20], eax
	jge	SHORT $LN37@TabBarLayo
$LN38@TabBarLayo:
	test	DWORD PTR [rdi+4], 2097152		; 00200000H
	cmove	rcx, rdi
	mov	QWORD PTR most_recently_selected_tab$1$[rbp-153], rcx
$LN37@TabBarLayo:

; 7801 :             most_recently_selected_tab = tab;
; 7802 :         if (tab->ID == tab_bar->SelectedTabId)

	mov	eax, DWORD PTR [rdi]
	mov	ecx, 1
	cmp	eax, DWORD PTR [rbx+24]
	movzx	edx, dl
	cmove	edx, ecx
	mov	DWORD PTR tv5522[rbp-153], edx

; 7803 :             found_selected_tab_id = true;
; 7804 :         if (scroll_to_tab_id == 0 && g.NavJustMovedToId == tab->ID)

	test	r12d, r12d
	jne	SHORT $LN40@TabBarLayo
	cmp	DWORD PTR [r13+19128], eax
	cmove	r12d, eax
$LN40@TabBarLayo:

; 8020 :     if (tab->Window)

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN250@TabBarLayo

; 8021 :         return tab->Window->Name;

	mov	rdx, QWORD PTR [rdx+8]
	jmp	SHORT $LN249@TabBarLayo
$LN250@TabBarLayo:

; 8022 :     if (tab->NameOffset == -1)

	movsxd	rax, DWORD PTR [rdi+40]
	cmp	eax, -1
	jne	SHORT $LN251@TabBarLayo

; 8023 :         return "N/A";

	lea	rdx, OFFSET FLAT:??_C@_03HPADHAHE@N?1A@
	jmp	SHORT $LN249@TabBarLayo
$LN251@TabBarLayo:

; 8024 :     IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
; 8025 :     return tab_bar->TabsNames.Buf.Data + tab->NameOffset;

	mov	rdx, rax
	add	rdx, QWORD PTR [rbx+144]
$LN249@TabBarLayo:
	mov	eax, DWORD PTR [rdi+4]

; 7805 :             scroll_to_tab_id = tab->ID;
; 7806 : 
; 7807 :         // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
; 7808 :         // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
; 7809 :         // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
; 7810 :         const char* tab_name = TabBarGetTabName(tab_bar, tab);
; 7811 :         const bool has_close_button_or_unsaved_marker = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) == 0 || (tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
; 7812 :         tab->ContentWidth = (tab->RequestedWidth >= 0.0f) ? tab->RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;

	movss	xmm1, DWORD PTR [rdi+36]
	and	eax, 1048577				; 00100001H
	cmp	eax, 1048576				; 00100000H
	setne	r8b
	comiss	xmm1, xmm6
	jae	SHORT $LN67@TabBarLayo
	lea	rcx, QWORD PTR $T2[rbp-153]
	call	?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ; ImGui::TabItemCalcSize
	movss	xmm1, DWORD PTR [rax]
$LN67@TabBarLayo:

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdi+4]

; 7805 :             scroll_to_tab_id = tab->ID;
; 7806 : 
; 7807 :         // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
; 7808 :         // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
; 7809 :         // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
; 7810 :         const char* tab_name = TabBarGetTabName(tab_bar, tab);
; 7811 :         const bool has_close_button_or_unsaved_marker = (tab->Flags & ImGuiTabItemFlags_NoCloseButton) == 0 || (tab->Flags & ImGuiTabItemFlags_UnsavedDocument);
; 7812 :         tab->ContentWidth = (tab->RequestedWidth >= 0.0f) ? tab->RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x;

	movss	DWORD PTR [rdi+32], xmm1

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN255@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN256@TabBarLayo
$LN255@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	eax
$LN256@TabBarLayo:

; 7813 : 
; 7814 :         int section_n = TabItemGetSectionIdx(tab);
; 7815 :         ImGuiTabBarSection* section = &sections[section_n];

	mov	edx, eax
	lea	rcx, QWORD PTR [rax+rax*2]

; 7816 :         section->Width += tab->ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);

	cmp	eax, r14d
	jne	SHORT $LN68@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN69@TabBarLayo
$LN68@TabBarLayo:
	movaps	xmm0, xmm6
$LN69@TabBarLayo:
	addss	xmm0, xmm1

; 7817 :         curr_section_n = section_n;

	mov	r14d, eax
	add	rsi, 56					; 00000038H
	addss	xmm0, DWORD PTR sections$[rbp+rcx*4-149]
	movss	DWORD PTR sections$[rbp+rcx*4-149], xmm0

; 7821 :         ImGuiShrinkWidthItem* shrink_width_item = &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];

	movsxd	rcx, DWORD PTR shrink_buffer_indexes$[rbp+rax*4-153]
	lea	eax, DWORD PTR [rcx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rcx, QWORD PTR [rcx+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7821 :         ImGuiShrinkWidthItem* shrink_width_item = &g.ShrinkWidthBuffer[shrink_buffer_indexes[section_n]++];

	mov	DWORD PTR shrink_buffer_indexes$[rbp+rdx*4-153], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7795 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	edx, DWORD PTR tv5522[rbp-153]

; 7822 :         shrink_width_item->Index = tab_n;

	mov	DWORD PTR [rax+rcx*4], r15d
	inc	r15d

; 7823 :         shrink_width_item->Width = shrink_width_item->InitialWidth = tab->ContentWidth;

	movss	xmm0, DWORD PTR [rdi+32]
	movss	DWORD PTR [rax+rcx*4+8], xmm0
	movss	DWORD PTR [rax+rcx*4+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7795 :     for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	rcx, QWORD PTR most_recently_selected_tab$1$[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7824 :         tab->Width = ImMax(tab->ContentWidth, 1.0f);

	movss	DWORD PTR [rdi+28], xmm1
	mov	eax, DWORD PTR [rbx]
	cmp	r15d, eax
	jl	$LL7@TabBarLayo
$LN6@TabBarLayo:

; 7825 :     }
; 7826 : 
; 7827 :     // Compute total ideal width (used for e.g. auto-resizing a window)
; 7828 :     tab_bar->WidthAllTabsIdeal = 0.0f;
; 7829 :     for (int section_n = 0; section_n < 3; section_n++)
; 7830 :         tab_bar->WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing;

	movss	xmm0, DWORD PTR sections$[rbp-137]

; 7834 :     if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll))

	lea	r15, QWORD PTR [rbx+44]
	addss	xmm0, DWORD PTR sections$[rbp-133]
	movss	xmm2, DWORD PTR sections$[rbp-149]
	addss	xmm2, DWORD PTR sections$[rbp-145]
	movss	xmm1, DWORD PTR sections$[rbp-125]
	addss	xmm1, DWORD PTR sections$[rbp-121]
	addss	xmm2, xmm6
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR [rbx+72], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [r15+8]
	subss	xmm0, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7834 :     if ((tab_bar->WidthAllTabsIdeal > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll))

	comiss	xmm2, xmm0
	jbe	SHORT $LN492@TabBarLayo
	cmp	eax, 1
	jle	SHORT $LN492@TabBarLayo
	mov	eax, DWORD PTR [rbx+16]
	test	al, 16
	jne	SHORT $LN492@TabBarLayo
	test	al, al
	jns	SHORT $LN492@TabBarLayo

; 7835 :         if (ImGuiTabItem* scroll_and_select_tab = TabBarScrollingButtons(tab_bar))

	mov	rcx, rbx
	call	?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ; ImGui::TabBarScrollingButtons
	test	rax, rax
	je	SHORT $LN492@TabBarLayo

; 7836 :         {
; 7837 :             scroll_to_tab_id = scroll_and_select_tab->ID;
; 7838 :             if ((scroll_and_select_tab->Flags & ImGuiTabItemFlags_Button) == 0)

	test	DWORD PTR [rax+4], 2097152		; 00200000H
	mov	r12d, DWORD PTR [rax]
	jne	SHORT $LN492@TabBarLayo

; 7839 :                 tab_bar->SelectedTabId = scroll_to_tab_id;

	mov	DWORD PTR [rbx+24], r12d
$LN492@TabBarLayo:

; 7840 :         }
; 7841 : 
; 7842 :     // Shrink widths if full tabs don't fit in their allocated space
; 7843 :     float section_0_w = sections[0].Width + sections[0].Spacing;
; 7844 :     float section_1_w = sections[1].Width + sections[1].Spacing;
; 7845 :     float section_2_w = sections[2].Width + sections[2].Spacing;

	movss	xmm3, DWORD PTR sections$[rbp-125]
	addss	xmm3, DWORD PTR sections$[rbp-121]
	movss	xmm1, DWORD PTR sections$[rbp-149]
	addss	xmm1, DWORD PTR sections$[rbp-145]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [r15+8]
	subss	xmm0, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7846 :     bool central_section_is_visible = (section_0_w + section_2_w) < tab_bar->BarRect.GetWidth();

	movaps	xmm2, xmm3
	addss	xmm2, xmm1
	comiss	xmm0, xmm2
	seta	dl

; 7847 :     float width_excess;
; 7848 :     if (central_section_is_visible)

	test	dl, dl
	je	SHORT $LN44@TabBarLayo

; 7849 :         width_excess = ImMax(section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section

	movss	xmm2, DWORD PTR sections$[rbp-137]
	subss	xmm0, xmm1
	addss	xmm2, DWORD PTR sections$[rbp-133]
	subss	xmm0, xmm3
	subss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7849 :         width_excess = ImMax(section_1_w - (tab_bar->BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section

	jmp	SHORT $LN45@TabBarLayo
$LN44@TabBarLayo:

; 7850 :     else
; 7851 :         width_excess = (section_0_w + section_2_w) - tab_bar->BarRect.GetWidth(); // Excess used to shrink leading/trailing section

	subss	xmm2, xmm0
$LN45@TabBarLayo:

; 7852 : 
; 7853 :     // With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore
; 7854 :     if (width_excess >= 1.0f && ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown) || !central_section_is_visible))

	comiss	xmm2, xmm7
	jb	$LN433@TabBarLayo
	test	BYTE PTR [rbx+16], 64			; 00000040H
	jne	SHORT $LN47@TabBarLayo
	test	dl, dl
	jne	$LN433@TabBarLayo
$LN70@TabBarLayo:

; 7855 :     {
; 7856 :         int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);

	mov	esi, DWORD PTR sections$[rbp-129]
	add	esi, DWORD PTR sections$[rbp-153]

; 7857 :         int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);

	test	dl, dl
	je	SHORT $LN72@TabBarLayo
	mov	r14d, DWORD PTR sections$[rbp-129]
	add	r14d, DWORD PTR sections$[rbp-153]
	jmp	SHORT $LN73@TabBarLayo
$LN47@TabBarLayo:

; 7855 :     {
; 7856 :         int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);

	test	dl, dl
	je	SHORT $LN70@TabBarLayo

; 7857 :         int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);

	mov	r14d, DWORD PTR sections$[rbp-129]
	add	r14d, DWORD PTR sections$[rbp-153]
	mov	esi, DWORD PTR sections$[rbp-141]
	jmp	SHORT $LN73@TabBarLayo
$LN72@TabBarLayo:
	xor	r14d, r14d
$LN73@TabBarLayo:

; 7858 :         ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset, shrink_data_count, width_excess);

	mov	rcx, QWORD PTR [r13+19904]
	mov	edx, esi
	movsxd	r15, r14d
	lea	rax, QWORD PTR [r15+r15*2]
	lea	rdi, QWORD PTR [rax*4]
	add	rcx, rdi
	call	?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z ; ImGui::ShrinkWidths

; 7859 : 
; 7860 :         // Apply shrunk values into tabs and sections
; 7861 :         for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)

	lea	eax, DWORD PTR [r14+rsi]
	movsxd	r9, eax
	cmp	r15, r9
	jge	$LN493@TabBarLayo
	mov	rax, r9
	sub	rax, r15
	cmp	rax, 4
	jl	$LN487@TabBarLayo

; 7768 :         scroll_to_tab_id = tab_bar->SelectedTabId;

	mov	r8, r9
	sub	r8, r15
	sub	r8, 4
	shr	r8, 2
	inc	r8
	lea	r15, QWORD PTR [r15+r8*4]
	npad	8

; 7859 : 
; 7860 :         // Apply shrunk values into tabs and sections
; 7861 :         for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)

$LL447@TabBarLayo:

; 7862 :         {
; 7863 :             ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];

	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rdi+rcx]
	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvttss2si eax, DWORD PTR [rdi+rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	add	rdx, QWORD PTR [rbx+8]
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvtdq2ps xmm0, xmm0

; 7865 :             if (shrinked_width < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN437@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm7
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN435@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN436@TabBarLayo
$LN435@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	rax
$LN436@TabBarLayo:

; 7866 :                 continue;
; 7867 : 
; 7868 :             shrinked_width = ImMax(1.0f, shrinked_width);
; 7869 :             int section_n = TabItemGetSectionIdx(tab);
; 7870 :             sections[section_n].Width -= (tab->Width - shrinked_width);

	movss	xmm1, DWORD PTR [rdx+28]
	lea	rax, QWORD PTR [rax+rax*2]
	movss	xmm0, DWORD PTR sections$[rbp+rax*4-149]
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR sections$[rbp+rax*4-149], xmm0

; 7871 :             tab->Width = shrinked_width;

	movss	DWORD PTR [rdx+28], xmm2
$LN437@TabBarLayo:

; 7862 :         {
; 7863 :             ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];

	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rdi+rcx+12]
	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvttss2si eax, DWORD PTR [rdi+rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	add	rdx, QWORD PTR [rbx+8]
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvtdq2ps xmm0, xmm0

; 7865 :             if (shrinked_width < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN440@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm7
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN438@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN439@TabBarLayo
$LN438@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	rax
$LN439@TabBarLayo:

; 7866 :                 continue;
; 7867 : 
; 7868 :             shrinked_width = ImMax(1.0f, shrinked_width);
; 7869 :             int section_n = TabItemGetSectionIdx(tab);
; 7870 :             sections[section_n].Width -= (tab->Width - shrinked_width);

	movss	xmm1, DWORD PTR [rdx+28]
	lea	rax, QWORD PTR [rax+rax*2]
	movss	xmm0, DWORD PTR sections$[rbp+rax*4-149]
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR sections$[rbp+rax*4-149], xmm0

; 7871 :             tab->Width = shrinked_width;

	movss	DWORD PTR [rdx+28], xmm2
$LN440@TabBarLayo:

; 7862 :         {
; 7863 :             ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];

	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rdi+rcx+24]
	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvttss2si eax, DWORD PTR [rdi+rcx+28]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	add	rdx, QWORD PTR [rbx+8]
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvtdq2ps xmm0, xmm0

; 7865 :             if (shrinked_width < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN443@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm7
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN441@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN442@TabBarLayo
$LN441@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	rax
$LN442@TabBarLayo:

; 7866 :                 continue;
; 7867 : 
; 7868 :             shrinked_width = ImMax(1.0f, shrinked_width);
; 7869 :             int section_n = TabItemGetSectionIdx(tab);
; 7870 :             sections[section_n].Width -= (tab->Width - shrinked_width);

	movss	xmm1, DWORD PTR [rdx+28]
	lea	rax, QWORD PTR [rax+rax*2]
	movss	xmm0, DWORD PTR sections$[rbp+rax*4-149]
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR sections$[rbp+rax*4-149], xmm0

; 7871 :             tab->Width = shrinked_width;

	movss	DWORD PTR [rdx+28], xmm2
$LN443@TabBarLayo:

; 7862 :         {
; 7863 :             ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];

	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rdi+rcx+36]
	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvttss2si eax, DWORD PTR [rdi+rcx+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	add	rdx, QWORD PTR [rbx+8]
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvtdq2ps xmm0, xmm0

; 7865 :             if (shrinked_width < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN446@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm7
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN444@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN445@TabBarLayo
$LN444@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	rax
$LN445@TabBarLayo:

; 7866 :                 continue;
; 7867 : 
; 7868 :             shrinked_width = ImMax(1.0f, shrinked_width);
; 7869 :             int section_n = TabItemGetSectionIdx(tab);
; 7870 :             sections[section_n].Width -= (tab->Width - shrinked_width);

	movss	xmm1, DWORD PTR [rdx+28]
	lea	rax, QWORD PTR [rax+rax*2]
	movss	xmm0, DWORD PTR sections$[rbp+rax*4-149]
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR sections$[rbp+rax*4-149], xmm0

; 7871 :             tab->Width = shrinked_width;

	movss	DWORD PTR [rdx+28], xmm2
$LN446@TabBarLayo:
	add	rdi, 48					; 00000030H
	sub	r8, 1
	jne	$LL447@TabBarLayo

; 7859 : 
; 7860 :         // Apply shrunk values into tabs and sections
; 7861 :         for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)

	cmp	r15, r9
	jge	SHORT $LN493@TabBarLayo
$LN487@TabBarLayo:
	lea	r8, QWORD PTR [r15+r15*2]
	shl	r8, 2
	sub	r9, r15
$LC13@TabBarLayo:

; 7862 :         {
; 7863 :             ImGuiTabItem* tab = &tab_bar->Tabs[g.ShrinkWidthBuffer[tab_n].Index];

	mov	rcx, QWORD PTR [r13+19904]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [r8+rcx]
	imul	rdx, rax, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvttss2si eax, DWORD PTR [r8+rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	add	rdx, QWORD PTR [rbx+8]
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7864 :             float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);

	cvtdq2ps xmm0, xmm0

; 7865 :             if (shrinked_width < 0.0f)

	comiss	xmm6, xmm0
	ja	SHORT $LN11@TabBarLayo

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	mov	eax, DWORD PTR [rdx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm2, xmm7
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7546 :     return (tab->Flags & ImGuiTabItemFlags_Leading) ? 0 : (tab->Flags & ImGuiTabItemFlags_Trailing) ? 2 : 1;

	test	al, 64					; 00000040H
	je	SHORT $LN233@TabBarLayo
	xor	eax, eax
	jmp	SHORT $LN234@TabBarLayo
$LN233@TabBarLayo:
	test	al, 128					; 00000080H
	mov	eax, 0
	setne	al
	inc	rax
$LN234@TabBarLayo:

; 7866 :                 continue;
; 7867 : 
; 7868 :             shrinked_width = ImMax(1.0f, shrinked_width);
; 7869 :             int section_n = TabItemGetSectionIdx(tab);
; 7870 :             sections[section_n].Width -= (tab->Width - shrinked_width);

	movss	xmm1, DWORD PTR [rdx+28]
	lea	rax, QWORD PTR [rax+rax*2]
	movss	xmm0, DWORD PTR sections$[rbp+rax*4-149]
	subss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR sections$[rbp+rax*4-149], xmm0

; 7871 :             tab->Width = shrinked_width;

	movss	DWORD PTR [rdx+28], xmm2
$LN11@TabBarLayo:

; 7859 : 
; 7860 :         // Apply shrunk values into tabs and sections
; 7861 :         for (int tab_n = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n++)

	add	r8, 12
	sub	r9, 1
	jne	SHORT $LC13@TabBarLayo
$LN493@TabBarLayo:

; 7872 :         }
; 7873 :     }
; 7874 : 
; 7875 :     // Layout all active tabs
; 7876 :     int section_tab_index = 0;

	lea	r15, QWORD PTR [rbx+44]
$LN433@TabBarLayo:
	xor	edi, edi
	xor	r14d, r14d

; 7877 :     float tab_offset = 0.0f;
; 7878 :     tab_bar->WidthAllTabs = 0.0f;

	mov	DWORD PTR [rbx+68], edi
	xor	esi, esi
	movaps	xmm2, xmm6
	npad	5
$LL16@TabBarLayo:

; 7880 :     {
; 7881 :         ImGuiTabBarSection* section = &sections[section_n];

	lea	r10, QWORD PTR [rsi+rsi*2]
	lea	r11, QWORD PTR sections$[rbp-149]
	lea	r11, QWORD PTR [r11+r10*4]

; 7882 :         if (section_n == 2)

	cmp	rsi, 2
	jne	SHORT $LN484@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm1, DWORD PTR [r15+8]

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm6

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm1, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7883 :             tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);

	subss	xmm1, DWORD PTR [r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm2
	movaps	xmm2, xmm0
$LN484@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7885 :         for (int tab_n = 0; tab_n < section->TabCount; tab_n++)

	mov	r9d, DWORD PTR sections$[rbp+r10*4-153]
	xor	edx, edx
	test	r9d, r9d
	jle	SHORT $LN18@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movsxd	rax, edi
	imul	rcx, rax, 56				; 00000038H
$LL19@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7888 :             tab->Offset = tab_offset;

	movss	DWORD PTR [rcx+r8+24], xmm2

; 7889 :             tab->NameOffset = -1;

	mov	DWORD PTR [rcx+r8+40], -1

; 7890 :             tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);

	mov	r9d, DWORD PTR sections$[rbp+r10*4-153]
	lea	eax, DWORD PTR [r9-1]
	cmp	edx, eax
	jge	SHORT $LN74@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN75@TabBarLayo
$LN74@TabBarLayo:
	movaps	xmm0, xmm6
$LN75@TabBarLayo:
	addss	xmm0, DWORD PTR [rcx+r8+28]
	inc	edx
	add	rcx, 56					; 00000038H
	addss	xmm2, xmm0
	cmp	edx, r9d
	jl	SHORT $LL19@TabBarLayo
$LN18@TabBarLayo:

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	movss	xmm1, DWORD PTR sections$[rbp+r10*4-145]

; 7893 :         tab_offset += section->Spacing;
; 7894 :         section_tab_index += section->TabCount;

	add	edi, r9d
	addss	xmm2, xmm1
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	addss	xmm0, DWORD PTR [rbx+68]
	movss	DWORD PTR [rbx+68], xmm0
	cmp	r14d, 1
	jne	SHORT $LN482@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm1, DWORD PTR [r15+8]

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm6

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm1, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7883 :             tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);

	subss	xmm1, DWORD PTR sections$[rbp+r10*4-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm2
	movaps	xmm2, xmm0
$LN482@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7885 :         for (int tab_n = 0; tab_n < section->TabCount; tab_n++)

	mov	r9d, DWORD PTR sections$[rbp+r10*4-141]
	xor	edx, edx
	test	r9d, r9d
	jle	SHORT $LN414@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movsxd	rax, edi
	imul	rcx, rax, 56				; 00000038H
$LL411@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7888 :             tab->Offset = tab_offset;

	movss	DWORD PTR [rcx+r8+24], xmm2

; 7889 :             tab->NameOffset = -1;

	mov	DWORD PTR [rcx+r8+40], -1

; 7890 :             tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);

	mov	r9d, DWORD PTR sections$[rbp+r10*4-141]
	lea	eax, DWORD PTR [r9-1]
	cmp	edx, eax
	jge	SHORT $LN412@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN413@TabBarLayo
$LN412@TabBarLayo:
	movaps	xmm0, xmm6
$LN413@TabBarLayo:
	addss	xmm0, DWORD PTR [rcx+r8+28]
	inc	edx
	add	rcx, 56					; 00000038H
	addss	xmm2, xmm0
	cmp	edx, r9d
	jl	SHORT $LL411@TabBarLayo
$LN414@TabBarLayo:

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	movss	xmm1, DWORD PTR sections$[rbp+r10*4-133]

; 7893 :         tab_offset += section->Spacing;
; 7894 :         section_tab_index += section->TabCount;

	add	edi, r9d
	addss	xmm2, xmm1
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR sections$[rbp+r10*4-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	addss	xmm0, DWORD PTR [rbx+68]
	movss	DWORD PTR [rbx+68], xmm0
	test	r14d, r14d
	jne	SHORT $LN483@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm1, DWORD PTR [r15+8]

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movaps	xmm0, xmm6

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm1, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7883 :             tab_offset = ImMin(ImMax(0.0f, tab_bar->BarRect.GetWidth() - section->Width), tab_offset);

	subss	xmm1, DWORD PTR sections$[rbp+r10*4-125]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm2
	movaps	xmm2, xmm0
$LN483@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7885 :         for (int tab_n = 0; tab_n < section->TabCount; tab_n++)

	mov	r9d, DWORD PTR sections$[rbp+r10*4-129]
	xor	edx, edx
	test	r9d, r9d
	jle	SHORT $LN420@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movsxd	rax, edi
	imul	rcx, rax, 56				; 00000038H
	npad	8
$LL417@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7888 :             tab->Offset = tab_offset;

	movss	DWORD PTR [rcx+r8+24], xmm2

; 7889 :             tab->NameOffset = -1;

	mov	DWORD PTR [rcx+r8+40], -1

; 7890 :             tab_offset += tab->Width + (tab_n < section->TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);

	mov	r9d, DWORD PTR sections$[rbp+r10*4-129]
	lea	eax, DWORD PTR [r9-1]
	cmp	edx, eax
	jge	SHORT $LN418@TabBarLayo
	movss	xmm0, DWORD PTR [r13+14636]
	jmp	SHORT $LN419@TabBarLayo
$LN418@TabBarLayo:
	movaps	xmm0, xmm6
$LN419@TabBarLayo:
	addss	xmm0, DWORD PTR [rcx+r8+28]
	inc	edx
	add	rcx, 56					; 00000038H
	addss	xmm2, xmm0
	cmp	edx, r9d
	jl	SHORT $LL417@TabBarLayo
$LN420@TabBarLayo:

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	movss	xmm1, DWORD PTR sections$[rbp+r10*4-121]

; 7893 :         tab_offset += section->Spacing;
; 7894 :         section_tab_index += section->TabCount;

	add	edi, r9d
	movaps	xmm0, xmm1
	addss	xmm2, xmm1
	addss	xmm0, DWORD PTR sections$[rbp+r10*4-125]
	add	r14d, 3
	add	rsi, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7892 :         tab_bar->WidthAllTabs += ImMax(section->Width + section->Spacing, 0.0f);

	addss	xmm0, DWORD PTR [rbx+68]
	movss	DWORD PTR [rbx+68], xmm0
	cmp	rsi, 3
	jl	$LL16@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+140]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7879 :     for (int section_n = 0; section_n < 3; section_n++)

	mov	r14, QWORD PTR [rsp+280]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ecx, ecx
	jns	SHORT $LN89@TabBarLayo

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [rbx+136]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN89@TabBarLayo:
	xor	esi, esi
	mov	DWORD PTR [rbx+136], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7901 :     if (found_selected_tab_id == false)

	cmp	BYTE PTR tv5522[rbp-153], sil
	jne	SHORT $LN485@TabBarLayo

; 7902 :         tab_bar->SelectedTabId = 0;

	mov	DWORD PTR [rbx+24], esi
$LN485@TabBarLayo:

; 7903 :     if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)

	mov	ecx, DWORD PTR [rbx+24]
	mov	eax, ecx
	test	ecx, ecx
	jne	SHORT $LN51@TabBarLayo
	cmp	DWORD PTR [rbx+28], esi
	jne	SHORT $LN51@TabBarLayo
	mov	rcx, QWORD PTR most_recently_selected_tab$1$[rbp-153]
	test	rcx, rcx
	je	SHORT $LN51@TabBarLayo

; 7904 :         scroll_to_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;

	mov	r12d, DWORD PTR [rcx]
	mov	eax, r12d
	mov	DWORD PTR [rbx+24], r12d
$LN51@TabBarLayo:

; 7905 : 
; 7906 :     // Lock in visible tab
; 7907 :     tab_bar->VisibleTabId = tab_bar->SelectedTabId;

	mov	DWORD PTR [rbx+32], eax

; 7908 :     tab_bar->VisibleTabWasSubmitted = false;

	mov	BYTE PTR [rbx+108], sil

; 7909 : 
; 7910 :     // CTRL+TAB can override visible tab temporarily
; 7911 :     if (g.NavWindowingTarget != NULL && g.NavWindowingTarget->DockNode && g.NavWindowingTarget->DockNode->TabBar == tab_bar)

	mov	rax, QWORD PTR [r13+19488]
	test	rax, rax
	je	SHORT $LN52@TabBarLayo
	mov	rcx, QWORD PTR [rax+1096]
	test	rcx, rcx
	je	SHORT $LN52@TabBarLayo
	cmp	QWORD PTR [rcx+64], rbx
	jne	SHORT $LN52@TabBarLayo

; 7912 :         tab_bar->VisibleTabId = scroll_to_tab_id = g.NavWindowingTarget->TabId;

	mov	r12d, DWORD PTR [rax+176]
	mov	DWORD PTR [rbx+32], r12d
$LN52@TabBarLayo:

; 7913 : 
; 7914 :     // Apply request requests
; 7915 :     if (scroll_to_tab_id != 0)

	test	r12d, r12d
	je	$LN53@TabBarLayo

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	r8d, DWORD PTR [rbx]
	mov	eax, esi
	test	r8d, r8d
	jle	$LN494@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r9, QWORD PTR [rbx+8]
	mov	rcx, r9
	npad	5
$LL142@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rcx], r12d
	je	SHORT $LN387@TabBarLayo

; 7955 : 
; 7956 : // Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.
; 7957 : static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label, ImGuiWindow* docked_window)
; 7958 : {
; 7959 :     if (docked_window != NULL)
; 7960 :     {
; 7961 :         IM_UNUSED(tab_bar);
; 7962 :         IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_DockNode);
; 7963 :         ImGuiID id = docked_window->TabId;
; 7964 :         KeepAliveID(id);
; 7965 :         return id;
; 7966 :     }
; 7967 :     else
; 7968 :     {
; 7969 :         ImGuiWindow* window = GImGui->CurrentWindow;
; 7970 :         return window->GetID(label);
; 7971 :     }
; 7972 : }
; 7973 : 
; 7974 : static float ImGui::TabBarCalcMaxTabWidth()
; 7975 : {
; 7976 :     ImGuiContext& g = *GImGui;
; 7977 :     return g.FontSize * 20.0f;
; 7978 : }
; 7979 : 
; 7980 : ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
; 7981 : {
; 7982 :     if (tab_id != 0)
; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	rcx, 56					; 00000038H
	cmp	eax, r8d
	jl	SHORT $LL142@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 7833 :         if (window == potential_parent)

	jmp	$LN494@TabBarLayo
$LN387@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	imul	rdx, rcx, 56				; 00000038H
	add	r9, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8094 :     if (tab == NULL)

	je	$LN494@TabBarLayo

; 8095 :         return;
; 8096 :     if (tab->Flags & ImGuiTabItemFlags_SectionMask_)

	test	BYTE PTR [r9+4], 192			; 000000c0H
	jne	$LN494@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm3, DWORD PTR [r15+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rax, 5270498306774157605		; 4924924924924925H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm3, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8100 :     float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	imul	rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, DWORD PTR sections$[rbp-149]

; 8100 :     float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

	movss	xmm0, DWORD PTR [rcx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	sar	rdx, 4
	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, DWORD PTR sections$[rbp-125]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8107 :     float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);

	mov	eax, DWORD PTR sections$[rbp-153]
	dec	eax

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, DWORD PTR sections$[rbp-133]

; 8107 :     float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);

	cmp	edx, eax
	jle	SHORT $LN135@TabBarLayo
	movaps	xmm1, xmm0
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	jmp	SHORT $LN136@TabBarLayo
$LN135@TabBarLayo:
	movaps	xmm1, xmm6
$LN136@TabBarLayo:
	movss	xmm2, DWORD PTR [r9+24]

; 8108 :     float tab_x2 = tab->Offset - sections[0].Width + tab->Width + (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);

	lea	eax, DWORD PTR [rdx+1]
	subss	xmm2, DWORD PTR sections$[rbp-149]
	sub	r8d, DWORD PTR sections$[rbp-129]
	addss	xmm1, xmm2
	cmp	eax, r8d
	jl	SHORT $LN138@TabBarLayo
	movaps	xmm0, xmm7
$LN138@TabBarLayo:
	addss	xmm2, DWORD PTR [r9+28]

; 8109 :     tab_bar->ScrollingTargetDistToVisibility = 0.0f;
; 8110 :     if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width))

	movss	xmm4, DWORD PTR [rbx+80]
	comiss	xmm4, xmm1
	mov	DWORD PTR [rbx+84], esi
	addss	xmm2, xmm0
	ja	SHORT $LN132@TabBarLayo
	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	comiss	xmm0, xmm3
	jae	SHORT $LN132@TabBarLayo

; 8115 :     }
; 8116 :     else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width)

	subss	xmm2, xmm3
	comiss	xmm2, xmm4
	jbe	$LN494@TabBarLayo

; 8119 :         tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);

	subss	xmm1, xmm3

; 8120 :         tab_bar->ScrollingTarget = tab_x2 - scrollable_width;

	movss	DWORD PTR [rbx+80], xmm2
	subss	xmm1, DWORD PTR [rbx+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8119 :         tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);

	movss	DWORD PTR [rbx+84], xmm1

; 8120 :         tab_bar->ScrollingTarget = tab_x2 - scrollable_width;

	jmp	$LN494@TabBarLayo
$LN132@TabBarLayo:

; 8113 :         tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);

	movss	xmm0, DWORD PTR [rbx+76]
	subss	xmm0, xmm2

; 8114 :         tab_bar->ScrollingTarget = tab_x1;

	movss	DWORD PTR [rbx+80], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8113 :         tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);

	movss	DWORD PTR [rbx+84], xmm0

; 7916 :         TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);

	jmp	$LN494@TabBarLayo
$LN53@TabBarLayo:

; 7917 :     else if ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll) && IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow))

	test	BYTE PTR [rbx+16], 128			; 00000080H
	je	$LN494@TabBarLayo
	mov	r8b, 1
	lea	rdx, QWORD PTR [rbx+52]
	mov	rcx, r15
	call	?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	test	al, al
	je	$LN494@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4048 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7917 :     else if ((tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll) && IsMouseHoveringRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow))

	mov	rdx, QWORD PTR [r13+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4049 :     if (g.NavWindow)

	mov	rcx, QWORD PTR [r8+19096]
	test	rcx, rcx
	je	SHORT $LN212@TabBarLayo

; 4050 :         if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)

	mov	rcx, QWORD PTR [rcx+968]
	test	rcx, rcx
	je	SHORT $LN212@TabBarLayo

; 4051 :             if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)

	cmp	BYTE PTR [rcx+236], sil
	je	SHORT $LN212@TabBarLayo
	cmp	rcx, QWORD PTR [rdx+968]
	je	SHORT $LN212@TabBarLayo

; 4052 :             {
; 4053 :                 // For the purpose of those flags we differentiate "standard popup" from "modal popup"
; 4054 :                 // NB: The 'else' is important because Modal windows are also Popups.
; 4055 :                 bool want_inhibit = false;
; 4056 :                 if (focused_root_window->Flags & ImGuiWindowFlags_Modal)

	mov	eax, DWORD PTR [rcx+20]
	bt	eax, 27
	jb	SHORT $LN473@TabBarLayo

; 4057 :                     want_inhibit = true;
; 4058 :                 else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))

	bt	eax, 26
	jae	SHORT $LN212@TabBarLayo
$LN473@TabBarLayo:

; 4059 :                     want_inhibit = true;
; 4060 : 
; 4061 :                 // Inhibit hover unless the window is within the stack of our modal/popup
; 4062 :                 if (want_inhibit)
; 4063 :                     if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))

	mov	rax, QWORD PTR [rdx+952]

; 7829 :     if (window->RootWindow == potential_parent)

	cmp	QWORD PTR [rax+952], rcx
	je	SHORT $LN212@TabBarLayo
	npad	6
$LL218@TabBarLayo:

; 7833 :         if (window == potential_parent)

	cmp	rax, rcx
	je	SHORT $LN212@TabBarLayo

; 7834 :             return true;
; 7835 :         window = window->ParentWindowInBeginStack;

	mov	rax, QWORD PTR [rax+944]
	test	rax, rax
	jne	SHORT $LL218@TabBarLayo

; 7833 :         if (window == potential_parent)

	jmp	$LN494@TabBarLayo
$LN212@TabBarLayo:

; 4068 :     if (window->Viewport != g.MouseViewport)

	mov	rax, QWORD PTR [r8+19008]
	cmp	QWORD PTR [rdx+56], rax
	je	SHORT $LN214@TabBarLayo

; 4069 :         if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)

	mov	rax, QWORD PTR [r8+16432]
	test	rax, rax
	je	$LN494@TabBarLayo
	mov	rax, QWORD PTR [rax+968]
	cmp	QWORD PTR [rdx+968], rax
	jne	$LN494@TabBarLayo
$LN214@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7919 :         const float wheel = g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH;

	movzx	eax, BYTE PTR [r13+14205]
	test	al, al
	je	SHORT $LN76@TabBarLayo
	movss	xmm2, DWORD PTR [r13+3608]
	jmp	SHORT $LN77@TabBarLayo
$LN76@TabBarLayo:
	movss	xmm2, DWORD PTR [r13+3612]
$LN77@TabBarLayo:

; 7920 :         const ImGuiKey wheel_key = g.IO.MouseWheelRequestAxisSwap ? ImGuiKey_MouseWheelY : ImGuiKey_MouseWheelX;
; 7921 :         if (TestKeyOwner(wheel_key, tab_bar->ID) && wheel != 0.0f)

	mov	r11d, DWORD PTR [rbx+20]
	test	al, al
	mov	r10d, esi
	mov	edx, r11d
	setne	r10b
	lea	ecx, DWORD PTR [r10+646]
	call	?TestKeyOwner@ImGui@@YA_NW4ImGuiKey@@I@Z ; ImGui::TestKeyOwner
	test	al, al
	je	SHORT $LN56@TabBarLayo
	ucomiss	xmm2, xmm6
	jp	SHORT $LN490@TabBarLayo
	je	SHORT $LN56@TabBarLayo
$LN490@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm1, DWORD PTR [r15]
	movss	xmm0, DWORD PTR [r15+8]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7924 :             tab_bar->ScrollingTargetDistToVisibility = 0.0f;

	mov	DWORD PTR [rbx+84], esi

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm0, DWORD PTR sections$[rbp-149]
	subss	xmm0, DWORD PTR sections$[rbp-125]
	subss	xmm0, DWORD PTR sections$[rbp-133]

; 7922 :         {
; 7923 :             const float scroll_step = wheel * TabBarCalcScrollableWidth(tab_bar, sections) / 3.0f;

	mulss	xmm0, xmm2

; 7925 :             tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);

	movss	xmm2, DWORD PTR [rbx+80]
	divss	xmm0, DWORD PTR __real@40400000
	subss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [rbx+52]
	subss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	movss	xmm1, DWORD PTR [rbx+68]
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm2, xmm1

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7925 :             tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget - scroll_step);

	movss	DWORD PTR [rbx+80], xmm2
$LN56@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9668 :     ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	edx, DWORD PTR [r10+646]
	call	?GetKeyOwnerData@ImGui@@YAPEAUImGuiKeyOwnerData@@PEAUImGuiContext@@W4ImGuiKey@@@Z ; ImGui::GetKeyOwnerData

; 9669 :     owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;

	mov	DWORD PTR [rax+4], r11d
	mov	DWORD PTR [rax], r11d

; 9670 : 
; 9671 :     // We cannot lock by default as it would likely break lots of legacy code.
; 9672 :     // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
; 9673 :     owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
; 9674 :     owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);

	mov	WORD PTR [rax+8], si
$LN494@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm7, DWORD PTR [r15]
	movss	xmm0, DWORD PTR [r15+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	movss	xmm2, DWORD PTR [rbx+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	subss	xmm0, xmm7

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm3, DWORD PTR [rbx+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	movaps	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movss	xmm4, DWORD PTR [rbx+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7932 :     tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);

	mov	r12, QWORD PTR [rsp+272]
	mov	rdi, QWORD PTR [rsp+264]

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm3, xmm1

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7931 :     tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);

	movss	DWORD PTR [rbx+76], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm5, DWORD PTR [rbx+52]
	movaps	xmm0, xmm5
	subss	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	subss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm4, xmm2

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm4, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7932 :     tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);

	movaps	xmm6, XMMWORD PTR [rsp+192]

; 7933 :     if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)

	ucomiss	xmm3, xmm4
	movss	DWORD PTR [rbx+80], xmm4
	jp	SHORT $LN489@TabBarLayo
	jne	SHORT $LN489@TabBarLayo

; 7941 :     }
; 7942 :     else
; 7943 :     {
; 7944 :         tab_bar->ScrollingSpeed = 0.0f;

	mov	DWORD PTR [rbx+88], esi
	jmp	$LN58@TabBarLayo
$LN489@TabBarLayo:

; 7934 :     {
; 7935 :         // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
; 7936 :         // Teleport if we are aiming far off the visible line
; 7937 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);

	movss	xmm0, DWORD PTR [r13+15696]

; 7938 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);

	movaps	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR [rbx+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7938 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);

	subss	xmm1, xmm3
	mulss	xmm0, DWORD PTR __real@428c0000

; 7939 :         const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);

	mov	eax, DWORD PTR [rbx+40]
	inc	eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_math.h

; 680  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7938 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);

	divss	xmm1, DWORD PTR __real@3e99999a
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7938 :         tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);

	movss	DWORD PTR [rbx+88], xmm2

; 7939 :         const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);

	cmp	eax, DWORD PTR [r13+16240]
	jl	SHORT $LN78@TabBarLayo
	movss	xmm1, DWORD PTR [r13+15696]
	mulss	xmm1, DWORD PTR __real@41200000
	movss	xmm0, DWORD PTR [rbx+84]
	comiss	xmm0, xmm1
	ja	SHORT $LN78@TabBarLayo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	comiss	xmm4, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7940 :         tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);

	mulss	xmm2, DWORD PTR [r13+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	jbe	SHORT $LN187@TabBarLayo
	addss	xmm3, xmm2

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm3, xmm4

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	jmp	SHORT $LN186@TabBarLayo
$LN187@TabBarLayo:
	comiss	xmm3, xmm4
	jbe	SHORT $LN186@TabBarLayo
	subss	xmm3, xmm2

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm3, xmm4

; 479  : static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }

	jmp	SHORT $LN186@TabBarLayo
$LN78@TabBarLayo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7940 :         tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);

	movaps	xmm3, xmm4
$LN186@TabBarLayo:
	movss	DWORD PTR [rbx+76], xmm3
$LN58@TabBarLayo:

; 7945 :     }
; 7946 :     tab_bar->ScrollingRectMinX = tab_bar->BarRect.Min.x + sections[0].Width + sections[0].Spacing;

	movss	xmm0, DWORD PTR sections$[rbp-149]

; 7952 :     ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);

	lea	rcx, QWORD PTR $T1[rbp-153]
	subss	xmm5, DWORD PTR sections$[rbp-125]
	addss	xmm0, xmm7
	subss	xmm5, DWORD PTR sections$[rbp-133]
	addss	xmm0, DWORD PTR sections$[rbp-145]
	movss	DWORD PTR [rbx+96], xmm5
	movss	DWORD PTR [rbx+92], xmm0
	movsd	xmm0, QWORD PTR [r15]
	mov	r9, QWORD PTR [r13+16408]
	movsd	QWORD PTR [r9+312], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 530  :     float       GetHeight() const                   { return Max.y - Min.y; }

	movss	xmm0, DWORD PTR [rbx+56]
	subss	xmm0, DWORD PTR [rbx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rbp-153], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7952 :     ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);

	movss	xmm1, DWORD PTR [rbx+124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rbp-149], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7952 :     ItemSize(ImVec2(tab_bar->WidthAllTabs, tab_bar->BarRect.GetHeight()), tab_bar->FramePadding.y);

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize

; 7953 :     window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);

	movss	xmm1, DWORD PTR [r15]
	addss	xmm1, DWORD PTR [rbx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [r9+344]
	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7953 :     window->DC.IdealMaxPos.x = ImMax(window->DC.IdealMaxPos.x, tab_bar->BarRect.Min.x + tab_bar->WidthAllTabsIdeal);

	movss	DWORD PTR [r9+344], xmm0

; 7954 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-153]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm7, XMMWORD PTR [rsp+176]
	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r13
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?TabBarLayout@ImGui@@YAXPEAUImGuiTabBar@@@Z ENDP	; ImGui::TabBarLayout
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBDPEAUImGuiWindow@@@Z
_TEXT	SEGMENT
tab_bar$dead$ = 8
label$ = 16
docked_window$ = 24
?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBDPEAUImGuiWindow@@@Z PROC ; ImGui::TabBarCalcTabID, COMDAT

; 7959 :     if (docked_window != NULL)

	test	r8, r8
	je	SHORT $LN2@TabBarCalc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4018 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7963 :         ImGuiID id = docked_window->TabId;

	mov	eax, DWORD PTR [r8+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4019 :     if (g.ActiveId == id)

	cmp	DWORD PTR [rcx+16504], eax
	jne	SHORT $LN6@TabBarCalc

; 4020 :         g.ActiveIdIsAlive = id;

	mov	DWORD PTR [rcx+16508], eax
$LN6@TabBarCalc:

; 4021 :     if (g.ActiveIdPreviousFrame == id)

	cmp	DWORD PTR [rcx+16552], eax
	jne	SHORT $LN3@TabBarCalc

; 4022 :         g.ActiveIdPreviousFrameIsAlive = true;

	mov	BYTE PTR [rcx+16556], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7972 : }

	ret	0
$LN2@TabBarCalc:

; 7964 :         KeepAliveID(id);
; 7965 :         return id;
; 7966 :     }
; 7967 :     else
; 7968 :     {
; 7969 :         ImGuiWindow* window = GImGui->CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 7970 :         return window->GetID(label);

	mov	rcx, QWORD PTR [rax+16408]
	jmp	?GetID@ImGuiWindow@@QEAAIPEBD0@Z	; ImGuiWindow::GetID
$LN3@TabBarCalc:

; 7972 : }

	ret	0
?TabBarCalcTabID@ImGui@@YAIPEAUImGuiTabBar@@PEBDPEAUImGuiWindow@@@Z ENDP ; ImGui::TabBarCalcTabID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarCalcMaxTabWidth@ImGui@@YAMXZ
_TEXT	SEGMENT
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ PROC		; ImGui::TabBarCalcMaxTabWidth, COMDAT

; 7976 :     ImGuiContext& g = *GImGui;
; 7977 :     return g.FontSize * 20.0f;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+15696]
	mulss	xmm0, DWORD PTR __real@41a00000

; 7978 : }

	ret	0
?TabBarCalcMaxTabWidth@ImGui@@YAMXZ ENDP		; ImGui::TabBarCalcMaxTabWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z
_TEXT	SEGMENT
tab_bar$ = 8
scrolling$ = 16
?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z PROC	; ImGui::TabBarScrollClamp, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm0, DWORD PTR [rcx+52]
	subss	xmm0, DWORD PTR [rcx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8086 :     scrolling = ImMin(scrolling, tab_bar->WidthAllTabs - tab_bar->BarRect.GetWidth());

	movss	xmm2, DWORD PTR [rcx+68]
	subss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm2, xmm1
	ja	SHORT $LN8@TabBarScro
	movaps	xmm1, xmm2
$LN8@TabBarScro:
	xorps	xmm0, xmm0

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8087 :     return ImMax(scrolling, 0.0f);

	movaps	xmm0, xmm1

; 8088 : }

	ret	0
?TabBarScrollClamp@ImGui@@YAMPEAUImGuiTabBar@@M@Z ENDP	; ImGui::TabBarScrollClamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@IPEAUImGuiTabBarSection@@@Z
_TEXT	SEGMENT
tab_bar$ = 8
tab_id$ = 16
sections$ = 24
?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@IPEAUImGuiTabBarSection@@@Z PROC ; ImGui::TabBarScrollToTab, COMDAT

; 8092 : {

	mov	r11, r8

; 7982 :     if (tab_id != 0)

	test	edx, edx
	je	$LN7@TabBarScro

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	r9d, DWORD PTR [rcx]
	xor	eax, eax
	test	r9d, r9d
	jle	$LN7@TabBarScro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [rcx+8]
	mov	r8, r10
$LL16@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [r8], edx
	je	SHORT $LN41@TabBarScro

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	r8, 56					; 00000038H
	cmp	eax, r9d
	jl	SHORT $LL16@TabBarScro

; 8121 :     }
; 8122 : }

	ret	0
$LN41@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rdx, rax, 56				; 00000038H
	lea	r8, QWORD PTR [rdx+r10]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8094 :     if (tab == NULL)

	test	r8, r8
	je	$LN7@TabBarScro

; 8095 :         return;
; 8096 :     if (tab->Flags & ImGuiTabItemFlags_SectionMask_)

	test	BYTE PTR [r8+4], 192			; 000000c0H
	jne	$LN7@TabBarScro

; 8097 :         return;
; 8098 : 
; 8099 :     ImGuiContext& g = *GImGui;
; 8100 :     float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xorps	xmm4, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 529  :     float       GetWidth() const                    { return Max.x - Min.x; }

	movss	xmm3, DWORD PTR [rcx+52]
	subss	xmm3, DWORD PTR [rcx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	movss	xmm2, DWORD PTR [r11+4]

; 8097 :         return;
; 8098 : 
; 8099 :     ImGuiContext& g = *GImGui;
; 8100 :     float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)

	movss	xmm5, DWORD PTR [rax+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	sar	rdx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, DWORD PTR [r11+28]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8107 :     float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);

	mov	eax, DWORD PTR [r11]
	dec	eax

; 7705 :     return tab_bar->BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;

	subss	xmm3, DWORD PTR [r11+20]

; 8107 :     float tab_x1 = tab->Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0f);

	cmp	edx, eax
	jle	SHORT $LN9@TabBarScro
	movaps	xmm0, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	jmp	SHORT $LN10@TabBarScro
$LN9@TabBarScro:
	xorps	xmm0, xmm0
$LN10@TabBarScro:
	movss	xmm1, DWORD PTR [r8+24]

; 8108 :     float tab_x2 = tab->Offset - sections[0].Width + tab->Width + (order + 1 < tab_bar->Tabs.Size - sections[2].TabCount ? margin : 1.0f);

	lea	eax, DWORD PTR [rdx+1]
	sub	r9d, DWORD PTR [r11+24]
	subss	xmm1, xmm2
	movaps	xmm2, xmm1
	addss	xmm2, xmm0
	cmp	eax, r9d
	jl	SHORT $LN12@TabBarScro
	movss	xmm5, DWORD PTR __real@3f800000
$LN12@TabBarScro:
	addss	xmm1, DWORD PTR [r8+28]

; 8109 :     tab_bar->ScrollingTargetDistToVisibility = 0.0f;

	mov	DWORD PTR [rcx+84], 0
	addss	xmm1, xmm5

; 8110 :     if (tab_bar->ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width))

	movss	xmm5, DWORD PTR [rcx+80]
	comiss	xmm5, xmm2
	ja	SHORT $LN6@TabBarScro
	movaps	xmm0, xmm1
	subss	xmm0, xmm2
	comiss	xmm0, xmm3
	jae	SHORT $LN6@TabBarScro

; 8115 :     }
; 8116 :     else if (tab_bar->ScrollingTarget < tab_x2 - scrollable_width)

	subss	xmm1, xmm3
	comiss	xmm1, xmm5
	jbe	SHORT $LN7@TabBarScro

; 8119 :         tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);

	subss	xmm2, xmm3

; 8120 :         tab_bar->ScrollingTarget = tab_x2 - scrollable_width;

	movss	DWORD PTR [rcx+80], xmm1
	subss	xmm2, DWORD PTR [rcx+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm2, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8119 :         tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar->ScrollingAnim, 0.0f);

	movss	DWORD PTR [rcx+84], xmm2

; 8121 :     }
; 8122 : }

	ret	0
$LN6@TabBarScro:

; 8113 :         tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);

	movss	xmm0, DWORD PTR [rcx+76]
	subss	xmm0, xmm1

; 8114 :         tab_bar->ScrollingTarget = tab_x1;

	movss	DWORD PTR [rcx+80], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8113 :         tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);

	movss	DWORD PTR [rcx+84], xmm0
$LN7@TabBarScro:

; 8121 :     }
; 8122 : }

	ret	0
?TabBarScrollToTab@ImGui@@YAXPEAUImGuiTabBar@@IPEAUImGuiTabBarSection@@@Z ENDP ; ImGui::TabBarScrollToTab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z
_TEXT	SEGMENT
mouse_pos$ = 0
tab_bar$ = 64
src_tab$ = 72
?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z PROC ; ImGui::TabBarQueueReorderFromMousePos, COMDAT

; 8138 : {

$LN41:
	push	r12
	push	r15
	sub	rsp, 40					; 00000028H

; 8139 :     ImGuiContext& g = *GImGui;
; 8140 :     IM_ASSERT(tab_bar->ReorderRequestTabId == 0);
; 8141 :     if ((tab_bar->Flags & ImGuiTabBarFlags_Reorderable) == 0)

	test	BYTE PTR [rcx+16], 1
	mov	r15, rdx
	mov	r12, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r9, rcx
	mov	QWORD PTR mouse_pos$[rsp], r8
	je	$LN11@TabBarQueu

; 8142 :         return;
; 8143 : 
; 8144 :     const bool is_central_section = (src_tab->Flags & ImGuiTabItemFlags_SectionMask_) == 0;

	mov	r11d, DWORD PTR [rdx+4]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+24], rdi
	and	r11d, 192				; 000000c0H

; 8145 :     const float bar_offset = tab_bar->BarRect.Min.x - (is_central_section ? tab_bar->ScrollingTarget : 0);

	jne	SHORT $LN13@TabBarQueu
	movss	xmm0, DWORD PTR [rcx+80]
	jmp	SHORT $LN14@TabBarQueu
$LN13@TabBarQueu:
	xorps	xmm0, xmm0
$LN14@TabBarQueu:
	movss	xmm4, DWORD PTR [rcx+44]

; 8148 :     const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;

	mov	eax, -1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rdi, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8145 :     const float bar_offset = tab_bar->BarRect.Min.x - (is_central_section ? tab_bar->ScrollingTarget : 0);

	subss	xmm4, xmm0

; 8148 :     const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;

	movss	xmm3, DWORD PTR mouse_pos$[rsp]
	mov	esi, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8148 :     const int dir = (bar_offset + src_tab->Offset) > mouse_pos.x ? -1 : +1;

	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR [rdx+24]
	comiss	xmm0, xmm3
	cmova	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	sub	rcx, rdi
	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 4
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8150 :     int dst_idx = src_idx;

	mov	r8d, ebx

; 8151 :     for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir)

	mov	ecx, ebx
	test	ebx, ebx
	js	$LN38@TabBarQueu
	mov	QWORD PTR [rsp+72], rbp
	mov	ebp, DWORD PTR [r9]

; 8158 :             break;
; 8159 :         dst_idx = i;
; 8160 : 
; 8161 :         // Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
; 8162 :         const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;
; 8163 :         const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width + g.Style.ItemInnerSpacing.x;

	movsxd	rax, ebx
	imul	rdx, rax, 56				; 00000038H
	movsxd	r10, esi
	mov	QWORD PTR [rsp+16], r14
	add	rdx, 24
	imul	r14, r10, 56				; 00000038H
	add	rdx, rdi
$LL4@TabBarQueu:

; 8151 :     for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir)

	cmp	ecx, ebp
	jge	SHORT $LN22@TabBarQueu

; 8152 :     {
; 8153 :         // Reordered tabs must share the same section
; 8154 :         const ImGuiTabItem* dst_tab = &tab_bar->Tabs[i];
; 8155 :         if (dst_tab->Flags & ImGuiTabItemFlags_NoReorder)

	mov	eax, DWORD PTR [rdx-20]
	test	al, 32					; 00000020H
	jne	SHORT $LN22@TabBarQueu

; 8156 :             break;
; 8157 :         if ((dst_tab->Flags & ImGuiTabItemFlags_SectionMask_) != (src_tab->Flags & ImGuiTabItemFlags_SectionMask_))

	and	eax, 192				; 000000c0H
	cmp	eax, r11d
	jne	SHORT $LN22@TabBarQueu

; 8158 :             break;
; 8159 :         dst_idx = i;
; 8160 : 
; 8161 :         // Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
; 8162 :         const float x1 = bar_offset + dst_tab->Offset - g.Style.ItemInnerSpacing.x;
; 8163 :         const float x2 = bar_offset + dst_tab->Offset + dst_tab->Width + g.Style.ItemInnerSpacing.x;

	movss	xmm2, DWORD PTR [r12+14636]
	movaps	xmm0, xmm4
	mov	r8d, ecx
	addss	xmm0, DWORD PTR [rdx]
	movaps	xmm1, xmm0
	addss	xmm1, DWORD PTR [rdx+4]
	addss	xmm1, xmm2

; 8164 :         //GetForegroundDrawList()->AddRect(ImVec2(x1, tab_bar->BarRect.Min.y), ImVec2(x2, tab_bar->BarRect.Max.y), IM_COL32(255, 0, 0, 255));
; 8165 :         if ((dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2))

	test	esi, esi
	jns	SHORT $LN39@TabBarQueu
	subss	xmm0, xmm2
	comiss	xmm3, xmm0
	ja	SHORT $LN22@TabBarQueu
	test	esi, esi
$LN39@TabBarQueu:
	jle	SHORT $LN2@TabBarQueu
	comiss	xmm1, xmm3
	ja	SHORT $LN22@TabBarQueu
$LN2@TabBarQueu:

; 8151 :     for (int i = src_idx; i >= 0 && i < tab_bar->Tabs.Size; i += dir)

	add	rdx, r14
	add	ecx, esi
	jns	SHORT $LL4@TabBarQueu
$LN22@TabBarQueu:
	mov	r14, QWORD PTR [rsp+16]

; 8166 :             break;
; 8167 :     }
; 8168 : 
; 8169 :     if (dst_idx != src_idx)

	mov	rbp, QWORD PTR [rsp+72]
	cmp	r8d, ebx
	je	SHORT $LN38@TabBarQueu

; 8133 :     tab_bar->ReorderRequestTabId = tab->ID;

	mov	eax, DWORD PTR [r15]

; 8170 :         TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);

	sub	r8w, bx

; 8134 :     tab_bar->ReorderRequestOffset = (ImS16)offset;

	mov	WORD PTR [r9+104], r8w
	mov	DWORD PTR [r9+100], eax
$LN38@TabBarQueu:
	mov	rsi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+24]
$LN11@TabBarQueu:

; 8171 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r12
	ret	0
?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@UImVec2@@@Z ENDP ; ImGui::TabBarQueueReorderFromMousePos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
tab_bar$ = 112
?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarProcessReorder, COMDAT

; 8174 : {

$LN56:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 96					; 00000060H

; 8175 :     ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId);

	mov	r8d, DWORD PTR [rcx+100]
	mov	rbx, rcx

; 7982 :     if (tab_id != 0)

	test	r8d, r8d
	je	SHORT $LN3@TabBarProc

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	movsxd	rax, DWORD PTR [rcx]
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN3@TabBarProc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r10, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	r9, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	ecx, edx
$LL19@TabBarProc:

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rax], r8d
	je	SHORT $LN37@TabBarProc

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	edx
	inc	rcx
	add	rax, 56					; 00000038H
	cmp	rcx, r9
	jl	SHORT $LL19@TabBarProc
$LN3@TabBarProc:

; 8177 :         return false;

	xor	al, al

; 8202 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN37@TabBarProc:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	r9, rax, 56				; 00000038H
	add	r9, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8176 :     if (tab1 == NULL || (tab1->Flags & ImGuiTabItemFlags_NoReorder))

	je	SHORT $LN3@TabBarProc
	mov	r10d, DWORD PTR [r9+4]
	test	r10b, 32				; 00000020H
	jne	SHORT $LN3@TabBarProc

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	movsx	esi, WORD PTR [rbx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rcx, r9
	mov	r11, QWORD PTR [rbx+8]
	mov	rax, 5270498306774157605		; 4924924924924925H
	sub	rcx, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	mov	r8d, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	imul	rcx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8180 :     int tab2_order = TabBarGetTabOrder(tab_bar, tab1) + tab_bar->ReorderRequestOffset;

	add	edx, esi

; 8181 :     if (tab2_order < 0 || tab2_order >= tab_bar->Tabs.Size)

	js	SHORT $LN3@TabBarProc
	cmp	edx, DWORD PTR [rbx]
	jge	SHORT $LN3@TabBarProc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	imul	rdi, rax, 56				; 00000038H
	add	rdi, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8187 :     if (tab2->Flags & ImGuiTabItemFlags_NoReorder)

	mov	eax, DWORD PTR [rdi+4]
	test	al, 32					; 00000020H
	jne	SHORT $LN3@TabBarProc

; 8188 :         return false;
; 8189 :     if ((tab1->Flags & ImGuiTabItemFlags_SectionMask_) != (tab2->Flags & ImGuiTabItemFlags_SectionMask_))

	xor	eax, r10d
	test	al, 192					; 000000c0H
	jne	SHORT $LN3@TabBarProc
	movaps	XMMWORD PTR [rsp+80], xmm6

; 8190 :         return false;
; 8191 : 
; 8192 :     ImGuiTabItem item_tmp = *tab1;
; 8193 :     ImGuiTabItem* src_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 + 1 : tab2;
; 8194 :     ImGuiTabItem* dst_tab = (tab_bar->ReorderRequestOffset > 0) ? tab1 : tab2 + 1;

	lea	rdx, QWORD PTR [r9+56]
	movups	xmm6, XMMWORD PTR [r9]

; 8195 :     const int move_count = (tab_bar->ReorderRequestOffset > 0) ? tab_bar->ReorderRequestOffset : -tab_bar->ReorderRequestOffset;

	lea	rax, QWORD PTR [rdi+56]
	test	si, si
	movaps	XMMWORD PTR [rsp+64], xmm7
	movups	xmm7, XMMWORD PTR [r9+16]
	cmovle	rdx, rdi
	movaps	XMMWORD PTR [rsp+48], xmm8
	movups	xmm8, XMMWORD PTR [r9+32]
	movaps	XMMWORD PTR [rsp+32], xmm9
	movsd	xmm9, QWORD PTR [r9+48]
	cmovle	r9, rax
	jg	SHORT $LN15@TabBarProc
	neg	r8d
$LN15@TabBarProc:

; 8196 :     memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));

	movsxd	rax, r8d
	mov	rcx, r9
	imul	r8, rax, 56				; 00000038H
	call	memmove

; 8197 :     *tab2 = item_tmp;

	movups	XMMWORD PTR [rdi], xmm6
	movaps	xmm6, XMMWORD PTR [rsp+80]
	movups	XMMWORD PTR [rdi+16], xmm7
	movaps	xmm7, XMMWORD PTR [rsp+64]
	movups	XMMWORD PTR [rdi+32], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+48]
	movsd	QWORD PTR [rdi+48], xmm9

; 8198 : 
; 8199 :     if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)

	test	DWORD PTR [rbx+16], 4194304		; 00400000H
	movaps	xmm9, XMMWORD PTR [rsp+32]
	je	SHORT $LN34@TabBarProc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13620:     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	xorps	xmm0, xmm0

; 13621:     if (g.SettingsDirtyTimer <= 0.0f)

	comiss	xmm0, DWORD PTR [rcx+24092]
	jb	SHORT $LN34@TabBarProc

; 13622:         g.SettingsDirtyTimer = g.IO.IniSavingRate;

	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [rcx+24092], eax
$LN34@TabBarProc:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8202 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	al, 1
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarProcessReorder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
arrow_col$ = 32
backup$3 = 48
backup$4 = 48
tab_bar$ = 256
?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarScrollingButtons, COMDAT

; 8205 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H

; 8206 :     ImGuiContext& g = *GImGui;

	mov	rbp, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$3[rsp]
	movaps	XMMWORD PTR [rax-40], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8205 : {

	mov	rsi, rcx
	movaps	XMMWORD PTR [rax-56], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	xor	edi, edi
	movaps	XMMWORD PTR [rax-72], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8209 :     const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);

	movss	xmm0, DWORD PTR [rbp+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbp+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8207 :     ImGuiWindow* window = g.CurrentWindow;

	mov	r14, QWORD PTR [rbp+16408]

; 8209 :     const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);

	movss	xmm8, DWORD PTR [rbp+14616]
	movaps	XMMWORD PTR [rax-88], xmm9
	addss	xmm8, xmm8
	movaps	xmm9, xmm0
	movaps	XMMWORD PTR [rax-104], xmm10
	subss	xmm9, DWORD PTR __real@40000000
	movaps	XMMWORD PTR [rax-120], xmm11
	movaps	XMMWORD PTR [rsp+112], xmm12
	addss	xmm8, xmm0
	movaps	XMMWORD PTR [rsp+96], xmm13

; 8213 :     //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));
; 8214 : 
; 8215 :     int select_dir = 0;
; 8216 :     ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

	movups	xmm0, XMMWORD PTR [rbp+14776]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$3[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8212 :     const ImVec2 backup_cursor_pos = window->DC.CursorPos;

	movss	xmm13, DWORD PTR [r14+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm10, xmm9
	movaps	XMMWORD PTR [rsp+80], xmm14
	addss	xmm10, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8212 :     const ImVec2 backup_cursor_pos = window->DC.CursorPos;

	movss	xmm14, DWORD PTR [r14+316]

; 8213 :     //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));
; 8214 : 
; 8215 :     int select_dir = 0;
; 8216 :     ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

	movups	XMMWORD PTR arrow_col$[rsp], xmm0

; 8217 :     arrow_col.w *= 0.5f;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	movaps	xmm6, xmm0
	movups	xmm0, XMMWORD PTR [rbp+14776]
	movups	XMMWORD PTR backup$3[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$4[rsp]

; 3138 :     g.Style.Colors[idx] = col;

	movups	xmm0, XMMWORD PTR arrow_col$[rsp]

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$4[rsp], 21

; 3138 :     g.Style.Colors[idx] = col;

	shufps	xmm0, xmm0, 147				; 00000093H

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]

; 3138 :     g.Style.Colors[idx] = col;

	movss	xmm0, xmm6
	shufps	xmm0, xmm0, 57				; 00000039H
	movups	XMMWORD PTR [rbp+14776], xmm0

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]
	movups	XMMWORD PTR backup$4[rsp+4], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15112], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8227 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	lea	rcx, OFFSET FLAT:??_C@_03CFMEKBHF@?$CD?$CD?$DM@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15120], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8227 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	movaps	xmm7, xmm9
	movss	xmm11, DWORD PTR [rbp+120]
	xor	edx, edx
	movss	xmm12, DWORD PTR [rbp+124]
	mov	DWORD PTR [rbp+120], 1048576000		; 3e800000H
	mov	DWORD PTR [rbp+124], 1045220557		; 3e4ccccdH
	movss	xmm0, DWORD PTR [rsi+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm6, DWORD PTR [rsi+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8225 :     float x = ImMax(tab_bar->BarRect.Min.x, tab_bar->BarRect.Max.x - scrolling_buttons_width);

	subss	xmm0, xmm10

; 8227 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	unpcklps xmm7, xmm8
	movq	r8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rsi+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8226 :     window->DC.CursorPos = ImVec2(x, tab_bar->BarRect.Min.y);

	movss	DWORD PTR [r14+316], xmm0
	movss	DWORD PTR [r14+312], xmm6

; 8227 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	call	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rsi+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8227 :     if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	addss	xmm9, xmm6
	movzx	ebx, al

; 8230 :     if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	lea	rcx, OFFSET FLAT:??_C@_03BHPCMDPH@?$CD?$CD?$DO@
	mov	r15d, 1
	movss	DWORD PTR [r14+316], xmm0
	xor	ebx, 1
	movq	r8, xmm7
	mov	edx, r15d
	dec	ebx
	movss	DWORD PTR [r14+312], xmm9
	call	?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z ; ImGui::ArrowButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8230 :     if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))

	test	al, al

; 8231 :         select_dir = +1;
; 8232 :     PopStyleColor(2);

	mov	r9d, 2
	cmovne	ebx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3144 :     if (g.ColorStack.Size < count)

	mov	eax, DWORD PTR [r8+18824]
	cmp	eax, r9d
	jge	SHORT $LL39@TabBarScro

; 3145 :     {
; 3146 :         IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
; 3147 :         count = g.ColorStack.Size;

	mov	r9d, eax

; 3149 :     while (count > 0)

	test	eax, eax
	jle	SHORT $LN40@TabBarScro
$LL39@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3154 :         count--;

	dec	r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	cdqe
	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
	mov	eax, DWORD PTR [r8+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3149 :     while (count > 0)

	test	r9d, r9d
	jg	SHORT $LL39@TabBarScro
$LN40@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8233 :     g.IO.KeyRepeatRate = backup_repeat_rate;

	movss	DWORD PTR [rbp+124], xmm12

; 8234 :     g.IO.KeyRepeatDelay = backup_repeat_delay;

	movss	DWORD PTR [rbp+120], xmm11

; 8235 : 
; 8236 :     ImGuiTabItem* tab_to_scroll_to = NULL;
; 8237 :     if (select_dir != 0)

	test	ebx, ebx
	je	$LN78@TabBarScro

; 8238 :         if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))

	mov	r8d, DWORD PTR [rsi+24]

; 7982 :     if (tab_id != 0)

	test	r8d, r8d
	je	$LN78@TabBarScro

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	mov	ecx, DWORD PTR [rsi]
	mov	eax, edi
	test	ecx, ecx
	jle	$LN78@TabBarScro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r11, QWORD PTR [rsi+8]
	mov	rdx, r11
	npad	3
$LL50@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	cmp	DWORD PTR [rdx], r8d
	je	SHORT $LN67@TabBarScro

; 7983 :         for (int n = 0; n < tab_bar->Tabs.Size; n++)

	inc	eax
	add	rdx, 56					; 00000038H
	cmp	eax, ecx
	jl	SHORT $LL50@TabBarScro

; 7984 :             if (tab_bar->Tabs[n].ID == tab_id)

	jmp	SHORT $LN78@TabBarScro
$LN67@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rdx, rax, 56				; 00000038H
	lea	rax, QWORD PTR [rdx+r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8238 :         if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))

	test	rax, rax
	je	SHORT $LN78@TabBarScro
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	mov	rax, 5270498306774157605		; 4924924924924925H

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r10, ebx

; 1950 :     inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }

	imul	rdx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r9, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8241 :             int target_order = selected_order + select_dir;

	lea	eax, DWORD PTR [rdx+rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	r8, eax
$LL2@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8247 :                 tab_to_scroll_to = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order];

	test	eax, eax
	js	SHORT $LN73@TabBarScro
	mov	rdx, r8
	cmp	eax, ecx
	jl	SHORT $LN11@TabBarScro
$LN73@TabBarScro:
	mov	rdx, r9
$LN11@TabBarScro:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rdi, rdx, 56				; 00000038H
	add	rdi, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8251 :                 if (tab_to_scroll_to->Flags & ImGuiTabItemFlags_Button)

	test	DWORD PTR [rdi+4], 2097152		; 00200000H
	je	SHORT $LN78@TabBarScro

; 8252 :                 {
; 8253 :                     target_order += select_dir;

	add	r8, r10

; 8254 :                     selected_order += select_dir;

	add	r9, r10
	add	eax, ebx

; 8255 :                     tab_to_scroll_to = (target_order < 0 || target_order >= tab_bar->Tabs.Size) ? tab_to_scroll_to : NULL;

	js	SHORT $LN78@TabBarScro
	cmp	eax, ecx
	jl	SHORT $LL2@TabBarScro
$LN78@TabBarScro:

; 8256 :                 }
; 8257 :             }
; 8258 :         }
; 8259 :     window->DC.CursorPos = backup_cursor_pos;
; 8260 :     tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;

	addss	xmm10, DWORD PTR __real@3f800000

; 8261 : 
; 8262 :     return tab_to_scroll_to;
; 8263 : }

	lea	r11, QWORD PTR [rsp+224]
	movss	DWORD PTR [r14+312], xmm13
	mov	rbx, QWORD PTR [r11+32]
	mov	rax, rdi
	mov	rbp, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movss	DWORD PTR [r14+316], xmm14
	movss	xmm0, DWORD PTR [rsi+52]
	movaps	xmm14, XMMWORD PTR [rsp+80]
	subss	xmm0, xmm10
	movaps	xmm10, XMMWORD PTR [r11-80]
	movss	DWORD PTR [rsi+52], xmm0
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?TabBarScrollingButtons@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarScrollingButtons
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z
_TEXT	SEGMENT
arrow_col$ = 32
backup$2 = 48
$T3 = 160
tab_bar$ = 160
?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z PROC ; ImGui::TabBarTabListPopupButton, COMDAT

; 8266 : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 128				; 00000080H

; 8267 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR [rax-104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8273 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);

	movss	xmm1, DWORD PTR [rcx+44]
	mov	rdi, rcx
	movaps	XMMWORD PTR [rax-56], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	xor	esi, esi
	movaps	XMMWORD PTR [rax-72], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8271 :     const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;

	movss	xmm0, DWORD PTR [rbx+14616]
	mov	r15, QWORD PTR [rbx+16408]

; 8273 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);

	subss	xmm1, xmm0
	movaps	xmm2, xmm0
	movaps	XMMWORD PTR [rax-40], xmm6
	addss	xmm2, DWORD PTR [rbx+15696]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rcx+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8272 :     const ImVec2 backup_cursor_pos = window->DC.CursorPos;

	movss	xmm7, DWORD PTR [r15+312]
	movss	xmm8, DWORD PTR [r15+316]

; 8273 :     window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);

	movss	DWORD PTR [r15+316], xmm0
	movss	DWORD PTR [r15+312], xmm1

; 8274 :     tab_bar->BarRect.Min.x += tab_list_popup_button_width;

	addss	xmm2, DWORD PTR [rcx+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR [rax-104], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8274 :     tab_bar->BarRect.Min.x += tab_list_popup_button_width;

	movss	DWORD PTR [rcx+44], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8276 :     ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];

	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR [rax-120], xmm0

; 8277 :     arrow_col.w *= 0.5f;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	movaps	xmm6, xmm0
	movups	xmm0, XMMWORD PTR [rbx+14776]
	movups	XMMWORD PTR [rax-100], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back
	movups	xmm0, XMMWORD PTR arrow_col$[rsp]

; 3137 :     g.ColorStack.push_back(backup);

	lea	rdx, QWORD PTR backup$2[rsp]
	mov	DWORD PTR backup$2[rsp], 21

; 3138 :     g.Style.Colors[idx] = col;

	shufps	xmm0, xmm0, 147				; 00000093H
	movss	xmm0, xmm6
	shufps	xmm0, xmm0, 57				; 00000039H
	movups	XMMWORD PTR [rbx+14776], xmm0

; 3133 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15112]

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	movups	XMMWORD PTR backup$2[rsp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15112], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8280 :     bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);

	lea	r8d, QWORD PTR [rsi+80]
	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3138 :     g.Style.Colors[idx] = col;

	mov	QWORD PTR [rbx+15120], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8280 :     bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);

	lea	rcx, OFFSET FLAT:??_C@_03CPFCAGPK@?$CD?$CDv@
	call	?BeginCombo@ImGui@@YA_NPEBD0H@Z		; ImGui::BeginCombo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8281 :     PopStyleColor(2);

	mov	r9d, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3144 :     if (g.ColorStack.Size < count)

	movaps	xmm6, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8280 :     bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);

	movzx	r10d, al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3144 :     if (g.ColorStack.Size < count)

	mov	ecx, DWORD PTR [r8+18824]
	cmp	ecx, r9d
	jge	SHORT $LL26@TabBarTabL

; 3145 :     {
; 3146 :         IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
; 3147 :         count = g.ColorStack.Size;

	mov	r9d, ecx

; 3149 :     while (count > 0)

	test	ecx, ecx
	jle	SHORT $LN27@TabBarTabL
	npad	10
$LL26@TabBarTabL:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3154 :         count--;

	dec	r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [r8+18832]
	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	add	rax, rax
	movups	XMMWORD PTR [r8+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [r8+18824]
	mov	ecx, DWORD PTR [r8+18824]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3149 :     while (count > 0)

	test	r9d, r9d
	jg	SHORT $LL26@TabBarTabL
$LN27@TabBarTabL:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8284 :     if (open)

	test	r10b, r10b
	je	$LN5@TabBarTabL
	mov	QWORD PTR [rsp+168], rbp

; 8285 :     {
; 8286 :         for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	mov	ebp, esi
	cmp	DWORD PTR [rdi], esi
	jle	$LN3@TabBarTabL
	mov	QWORD PTR [rsp+176], r14
	mov	r14, rsi
$LL4@TabBarTabL:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rbx, QWORD PTR [rdi+8]
	add	rbx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8289 :             if (tab->Flags & ImGuiTabItemFlags_Button)

	test	DWORD PTR [rbx+4], 2097152		; 00200000H
	jne	SHORT $LN2@TabBarTabL

; 8020 :     if (tab->Window)

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN37@TabBarTabL

; 8021 :         return tab->Window->Name;

	mov	rcx, QWORD PTR [rcx+8]
	jmp	SHORT $LN36@TabBarTabL
$LN37@TabBarTabL:

; 8022 :     if (tab->NameOffset == -1)

	movsxd	rax, DWORD PTR [rbx+40]
	cmp	eax, -1
	jne	SHORT $LN38@TabBarTabL

; 8023 :         return "N/A";

	lea	rcx, OFFSET FLAT:??_C@_03HPADHAHE@N?1A@
	jmp	SHORT $LN36@TabBarTabL
$LN38@TabBarTabL:

; 8024 :     IM_ASSERT(tab->NameOffset < tab_bar->TabsNames.Buf.Size);
; 8025 :     return tab_bar->TabsNames.Buf.Data + tab->NameOffset;

	mov	rcx, rax
	add	rcx, QWORD PTR [rdi+144]
$LN36@TabBarTabL:

; 8293 :             if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))

	mov	eax, DWORD PTR [rbx]
	lea	r9, QWORD PTR $T3[rsp]
	cmp	DWORD PTR [rdi+24], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T3[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8293 :             if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))

	sete	dl
	xor	r8d, r8d
	call	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
	test	al, al
	cmovne	rsi, rbx
$LN2@TabBarTabL:

; 8285 :     {
; 8286 :         for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)

	inc	ebp
	add	r14, 56					; 00000038H
	cmp	ebp, DWORD PTR [rdi]
	jl	SHORT $LL4@TabBarTabL
	mov	r14, QWORD PTR [rsp+176]
$LN3@TabBarTabL:

; 1818 :     EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
	mov	rbp, QWORD PTR [rsp+168]
$LN5@TabBarTabL:

; 8294 :                 tab_to_select = tab;
; 8295 :         }
; 8296 :         EndCombo();
; 8297 :     }
; 8298 : 
; 8299 :     window->DC.CursorPos = backup_cursor_pos;
; 8300 :     return tab_to_select;
; 8301 : }

	mov	rbx, QWORD PTR [rsp+184]
	mov	rax, rsi
	movss	DWORD PTR [r15+312], xmm7
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movss	DWORD PTR [r15+316], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+80]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
?TabBarTabListPopupButton@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z ENDP ; ImGui::TabBarTabListPopupButton
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z
_TEXT	SEGMENT
text_size$1 = 80
__$ReturnUdt$ = 80
label$ = 88
has_close_button_or_unsaved_marker$ = 96
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z PROC	; ImGui::TabItemCalcSize, COMDAT

; 8683 : {

$LN40:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 8684 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movzx	esi, r8b
	mov	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3327 :     const char* text_display_end = text;

	mov	rax, rdx

; 3328 :     if (!text_end)
; 3329 :         text_end = (const char*)-1;
; 3330 : 
; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	rdx, -1
	jae	SHORT $LN33@TabItemCal
$LL11@TabItemCal:
	movzx	r9d, BYTE PTR [rax]
	test	r9b, r9b
	je	SHORT $LN33@TabItemCal
	lea	rcx, QWORD PTR [rax+1]
	cmp	r9b, 35					; 00000023H
	jne	SHORT $LN14@TabItemCal
	cmp	BYTE PTR [rcx], r9b
	je	SHORT $LN33@TabItemCal
$LN14@TabItemCal:

; 3332 :         text_display_end++;

	mov	rax, rcx
	cmp	rcx, -1
	jb	SHORT $LL11@TabItemCal
$LN33@TabItemCal:

; 5417 :     const float font_size = g.FontSize;

	movss	xmm4, DWORD PTR [rbx+15696]

; 5418 :     if (text == text_display_end)

	cmp	rdx, rax
	jne	SHORT $LN8@TabItemCal
	xorps	xmm0, xmm0

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN5@TabItemCal
$LN8@TabItemCal:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR __real@bf800000
	movaps	xmm2, xmm4
	movss	xmm3, DWORD PTR __real@7f7fffff
	mov	rcx, QWORD PTR [rbx+15688]
	mov	QWORD PTR [rsp+56], 0
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rdx
	lea	rdx, QWORD PTR text_size$1[rsp]
	movss	DWORD PTR [rsp+32], xmm0
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$1[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58

; 5428 : 
; 5429 :     return text_size;

	movss	xmm4, DWORD PTR text_size$1[rsp+4]
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	cvtdq2ps xmm0, xmm0
$LN5@TabItemCal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8686 :     ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);

	movss	xmm2, DWORD PTR [rbx+14616]
	movss	xmm1, DWORD PTR [rbx+14612]
	addss	xmm2, xmm2
	movaps	xmm3, xmm1
	addss	xmm3, xmm0
	addss	xmm2, xmm4

; 8687 :     if (has_close_button_or_unsaved_marker)

	test	sil, sil
	je	SHORT $LN2@TabItemCal

; 8688 :         size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.

	movss	xmm0, DWORD PTR [rbx+14636]
	addss	xmm0, DWORD PTR [rbx+15696]
	jmp	SHORT $LN3@TabItemCal
$LN2@TabItemCal:

; 8689 :     else
; 8690 :         size.x += g.Style.FramePadding.x + 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
$LN3@TabItemCal:

; 8692 : }

	mov	rsi, QWORD PTR [rsp+96]

; 7977 :     return g.FontSize * 20.0f;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [rbx+15696]

; 8691 :     return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);

	mov	rax, rdi

; 7977 :     return g.FontSize * 20.0f;

	mulss	xmm0, DWORD PTR __real@41a00000

; 8692 : }

	mov	rbx, QWORD PTR [rsp+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rdi+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 7977 :     return g.FontSize * 20.0f;

	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rdi], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 8692 : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z ENDP	; ImGui::TabItemCalcSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z
_TEXT	SEGMENT
this$ = 48
it$ = 56
?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z PROC ; ImVector<ImGuiTabItem>::erase, COMDAT

; 1941 :     inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8, QWORD PTR [rcx+8]
	mov	rdi, rcx
	sub	rdx, r8
	mov	rax, 5270498306774157605		; 4924924924924925H
	imul	rdx
	sar	rdx, 4
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	movsxd	rax, DWORD PTR [rdi]
	imul	rbx, rdx, 56				; 00000038H
	sub	rax, rdx
	lea	rcx, QWORD PTR [rbx+r8]
	imul	r8, rax, 56				; 00000038H
	lea	rdx, QWORD PTR [rcx+56]
	sub	r8, 56					; 00000038H
	call	memmove
	mov	rax, QWORD PTR [rdi+8]
	dec	DWORD PTR [rdi]
	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?erase@?$ImVector@UImGuiTabItem@@@@QEAAPEAUImGuiTabItem@@PEBU2@@Z ENDP ; ImVector<ImGuiTabItem>::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z PROC ; ImVector<ImGuiTabItem>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN2@push_back:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rdi]
	imul	rcx, rax, 56				; 00000038H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdi+32]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movsd	xmm1, QWORD PTR [rdi+48]
	movsd	QWORD PTR [rcx+rax+48], xmm1
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImGuiTabItem@@@@QEAAXAEBUImGuiTabItem@@@Z ENDP ; ImVector<ImGuiTabItem>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabItem>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, ebx
	mov	edx, ebx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rdi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ; ImVector<ImGuiTabItem>::reserve
$LN8@resize:
	mov	DWORD PTR [rdi], ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabItem>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ PROC		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImGuiTabItem@@@@QEAA@XZ ENDP		; ImVector<ImGuiTabItem>::ImVector<ImGuiTabItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	$LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 2
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiShrinkWidthItem@@@@QEAAAEAUImGuiShrinkWidthItem@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@UImGuiShrinkWidthItem@@@@QEAAAEAUImGuiShrinkWidthItem@@H@Z PROC ; ImVector<ImGuiShrinkWidthItem>::operator[], COMDAT

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*4]
	ret	0
??A?$ImVector@UImGuiShrinkWidthItem@@@@QEAAAEAUImGuiShrinkWidthItem@@H@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXXZ PROC	; ImVector<ImGuiPtrOrIndex>::pop_back, COMDAT

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rcx]
	ret	0
?pop_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXXZ ENDP	; ImVector<ImGuiPtrOrIndex>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z PROC ; ImVector<ImGuiPtrOrIndex>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN35:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rbp, rdx
	cmp	edi, ecx
	jne	$LN8@push_back
	inc	edi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@push_back

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, edi
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@push_back
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 4
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@push_back

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@push_back

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@push_back:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rcx, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rbp]
	mov	rax, QWORD PTR [rbx+8]
	add	rcx, rcx
	mov	rbp, QWORD PTR [rsp+64]
	movups	XMMWORD PTR [rax+rcx*8], xmm0
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXAEBUImGuiPtrOrIndex@@@Z ENDP ; ImVector<ImGuiPtrOrIndex>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAAEAUImGuiPtrOrIndex@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAAEAUImGuiPtrOrIndex@@XZ PROC ; ImVector<ImGuiPtrOrIndex>::back, COMDAT

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cdqe
	shl	rax, 4
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiPtrOrIndex@@@@QEAAAEAUImGuiPtrOrIndex@@XZ ENDP ; ImVector<ImGuiPtrOrIndex>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiPtrOrIndex@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$ImVector@UImGuiPtrOrIndex@@@@QEBA_NXZ PROC	; ImVector<ImGuiPtrOrIndex>::empty, COMDAT

; 1912 :     inline bool         empty() const                       { return Size == 0; }

	cmp	DWORD PTR [rcx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImGuiPtrOrIndex@@@@QEBA_NXZ ENDP	; ImVector<ImGuiPtrOrIndex>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?Contains@?$ImPool@UImGuiTabBar@@@@QEBA_NPEBUImGuiTabBar@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?Contains@?$ImPool@UImGuiTabBar@@@@QEBA_NPEBUImGuiTabBar@@@Z PROC ; ImPool<ImGuiTabBar>::Contains, COMDAT

; 674  :     bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }

	mov	r8, QWORD PTR [rcx+8]
	cmp	rdx, r8
	jb	SHORT $LN3@Contains
	movsxd	rax, DWORD PTR [rcx]
	imul	rcx, rax, 152				; 00000098H
	add	rcx, r8
	cmp	rdx, rcx
	jae	SHORT $LN3@Contains
	mov	al, 1
	ret	0
$LN3@Contains:
	xor	al, al
	ret	0
?Contains@?$ImPool@UImGuiTabBar@@@@QEBA_NPEBUImGuiTabBar@@@Z ENDP ; ImPool<ImGuiTabBar>::Contains
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetIndex@?$ImPool@UImGuiTabBar@@@@QEBAHPEBUImGuiTabBar@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?GetIndex@?$ImPool@UImGuiTabBar@@@@QEBAHPEBUImGuiTabBar@@@Z PROC ; ImPool<ImGuiTabBar>::GetIndex, COMDAT

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sub	rdx, QWORD PTR [rcx+8]
	mov	rax, 485440633518672411			; 06bca1af286bca1bH
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
	ret	0
?GetIndex@?$ImPool@UImGuiTabBar@@@@QEBAHPEBUImGuiTabBar@@@Z ENDP ; ImPool<ImGuiTabBar>::GetIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z PROC ; ImVector<ImGuiNavTreeNodeData>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	edi, edx
	mov	ecx, DWORD PTR [rcx+4]
	cmp	edx, ecx
	jle	$LN27@resize
	mov	QWORD PTR [rsp+56], rsi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	cmp	eax, edi
	mov	esi, edi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	$LN28@resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@resize

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@resize
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@resize

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@resize

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@resize:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rbp, QWORD PTR [rsp+48]

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	DWORD PTR [rbx+4], esi
	mov	rsi, QWORD PTR [rsp+56]

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@resize:
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@resize:
	mov	DWORD PTR [rbx], edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiNavTreeNodeData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAAEAUImGuiNavTreeNodeData@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAAEAUImGuiNavTreeNodeData@@XZ PROC ; ImVector<ImGuiNavTreeNodeData>::back, COMDAT

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cdqe
	lea	rdx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rax+rdx*8]
	ret	0
?back@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAAEAUImGuiNavTreeNodeData@@XZ ENDP ; ImVector<ImGuiNavTreeNodeData>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QEBAAEBMH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@M@@QEBAAEBMH@Z PROC			; ImVector<float>::operator[], COMDAT

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+8]
	movsxd	rdx, edx
	lea	rax, QWORD PTR [rax+rdx*4]
	ret	0
??A?$ImVector@M@@QEBAAEBMH@Z ENDP			; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve_discard@?$ImVector@D@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve_discard@?$ImVector@D@@QEAAXH@Z PROC		; ImVector<char>::reserve_discard, COMDAT

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve_di
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN9@reserve_di
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN7@reserve_di

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN7@reserve_di:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN9@reserve_di:

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve_di

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN14@reserve_di:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1935 :     inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rax
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve_di:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve_discard@?$ImVector@D@@QEAAXH@Z ENDP		; ImVector<char>::reserve_discard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QEBAAEBGH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImVector@G@@QEBAAEBGH@Z PROC			; ImVector<unsigned short>::operator[], COMDAT

; 1918 :     inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	rax, QWORD PTR [rcx+8]
	movsxd	rdx, edx
	lea	rax, QWORD PTR [rax+rdx*2]
	ret	0
??A?$ImVector@G@@QEBAAEBGH@Z ENDP			; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z PROC	; ImVector<ImGuiTabItem>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 56				; 00000038H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 56				; 00000038H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiTabItem@@@@QEAAXH@Z ENDP	; ImVector<ImGuiTabItem>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z PROC ; ImVector<ImGuiTabItem>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiTabItem@@@@QEBAHH@Z ENDP ; ImVector<ImGuiTabItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	lea	rcx, QWORD PTR [rdi+rdi*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 2
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiShrinkWidthItem@@@@QEAAXH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QEBAHH@Z PROC ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiShrinkWidthItem@@@@QEBAHH@Z ENDP ; ImVector<ImGuiShrinkWidthItem>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z PROC	; ImVector<ImGuiPtrOrIndex>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rcx, rdi
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	r8, DWORD PTR [rbx]
	mov	rcx, rax
	shl	r8, 4
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiPtrOrIndex@@@@QEAAXH@Z ENDP	; ImVector<ImGuiPtrOrIndex>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QEBAHH@Z PROC ; ImVector<ImGuiPtrOrIndex>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiPtrOrIndex@@@@QEBAHH@Z ENDP ; ImVector<ImGuiPtrOrIndex>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z PROC ; ImVector<ImGuiNavTreeNodeData>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	lea	rcx, QWORD PTR [rdi+rdi*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	shl	r8, 3
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiNavTreeNodeData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiNavTreeNodeData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiNavTreeNodeData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiNavTreeNodeData@@@@QEBAHH@Z PROC ; ImVector<ImGuiNavTreeNodeData>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiNavTreeNodeData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiNavTreeNodeData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm1
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@H@@YAHHH@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@H@@YAHHH@Z PROC				; ImMin<int>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	ecx, edx
	cmovl	edx, ecx
	mov	eax, edx
	ret	0
??$ImMin@H@@YAHHH@Z ENDP				; ImMin<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@M@@YAMMMM@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN5@ImClamp
	movaps	xmm0, xmm1
	ret	0
$LN5@ImClamp:
	minss	xmm2, xmm0
	movaps	xmm0, xmm2
	ret	0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@_J@@YA_J_J0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@_J@@YA_J_J0@Z PROC				; ImMax<__int64>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	rcx, rdx
	cmovge	rdx, rcx
	mov	rax, rdx
	ret	0
??$ImMax@_J@@YA_J_J0@Z ENDP				; ImMax<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@M@@YAMMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z
_TEXT	SEGMENT
label$dead$ = 48
flags$ = 56
flags_value$dead$ = 64
all_on$ = 64
??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z PROC		; ImGui::CheckboxFlagsT<int>, COMDAT

; 1160 : {

$LN13:
	mov	DWORD PTR [rsp+24], r8d
	push	rbx
	sub	rsp, 32					; 00000020H

; 1161 :     bool all_on = (*flags & flags_value) == flags_value;

	movzx	eax, BYTE PTR [rdx+2]

; 1162 :     bool any_on = (*flags & flags_value) != 0;
; 1163 :     bool pressed;
; 1164 :     if (!all_on && any_on)
; 1165 :     {
; 1166 :         ImGuiContext& g = *GImGui;
; 1167 :         g.NextItemData.ItemFlags |= ImGuiItemFlags_MixedValue;
; 1168 :         pressed = Checkbox(label, &all_on);
; 1169 :     }
; 1170 :     else
; 1171 :     {
; 1172 :         pressed = Checkbox(label, &all_on);
; 1173 : 
; 1174 :     }
; 1175 :     if (pressed)

	lea	rcx, OFFSET FLAT:??_C@_09KEDLMDJL@Alpha?5Bar@
	and	al, 1
	mov	rbx, rdx
	lea	rdx, QWORD PTR all_on$[rsp]
	mov	BYTE PTR all_on$[rsp], al
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox
	test	al, al
	je	SHORT $LN8@CheckboxFl

; 1176 :     {
; 1177 :         if (all_on)

	cmp	BYTE PTR all_on$[rsp], 0
	mov	ecx, DWORD PTR [rbx]
	je	SHORT $LN5@CheckboxFl

; 1178 :             *flags |= flags_value;

	bts	ecx, 16

; 1181 :     }
; 1182 :     return pressed;
; 1183 : }

	mov	DWORD PTR [rbx], ecx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@CheckboxFl:

; 1179 :         else
; 1180 :             *flags &= ~flags_value;

	btr	ecx, 16

; 1181 :     }
; 1182 :     return pressed;
; 1183 : }

	mov	DWORD PTR [rbx], ecx
$LN8@CheckboxFl:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$CheckboxFlagsT@H@ImGui@@YA_NPEBDPEAHH@Z ENDP		; ImGui::CheckboxFlagsT<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@C@@YACCCCC@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@C@@YACCCCC@Z PROC			; ImAddClampOverflow<signed char>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	movsx	r8d, dl
	movsx	r9d, cl
	test	dl, dl
	jns	SHORT $LN6@ImAddClamp
	mov	eax, -128				; ffffffffffffff80H
	sub	eax, r8d
	cmp	r9d, eax
	jge	SHORT $LN5@ImAddClamp
	mov	al, -128				; ffffffffffffff80H
	ret	0
$LN5@ImAddClamp:
	test	dl, dl
$LN6@ImAddClamp:
	jle	SHORT $LN3@ImAddClamp
	mov	eax, 127				; 0000007fH
	sub	eax, r8d
	cmp	r9d, eax
	jle	SHORT $LN3@ImAddClamp
	mov	al, 127					; 0000007fH
	ret	0
$LN3@ImAddClamp:
	lea	eax, DWORD PTR [r9+r8]
	ret	0
??$ImAddClampOverflow@C@@YACCCCC@Z ENDP			; ImAddClampOverflow<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@C@@YACCCCC@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@C@@YACCCCC@Z PROC			; ImSubClampOverflow<signed char>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	movsx	r9d, dl
	movsx	r8d, cl
	test	dl, dl
	jle	SHORT $LN6@ImSubClamp
	lea	eax, DWORD PTR [r9-128]
	cmp	r8d, eax
	jge	SHORT $LN5@ImSubClamp
	mov	al, -128				; ffffffffffffff80H
	ret	0
$LN5@ImSubClamp:
	test	dl, dl
$LN6@ImSubClamp:
	jns	SHORT $LN3@ImSubClamp
	lea	eax, DWORD PTR [r9+127]
	cmp	r8d, eax
	jle	SHORT $LN3@ImSubClamp
	mov	al, 127					; 0000007fH
	ret	0
$LN3@ImSubClamp:
	sub	r8b, r9b
	movzx	eax, r8b
	ret	0
??$ImSubClampOverflow@C@@YACCCCC@Z ENDP			; ImSubClampOverflow<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@E@@YAEEEEE@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@E@@YAEEEEE@Z PROC			; ImAddClampOverflow<unsigned char>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	movzx	r8d, dl
	movzx	r9d, cl
	test	dl, dl
	je	SHORT $LN3@ImAddClamp
	mov	eax, 255				; 000000ffH
	sub	eax, r8d
	cmp	r9d, eax
	jle	SHORT $LN3@ImAddClamp
	mov	al, 255					; 000000ffH
	ret	0
$LN3@ImAddClamp:
	lea	eax, DWORD PTR [r9+r8]
	ret	0
??$ImAddClampOverflow@E@@YAEEEEE@Z ENDP			; ImAddClampOverflow<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@E@@YAEEEEE@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@E@@YAEEEEE@Z PROC			; ImSubClampOverflow<unsigned char>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	movzx	r8d, dl
	movzx	eax, cl
	test	dl, dl
	je	SHORT $LN5@ImSubClamp
	cmp	cl, dl
	jae	SHORT $LN5@ImSubClamp
	xor	al, al
	ret	0
$LN5@ImSubClamp:
	sub	al, r8b
	ret	0
??$ImSubClampOverflow@E@@YAEEEEE@Z ENDP			; ImSubClampOverflow<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@F@@YAFFFFF@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@F@@YAFFFFF@Z PROC			; ImAddClampOverflow<short>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	movsx	eax, dx
	movsx	r8d, cx
	test	dx, dx
	jns	SHORT $LN6@ImAddClamp
	mov	r9d, -32768				; ffffffffffff8000H
	mov	ecx, r9d
	sub	ecx, eax
	cmp	r8d, ecx
	jge	SHORT $LN5@ImAddClamp
	movzx	eax, r9w
	ret	0
$LN5@ImAddClamp:
	test	dx, dx
$LN6@ImAddClamp:
	jle	SHORT $LN3@ImAddClamp
	mov	edx, 32767				; 00007fffH
	mov	ecx, edx
	sub	ecx, eax
	cmp	r8d, ecx
	jle	SHORT $LN3@ImAddClamp
	movzx	eax, dx
	ret	0
$LN3@ImAddClamp:
	add	ax, r8w
	ret	0
??$ImAddClampOverflow@F@@YAFFFFF@Z ENDP			; ImAddClampOverflow<short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@F@@YAFFFFF@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@F@@YAFFFFF@Z PROC			; ImSubClampOverflow<short>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	movsx	r9d, dx
	movsx	r8d, cx
	test	dx, dx
	jle	SHORT $LN6@ImSubClamp
	lea	eax, DWORD PTR [r9-32768]
	cmp	r8d, eax
	jge	SHORT $LN5@ImSubClamp
	mov	eax, -32768				; ffffffffffff8000H
	ret	0
$LN5@ImSubClamp:
	test	dx, dx
$LN6@ImSubClamp:
	jns	SHORT $LN3@ImSubClamp
	lea	eax, DWORD PTR [r9+32767]
	cmp	r8d, eax
	jle	SHORT $LN3@ImSubClamp
	mov	eax, 32767				; 00007fffH
	ret	0
$LN3@ImSubClamp:
	sub	r8w, r9w
	movzx	eax, r8w
	ret	0
??$ImSubClampOverflow@F@@YAFFFFF@Z ENDP			; ImSubClampOverflow<short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@G@@YAGGGGG@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@G@@YAGGGGG@Z PROC			; ImAddClampOverflow<unsigned short>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	movzx	r8d, dx
	movzx	r9d, cx
	test	dx, dx
	je	SHORT $LN3@ImAddClamp
	mov	ecx, 65535				; 0000ffffH
	mov	eax, ecx
	sub	eax, r8d
	cmp	r9d, eax
	jle	SHORT $LN3@ImAddClamp
	movzx	eax, cx
	ret	0
$LN3@ImAddClamp:
	lea	eax, DWORD PTR [r9+r8]
	ret	0
??$ImAddClampOverflow@G@@YAGGGGG@Z ENDP			; ImAddClampOverflow<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@G@@YAGGGGG@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@G@@YAGGGGG@Z PROC			; ImSubClampOverflow<unsigned short>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	movzx	r8d, dx
	movzx	eax, cx
	test	dx, dx
	je	SHORT $LN5@ImSubClamp
	cmp	cx, dx
	jae	SHORT $LN5@ImSubClamp
	xor	eax, eax
	ret	0
$LN5@ImSubClamp:
	sub	ax, r8w
	ret	0
??$ImSubClampOverflow@G@@YAGGGGG@Z ENDP			; ImSubClampOverflow<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@H@@YAHHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@H@@YAHHHHH@Z PROC			; ImAddClampOverflow<int>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	lea	r8d, DWORD PTR [rcx+rdx]
	mov	r9d, ecx
	test	edx, edx
	jns	SHORT $LN5@ImAddClamp
	mov	ecx, -2147483648			; ffffffff80000000H
	mov	eax, ecx
	sub	eax, edx
	cmp	r9d, eax
	cmovl	r8d, ecx
	mov	eax, r8d
	ret	0
$LN5@ImAddClamp:
	jle	SHORT $LN3@ImAddClamp
	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, eax
	sub	ecx, edx
	cmp	r9d, ecx
	cmovg	r8d, eax
$LN3@ImAddClamp:
	mov	eax, r8d
	ret	0
??$ImAddClampOverflow@H@@YAHHHHH@Z ENDP			; ImAddClampOverflow<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@H@@YAHHHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@H@@YAHHHHH@Z PROC			; ImSubClampOverflow<int>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	mov	r8d, ecx
	mov	r9d, ecx
	sub	r8d, edx
	test	edx, edx
	jle	SHORT $LN5@ImSubClamp
	lea	eax, DWORD PTR [rdx-2147483648]
	mov	ecx, -2147483648			; ffffffff80000000H
	cmp	r9d, eax
	cmovl	r8d, ecx
	mov	eax, r8d
	ret	0
$LN5@ImSubClamp:
	jns	SHORT $LN3@ImSubClamp
	lea	ecx, DWORD PTR [rdx+2147483647]
	mov	eax, 2147483647				; 7fffffffH
	cmp	r9d, ecx
	cmovg	r8d, eax
$LN3@ImSubClamp:
	mov	eax, r8d
	ret	0
??$ImSubClampOverflow@H@@YAHHHHH@Z ENDP			; ImSubClampOverflow<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@I@@YAIIIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@I@@YAIIIII@Z PROC			; ImAddClampOverflow<unsigned int>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	lea	eax, DWORD PTR [rcx+rdx]
	test	edx, edx
	je	SHORT $LN3@ImAddClamp
	not	edx
	mov	r8d, -1					; ffffffffH
	cmp	ecx, edx
	cmova	eax, r8d
$LN3@ImAddClamp:
	ret	0
??$ImAddClampOverflow@I@@YAIIIII@Z ENDP			; ImAddClampOverflow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@I@@YAIIIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@I@@YAIIIII@Z PROC			; ImSubClampOverflow<unsigned int>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	mov	eax, ecx
	sub	eax, edx
	test	edx, edx
	je	SHORT $LN2@ImSubClamp
	xor	r8d, r8d
	cmp	ecx, edx
	cmovb	eax, r8d
$LN2@ImSubClamp:
	ret	0
??$ImSubClampOverflow@I@@YAIIIII@Z ENDP			; ImSubClampOverflow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@_J@@YA_J_J000@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@_J@@YA_J_J000@Z PROC		; ImAddClampOverflow<__int64>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	lea	r8, QWORD PTR [rcx+rdx]
	mov	r9, rcx
	test	rdx, rdx
	jns	SHORT $LN5@ImAddClamp
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
	sub	rax, rdx
	cmp	r9, rax
	cmovl	r8, rcx
	mov	rax, r8
	ret	0
$LN5@ImAddClamp:
	jle	SHORT $LN3@ImAddClamp
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rcx, rax
	sub	rcx, rdx
	cmp	r9, rcx
	cmovg	r8, rax
$LN3@ImAddClamp:
	mov	rax, r8
	ret	0
??$ImAddClampOverflow@_J@@YA_J_J000@Z ENDP		; ImAddClampOverflow<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@_J@@YA_J_J000@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@_J@@YA_J_J000@Z PROC		; ImSubClampOverflow<__int64>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	mov	r8, rcx
	mov	r9, rcx
	sub	r8, rdx
	test	rdx, rdx
	jle	SHORT $LN5@ImSubClamp
	mov	rcx, -9223372036854775808		; 8000000000000000H
	lea	rax, QWORD PTR [rdx+rcx]
	cmp	r9, rax
	cmovl	r8, rcx
	mov	rax, r8
	ret	0
$LN5@ImSubClamp:
	jns	SHORT $LN3@ImSubClamp
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	lea	rcx, QWORD PTR [rdx+rax]
	cmp	r9, rcx
	cmovg	r8, rax
$LN3@ImSubClamp:
	mov	rax, r8
	ret	0
??$ImSubClampOverflow@_J@@YA_J_J000@Z ENDP		; ImSubClampOverflow<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImAddClampOverflow@_K@@YA_K_K000@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImAddClampOverflow@_K@@YA_K_K000@Z PROC		; ImAddClampOverflow<unsigned __int64>, COMDAT

; 459  : template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }

	lea	rax, QWORD PTR [rcx+rdx]
	test	rdx, rdx
	je	SHORT $LN3@ImAddClamp
	not	rdx
	mov	r8, -1
	cmp	rcx, rdx
	cmova	rax, r8
$LN3@ImAddClamp:
	ret	0
??$ImAddClampOverflow@_K@@YA_K_K000@Z ENDP		; ImAddClampOverflow<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSubClampOverflow@_K@@YA_K_K000@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
mn$dead$ = 24
mx$dead$ = 32
??$ImSubClampOverflow@_K@@YA_K_K000@Z PROC		; ImSubClampOverflow<unsigned __int64>, COMDAT

; 460  : template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

	mov	rax, rcx
	sub	rax, rdx
	test	rdx, rdx
	je	SHORT $LN2@ImSubClamp
	xor	r8d, r8d
	cmp	rcx, rdx
	cmovb	rax, r8
$LN2@ImSubClamp:
	ret	0
??$ImSubClampOverflow@_K@@YA_K_K000@Z ENDP		; ImSubClampOverflow<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@H@@YAHHHH@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	ecx, edx
	jge	SHORT $LN3@ImClamp
	mov	eax, edx
	ret	0
$LN3@ImClamp:
	cmp	ecx, r8d
	cmovg	ecx, r8d
	mov	eax, ecx
	ret	0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@C@@YAHPEBC0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@C@@YAHPEBC0@Z PROC			; DataTypeCompareT<signed char>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	r8d, BYTE PTR [rcx]
	movzx	ecx, BYTE PTR [rdx]
	cmp	r8b, cl
	jge	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8b, cl
	setg	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@C@@YAHPEBC0@Z ENDP			; DataTypeCompareT<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@E@@YAHPEBE0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@E@@YAHPEBE0@Z PROC			; DataTypeCompareT<unsigned char>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	r8d, BYTE PTR [rcx]
	movzx	ecx, BYTE PTR [rdx]
	cmp	r8b, cl
	jae	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8b, cl
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@E@@YAHPEBE0@Z ENDP			; DataTypeCompareT<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@F@@YAHPEBF0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@F@@YAHPEBF0@Z PROC			; DataTypeCompareT<short>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	r8d, WORD PTR [rcx]
	movzx	ecx, WORD PTR [rdx]
	cmp	r8w, cx
	jge	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8w, cx
	setg	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@F@@YAHPEBF0@Z ENDP			; DataTypeCompareT<short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@G@@YAHPEBG0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@G@@YAHPEBG0@Z PROC			; DataTypeCompareT<unsigned short>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movzx	r8d, WORD PTR [rcx]
	movzx	ecx, WORD PTR [rdx]
	cmp	r8w, cx
	jae	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8w, cx
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@G@@YAHPEBG0@Z ENDP			; DataTypeCompareT<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@H@@YAHPEBH0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@H@@YAHPEBH0@Z PROC			; DataTypeCompareT<int>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	mov	r8d, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rdx]
	cmp	r8d, ecx
	jge	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8d, ecx
	setg	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@H@@YAHPEBH0@Z ENDP			; DataTypeCompareT<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@I@@YAHPEBI0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@I@@YAHPEBI0@Z PROC			; DataTypeCompareT<unsigned int>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	mov	r8d, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rdx]
	cmp	r8d, ecx
	jae	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8d, ecx
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@I@@YAHPEBI0@Z ENDP			; DataTypeCompareT<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@_J@@YAHPEB_J0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@_J@@YAHPEB_J0@Z PROC		; DataTypeCompareT<__int64>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	mov	r8, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rdx]
	cmp	r8, rcx
	jge	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8, rcx
	setg	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@_J@@YAHPEB_J0@Z ENDP		; DataTypeCompareT<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@_K@@YAHPEB_K0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@_K@@YAHPEB_K0@Z PROC		; DataTypeCompareT<unsigned __int64>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	mov	r8, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rdx]
	cmp	r8, rcx
	jae	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	cmp	r8, rcx
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@_K@@YAHPEB_K0@Z ENDP		; DataTypeCompareT<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@M@@YAHPEBM0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@M@@YAHPEBM0@Z PROC			; DataTypeCompareT<float>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rdx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@M@@YAHPEBM0@Z ENDP			; DataTypeCompareT<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeCompareT@N@@YAHPEBN0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$DataTypeCompareT@N@@YAHPEBN0@Z PROC			; DataTypeCompareT<double>, COMDAT

; 2129 :     if (*lhs < *rhs) return -1;

	movsd	xmm0, QWORD PTR [rcx]
	movsd	xmm1, QWORD PTR [rdx]
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@DataTypeCo
	mov	eax, -1

; 2131 :     return 0;
; 2132 : }

	ret	0
$LN2@DataTypeCo:

; 2130 :     if (*lhs > *rhs) return +1;

	xor	eax, eax
	comisd	xmm0, xmm1
	seta	al

; 2131 :     return 0;
; 2132 : }

	ret	0
??$DataTypeCompareT@N@@YAHPEBN0@Z ENDP			; DataTypeCompareT<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@C@@YA_NPEACPEBC1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@C@@YA_NPEACPEBC1@Z PROC		; DataTypeClampT<signed char>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movzx	eax, BYTE PTR [rdx]
	cmp	BYTE PTR [rcx], al
	jge	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	BYTE PTR [rcx], al
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rcx], al
	jg	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@C@@YA_NPEACPEBC1@Z ENDP		; DataTypeClampT<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@E@@YA_NPEAEPEBE1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@E@@YA_NPEAEPEBE1@Z PROC		; DataTypeClampT<unsigned char>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movzx	eax, BYTE PTR [rdx]
	cmp	BYTE PTR [rcx], al
	jae	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	BYTE PTR [rcx], al
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [rcx], al
	ja	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@E@@YA_NPEAEPEBE1@Z ENDP		; DataTypeClampT<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@F@@YA_NPEAFPEBF1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@F@@YA_NPEAFPEBF1@Z PROC		; DataTypeClampT<short>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	jge	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	WORD PTR [rcx], ax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rcx], ax
	jg	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@F@@YA_NPEAFPEBF1@Z ENDP		; DataTypeClampT<short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@G@@YA_NPEAGPEBG1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@G@@YA_NPEAGPEBG1@Z PROC		; DataTypeClampT<unsigned short>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	jae	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	WORD PTR [rcx], ax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movzx	eax, WORD PTR [r8]
	cmp	WORD PTR [rcx], ax
	ja	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@G@@YA_NPEAGPEBG1@Z ENDP		; DataTypeClampT<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@H@@YA_NPEAHPEBH1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@H@@YA_NPEAHPEBH1@Z PROC		; DataTypeClampT<int>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jge	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	DWORD PTR [rcx], eax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rcx], eax
	jg	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@H@@YA_NPEAHPEBH1@Z ENDP		; DataTypeClampT<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@I@@YA_NPEAIPEBI1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@I@@YA_NPEAIPEBI1@Z PROC		; DataTypeClampT<unsigned int>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jae	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	DWORD PTR [rcx], eax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rcx], eax
	ja	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@I@@YA_NPEAIPEBI1@Z ENDP		; DataTypeClampT<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@_J@@YA_NPEA_JPEB_J1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@_J@@YA_NPEA_JPEB_J1@Z PROC		; DataTypeClampT<__int64>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	jge	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	QWORD PTR [rcx], rax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rcx], rax
	jg	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@_J@@YA_NPEA_JPEB_J1@Z ENDP		; DataTypeClampT<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@_K@@YA_NPEA_KPEB_K1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@_K@@YA_NPEA_KPEB_K1@Z PROC		; DataTypeClampT<unsigned __int64>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	jae	SHORT $LN6@DataTypeCl
$LN7@DataTypeCl:

; 2161 : }

	mov	QWORD PTR [rcx], rax
	mov	al, 1
	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	mov	rax, QWORD PTR [r8]
	cmp	QWORD PTR [rcx], rax
	ja	SHORT $LN7@DataTypeCl
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@_K@@YA_NPEA_KPEB_K1@Z ENDP		; DataTypeClampT<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@M@@YA_NPEAMPEBM1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@M@@YA_NPEAMPEBM1@Z PROC		; DataTypeClampT<float>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, DWORD PTR [rcx]
	jbe	SHORT $LN6@DataTypeCl
	movss	DWORD PTR [rcx], xmm0
	mov	al, 1

; 2161 : }

	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movss	xmm1, DWORD PTR [r8]
	movss	xmm0, DWORD PTR [rcx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@DataTypeCl
	movss	DWORD PTR [rcx], xmm1
	mov	al, 1

; 2161 : }

	ret	0
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@M@@YA_NPEAMPEBM1@Z ENDP		; DataTypeClampT<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DataTypeClampT@N@@YA_NPEANPEBN1@Z
_TEXT	SEGMENT
v$ = 8
v_min$ = 16
v_max$ = 24
??$DataTypeClampT@N@@YA_NPEANPEBN1@Z PROC		; DataTypeClampT<double>, COMDAT

; 2157 :     // Clamp, both sides are optional, return true if modified
; 2158 :     if (v_min && *v < *v_min) { *v = *v_min; return true; }

	test	rdx, rdx
	je	SHORT $LN6@DataTypeCl
	movsd	xmm0, QWORD PTR [rdx]
	comisd	xmm0, QWORD PTR [rcx]
	jbe	SHORT $LN6@DataTypeCl
	movsd	QWORD PTR [rcx], xmm0
	mov	al, 1

; 2161 : }

	ret	0
$LN6@DataTypeCl:

; 2159 :     if (v_max && *v > *v_max) { *v = *v_max; return true; }

	test	r8, r8
	je	SHORT $LN3@DataTypeCl
	movsd	xmm1, QWORD PTR [r8]
	movsd	xmm0, QWORD PTR [rcx]
	comisd	xmm0, xmm1
	jbe	SHORT $LN3@DataTypeCl
	movsd	QWORD PTR [rcx], xmm1
	mov	al, 1

; 2161 : }

	ret	0
$LN3@DataTypeCl:

; 2160 :     return false;

	xor	al, al

; 2161 : }

	ret	0
??$DataTypeClampT@N@@YA_NPEANPEBN1@Z ENDP		; DataTypeClampT<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z
_TEXT	SEGMENT
data_type$ = 160
v$ = 168
v_speed$ = 176
v_min$ = 184
v_max$ = 192
format$ = 200
flags$dead$ = 208
??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z PROC	; ImGui::DragBehaviorT<int,int,float>, COMDAT

; 2238 : {

$LN247:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H
	mov	r13, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	eax, 1

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	mov	ebp, DWORD PTR v_max$[rsp]
	mov	esi, r9d
	movaps	XMMWORD PTR [rsp+80], xmm6
	setbe	r12b
	movaps	XMMWORD PTR [rsp+32], xmm9
	mov	r15, rdx
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+64], xmm7
	ucomiss	xmm2, xmm9
	movaps	xmm7, xmm2
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	cmp	r9d, ebp
	jge	SHORT $LN2@DragBehavi
	movss	xmm0, DWORD PTR __real@7f7fffff
	mov	eax, ebp
	sub	eax, r9d
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movaps	xmm7, xmm1
	mulss	xmm7, DWORD PTR [rbx+23932]
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm9, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+176], rdi
	mov	QWORD PTR [rsp+96], r14
	movaps	XMMWORD PTR [rsp+48], xmm8

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r12b, r12b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r13
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	r14d, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	r14b, r14b
	je	SHORT $LN33@DragBehavi
	movss	xmm8, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm8, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	r14, QWORD PTR [rsp+96]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+48]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm7, xmm0
	mov	rdi, QWORD PTR [rsp+176]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm7, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+64]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	cmp	esi, ebp
	jge	SHORT $LN40@DragBehavi
	mov	eax, DWORD PTR [r15]
	cmp	eax, ebp
	jl	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm9
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	cmp	eax, esi
	jg	SHORT $LN40@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm9
	jp	SHORT $LN211@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN211@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN207@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;
; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	cvttss2si eax, DWORD PTR [rbx+23928]
	mov	edx, DWORD PTR [r15]
	add	edx, eax

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r12b, r12b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	mov	r8d, edx
	mov	rcx, r13
	call	??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z ; ImGui::RoundScalarWithFormatT<int>
	mov	edx, eax
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	movss	xmm1, DWORD PTR [rbx+23928]
	mov	eax, edx
	mov	BYTE PTR [rbx+23925], 0
	sub	eax, DWORD PTR [r15]
	movd	xmm0, eax

; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)
; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	mov	eax, edx
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+23928], xmm1
	mov	ecx, DWORD PTR [r15]
	cmp	ecx, edx
	je	SHORT $LN25@DragBehavi
	cmp	esi, ebp
	jge	SHORT $LN27@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	cmp	edx, esi
	jl	SHORT $LN24@DragBehavi
	cmp	edx, ecx
	jle	SHORT $LN23@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r12b, r12b
	je	SHORT $LN24@DragBehavi
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	eax, ebp
	jg	SHORT $LN26@DragBehavi
	jmp	SHORT $LN205@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	mov	eax, esi
$LN205@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	ecx, eax
	jle	SHORT $LN245@DragBehavi
	comiss	xmm6, xmm9
	jbe	SHORT $LN25@DragBehavi
	test	r12b, r12b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	mov	eax, ebp
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	cmp	ecx, eax
$LN245@DragBehavi:
	je	SHORT $LN207@DragBehavi
$LN27@DragBehavi:

; 2351 :     *v = v_cur;

	mov	DWORD PTR [r15], eax

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN207@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@HHM@ImGui@@YA_NHPEAHMHHPEBDH@Z ENDP	; ImGui::DragBehaviorT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z
_TEXT	SEGMENT
data_type$ = 160
v$ = 168
v_speed$ = 176
v_min$ = 184
v_max$ = 192
format$ = 200
flags$dead$ = 208
??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z PROC	; ImGui::DragBehaviorT<unsigned int,int,float>, COMDAT

; 2238 : {

$LN247:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H
	mov	r13, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	eax, 1

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	mov	ebp, DWORD PTR v_max$[rsp]
	mov	esi, r9d
	movaps	XMMWORD PTR [rsp+80], xmm6
	setbe	r12b
	movaps	XMMWORD PTR [rsp+32], xmm9
	mov	r15, rdx
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+64], xmm7
	ucomiss	xmm2, xmm9
	movaps	xmm7, xmm2
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	cmp	r9d, ebp
	jae	SHORT $LN2@DragBehavi
	movss	xmm0, DWORD PTR __real@7f7fffff
	mov	eax, ebp
	sub	eax, r9d
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movaps	xmm7, xmm1
	mulss	xmm7, DWORD PTR [rbx+23932]
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm9, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+176], rdi
	mov	QWORD PTR [rsp+96], r14
	movaps	XMMWORD PTR [rsp+48], xmm8

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r12b, r12b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r13
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	r14d, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	r14b, r14b
	je	SHORT $LN33@DragBehavi
	movss	xmm8, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm8, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	r14, QWORD PTR [rsp+96]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+48]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm7, xmm0
	mov	rdi, QWORD PTR [rsp+176]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm7, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+64]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	cmp	esi, ebp
	jae	SHORT $LN40@DragBehavi
	mov	eax, DWORD PTR [r15]
	cmp	eax, ebp
	jb	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm9
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	cmp	eax, esi
	ja	SHORT $LN40@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm9
	jp	SHORT $LN211@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN211@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN207@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;
; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	cvttss2si eax, DWORD PTR [rbx+23928]
	mov	edx, DWORD PTR [r15]
	add	edx, eax

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r12b, r12b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	mov	r8d, edx
	mov	rcx, r13
	call	??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z ; ImGui::RoundScalarWithFormatT<unsigned int>
	mov	edx, eax
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	movss	xmm1, DWORD PTR [rbx+23928]
	mov	eax, edx
	mov	BYTE PTR [rbx+23925], 0
	sub	eax, DWORD PTR [r15]
	movd	xmm0, eax

; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)
; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	mov	eax, edx
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+23928], xmm1
	mov	ecx, DWORD PTR [r15]
	cmp	ecx, edx
	je	SHORT $LN25@DragBehavi
	cmp	esi, ebp
	jae	SHORT $LN27@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	cmp	edx, esi
	jb	SHORT $LN24@DragBehavi
	cmp	edx, ecx
	jbe	SHORT $LN23@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r12b, r12b
	je	SHORT $LN24@DragBehavi
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	eax, ebp
	ja	SHORT $LN26@DragBehavi
	jmp	SHORT $LN205@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	mov	eax, esi
$LN205@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	ecx, eax
	jbe	SHORT $LN245@DragBehavi
	comiss	xmm6, xmm9
	jbe	SHORT $LN25@DragBehavi
	test	r12b, r12b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	mov	eax, ebp
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	cmp	ecx, eax
$LN245@DragBehavi:
	je	SHORT $LN207@DragBehavi
$LN27@DragBehavi:

; 2351 :     *v = v_cur;

	mov	DWORD PTR [r15], eax

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN207@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@IHM@ImGui@@YA_NHPEAIMIIPEBDH@Z ENDP	; ImGui::DragBehaviorT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z
_TEXT	SEGMENT
data_type$ = 160
v$ = 168
v_speed$ = 176
v_min$ = 184
v_max$ = 192
format$ = 200
flags$dead$ = 208
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z PROC ; ImGui::DragBehaviorT<__int64,__int64,double>, COMDAT

; 2238 : {

$LN239:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H
	mov	r13, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	eax, 1

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	mov	rbp, QWORD PTR v_max$[rsp]
	mov	rsi, r9
	movaps	XMMWORD PTR [rsp+80], xmm6
	setbe	r12b
	movaps	XMMWORD PTR [rsp+32], xmm9
	mov	r15, rdx
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+64], xmm7
	ucomiss	xmm2, xmm9
	movaps	xmm7, xmm2
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	cmp	r9, rbp
	jge	SHORT $LN2@DragBehavi
	movss	xmm0, DWORD PTR __real@7f7fffff
	mov	rax, rbp
	sub	rax, r9
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, rax
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movaps	xmm7, xmm1
	mulss	xmm7, DWORD PTR [rbx+23932]
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm9, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+176], rdi
	mov	QWORD PTR [rsp+96], r14
	movaps	XMMWORD PTR [rsp+48], xmm8

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r12b, r12b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r13
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	r14d, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	r14b, r14b
	je	SHORT $LN33@DragBehavi
	movss	xmm8, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm8, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	r14, QWORD PTR [rsp+96]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+48]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm7, xmm0
	mov	rdi, QWORD PTR [rsp+176]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm7, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+64]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	cmp	rsi, rbp
	jge	SHORT $LN40@DragBehavi
	mov	rax, QWORD PTR [r15]
	cmp	rax, rbp
	jl	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm9
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	cmp	rax, rsi
	jg	SHORT $LN40@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm9
	jp	SHORT $LN203@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN203@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN199@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;
; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	cvttss2si rax, DWORD PTR [rbx+23928]
	mov	rdx, QWORD PTR [r15]
	add	rdx, rax

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r12b, r12b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	mov	r8, rdx
	mov	rcx, r13
	call	??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z ; ImGui::RoundScalarWithFormatT<__int64>
	mov	rdx, rax
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	movss	xmm1, DWORD PTR [rbx+23928]
	mov	rax, rdx
	mov	BYTE PTR [rbx+23925], 0
	xorps	xmm0, xmm0
	sub	rax, QWORD PTR [r15]
	cvtsi2ss xmm0, rax

; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)
; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	mov	rax, rdx
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+23928], xmm1
	mov	rcx, QWORD PTR [r15]
	cmp	rcx, rdx
	je	SHORT $LN25@DragBehavi
	cmp	rsi, rbp
	jge	SHORT $LN27@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	cmp	rdx, rsi
	jl	SHORT $LN24@DragBehavi
	cmp	rdx, rcx
	jle	SHORT $LN23@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r12b, r12b
	je	SHORT $LN24@DragBehavi
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	rax, rbp
	jg	SHORT $LN26@DragBehavi
	jmp	SHORT $LN197@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	mov	rax, rsi
$LN197@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	rcx, rax
	jle	SHORT $LN237@DragBehavi
	comiss	xmm6, xmm9
	jbe	SHORT $LN25@DragBehavi
	test	r12b, r12b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	mov	rax, rbp
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	cmp	rcx, rax
$LN237@DragBehavi:
	je	SHORT $LN199@DragBehavi
$LN27@DragBehavi:

; 2351 :     *v = v_cur;

	mov	QWORD PTR [r15], rax

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN199@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@_J_JN@ImGui@@YA_NHPEA_JM_J1PEBDH@Z ENDP ; ImGui::DragBehaviorT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z
_TEXT	SEGMENT
data_type$ = 160
v$ = 168
v_speed$ = 176
v_min$ = 184
v_max$ = 192
format$ = 200
flags$dead$ = 208
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z PROC ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>, COMDAT

; 2238 : {

$LN242:
	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r15
	sub	rsp, 104				; 00000068H
	mov	r13, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	cmp	eax, 1

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	mov	rbp, QWORD PTR v_max$[rsp]
	mov	rsi, r9
	movaps	XMMWORD PTR [rsp+80], xmm6
	setbe	r12b
	movaps	XMMWORD PTR [rsp+32], xmm9
	mov	r15, rdx
	xorps	xmm9, xmm9
	movaps	XMMWORD PTR [rsp+64], xmm7
	ucomiss	xmm2, xmm9
	movaps	xmm7, xmm2
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	cmp	r9, rbp
	jae	SHORT $LN2@DragBehavi
	mov	rcx, rbp
	xorps	xmm1, xmm1
	sub	rcx, r9
	js	SHORT $LN204@DragBehavi
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN205@DragBehavi
$LN204@DragBehavi:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN205@DragBehavi:
	movss	xmm0, DWORD PTR __real@7f7fffff
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movaps	xmm7, xmm1
	mulss	xmm7, DWORD PTR [rbx+23932]
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm9, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+176], rdi
	mov	QWORD PTR [rsp+96], r14
	movaps	XMMWORD PTR [rsp+48], xmm8

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r12b, r12b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r13
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	r14d, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	r14b, r14b
	je	SHORT $LN33@DragBehavi
	movss	xmm8, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm8, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	r14, QWORD PTR [rsp+96]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+48]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm7, xmm0
	mov	rdi, QWORD PTR [rsp+176]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm7, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+64]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	cmp	rsi, rbp
	jae	SHORT $LN40@DragBehavi
	mov	rax, QWORD PTR [r15]
	cmp	rax, rbp
	jb	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm9
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	cmp	rax, rsi
	ja	SHORT $LN40@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm9
	jp	SHORT $LN203@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN203@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN199@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;
; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	cvttss2si rax, DWORD PTR [rbx+23928]
	mov	rdx, QWORD PTR [r15]
	add	rdx, rax

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r12b, r12b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	mov	r8, rdx
	mov	rcx, r13
	call	??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z ; ImGui::RoundScalarWithFormatT<unsigned __int64>
	mov	rdx, rax
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	movss	xmm1, DWORD PTR [rbx+23928]
	mov	rax, rdx
	mov	BYTE PTR [rbx+23925], 0
	xorps	xmm0, xmm0
	sub	rax, QWORD PTR [r15]
	cvtsi2ss xmm0, rax

; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)
; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	mov	rax, rdx
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+23928], xmm1
	mov	rcx, QWORD PTR [r15]
	cmp	rcx, rdx
	je	SHORT $LN25@DragBehavi
	cmp	rsi, rbp
	jae	SHORT $LN27@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	cmp	rdx, rsi
	jb	SHORT $LN24@DragBehavi
	cmp	rdx, rcx
	jbe	SHORT $LN23@DragBehavi
	comiss	xmm9, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r12b, r12b
	je	SHORT $LN24@DragBehavi
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	rax, rbp
	ja	SHORT $LN26@DragBehavi
	jmp	SHORT $LN197@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	mov	rax, rsi
$LN197@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	cmp	rcx, rax
	jbe	SHORT $LN240@DragBehavi
	comiss	xmm6, xmm9
	jbe	SHORT $LN25@DragBehavi
	test	r12b, r12b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	mov	rax, rbp
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	cmp	rcx, rax
$LN240@DragBehavi:
	je	SHORT $LN199@DragBehavi
$LN27@DragBehavi:

; 2351 :     *v = v_cur;

	mov	QWORD PTR [r15], rax

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN199@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@_K_JN@ImGui@@YA_NHPEA_KM_K1PEBDH@Z ENDP ; ImGui::DragBehaviorT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z
_TEXT	SEGMENT
data_type$ = 192
v$ = 200
v_speed$ = 208
v_min$ = 216
v_max$ = 224
format$ = 232
flags$dead$ = 240
??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z PROC	; ImGui::DragBehaviorT<float,float,float>, COMDAT

; 2238 : {

$LN259:
	push	rbx
	push	rbp
	push	r12
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	r12, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbp, rdx
	movaps	XMMWORD PTR [rsp+112], xmm6
	movaps	XMMWORD PTR [rsp+96], xmm7
	xorps	xmm7, xmm7
	movaps	XMMWORD PTR [rsp+48], xmm11
	movss	xmm11, DWORD PTR v_max$[rsp]
	movaps	XMMWORD PTR [rsp+32], xmm12
	movaps	xmm12, xmm3
	comiss	xmm11, xmm12
	movaps	XMMWORD PTR [rsp+80], xmm8
	movaps	xmm8, xmm2
	seta	r15b
	cmp	eax, 1
	setbe	r14b

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	ucomiss	xmm2, xmm7
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	test	r15b, r15b
	je	SHORT $LN2@DragBehavi
	movss	xmm0, DWORD PTR __real@7f7fffff
	movaps	xmm1, xmm11
	subss	xmm1, xmm12
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+23932]
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm7, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+136], rsi
	mov	QWORD PTR [rsp+128], rdi
	movaps	XMMWORD PTR [rsp+64], xmm9

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r14b, r14b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r12
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	esi, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	sil, sil
	je	SHORT $LN33@DragBehavi
	movss	xmm9, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm9, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	rsi, QWORD PTR [rsp+136]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm9
	movaps	xmm9, XMMWORD PTR [rsp+64]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm8, xmm0
	mov	rdi, QWORD PTR [rsp+128]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm8, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm8
	movaps	xmm8, XMMWORD PTR [rsp+80]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	test	r15b, r15b
	je	SHORT $LN40@DragBehavi
	movss	xmm0, DWORD PTR [rbp]
	comiss	xmm0, xmm11
	jb	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm7
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	comiss	xmm12, xmm0
	jb	SHORT $LN40@DragBehavi
	comiss	xmm7, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm7
	jp	SHORT $LN220@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN220@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN213@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;

	movss	xmm2, DWORD PTR [rbp]

; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	addss	xmm2, DWORD PTR [rbx+23928]

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r14b, r14b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	mov	rcx, r12
	call	??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z ; ImGui::RoundScalarWithFormatT<float>
	movaps	xmm2, xmm0
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)

	ucomiss	xmm2, xmm7
	mov	BYTE PTR [rbx+23925], 0
	movss	xmm0, DWORD PTR [rbx+23928]
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR [rbp]
	subss	xmm0, xmm1
	movss	DWORD PTR [rbx+23928], xmm0
	jp	SHORT $LN21@DragBehavi
	jne	SHORT $LN21@DragBehavi
	xorps	xmm2, xmm2
$LN21@DragBehavi:

; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	movss	xmm0, DWORD PTR [rbp]
	ucomiss	xmm0, xmm2
	jp	SHORT $LN219@DragBehavi
	je	SHORT $LN213@DragBehavi
$LN219@DragBehavi:
	test	r15b, r15b
	je	SHORT $LN25@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	comiss	xmm12, xmm2
	ja	SHORT $LN24@DragBehavi
	comiss	xmm2, xmm0
	jbe	SHORT $LN23@DragBehavi
	comiss	xmm7, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r14b, r14b
	jne	SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	movaps	xmm2, xmm12
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	comiss	xmm2, xmm11
	ja	SHORT $LN26@DragBehavi
	comiss	xmm0, xmm2
	jbe	SHORT $LN25@DragBehavi
	comiss	xmm6, xmm7
	jbe	SHORT $LN25@DragBehavi
	test	r14b, r14b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	movaps	xmm2, xmm11
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	ucomiss	xmm0, xmm2
	jp	SHORT $LN218@DragBehavi
	je	SHORT $LN213@DragBehavi
$LN218@DragBehavi:

; 2351 :     *v = v_cur;

	movss	DWORD PTR [rbp], xmm2

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN213@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm7, XMMWORD PTR [rsp+96]
	movaps	xmm11, XMMWORD PTR [rsp+48]
	movaps	xmm12, XMMWORD PTR [rsp+32]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@MMM@ImGui@@YA_NHPEAMMMMPEBDH@Z ENDP	; ImGui::DragBehaviorT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z
_TEXT	SEGMENT
data_type$ = 192
v$ = 200
v_speed$ = 208
v_min$ = 216
v_max$ = 224
format$ = 232
flags$dead$ = 240
??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z PROC	; ImGui::DragBehaviorT<double,double,double>, COMDAT

; 2238 : {

$LN251:
	push	rbx
	push	rbp
	push	r12
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	r12, QWORD PTR format$[rsp]

; 2239 :     ImGuiContext& g = *GImGui;
; 2240 :     const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
; 2241 :     const bool is_clamped = (v_min < v_max);
; 2242 :     const bool is_logarithmic = (flags & ImGuiSliderFlags_Logarithmic) != 0;
; 2243 :     const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbp, rdx
	movaps	XMMWORD PTR [rsp+112], xmm6
	movaps	XMMWORD PTR [rsp+80], xmm8
	xorps	xmm8, xmm8
	movaps	XMMWORD PTR [rsp+48], xmm11
	movsd	xmm11, QWORD PTR v_max$[rsp]
	comisd	xmm11, xmm3
	movaps	XMMWORD PTR [rsp+32], xmm12
	movaps	xmm12, xmm3
	movaps	XMMWORD PTR [rsp+64], xmm9
	movaps	xmm9, xmm2
	seta	r15b
	cmp	eax, 1
	setbe	r14b

; 2244 : 
; 2245 :     // Default tweak speed
; 2246 :     if (v_speed == 0.0f && is_clamped && (v_max - v_min < FLT_MAX))

	ucomiss	xmm2, xmm8
	jp	SHORT $LN2@DragBehavi
	jne	SHORT $LN2@DragBehavi
	test	r15b, r15b
	je	SHORT $LN2@DragBehavi
	movsd	xmm0, QWORD PTR __real@47efffffe0000000
	movaps	xmm1, xmm11
	subsd	xmm1, xmm3
	comisd	xmm0, xmm1
	jbe	SHORT $LN2@DragBehavi

; 2247 :         v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

	movss	xmm0, DWORD PTR [rbx+23932]
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	cvtpd2ps xmm9, xmm0
$LN2@DragBehavi:

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	mov	eax, DWORD PTR [rbx+16544]
	xorps	xmm6, xmm6
	cmp	eax, 1
	jne	$LN3@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9028 :     ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;

	movss	xmm0, DWORD PTR [rbx+3592]

; 9029 :     return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;

	movss	xmm1, DWORD PTR __real@c87a0000
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [rbx+3596]
	jb	$LN54@DragBehavi
	comiss	xmm2, xmm1
	jb	$LN54@DragBehavi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	movss	xmm0, DWORD PTR [rbx+116]
	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3f000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8992 :     if (lock_threshold < 0.0f)

	comiss	xmm8, xmm1
	jbe	SHORT $LN62@DragBehavi

; 8993 :         lock_threshold = g.IO.MouseDragThreshold;

	movaps	xmm1, xmm0
$LN62@DragBehavi:

; 8994 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [rbx+14288]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2251 :     if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))

	jb	$LN54@DragBehavi

; 2252 :     {
; 2253 :         adjust_delta = g.IO.MouseDelta[axis];
; 2254 :         if (g.IO.KeyAlt)

	cmp	BYTE PTR [rbx+3626], 0
	movss	xmm6, DWORD PTR [rbx+248]
	je	SHORT $LN5@DragBehavi

; 2255 :             adjust_delta *= 1.0f / 100.0f;

	mulss	xmm6, DWORD PTR __real@3c23d70a
$LN5@DragBehavi:

; 2256 :         if (g.IO.KeyShift)

	cmp	BYTE PTR [rbx+3625], 0
	je	$LN54@DragBehavi

; 2257 :             adjust_delta *= 10.0f;

	mulss	xmm6, DWORD PTR __real@41200000

; 2258 :     }

	jmp	$LN54@DragBehavi
$LN3@DragBehavi:

; 2259 :     else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)

	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	$LN54@DragBehavi
	mov	QWORD PTR [rsp+136], rsi
	mov	QWORD PTR [rsp+128], rdi
	movaps	XMMWORD PTR [rsp+96], xmm7

; 2260 :     {
; 2261 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;

	test	r14b, r14b
	je	SHORT $LN31@DragBehavi
	mov	rcx, r12
	call	?ImParseFormatPrecision@@YAHPEBDH@Z	; ImParseFormatPrecision
	mov	edi, eax
	jmp	SHORT $LN32@DragBehavi
$LN31@DragBehavi:
	xor	edi, edi
$LN32@DragBehavi:

; 2262 :         const bool tweak_slow = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow);
; 2263 :         const bool tweak_fast = IsKeyDown((g.NavInputSource == ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast);

	mov	r11d, DWORD PTR [rbx+19148]
	mov	ecx, 8192				; 00002000H
	mov	eax, 628				; 00000274H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown
	movzx	esi, al
	mov	ecx, 4096				; 00001000H
	mov	eax, 627				; 00000273H
	cmp	r11d, 3
	cmove	ecx, eax
	call	?IsKeyDown@ImGui@@YA_NW4ImGuiKey@@@Z	; ImGui::IsKeyDown

; 2264 :         const float tweak_factor = tweak_slow ? 1.0f / 1.0f : tweak_fast ? 10.0f : 1.0f;

	test	al, al
	jne	SHORT $LN33@DragBehavi
	test	sil, sil
	je	SHORT $LN33@DragBehavi
	movss	xmm7, DWORD PTR __real@41200000
	jmp	SHORT $LN34@DragBehavi
$LN33@DragBehavi:

; 2265 :         adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor;

	movss	xmm7, DWORD PTR __real@3f800000
$LN34@DragBehavi:
	call	?GetNavTweakPressedAmount@ImGui@@YAMW4ImGuiAxis@@@Z ; ImGui::GetNavTweakPressedAmount
	mov	rsi, QWORD PTR [rsp+136]
	movaps	xmm6, xmm0
	mulss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+96]

; 2186 :     if (decimal_precision < 0)

	test	edi, edi
	jns	SHORT $LN45@DragBehavi

; 2187 :         return FLT_MIN;

	movss	xmm0, DWORD PTR __real@00800000
	jmp	SHORT $LN48@DragBehavi
$LN45@DragBehavi:

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	cmp	edi, 10
	jge	SHORT $LN47@DragBehavi
	movsxd	rax, edi
	lea	rcx, OFFSET FLAT:?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
	movss	xmm0, DWORD PTR [rcx+rax*4]
	jmp	SHORT $LN48@DragBehavi
$LN47@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	movss	xmm0, DWORD PTR __real@41200000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2188 :     return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);

	neg	edi
	movd	xmm1, edi
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 436  : static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision

	call	powf
$LN48@DragBehavi:

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm9, xmm0
	mov	rdi, QWORD PTR [rsp+128]
	jae	SHORT $LN54@DragBehavi
	movaps	xmm9, xmm0
$LN54@DragBehavi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2268 :     adjust_delta *= v_speed;

	mulss	xmm6, xmm9
	movaps	xmm9, XMMWORD PTR [rsp+64]

; 2269 : 
; 2270 :     // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
; 2271 :     if (axis == ImGuiAxis_Y)
; 2272 :         adjust_delta = -adjust_delta;
; 2273 : 
; 2274 :     // For logarithmic use our range is effectively 0..1 so scale the delta into that range
; 2275 :     if (is_logarithmic && (v_max - v_min < FLT_MAX) && ((v_max - v_min) > 0.000001f)) // Epsilon to avoid /0
; 2276 :         adjust_delta /= (float)(v_max - v_min);
; 2277 : 
; 2278 :     // Clear current value on activation
; 2279 :     // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
; 2280 :     bool is_just_activated = g.ActiveIdIsJustActivated;
; 2281 :     bool is_already_past_limits_and_pushing_outward = is_clamped && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));

	test	r15b, r15b
	je	SHORT $LN40@DragBehavi
	movsd	xmm0, QWORD PTR [rbp]
	comisd	xmm0, xmm11
	jb	SHORT $LN37@DragBehavi
	comiss	xmm6, xmm8
	ja	SHORT $LN39@DragBehavi
$LN37@DragBehavi:
	comisd	xmm12, xmm0
	jb	SHORT $LN40@DragBehavi
	comiss	xmm8, xmm6
	jbe	SHORT $LN40@DragBehavi
$LN39@DragBehavi:
	mov	al, 1
	jmp	SHORT $LN41@DragBehavi
$LN40@DragBehavi:
	xor	al, al
$LN41@DragBehavi:

; 2282 :     if (is_just_activated || is_already_past_limits_and_pushing_outward)

	cmp	BYTE PTR [rbx+16516], 0
	jne	SHORT $LN13@DragBehavi
	test	al, al
	jne	SHORT $LN13@DragBehavi

; 2286 :     }
; 2287 :     else if (adjust_delta != 0.0f)

	ucomiss	xmm6, xmm8
	jp	SHORT $LN212@DragBehavi
	je	SHORT $LN14@DragBehavi
$LN212@DragBehavi:

; 2288 :     {
; 2289 :         g.DragCurrentAccum += adjust_delta;

	movaps	xmm0, xmm6

; 2290 :         g.DragCurrentAccumDirty = true;

	mov	BYTE PTR [rbx+23925], 1
	addss	xmm0, DWORD PTR [rbx+23928]
	movss	DWORD PTR [rbx+23928], xmm0
	jmp	SHORT $LN14@DragBehavi
$LN13@DragBehavi:

; 2283 :     {
; 2284 :         g.DragCurrentAccum = 0.0f;

	mov	DWORD PTR [rbx+23928], 0

; 2285 :         g.DragCurrentAccumDirty = false;

	mov	BYTE PTR [rbx+23925], 0
$LN14@DragBehavi:

; 2291 :     }
; 2292 : 
; 2293 :     if (!g.DragCurrentAccumDirty)

	cmp	BYTE PTR [rbx+23925], 0
	je	$LN205@DragBehavi

; 2294 :         return false;
; 2295 : 
; 2296 :     TYPE v_cur = *v;

	movss	xmm0, DWORD PTR [rbx+23928]
	movsd	xmm3, QWORD PTR [rbp]

; 2297 :     FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;
; 2298 : 
; 2299 :     float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
; 2300 :     const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
; 2301 :     if (is_logarithmic)
; 2302 :     {
; 2303 :         // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
; 2304 :         const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
; 2305 :         logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
; 2306 : 
; 2307 :         // Convert to parametric space, apply delta, convert back
; 2308 :         float v_old_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2309 :         float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
; 2310 :         v_cur = ScaleValueFromRatioT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2311 :         v_old_ref_for_accum_remainder = v_old_parametric;
; 2312 :     }
; 2313 :     else
; 2314 :     {
; 2315 :         v_cur += (SIGNEDTYPE)g.DragCurrentAccum;

	cvtps2pd xmm0, xmm0
	addsd	xmm3, xmm0

; 2316 :     }
; 2317 : 
; 2318 :     // Round to user desired precision based on format string
; 2319 :     if (is_floating_point && !(flags & ImGuiSliderFlags_NoRoundToFormat))

	test	r14b, r14b
	je	SHORT $LN18@DragBehavi

; 2320 :         v_cur = RoundScalarWithFormatT<TYPE>(format, data_type, v_cur);

	movaps	xmm2, xmm3
	mov	rcx, r12
	call	??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z ; ImGui::RoundScalarWithFormatT<double>
	movaps	xmm3, xmm0
$LN18@DragBehavi:

; 2321 : 
; 2322 :     // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
; 2323 :     g.DragCurrentAccumDirty = false;
; 2324 :     if (is_logarithmic)
; 2325 :     {
; 2326 :         // Convert to parametric space, apply delta, convert back
; 2327 :         float v_new_parametric = ScaleRatioFromValueT<TYPE, SIGNEDTYPE, FLOATTYPE>(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
; 2328 :         g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
; 2329 :     }
; 2330 :     else
; 2331 :     {
; 2332 :         g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);

	movss	xmm2, DWORD PTR [rbx+23928]
	movaps	xmm0, xmm3
	mov	BYTE PTR [rbx+23925], 0
	xorps	xmm1, xmm1
	subsd	xmm0, QWORD PTR [rbp]
	cvtsd2ss xmm1, xmm0
	xorps	xmm0, xmm0

; 2333 :     }
; 2334 : 
; 2335 :     // Lose zero sign for float/double
; 2336 :     if (v_cur == (TYPE)-0)

	ucomisd	xmm3, xmm0
	subss	xmm2, xmm1
	movss	DWORD PTR [rbx+23928], xmm2
	jp	SHORT $LN21@DragBehavi
	jne	SHORT $LN21@DragBehavi
	xorps	xmm3, xmm3
$LN21@DragBehavi:

; 2337 :         v_cur = (TYPE)0;
; 2338 : 
; 2339 :     // Clamp values (+ handle overflow/wrap-around for integer types)
; 2340 :     if (*v != v_cur && is_clamped)

	movsd	xmm0, QWORD PTR [rbp]
	ucomisd	xmm0, xmm3
	jp	SHORT $LN211@DragBehavi
	je	SHORT $LN205@DragBehavi
$LN211@DragBehavi:
	test	r15b, r15b
	je	SHORT $LN25@DragBehavi

; 2341 :     {
; 2342 :         if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_floating_point))

	comisd	xmm12, xmm3
	ja	SHORT $LN24@DragBehavi
	comisd	xmm3, xmm0
	jbe	SHORT $LN23@DragBehavi
	comiss	xmm8, xmm6
	jbe	SHORT $LN23@DragBehavi
	test	r14b, r14b
	jne	SHORT $LN23@DragBehavi
$LN24@DragBehavi:

; 2343 :             v_cur = v_min;

	movaps	xmm3, xmm12
$LN23@DragBehavi:

; 2344 :         if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_floating_point))

	comisd	xmm3, xmm11
	ja	SHORT $LN26@DragBehavi
	comisd	xmm0, xmm3
	jbe	SHORT $LN25@DragBehavi
	comiss	xmm6, xmm8
	jbe	SHORT $LN25@DragBehavi
	test	r14b, r14b
	jne	SHORT $LN25@DragBehavi
$LN26@DragBehavi:

; 2345 :             v_cur = v_max;

	movaps	xmm3, xmm11
$LN25@DragBehavi:

; 2346 :     }
; 2347 : 
; 2348 :     // Apply result
; 2349 :     if (*v == v_cur)

	ucomisd	xmm0, xmm3
	jp	SHORT $LN210@DragBehavi
	je	SHORT $LN205@DragBehavi
$LN210@DragBehavi:

; 2351 :     *v = v_cur;

	movsd	QWORD PTR [rbp], xmm3

; 2352 :     return true;

	mov	al, 1
	jmp	SHORT $LN1@DragBehavi
$LN205@DragBehavi:

; 2350 :         return false;

	xor	al, al
$LN1@DragBehavi:

; 2353 : }

	movaps	xmm6, XMMWORD PTR [rsp+112]
	movaps	xmm8, XMMWORD PTR [rsp+80]
	movaps	xmm11, XMMWORD PTR [rsp+48]
	movaps	xmm12, XMMWORD PTR [rsp+32]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
??$DragBehaviorT@NNN@ImGui@@YA_NHPEANMNNPEBDH@Z ENDP	; ImGui::DragBehaviorT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@H@@YAHHH@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	ecx, edx
	cmovge	edx, ecx
	mov	eax, edx
	ret	0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@_K@@YA_K_K0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@_K@@YA_K_K0@Z PROC				; ImMin<unsigned __int64>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	rcx, rdx
	cmovb	rdx, rcx
	mov	rax, rdx
	ret	0
??$ImMin@_K@@YA_K_K0@Z ENDP				; ImMin<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ImAtoi@H@@YAPEBDPEBDPEAH@Z
_TEXT	SEGMENT
src$ = 8
output$ = 16
??$ImAtoi@H@@YAPEBDPEBDPEAH@Z PROC			; ImAtoi<int>, COMDAT

; 3337 : {

	mov	QWORD PTR [rsp+8], rbx

; 3338 :     int negative = 0;
; 3339 :     if (*src == '-') { negative = 1; src++; }

	movzx	r9d, BYTE PTR [rcx]
	xor	r8d, r8d
	mov	rbx, rdx
	mov	rax, rcx
	mov	r11d, r8d
	cmp	r9b, 45					; 0000002dH
	jne	SHORT $LN4@ImAtoi
	movzx	r9d, BYTE PTR [rcx+1]
	lea	r11d, QWORD PTR [r8+1]
$LN4@ImAtoi:

; 3340 :     if (*src == '+') { src++; }

	lea	rcx, QWORD PTR [rcx+1]
	cmovne	rcx, rax
	movzx	eax, r9b
	cmp	r9b, 43					; 0000002bH
	jne	SHORT $LN5@ImAtoi
	movzx	eax, BYTE PTR [rcx+1]
$LN5@ImAtoi:

; 3341 :     TYPE v = 0;

	lea	rdx, QWORD PTR [rcx+1]
	cmovne	rdx, rcx

; 3342 :     while (*src >= '0' && *src <= '9')

	cmp	al, 48					; 00000030H
	jl	SHORT $LN13@ImAtoi
$LL2@ImAtoi:
	cmp	al, 57					; 00000039H
	ja	SHORT $LN13@ImAtoi

; 3343 :         v = (v * 10) + (*src++ - '0');

	movzx	eax, al
	lea	r8d, DWORD PTR [r8+r8*4]
	inc	rdx
	lea	r8d, DWORD PTR [r8-24]
	lea	r8d, DWORD PTR [rax+r8*2]
	movzx	eax, BYTE PTR [rdx]
	cmp	al, 48					; 00000030H
	jge	SHORT $LL2@ImAtoi
$LN13@ImAtoi:

; 3344 :     *output = negative ? -v : v;

	mov	ecx, r8d

; 3345 :     return src;

	mov	rax, rdx
	neg	ecx
	test	r11d, r11d
	cmove	ecx, r8d
	mov	DWORD PTR [rbx], ecx

; 3346 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$ImAtoi@H@@YAPEBDPEBDPEAH@Z ENDP			; ImAtoi<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@PEBX@@YAXAEAPEBX0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@PEBX@@YAXAEAPEBX0@Z PROC			; ImSwap<void const *>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rdx], r8
	ret	0
??$ImSwap@PEBX@@YAXAEAPEBX0@Z ENDP			; ImSwap<void const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@H@@YAXAEAH0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@H@@YAXAEAH0@Z PROC				; ImSwap<int>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	r8d, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rdx], r8d
	ret	0
??$ImSwap@H@@YAXAEAH0@Z ENDP				; ImSwap<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@G@@YAGGG@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@G@@YAGGG@Z PROC				; ImMax<unsigned short>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	cx, dx
	cmovae	dx, cx
	movzx	eax, dx
	ret	0
??$ImMax@G@@YAGGG@Z ENDP				; ImMax<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@I@@YAIII@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@I@@YAIII@Z PROC				; ImMax<unsigned int>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	cmp	ecx, edx
	cmovae	edx, ecx
	mov	eax, edx
	ret	0
??$ImMax@I@@YAIII@Z ENDP				; ImMax<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@HHM@ImGui@@YAMHHHH_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@HHM@ImGui@@YAMHHHH_NMM@Z PROC	; ImGui::ScaleRatioFromValueT<int,int,float>, COMDAT

; 2651 :     if (v_min == v_max)

	cmp	r8d, r9d
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jge	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, r8d
	jge	SHORT $LN37@ScaleRatio
	mov	edx, r8d
	jmp	SHORT $LN3@ScaleRatio
$LN37@ScaleRatio:
	cmp	edx, r9d
	cmovg	edx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN3@ScaleRatio
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, r9d
	jge	SHORT $LN41@ScaleRatio
	mov	edx, r9d
	jmp	SHORT $LN3@ScaleRatio
$LN41@ScaleRatio:
	cmp	edx, r8d
	cmovg	edx, r8d
$LN3@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	sub	edx, r8d
	sub	r9d, r8d
	movd	xmm0, edx
	movd	xmm1, r9d
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	divss	xmm0, xmm1

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@HHM@ImGui@@YAMHHHH_NMM@Z ENDP	; ImGui::ScaleRatioFromValueT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@HHM@ImGui@@YAHHMHH_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@HHM@ImGui@@YAHHMHH_NMM@Z PROC	; ImGui::ScaleValueFromRatioT<int,int,float>, COMDAT

; 2707 : {

	movaps	xmm2, xmm1
	xorps	xmm0, xmm0

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm2
	mov	eax, ecx
	jae	$LN3@ScaleValue
	cmp	r8d, r9d
	je	SHORT $LN3@ScaleValue

; 2712 :     if (t >= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm2, xmm0
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	mov	eax, r9d

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;

	xor	ecx, ecx

; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	add	eax, -8					; fffffff8H
	cmp	eax, 1
	ja	SHORT $LN18@ScaleValue
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	r9d, r8d
	movd	xmm0, r8d
	cvtdq2ps xmm0, xmm0
	movd	xmm1, r9d
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	mov	eax, ecx

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm0, xmm2
	jbe	SHORT $LN20@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;

	mov	eax, r9d
	sub	eax, r8d
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	cmp	r8d, r9d
	jle	SHORT $LN34@ScaleValue
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	jmp	SHORT $LN35@ScaleValue
$LN34@ScaleValue:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
$LN35@ScaleValue:
	cvtpd2ps xmm0, xmm0
	addss	xmm0, xmm1
	cvttss2si ecx, xmm0
	add	ecx, r8d
$LN20@ScaleValue:

; 2768 :     return result;

	mov	eax, ecx

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	mov	eax, r8d

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@HHM@ImGui@@YAHHMHH_NMM@Z ENDP	; ImGui::ScaleValueFromRatioT<int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z PROC	; ImGui::RoundScalarWithFormatT<int>, COMDAT

; 2193 : {

$LN45:
	push	rbx
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx
	mov	ebx, r8d

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN34@RoundScala
	npad	8
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN43@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN34@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN43@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN34@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	SHORT $LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	1
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9d, ebx

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof
	cvttsd2si eax, xmm0

; 2212 : 
; 2213 :     return v;

	jmp	SHORT $LN1@RoundScala
$LN5@RoundScala:

; 2198 :         return v;

	mov	eax, ebx
$LN1@RoundScala:

; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
??$RoundScalarWithFormatT@H@ImGui@@YAHPEBDHH@Z ENDP	; ImGui::RoundScalarWithFormatT<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@IHM@ImGui@@YAMHIII_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@IHM@ImGui@@YAMHIII_NMM@Z PROC	; ImGui::ScaleRatioFromValueT<unsigned int,int,float>, COMDAT

; 2651 :     if (v_min == v_max)

	cmp	r8d, r9d
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jae	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, r8d
	jae	SHORT $LN37@ScaleRatio
	mov	edx, r8d
	jmp	SHORT $LN3@ScaleRatio
$LN37@ScaleRatio:
	cmp	edx, r9d
	cmova	edx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN3@ScaleRatio
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, r9d
	jae	SHORT $LN41@ScaleRatio
	mov	edx, r9d
	jmp	SHORT $LN3@ScaleRatio
$LN41@ScaleRatio:
	cmp	edx, r8d
	cmova	edx, r8d
$LN3@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	sub	edx, r8d
	sub	r9d, r8d
	movd	xmm0, edx
	movd	xmm1, r9d
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm1, xmm1
	divss	xmm0, xmm1

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@IHM@ImGui@@YAMHIII_NMM@Z ENDP	; ImGui::ScaleRatioFromValueT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@IHM@ImGui@@YAIHMII_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@IHM@ImGui@@YAIHMII_NMM@Z PROC	; ImGui::ScaleValueFromRatioT<unsigned int,int,float>, COMDAT

; 2707 : {

	movaps	xmm2, xmm1
	xorps	xmm0, xmm0

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm2
	mov	eax, ecx
	jae	$LN3@ScaleValue
	cmp	r8d, r9d
	je	$LN3@ScaleValue

; 2712 :     if (t >= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm2, xmm0
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	mov	eax, r9d

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;

	xor	ecx, ecx

; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	add	eax, -8					; fffffff8H
	cmp	eax, 1
	ja	SHORT $LN18@ScaleValue
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	r9d, r8d
	mov	eax, r9d
	xorps	xmm0, xmm0
	cvtsi2ss xmm1, rax
	mov	eax, r8d
	cvtsi2ss xmm0, rax
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si rcx, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	mov	eax, ecx

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm0, xmm2
	jbe	SHORT $LN20@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;

	mov	eax, r9d
	sub	eax, r8d
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	cmp	r8d, r9d
	jbe	SHORT $LN34@ScaleValue
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	jmp	SHORT $LN35@ScaleValue
$LN34@ScaleValue:
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
$LN35@ScaleValue:
	cvtpd2ps xmm0, xmm0
	addss	xmm0, xmm1
	cvttss2si ecx, xmm0
	add	ecx, r8d
$LN20@ScaleValue:

; 2768 :     return result;

	mov	eax, ecx

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	mov	eax, r8d

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@IHM@ImGui@@YAIHMII_NMM@Z ENDP	; ImGui::ScaleValueFromRatioT<unsigned int,int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z PROC	; ImGui::RoundScalarWithFormatT<unsigned int>, COMDAT

; 2193 : {

$LN45:
	push	rbx
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx
	mov	ebx, r8d

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN34@RoundScala
	npad	8
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN43@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN34@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN43@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN34@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	$LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	13
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9d, ebx

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof
	cvttsd2si rax, xmm0

; 2212 : 
; 2213 :     return v;

	jmp	SHORT $LN1@RoundScala
$LN5@RoundScala:

; 2198 :         return v;

	mov	eax, ebx
$LN1@RoundScala:

; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
??$RoundScalarWithFormatT@I@ImGui@@YAIPEBDHI@Z ENDP	; ImGui::RoundScalarWithFormatT<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@_J_JN@ImGui@@YAMH_J00_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@_J_JN@ImGui@@YAMH_J00_NMM@Z PROC ; ImGui::ScaleRatioFromValueT<__int64,__int64,double>, COMDAT

; 2651 :     if (v_min == v_max)

	cmp	r8, r9
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jge	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rdx, r8
	jge	SHORT $LN37@ScaleRatio
	mov	rdx, r8
	jmp	SHORT $LN3@ScaleRatio
$LN37@ScaleRatio:
	cmp	rdx, r9
	cmovg	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN3@ScaleRatio
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rdx, r9
	jge	SHORT $LN41@ScaleRatio
	mov	rdx, r9
	jmp	SHORT $LN3@ScaleRatio
$LN41@ScaleRatio:
	cmp	rdx, r8
	cmovg	rdx, r8
$LN3@ScaleRatio:
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	sub	rdx, r8
	sub	r9, r8
	cvtsi2sd xmm1, rdx
	cvtsi2sd xmm0, r9
	divsd	xmm1, xmm0
	cvtpd2ps xmm0, xmm1

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@_J_JN@ImGui@@YAMH_J00_NMM@Z ENDP ; ImGui::ScaleRatioFromValueT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@_J_JN@ImGui@@YA_JHM_J0_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@_J_JN@ImGui@@YA_JHM_J0_NMM@Z PROC ; ImGui::ScaleValueFromRatioT<__int64,__int64,double>, COMDAT

; 2707 : {

	movaps	xmm2, xmm1
	xorps	xmm0, xmm0

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm2
	mov	eax, ecx
	jae	$LN3@ScaleValue
	cmp	r8, r9
	je	$LN3@ScaleValue

; 2712 :     if (t >= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm2, xmm0
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	mov	rax, r9

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;

	xor	ecx, ecx

; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	add	eax, -8					; fffffff8H
	cmp	eax, 1
	ja	SHORT $LN18@ScaleValue
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	r9, r8
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, r8
	cvtsi2ss xmm1, r9
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si rcx, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm0, xmm2
	jbe	SHORT $LN20@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;

	xorps	xmm0, xmm0
	mov	rax, r9
	sub	rax, r8
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm2
	cvtps2pd xmm1, xmm0

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	cmp	r8, r9
	jle	SHORT $LN34@ScaleValue
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	addsd	xmm0, xmm1
	cvttsd2si rcx, xmm0
	add	rcx, r8

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN34@ScaleValue:

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm0, xmm1
	cvttsd2si rcx, xmm0
	add	rcx, r8
$LN20@ScaleValue:

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	mov	rax, r8

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@_J_JN@ImGui@@YA_JHM_J0_NMM@Z ENDP ; ImGui::ScaleValueFromRatioT<__int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z PROC	; ImGui::RoundScalarWithFormatT<__int64>, COMDAT

; 2193 : {

$LN45:
	push	rbx
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx
	mov	rbx, r8

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN34@RoundScala
	npad	8
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN43@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN34@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN43@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN34@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	$LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	13
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9, rbx

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof
	cvttsd2si rax, xmm0

; 2212 : 
; 2213 :     return v;

	jmp	SHORT $LN1@RoundScala
$LN5@RoundScala:

; 2198 :         return v;

	mov	rax, rbx
$LN1@RoundScala:

; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
??$RoundScalarWithFormatT@_J@ImGui@@YA_JPEBDH_J@Z ENDP	; ImGui::RoundScalarWithFormatT<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@_K_JN@ImGui@@YAMH_K00_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@_K_JN@ImGui@@YAMH_K00_NMM@Z PROC ; ImGui::ScaleRatioFromValueT<unsigned __int64,__int64,double>, COMDAT

; 2651 :     if (v_min == v_max)

	cmp	r8, r9
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jae	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rdx, r8
	jae	SHORT $LN37@ScaleRatio
	mov	rdx, r8
	jmp	SHORT $LN3@ScaleRatio
$LN37@ScaleRatio:
	cmp	rdx, r9
	cmova	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN3@ScaleRatio
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rdx, r9
	jae	SHORT $LN41@ScaleRatio
	mov	rdx, r9
	jmp	SHORT $LN3@ScaleRatio
$LN41@ScaleRatio:
	cmp	rdx, r8
	cmova	rdx, r8
$LN3@ScaleRatio:
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	sub	rdx, r8
	sub	r9, r8
	cvtsi2sd xmm1, rdx
	cvtsi2sd xmm0, r9
	divsd	xmm1, xmm0
	cvtpd2ps xmm0, xmm1

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@_K_JN@ImGui@@YAMH_K00_NMM@Z ENDP ; ImGui::ScaleRatioFromValueT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@_K_JN@ImGui@@YA_KHM_K0_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@_K_JN@ImGui@@YA_KHM_K0_NMM@Z PROC ; ImGui::ScaleValueFromRatioT<unsigned __int64,__int64,double>, COMDAT

; 2707 : {

	xorps	xmm0, xmm0
	mov	eax, ecx

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm1
	jae	$LN3@ScaleValue
	cmp	r8, r9
	je	$LN3@ScaleValue

; 2712 :     if (t >= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	mov	rax, r9

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;

	xor	ecx, ecx

; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	add	eax, -8					; fffffff8H
	cmp	eax, 1
	ja	$LN18@ScaleValue
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	r9, r8
	xorps	xmm0, xmm0
	js	SHORT $LN63@ScaleValue
	cvtsi2ss xmm0, r9
	jmp	SHORT $LN64@ScaleValue
$LN63@ScaleValue:
	mov	rax, r9
	and	r9d, 1
	shr	rax, 1
	or	rax, r9
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN64@ScaleValue:
	mulss	xmm0, xmm1
	xorps	xmm1, xmm1
	test	r8, r8
	js	SHORT $LN61@ScaleValue
	cvtsi2ss xmm1, r8
	jmp	SHORT $LN62@ScaleValue
$LN61@ScaleValue:
	mov	rax, r8
	and	r8d, 1
	shr	rax, 1
	or	rax, r8
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN62@ScaleValue:
	addss	xmm0, xmm1
	xor	eax, eax
	movss	xmm1, DWORD PTR __real@5f000000
	comiss	xmm0, xmm1
	jb	SHORT $LN60@ScaleValue
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN60@ScaleValue
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN60@ScaleValue:
	cvttss2si rcx, xmm0
	add	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm0, xmm1
	jbe	SHORT $LN20@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;

	xorps	xmm0, xmm0
	mov	rax, r9
	sub	rax, r8
	cvtsi2ss xmm0, rax
	mulss	xmm0, xmm1
	cvtps2pd xmm2, xmm0

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	cmp	r8, r9
	jbe	SHORT $LN34@ScaleValue
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	addsd	xmm0, xmm2
	cvttsd2si rcx, xmm0
	add	rcx, r8

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN34@ScaleValue:

; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm0, xmm2
	cvttsd2si rcx, xmm0
	add	rcx, r8
$LN20@ScaleValue:

; 2768 :     return result;

	mov	rax, rcx

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	mov	rax, r8

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@_K_JN@ImGui@@YA_KHM_K0_NMM@Z ENDP ; ImGui::ScaleValueFromRatioT<unsigned __int64,__int64,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z PROC	; ImGui::RoundScalarWithFormatT<unsigned __int64>, COMDAT

; 2193 : {

$LN48:
	push	rbx
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx
	mov	rbx, r8

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN35@RoundScala
	npad	8
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN46@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN35@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN46@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN35@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	$LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	13
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	mov	r9, rbx

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof
	movsd	xmm1, QWORD PTR __real@43e0000000000000
	xor	ecx, ecx
	comisd	xmm0, xmm1
	jb	SHORT $LN34@RoundScala
	subsd	xmm0, xmm1
	comisd	xmm0, xmm1
	jae	SHORT $LN34@RoundScala
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN34@RoundScala:
	cvttsd2si rax, xmm0
	add	rax, rcx

; 2212 : 
; 2213 :     return v;

	jmp	SHORT $LN1@RoundScala
$LN5@RoundScala:

; 2198 :         return v;

	mov	rax, rbx
$LN1@RoundScala:

; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	rbx
	ret	0
??$RoundScalarWithFormatT@_K@ImGui@@YA_KPEBDH_K@Z ENDP	; ImGui::RoundScalarWithFormatT<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@MMM@ImGui@@YAMHMMM_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@MMM@ImGui@@YAMHMMM_NMM@Z PROC	; ImGui::ScaleRatioFromValueT<float,float,float>, COMDAT

; 2651 :     if (v_min == v_max)

	ucomiss	xmm2, xmm3
	jp	SHORT $LN2@ScaleRatio
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2652 :         return 0.0f;
; 2653 :     IM_UNUSED(data_type);
; 2654 : 
; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	comiss	xmm3, xmm2
	jbe	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm1
	jbe	SHORT $LN39@ScaleRatio
	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subss	xmm3, xmm2
	subss	xmm0, xmm2
	divss	xmm0, xmm3

; 2701 :     }
; 2702 : }

	ret	0
$LN39@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subss	xmm3, xmm2
	minss	xmm0, xmm1
	subss	xmm0, xmm2
	divss	xmm0, xmm3

; 2701 :     }
; 2702 : }

	ret	0
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm1
	jbe	SHORT $LN45@ScaleRatio
	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subss	xmm3, xmm2
	subss	xmm0, xmm2
	divss	xmm0, xmm3

; 2701 :     }
; 2702 : }

	ret	0
$LN45@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subss	xmm3, xmm2
	minss	xmm0, xmm1
	subss	xmm0, xmm2
	divss	xmm0, xmm3

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@MMM@ImGui@@YAMHMMM_NMM@Z ENDP	; ImGui::ScaleRatioFromValueT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@MMM@ImGui@@YAMHMMM_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@MMM@ImGui@@YAMHMMM_NMM@Z PROC	; ImGui::ScaleValueFromRatioT<float,float,float>, COMDAT

; 2707 : {

	movaps	xmm4, xmm1
	xorps	xmm0, xmm0

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm4
	jae	SHORT $LN3@ScaleValue
	ucomiss	xmm2, xmm3
	jp	SHORT $LN66@ScaleValue
	je	SHORT $LN3@ScaleValue
$LN66@ScaleValue:

; 2712 :     if (t >= 1.0f)

	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm4, xmm1
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	movaps	xmm0, xmm3

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;
; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	cmp	eax, 1
	ja	SHORT $LN18@ScaleValue
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movaps	xmm0, xmm3
	subss	xmm0, xmm2
	mulss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	addss	xmm0, xmm2

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm1, xmm4
	jbe	SHORT $LN1@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	comiss	xmm2, xmm3
	movaps	xmm1, xmm3
	subss	xmm1, xmm2
	mulss	xmm1, xmm4
	jbe	SHORT $LN34@ScaleValue
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	cvtpd2ps xmm0, xmm0
	addss	xmm0, xmm1

; 2768 :     return result;

	addss	xmm0, xmm2

; 2769 : }

	ret	0
$LN34@ScaleValue:

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtpd2ps xmm0, xmm0
	addss	xmm0, xmm1

; 2768 :     return result;

	addss	xmm0, xmm2

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	movaps	xmm0, xmm2
$LN1@ScaleValue:

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@MMM@ImGui@@YAMHMMM_NMM@Z ENDP	; ImGui::ScaleValueFromRatioT<float,float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z PROC	; ImGui::RoundScalarWithFormatT<float>, COMDAT

; 2193 : {

$LN37:
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN9@RoundScala
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN35@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN9@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN35@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN9@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	$LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	10
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	xorps	xmm3, xmm3

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	cvtss2sd xmm3, xmm2
	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	movq	r9, xmm3
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof
	cvtsd2ss xmm0, xmm0

; 2212 : 
; 2213 :     return v;
; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
$LN5@RoundScala:

; 2198 :         return v;

	movaps	xmm0, xmm2

; 2212 : 
; 2213 :     return v;
; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
??$RoundScalarWithFormatT@M@ImGui@@YAMPEBDHM@Z ENDP	; ImGui::RoundScalarWithFormatT<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleRatioFromValueT@NNN@ImGui@@YAMHNNN_NMM@Z
_TEXT	SEGMENT
data_type$dead$ = 8
v$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleRatioFromValueT@NNN@ImGui@@YAMHNNN_NMM@Z PROC	; ImGui::ScaleRatioFromValueT<double,double,double>, COMDAT

; 2651 :     if (v_min == v_max)

	ucomisd	xmm2, xmm3
	jp	SHORT $LN2@ScaleRatio
	jne	SHORT $LN2@ScaleRatio
	xorps	xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN2@ScaleRatio:

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	comisd	xmm3, xmm2
	jbe	SHORT $LN23@ScaleRatio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comisd	xmm2, xmm1
	jbe	SHORT $LN39@ScaleRatio
	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subsd	xmm3, xmm2
	subsd	xmm0, xmm2
	divsd	xmm0, xmm3
	cvtsd2ss xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN39@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2655 :     const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN69@ScaleRatio
$LN23@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comisd	xmm3, xmm1
	jbe	SHORT $LN45@ScaleRatio
	movaps	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	subsd	xmm3, xmm2
	subsd	xmm0, xmm2
	divsd	xmm0, xmm3
	cvtsd2ss xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
$LN45@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movaps	xmm0, xmm2
$LN69@ScaleRatio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2700 :         return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));

	minsd	xmm0, xmm1
	subsd	xmm3, xmm2
	subsd	xmm0, xmm2
	divsd	xmm0, xmm3
	cvtsd2ss xmm0, xmm0

; 2701 :     }
; 2702 : }

	ret	0
??$ScaleRatioFromValueT@NNN@ImGui@@YAMHNNN_NMM@Z ENDP	; ImGui::ScaleRatioFromValueT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$ScaleValueFromRatioT@NNN@ImGui@@YANHMNN_NMM@Z
_TEXT	SEGMENT
data_type$ = 8
t$ = 16
v_min$ = 24
v_max$ = 32
is_logarithmic$dead$ = 40
logarithmic_zero_epsilon$dead$ = 48
zero_deadzone_halfsize$dead$ = 56
??$ScaleValueFromRatioT@NNN@ImGui@@YANHMNN_NMM@Z PROC	; ImGui::ScaleValueFromRatioT<double,double,double>, COMDAT

; 2707 : {

	movaps	xmm5, xmm1
	xorps	xmm0, xmm0

; 2708 :     // We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
; 2709 :     // but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
; 2710 :     if (t <= 0.0f || v_min == v_max)

	comiss	xmm0, xmm5
	jae	$LN3@ScaleValue
	ucomisd	xmm2, xmm3
	jp	SHORT $LN62@ScaleValue
	je	SHORT $LN3@ScaleValue
$LN62@ScaleValue:

; 2712 :     if (t >= 1.0f)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm5, xmm0
	jb	SHORT $LN4@ScaleValue

; 2713 :         return v_max;

	movaps	xmm0, xmm3

; 2769 : }

	ret	0
$LN4@ScaleValue:

; 2714 : 
; 2715 :     TYPE result = (TYPE)0;
; 2716 :     if (is_logarithmic)
; 2717 :     {
; 2718 :         // Fudge min/max to avoid getting silly results close to zero
; 2719 :         FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) < logarithmic_zero_epsilon) ? ((v_min < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
; 2720 :         FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) < logarithmic_zero_epsilon) ? ((v_max < 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;
; 2721 : 
; 2722 :         const bool flipped = v_max < v_min; // Check if range is "backwards"
; 2723 :         if (flipped)
; 2724 :             ImSwap(v_min_fudged, v_max_fudged);
; 2725 : 
; 2726 :         // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
; 2727 :         if ((v_max == 0.0f) && (v_min < 0.0f))
; 2728 :             v_max_fudged = -logarithmic_zero_epsilon;
; 2729 : 
; 2730 :         float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range
; 2731 : 
; 2732 :         if ((v_min * v_max) < 0.0f) // Range crosses zero, so we have to do this in two parts
; 2733 :         {
; 2734 :             float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
; 2735 :             float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
; 2736 :             float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
; 2737 :             if (t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R)
; 2738 :                 result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
; 2739 :             else if (t_with_flip < zero_point_center)
; 2740 :                 result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));
; 2741 :             else
; 2742 :                 result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
; 2743 :         }
; 2744 :         else if ((v_min < 0.0f) || (v_max < 0.0f)) // Entirely negative slider
; 2745 :             result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));
; 2746 :         else
; 2747 :             result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));
; 2748 :     }
; 2749 :     else
; 2750 :     {
; 2751 :         // Linear slider
; 2752 :         const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);

	lea	eax, DWORD PTR [rcx-8]
	xorps	xmm1, xmm1
	cmp	eax, 1
	ja	SHORT $LN18@ScaleValue
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	xorps	xmm0, xmm0
	movaps	xmm1, xmm3
	subsd	xmm1, xmm2
	cvtss2sd xmm0, xmm5
	mulsd	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 2768 :     return result;

	addsd	xmm1, xmm2
	movaps	xmm0, xmm1

; 2769 : }

	ret	0
$LN18@ScaleValue:

; 2753 :         if (is_floating_point)
; 2754 :         {
; 2755 :             result = ImLerp(v_min, v_max, t);
; 2756 :         }
; 2757 :         else if (t < 1.0)

	comiss	xmm0, xmm5
	jbe	SHORT $LN20@ScaleValue

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	comisd	xmm2, xmm3
	xorps	xmm0, xmm0
	movaps	xmm4, xmm3
	cvtss2sd xmm0, xmm5
	subsd	xmm4, xmm2
	mulsd	xmm4, xmm0
	jbe	SHORT $LN34@ScaleValue
	movsd	xmm1, QWORD PTR __real@bfe0000000000000
	addsd	xmm1, xmm4

; 2768 :     return result;

	addsd	xmm1, xmm2
	movaps	xmm0, xmm1

; 2769 : }

	ret	0
$LN34@ScaleValue:

; 2758 :         {
; 2759 :             // - For integer values we want the clicking position to match the grab box so we round above
; 2760 :             //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
; 2761 :             // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
; 2762 :             //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
; 2763 :             FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
; 2764 :             result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min > v_max ? -0.5 : 0.5)));

	movsd	xmm1, QWORD PTR __real@3fe0000000000000
	addsd	xmm1, xmm4

; 2768 :     return result;

	addsd	xmm1, xmm2
$LN20@ScaleValue:
	movaps	xmm0, xmm1

; 2769 : }

	ret	0
$LN3@ScaleValue:

; 2711 :         return v_min;

	movaps	xmm0, xmm2

; 2769 : }

	ret	0
??$ScaleValueFromRatioT@NNN@ImGui@@YANHMNN_NMM@Z ENDP	; ImGui::ScaleValueFromRatioT<double,double,double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
;	COMDAT ??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z
_TEXT	SEGMENT
fmt_sanitized$ = 32
v_str$ = 64
__$ArrayPad$ = 128
format$ = 160
data_type$dead$ = 168
v$ = 176
??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z PROC	; ImGui::RoundScalarWithFormatT<double>, COMDAT

; 2193 : {

$LN37:
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r10, rcx

; 3252 :     while (char c = fmt[0])

	movzx	ecx, BYTE PTR [rcx]
	test	cl, cl
	je	SHORT $LN9@RoundScala
$LL8@RoundScala:

; 3253 :     {
; 3254 :         if (c == '%' && fmt[1] != '%')

	lea	rax, QWORD PTR [r10+1]
	cmp	cl, 37					; 00000025H
	jne	SHORT $LN35@RoundScala
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LN9@RoundScala

; 3255 :             return fmt;
; 3256 :         else if (c == '%')
; 3257 :             fmt++;
; 3258 :         fmt++;

	cmp	cl, cl
$LN35@RoundScala:
	cmovne	rax, r10
	movzx	ecx, BYTE PTR [rax+1]
	lea	r10, QWORD PTR [rax+1]
	test	cl, cl
	jne	SHORT $LL8@RoundScala
$LN9@RoundScala:

; 2194 :     IM_UNUSED(data_type);
; 2195 :     IM_ASSERT(data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
; 2196 :     const char* fmt_start = ImParseFormatFindStart(format);
; 2197 :     if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string

	cmp	BYTE PTR [r10], 37			; 00000025H
	jne	$LN5@RoundScala
	cmp	BYTE PTR [r10+1], 37			; 00000025H
	je	$LN5@RoundScala

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	mov	rcx, r10

; 2199 : 
; 2200 :     // Sanitize format
; 2201 :     char fmt_sanitized[32];
; 2202 :     ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));

	lea	r11, QWORD PTR fmt_sanitized$[rsp]

; 3302 :     const char* fmt_end = ImParseFormatFindEnd(fmt_in);

	call	?ImParseFormatFindEnd@@YAPEBDPEBD@Z	; ImParseFormatFindEnd
	mov	r8, rax

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, rax
	jae	SHORT $LN16@RoundScala
	mov	r9, 576460752303423497			; 0800000000000009H
	npad	10
$LL15@RoundScala:

; 3306 :     {
; 3307 :         char c = *fmt_in++;

	movzx	edx, BYTE PTR [r10]
	inc	r10

; 3308 :         if (c != '\'' && c != '$' && c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.

	lea	ecx, DWORD PTR [rdx-36]
	cmp	cl, 59					; 0000003bH
	ja	SHORT $LN32@RoundScala
	bt	r9, rcx
	jb	SHORT $LN17@RoundScala
$LN32@RoundScala:

; 3309 :             *(fmt_out++) = c;

	mov	BYTE PTR [r11], dl
	inc	r11
$LN17@RoundScala:

; 3303 :     IM_UNUSED(fmt_out_size);
; 3304 :     IM_ASSERT((size_t)(fmt_end - fmt_in + 1) < fmt_out_size); // Format is too long, let us know if this happens to you!
; 3305 :     while (fmt_in < fmt_end)

	cmp	r10, r8
	jb	SHORT $LL15@RoundScala
$LN16@RoundScala:

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	movaps	xmm3, xmm2

; 3311 :     *fmt_out = 0; // Zero-terminate

	mov	BYTE PTR [r11], 0

; 2203 :     fmt_start = fmt_sanitized;
; 2204 : 
; 2205 :     // Format value with our rounding, and read back
; 2206 :     char v_str[64];
; 2207 :     ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);

	movq	r9, xmm2
	lea	r8, QWORD PTR fmt_sanitized$[rsp]
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR v_str$[rsp]
	call	?ImFormatString@@YAHPEAD_KPEBDZZ	; ImFormatString

; 2208 :     const char* p = v_str;
; 2209 :     while (*p == ' ')

	cmp	BYTE PTR v_str$[rsp], 32		; 00000020H
	lea	rcx, QWORD PTR v_str$[rsp]
	jne	SHORT $LN3@RoundScala
	npad	4
$LL2@RoundScala:

; 2210 :         p++;

	inc	rcx
	cmp	BYTE PTR [rcx], 32			; 00000020H
	je	SHORT $LL2@RoundScala
$LN3@RoundScala:

; 2211 :     v = (TYPE)ImAtof(p);

	call	QWORD PTR __imp_atof

; 2212 : 
; 2213 :     return v;
; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
$LN5@RoundScala:

; 2198 :         return v;

	movaps	xmm0, xmm2

; 2212 : 
; 2213 :     return v;
; 2214 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	ret	0
??$RoundScalarWithFormatT@N@ImGui@@YANPEBDHN@Z ENDP	; ImGui::RoundScalarWithFormatT<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@M@@YAXAEAM0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@M@@YAXAEAM0@Z PROC				; ImSwap<float>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	movss	xmm0, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	movss	DWORD PTR [rdx], xmm0
	ret	0
??$ImSwap@M@@YAXAEAM0@Z ENDP				; ImSwap<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@H@@YAHHHM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@H@@YAHHHM@Z PROC				; ImLerp<int>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	edx, ecx
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, edx
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	ret	0
??$ImLerp@H@@YAHHHM@Z ENDP				; ImLerp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@I@@YAIIII@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@I@@YAIIII@Z PROC				; ImClamp<unsigned int>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	ecx, edx
	jae	SHORT $LN3@ImClamp
	mov	eax, edx
	ret	0
$LN3@ImClamp:
	cmp	ecx, r8d
	cmova	ecx, r8d
	mov	eax, ecx
	ret	0
??$ImClamp@I@@YAIIII@Z ENDP				; ImClamp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@I@@YAXAEAI0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@I@@YAXAEAI0@Z PROC				; ImSwap<unsigned int>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	r8d, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rdx], r8d
	ret	0
??$ImSwap@I@@YAXAEAI0@Z ENDP				; ImSwap<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@I@@YAIII@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@I@@YAIII@Z PROC				; ImMin<unsigned int>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	ecx, edx
	cmovb	edx, ecx
	mov	eax, edx
	ret	0
??$ImMin@I@@YAIII@Z ENDP				; ImMin<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@I@@YAIIIM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@I@@YAIIIM@Z PROC				; ImLerp<unsigned int>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	xorps	xmm1, xmm1
	sub	edx, ecx
	mov	eax, edx
	xorps	xmm0, xmm0
	cvtsi2ss xmm1, rax
	mov	eax, ecx
	cvtsi2ss xmm0, rax
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si rax, xmm1
	ret	0
??$ImLerp@I@@YAIIIM@Z ENDP				; ImLerp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@_J@@YA_J_J00@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@_J@@YA_J_J00@Z PROC				; ImClamp<__int64>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rcx, rdx
	jge	SHORT $LN3@ImClamp
	mov	rax, rdx
	ret	0
$LN3@ImClamp:
	cmp	rcx, r8
	cmovg	rcx, r8
	mov	rax, rcx
	ret	0
??$ImClamp@_J@@YA_J_J00@Z ENDP				; ImClamp<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@_J@@YAXAEA_J0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@_J@@YAXAEA_J0@Z PROC				; ImSwap<__int64>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rdx], r8
	ret	0
??$ImSwap@_J@@YAXAEA_J0@Z ENDP				; ImSwap<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@N@@YAXAEAN0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@N@@YAXAEAN0@Z PROC				; ImSwap<double>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	rax, QWORD PTR [rdx]
	movsd	xmm0, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	movsd	QWORD PTR [rdx], xmm0
	ret	0
??$ImSwap@N@@YAXAEAN0@Z ENDP				; ImSwap<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@_J@@YA_J_J0@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@_J@@YA_J_J0@Z PROC				; ImMin<__int64>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	cmp	rcx, rdx
	cmovl	rdx, rcx
	mov	rax, rdx
	ret	0
??$ImMin@_J@@YA_J_J0@Z ENDP				; ImMin<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@_J@@YA_J_J0M@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@_J@@YA_J_J0M@Z PROC				; ImLerp<__int64>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	xorps	xmm1, xmm1
	sub	rdx, rcx
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rcx
	cvtsi2ss xmm1, rdx
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	cvttss2si rax, xmm1
	ret	0
??$ImLerp@_J@@YA_J_J0M@Z ENDP				; ImLerp<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@_K@@YA_K_K00@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@_K@@YA_K_K00@Z PROC				; ImClamp<unsigned __int64>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	rcx, rdx
	jae	SHORT $LN3@ImClamp
	mov	rax, rdx
	ret	0
$LN3@ImClamp:
	cmp	rcx, r8
	cmova	rcx, r8
	mov	rax, rcx
	ret	0
??$ImClamp@_K@@YA_K_K00@Z ENDP				; ImClamp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImSwap@_K@@YAXAEA_K0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$ImSwap@_K@@YAXAEA_K0@Z PROC				; ImSwap<unsigned __int64>, COMDAT

; 458  : template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rdx], r8
	ret	0
??$ImSwap@_K@@YAXAEA_K0@Z ENDP				; ImSwap<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@_K@@YA_K_K0M@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@_K@@YA_K_K0M@Z PROC				; ImLerp<unsigned __int64>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	sub	rdx, rcx
	xorps	xmm0, xmm0
	js	SHORT $LN6@ImLerp
	cvtsi2ss xmm0, rdx
	jmp	SHORT $LN7@ImLerp
$LN6@ImLerp:
	mov	rax, rdx
	and	edx, 1
	shr	rax, 1
	or	rax, rdx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN7@ImLerp:
	mulss	xmm0, xmm2
	xorps	xmm1, xmm1
	test	rcx, rcx
	js	SHORT $LN4@ImLerp
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN5@ImLerp
$LN4@ImLerp:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN5@ImLerp:
	addss	xmm0, xmm1
	xor	ecx, ecx
	movss	xmm1, DWORD PTR __real@5f000000
	comiss	xmm0, xmm1
	jb	SHORT $LN3@ImLerp
	subss	xmm0, xmm1
	comiss	xmm0, xmm1
	jae	SHORT $LN3@ImLerp
	mov	rax, -9223372036854775808		; 8000000000000000H
	mov	rcx, rax
$LN3@ImLerp:
	cvttss2si rax, xmm0
	add	rax, rcx
	ret	0
??$ImLerp@_K@@YA_K_K0M@Z ENDP				; ImLerp<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImClamp@N@@YANNNN@Z
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@N@@YANNNN@Z PROC				; ImClamp<double>, COMDAT

; 456  : template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comisd	xmm1, xmm0
	jbe	SHORT $LN5@ImClamp
	movaps	xmm0, xmm1
	ret	0
$LN5@ImClamp:
	minsd	xmm2, xmm0
	movaps	xmm0, xmm2
	ret	0
??$ImClamp@N@@YANNNN@Z ENDP				; ImClamp<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@N@@YANNN@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@N@@YANNN@Z PROC				; ImMin<double>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minsd	xmm0, xmm1
	ret	0
??$ImMin@N@@YANNN@Z ENDP				; ImMin<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@N@@YANNNM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@N@@YANNNM@Z PROC				; ImLerp<double>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subsd	xmm1, xmm0
	cvtss2sd xmm2, xmm2
	mulsd	xmm1, xmm2
	addsd	xmm0, xmm1
	ret	0
??$ImLerp@N@@YANNNM@Z ENDP				; ImLerp<double>
_TEXT	ENDS
END
