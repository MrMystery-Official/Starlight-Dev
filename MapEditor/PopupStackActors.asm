; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05IJGIMMHE@Count@				; `string'
PUBLIC	??_C@_0N@HAJMNOBJ@Stack?5actors@		; `string'
PUBLIC	??_C@_04PBDNGNOJ@OffZ@				; `string'
PUBLIC	??_C@_04NKBADOCK@OffY@				; `string'
PUBLIC	??_C@_04MDALAPGL@OffX@				; `string'
PUBLIC	?OffsetZ@PopupStackActors@@3MA			; PopupStackActors::OffsetZ
PUBLIC	?SrcActor@PopupStackActors@@3_KA		; PopupStackActors::SrcActor
PUBLIC	?OffsetY@PopupStackActors@@3MA			; PopupStackActors::OffsetY
PUBLIC	?OffsetX@PopupStackActors@@3MA			; PopupStackActors::OffsetX
PUBLIC	?Count@PopupStackActors@@3GA			; PopupStackActors::Count
PUBLIC	?Func@PopupStackActors@@3P6AX_KMMMG@ZEA		; PopupStackActors::Func
PUBLIC	?IsOpen@PopupStackActors@@3_NA			; PopupStackActors::IsOpen
	ALIGN	4

?OffsetZ@PopupStackActors@@3MA DD 01H DUP (?)		; PopupStackActors::OffsetZ
?SrcActor@PopupStackActors@@3_KA DQ 01H DUP (?)		; PopupStackActors::SrcActor
?OffsetY@PopupStackActors@@3MA DD 01H DUP (?)		; PopupStackActors::OffsetY
?OffsetX@PopupStackActors@@3MA DD 01H DUP (?)		; PopupStackActors::OffsetX
?Count@PopupStackActors@@3GA DW 01H DUP (?)		; PopupStackActors::Count
	ALIGN	8

?Func@PopupStackActors@@3P6AX_KMMMG@ZEA DQ 01H DUP (?)	; PopupStackActors::Func
?IsOpen@PopupStackActors@@3_NA DB 01H DUP (?)		; PopupStackActors::IsOpen
_BSS	ENDS
;	COMDAT ??_C@_04MDALAPGL@OffX@
CONST	SEGMENT
??_C@_04MDALAPGL@OffX@ DB 'OffX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKBADOCK@OffY@
CONST	SEGMENT
??_C@_04NKBADOCK@OffY@ DB 'OffY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PBDNGNOJ@OffZ@
CONST	SEGMENT
??_C@_04PBDNGNOJ@OffZ@ DB 'OffZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAJMNOBJ@Stack?5actors@
CONST	SEGMENT
??_C@_0N@HAJMNOBJ@Stack?5actors@ DB 'Stack actors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJGIMMHE@Count@
CONST	SEGMENT
??_C@_05IJGIMMHE@Count@ DB 'Count', 00H			; `string'
PUBLIC	?Open@PopupStackActors@@YAXP6AX_KMMMG@Z0@Z	; PopupStackActors::Open
PUBLIC	?Render@PopupStackActors@@YAXXZ			; PopupStackActors::Render
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@PopupStackActors@@YAXXZ DD imagerel $LN342
	DD	imagerel $LN342+1326
	DD	imagerel $unwind$?Render@PopupStackActors@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@PopupStackActors@@YAXXZ DB 010H
	DB	0c8H
	DB	00H
	DB	01dH, 08H
	DB	02H
	DB	0c0H
	DB	04H
	DB	086H
	DB	06H
	DB	0e2H
	DB	08H
	DB	'$'
	DB	0aH
	DB	'('
	DB	08H
	DB	0a9H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@PopupStackActors@@YAXXZ DB 0aH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@PopupStackActors@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@PopupStackActors@@YAXXZ
	DD	imagerel $ip2state$?Render@PopupStackActors@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@PopupStackActors@@YAXXZ DD 091b11H
	DD	0e681bH
	DD	0227417H
	DD	0213417H
	DD	01e0117H
	DD	0500cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Render@PopupStackActors@@YAXXZ
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
;	COMDAT ?Render@PopupStackActors@@YAXXZ
_TEXT	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?Render@PopupStackActors@@YAXXZ PROC			; PopupStackActors::Render, COMDAT

; 15   : {

$LN342:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 240				; 000000f0H
	movaps	XMMWORD PTR [rax-24], xmm6
	xor	edi, edi

; 16   : 	if (IsOpen)

	cmp	BYTE PTR ?IsOpen@PopupStackActors@@3_NA, dil ; PopupStackActors::IsOpen
	je	$LN2@Render

; 17   : 	{
; 18   : 		UIMapView::RenderSettings.AllowSelectingActor = false;

	mov	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8124 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8125 :     IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	or	DWORD PTR [rax+18680], 2

; 8127 :     g.NextWindowData.SizeVal = size;

	mov	DWORD PTR [rax+18716], 1135017984	; 43a70000H
	mov	DWORD PTR [rax+18720], 1137180672	; 43c80000H

; 8128 :     g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rax+18688], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 20   : 		ImGui::OpenPopup("Stack actors");

	lea	rcx, OFFSET FLAT:??_C@_0N@HAJMNOBJ@Stack?5actors@
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup

; 21   : 		if (ImGui::BeginPopupModal("Stack actors", NULL))

	xor	r8d, r8d
	lea	rcx, OFFSET FLAT:??_C@_0N@HAJMNOBJ@Stack?5actors@
	call	?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z ; ImGui::BeginPopupModal
	movss	xmm6, DWORD PTR __real@bf800000
	test	al, al
	je	$LN5@Render

; 22   : 		{
; 23   : 			ImGui::InputScalar("Source", ImGuiDataType_::ImGuiDataType_U64, &SrcActor);

	mov	DWORD PTR [rsp+48], edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?SrcActor@PopupStackActors@@3_KA ; PopupStackActors::SrcActor
	lea	edx, QWORD PTR [rdi+7]
	lea	rcx, OFFSET FLAT:??_C@_06CLBDIDBH@Source@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 24   : 			ImGui::InputScalar("Count", ImGuiDataType_::ImGuiDataType_U16, &Count);

	mov	DWORD PTR [rsp+48], edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?Count@PopupStackActors@@3GA ; PopupStackActors::Count
	lea	edx, QWORD PTR [rdi+3]
	lea	rcx, OFFSET FLAT:??_C@_05IJGIMMHE@Count@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 25   : 			ImGui::InputScalar("OffX", ImGuiDataType_::ImGuiDataType_Float, &OffsetX);

	mov	DWORD PTR [rsp+48], edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?OffsetX@PopupStackActors@@3MA ; PopupStackActors::OffsetX
	lea	edx, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:??_C@_04MDALAPGL@OffX@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 26   : 			ImGui::InputScalar("OffY", ImGuiDataType_::ImGuiDataType_Float, &OffsetY);

	mov	DWORD PTR [rsp+48], edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?OffsetY@PopupStackActors@@3MA ; PopupStackActors::OffsetY
	lea	edx, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:??_C@_04NKBADOCK@OffY@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar

; 27   : 			ImGui::InputScalar("OffZ", ImGuiDataType_::ImGuiDataType_Float, &OffsetZ);

	mov	DWORD PTR [rsp+48], edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], rdi
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:?OffsetZ@PopupStackActors@@3MA ; PopupStackActors::OffsetZ
	lea	edx, QWORD PTR [rdi+8]
	lea	rcx, OFFSET FLAT:??_C@_04PBDNGNOJ@OffZ@
	call	?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z ; ImGui::InputScalar
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T10[rbp-153], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T10[rbp-153]
	lea	rcx, OFFSET FLAT:??_C@_03LDFMNCOE@Add@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 28   : 			if (ImGui::Button("Add"))

	test	al, al
	je	SHORT $LN4@Render

; 29   : 			{
; 30   : 				Func(SrcActor, OffsetX, OffsetY, OffsetZ, Count);

	movzx	eax, WORD PTR ?Count@PopupStackActors@@3GA ; PopupStackActors::Count
	mov	WORD PTR [rsp+32], ax
	movss	xmm3, DWORD PTR ?OffsetZ@PopupStackActors@@3MA ; PopupStackActors::OffsetZ
	movss	xmm2, DWORD PTR ?OffsetY@PopupStackActors@@3MA ; PopupStackActors::OffsetY
	movss	xmm1, DWORD PTR ?OffsetX@PopupStackActors@@3MA ; PopupStackActors::OffsetX
	mov	rcx, QWORD PTR ?SrcActor@PopupStackActors@@3_KA ; PopupStackActors::SrcActor
	call	QWORD PTR ?Func@PopupStackActors@@3P6AX_KMMMG@ZEA ; PopupStackActors::Func

; 31   : 				IsOpen = false;

	mov	BYTE PTR ?IsOpen@PopupStackActors@@3_NA, dil ; PopupStackActors::IsOpen

; 32   : 				Func = nullptr;

	mov	QWORD PTR ?Func@PopupStackActors@@3P6AX_KMMMG@ZEA, rdi ; PopupStackActors::Func

; 33   : 				SrcActor = 0;

	mov	QWORD PTR ?SrcActor@PopupStackActors@@3_KA, rdi ; PopupStackActors::SrcActor
$LN4@Render:

; 34   : 			}
; 35   : 			ImGui::SameLine();

	movaps	xmm1, xmm6
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T9[rbp-153], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T9[rbp-153]
	lea	rcx, OFFSET FLAT:??_C@_06HCFIKKEA@Return@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 36   : 			if (ImGui::Button("Return"))

	test	al, al
	je	SHORT $LN5@Render

; 37   : 			{
; 38   : 				IsOpen = false;

	mov	BYTE PTR ?IsOpen@PopupStackActors@@3_NA, dil ; PopupStackActors::IsOpen

; 39   : 				Func = nullptr;

	mov	QWORD PTR ?Func@PopupStackActors@@3P6AX_KMMMG@ZEA, rdi ; PopupStackActors::Func

; 40   : 				SrcActor = 0;

	mov	QWORD PTR ?SrcActor@PopupStackActors@@3_KA, rdi ; PopupStackActors::SrcActor

; 41   : 				OffsetX = 0;

	mov	DWORD PTR ?OffsetX@PopupStackActors@@3MA, edi

; 42   : 				OffsetY = 0;

	mov	DWORD PTR ?OffsetY@PopupStackActors@@3MA, edi

; 43   : 				OffsetZ = 0;

	mov	DWORD PTR ?OffsetZ@PopupStackActors@@3MA, edi

; 44   : 				Count = 0;

	mov	WORD PTR ?Count@PopupStackActors@@3GA, di ; PopupStackActors::Count
$LN5@Render:

; 45   : 			}
; 46   : 		}
; 47   : 		ImGui::SameLine();

	movaps	xmm1, xmm6
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
	movss	xmm6, DWORD PTR [rcx+92]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T7[rbp-153]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T7[rbp-153]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T7[rbp-129], 16
	cmovae	rcx, QWORD PTR $T7[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
	movss	xmm6, DWORD PTR [rcx+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rbp-153]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T5[rbp-153]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T5[rbp-129], 16
	cmovae	rcx, QWORD PTR $T5[rbp-153]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06FMLHDGIC@Size?3?5@
	lea	rcx, QWORD PTR $T5[rbp-153]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rbp-153], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T4[rbp-137], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T4[rbp-153], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T4[rbp-137], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 48   : 		ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T4[rbp-137]
	mov	rdx, QWORD PTR $T4[rbp-129]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN97@Render

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T4[rbp-137], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T4[rbp-153]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T4[rbp-153]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 120			; 00000078H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T4[rbp-153]
	jmp	SHORT $LN96@Render
$LN97@Render:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01FJMABOPO@x@
	mov	edx, 1
	lea	rcx, QWORD PTR $T4[rbp-153]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN96@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T8[rbp-153], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T8[rbp-137], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 48   : 		ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T7[rbp-153]
	lea	r8, QWORD PTR $T8[rbp-153]
	lea	rcx, QWORD PTR $T6[rbp-153]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T6[rbp-153]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T6[rbp-129], 16
	cmovae	rcx, QWORD PTR $T6[rbp-153]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 48   : 		ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rbp-129]
	cmp	rdx, 16
	jb	SHORT $LN172@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rbp-153]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN184@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN184@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN184@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN172@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T6[rbp-137], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T6[rbp-153], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T8[rbp-129]
	cmp	rdx, 16
	jb	SHORT $LN202@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rbp-153]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN214@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN214@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN214@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN202@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T4[rbp-129]
	cmp	rdx, 16
	jb	SHORT $LN231@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rbp-153]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN243@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN243@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN243@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN231@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T4[rbp-137], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T4[rbp-153], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rbp-129]
	cmp	rdx, 16
	jb	SHORT $LN260@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rbp-153]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN272@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN272@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN272@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN260@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T5[rbp-137], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T5[rbp-153], 0

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T7[rbp-129]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN289@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rbp-153]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN301@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN301@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN301@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN289@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 49   : 		ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN2@Render:

; 50   : 	}
; 51   : }

	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN339@Render:
?Render@PopupStackActors@@YAXXZ ENDP			; PopupStackActors::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?dtor$0@?0??Render@PopupStackActors@@YAXXZ@4HA PROC	; `PopupStackActors::Render'::`1'::dtor$0
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Render@PopupStackActors@@YAXXZ@4HA ENDP	; `PopupStackActors::Render'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?dtor$1@?0??Render@PopupStackActors@@YAXXZ@4HA PROC	; `PopupStackActors::Render'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Render@PopupStackActors@@YAXXZ@4HA ENDP	; `PopupStackActors::Render'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?dtor$2@?0??Render@PopupStackActors@@YAXXZ@4HA PROC	; `PopupStackActors::Render'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Render@PopupStackActors@@YAXXZ@4HA ENDP	; `PopupStackActors::Render'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?dtor$3@?0??Render@PopupStackActors@@YAXXZ@4HA PROC	; `PopupStackActors::Render'::`1'::dtor$3
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Render@PopupStackActors@@YAXXZ@4HA ENDP	; `PopupStackActors::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 192
$T9 = 256
$T10 = 256
?dtor$4@?0??Render@PopupStackActors@@YAXXZ@4HA PROC	; `PopupStackActors::Render'::`1'::dtor$4
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Render@PopupStackActors@@YAXXZ@4HA ENDP	; `PopupStackActors::Render'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
;	COMDAT ?Open@PopupStackActors@@YAXP6AX_KMMMG@Z0@Z
_TEXT	SEGMENT
Callback$dead$ = 8
Src$ = 16
?Open@PopupStackActors@@YAXP6AX_KMMMG@Z0@Z PROC		; PopupStackActors::Open, COMDAT

; 55   : 	Func = Callback;

	lea	rax, OFFSET FLAT:?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::<lambda_invoker_cdecl>

; 56   : 	SrcActor = Src;

	mov	QWORD PTR ?SrcActor@PopupStackActors@@3_KA, rdx ; PopupStackActors::SrcActor
	mov	QWORD PTR ?Func@PopupStackActors@@3P6AX_KMMMG@ZEA, rax ; PopupStackActors::Func

; 57   : 
; 58   : 	IsOpen = true;

	mov	BYTE PTR ?IsOpen@PopupStackActors@@3_NA, 1 ; PopupStackActors::IsOpen

; 59   : }

	ret	0
?Open@PopupStackActors@@YAXP6AX_KMMMG@Z0@Z ENDP		; PopupStackActors::Open
_TEXT	ENDS
END
