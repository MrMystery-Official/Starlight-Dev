; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05CBIDHJPB@?4epng@			; `string'
PUBLIC	??_C@_06KINIHAEN@Cache?1@			; `string'
PUBLIC	??_C@_08KKONLFDB@TexToGo?1@			; `string'
PUBLIC	??_C@_0BO@PFKENAAJ@Magic?5mismatch?0?5expected?56PK0@ ; `string'
PUBLIC	??_C@_0P@MBKHCCBD@TexToGoDecoder@		; `string'
EXTRN	ZSTD_decompressDCtx:PROC
EXTRN	ZSTD_createDCtx:PROC
EXTRN	ZSTD_getFrameContentSize:PROC
EXTRN	ZSTD_freeDCtx:PROC
;	COMDAT ??_C@_0P@MBKHCCBD@TexToGoDecoder@
CONST	SEGMENT
??_C@_0P@MBKHCCBD@TexToGoDecoder@ DB 'TexToGoDecoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKENAAJ@Magic?5mismatch?0?5expected?56PK0@
CONST	SEGMENT
??_C@_0BO@PFKENAAJ@Magic?5mismatch?0?5expected?56PK0@ DB 'Magic mismatch,'
	DB	' expected 6PK0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKONLFDB@TexToGo?1@
CONST	SEGMENT
??_C@_08KKONLFDB@TexToGo?1@ DB 'TexToGo/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KINIHAEN@Cache?1@
CONST	SEGMENT
??_C@_06KINIHAEN@Cache?1@ DB 'Cache/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CBIDHJPB@?4epng@
CONST	SEGMENT
??_C@_05CBIDHJPB@?4epng@ DB '.epng', 00H		; `string'
PUBLIC	??$construct_at@USurfaceInfo@TextureToGo@@$$V$0A@@std@@YAPEAUSurfaceInfo@TextureToGo@@QEAU12@@Z ; std::construct_at<TextureToGo::SurfaceInfo,0>
PUBLIC	??$construct@USurfaceInfo@TextureToGo@@$$V@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SAXAEAV?$allocator@USurfaceInfo@TextureToGo@@@1@QEAUSurfaceInfo@TextureToGo@@@Z ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::construct<TextureToGo::SurfaceInfo>
PUBLIC	??$_Unfancy@USurfaceInfo@TextureToGo@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@@Z ; std::_Unfancy<TextureToGo::SurfaceInfo>
PUBLIC	??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,0>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Emplace_back<>
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@PEAUSurfaceInfo@TextureToGo@@AEAV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::~_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@XZ ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	??$forward@AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAAEBV?$allocator@USurfaceInfo@TextureToGo@@@0@AEBV10@@Z ; std::forward<std::allocator<TextureToGo::SurfaceInfo> const &>
PUBLIC	??$_Seek_wrapped@PEAEPEAE@std@@YAXAEAPEAE$$QEAPEAE@Z ; std::_Seek_wrapped<unsigned char *,unsigned char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1><>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z ; std::allocator<TextureToGo::SurfaceInfo>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SA_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@@Z ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::max_size
PUBLIC	?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal
PUBLIC	?max_size@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEBA_KXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::max_size
PUBLIC	?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength
PUBLIC	?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >
PUBLIC	??1?$_Tidy_guard@V?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >::~_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAXPEAUSurfaceInfo@TextureToGo@@QEAU12@AEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z ; std::_Destroy_range<std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@$$V@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1><std::allocator<TextureToGo::SurfaceInfo> const &>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
PUBLIC	??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$assign@PEAE$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<unsigned char *,0>
PUBLIC	??$_Get_unwrapped_n@AEAPEAE_J@std@@YA?A_TAEAPEAE_J@Z ; std::_Get_unwrapped_n<unsigned char * &,__int64>
PUBLIC	??$_Idl_distance@PEAEPEAE@std@@YA?A_PAEBQEAE0@Z	; std::_Idl_distance<unsigned char *,unsigned char *>
PUBLIC	??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z		; std::copy<unsigned char *,unsigned char *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z ; std::allocator<TextureToGo::SurfaceInfo>::deallocate
PUBLIC	?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Tidy
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >
PUBLIC	??0?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAA@XZ ; std::allocator<TextureToGo::SurfaceInfo>::allocator<TextureToGo::SurfaceInfo>
PUBLIC	??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::~vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >
PUBLIC	??A?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAAEAUSurfaceInfo@TextureToGo@@_K@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
PUBLIC	?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAX_K@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::__autoclassinit2
PUBLIC	??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGo::TextureToGo
PUBLIC	?__autoclassinit2@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2
PUBLIC	??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ; TextureToGo::TextureToGo
PUBLIC	?IsFail@TextureToGo@@QEAAAEA_NXZ		; TextureToGo::IsFail
PUBLIC	?IsTransparent@TextureToGo@@QEAAAEA_NXZ		; TextureToGo::IsTransparent
PUBLIC	?GetHeight@TextureToGo@@QEAAAEAGXZ		; TextureToGo::GetHeight
PUBLIC	?GetWidth@TextureToGo@@QEAAAEAGXZ		; TextureToGo::GetWidth
PUBLIC	?GetPixels@TextureToGo@@QEAAAEAV?$vector@EV?$allocator@E@std@@@std@@XZ ; TextureToGo::GetPixels
PUBLIC	?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::GetTexture
PUBLIC	?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGoLibrary::IsTextureLoaded
PUBLIC	?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A DB 010H DUP (?) ; TextureToGoLibrary::Textures
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD imagerel $LN26+14
	DD	imagerel $LN26+52
	DD	imagerel $chain$0$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD imagerel $LN26+52
	DD	imagerel $LN26+61
	DD	imagerel $chain$1$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+136
	DD	imagerel $unwind$?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+24
	DD	imagerel $LN45+131
	DD	imagerel $chain$0$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+131
	DD	imagerel $LN45+137
	DD	imagerel $chain$1$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN45+137
	DD	imagerel $LN45+143
	DD	imagerel $chain$2$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD imagerel $LN33
	DD	imagerel $LN33+36
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+40
	DD	imagerel $LN83+202
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+202
	DD	imagerel $LN83+203
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+203
	DD	imagerel $LN83+209
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+209
	DD	imagerel $LN83+215
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD imagerel $LN113
	DD	imagerel $LN113+27
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD imagerel $LN113+27
	DD	imagerel $LN113+86
	DD	imagerel $chain$0$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD imagerel $LN113+86
	DD	imagerel $LN113+106
	DD	imagerel $chain$1$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD imagerel $LN44
	DD	imagerel $LN44+92
	DD	imagerel $unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN20
	DD	imagerel $LN20+48
	DD	imagerel $unwind$??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN36
	DD	imagerel $LN36+43
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD imagerel $LN46
	DD	imagerel $LN46+61
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z DD imagerel $LN84
	DD	imagerel $LN84+210
	DD	imagerel $unwind$??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN116
	DD	imagerel $LN116+26
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN116+26
	DD	imagerel $LN116+86
	DD	imagerel $chain$0$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN116+86
	DD	imagerel $LN116+109
	DD	imagerel $chain$1$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN50
	DD	imagerel $LN50+70
	DD	imagerel $unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FTextures@TextureToGoLibrary@@YAXXZ DD imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+23
	DD	imagerel $unwind$??__FTextures@TextureToGoLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??__FTextures@TextureToGoLibrary@@YAXXZ DD imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+23
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+101
	DD	imagerel $chain$0$??__FTextures@TextureToGoLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??__FTextures@TextureToGoLibrary@@YAXXZ DD imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+101
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+116
	DD	imagerel $chain$1$??__FTextures@TextureToGoLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ETextures@TextureToGoLibrary@@YAXXZ DD imagerel ??__ETextures@TextureToGoLibrary@@YAXXZ
	DD	imagerel ??__ETextures@TextureToGoLibrary@@YAXXZ+54
	DD	imagerel $unwind$??__ETextures@TextureToGoLibrary@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1039
	DD	imagerel $LN1039+3438
	DD	imagerel $unwind$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DD imagerel $LN1347
	DD	imagerel $LN1347+3739
	DD	imagerel $unwind$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN143
	DD	imagerel $LN143+524
	DD	imagerel $unwind$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN8
	DD	imagerel $LN8+49
	DD	imagerel $unwind$?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 010H
	DB	'n'
	DB	02H
	DB	'-', 02H
	DB	04H
	DB	'"'
	DB	06H
	DB	't'
	DB	08H
	DB	'&'
	DB	04H
	DB	0b9H, 02H
	DB	02H
	DB	'<'
	DB	00H
	DB	'4'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 08H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	06aH
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
	DB	041H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 072419H
	DD	0266412H
	DD	0253412H
	DD	0220112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB '6'
	DB	0c9H, 04H
	DB	06H
	DB	'-', 06H
	DB	0aH
	DB	08cH
	DB	0cH
	DB	'!', 02H
	DB	0eH
	DB	'=', 04H
	DB	010H
	DB	'm', 02H
	DB	0eH
	DB	0f5H, 02H
	DB	0cH
	DB	'i', 03H
	DB	0aH
	DB	0eeH
	DB	012H
	DB	0a9H, 03H
	DB	014H
	DB	'9', 04H
	DB	016H
	DB	08eH
	DB	018H
	DB	0a9H, 02H
	DB	01aH
	DB	084H
	DB	01eH
	DB	09H, 04H
	DB	'"'
	DB	't'
	DB	014H
	DB	'u', 02H
	DB	012H
	DB	'Y', 05H
	DB	06H
	DB	'P'
	DB	08H
	DB	' '
	DB	06H
	DB	0beH
	DB	00H
	DB	'b'
	DB	014H
	DB	0cH
	DB	0aH
	DB	018H
	DB	0eH
	DB	018H
	DB	0aH
	DB	0cH
	DB	012H
	DB	018H
	DB	014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB 022H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	021H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03eH
	DD	imagerel ?dtor$2@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	062H
	DD	imagerel ??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ
	DB	01H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	021H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	03cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	0e2H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0f0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	03aH
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	081H
	DB	05H
	DB	0a2H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	081H
	DB	05H
	DB	015H
	DB	02H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	081H
	DB	05H
	DB	05H
	DB	03H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	081H
	DB	05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
	DD	imagerel $ip2state$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z DD 0f3919H
	DD	0287828H
	DD	0296824H
	DD	05f3420H
	DD	0540120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
	DD	0272H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB '8'
	DB	'=', 04H
	DB	04H
	DB	't'
	DB	06H
	DB	085H, 02H
	DB	08H
	DB	0ceH
	DB	06H
	DB	0bdH, 05H
	DB	04H
	DB	08cH
	DB	0aH
	DB	085H, 02H
	DB	0cH
	DB	086H
	DB	0eH
	DB	0a2H
	DB	012H
	DB	'q', 04H
	DB	016H
	DB	0a1H, 02H
	DB	018H
	DB	0adH, 04H
	DB	016H
	DB	'-', 03H
	DB	04H
	DB	')', 02H
	DB	01aH
	DB	0adH, 02H
	DB	01cH
	DB	']', 03H
	DB	01eH
	DB	01aH
	DB	01cH
	DB	'&'
	DB	01aH
	DB	'Q', 02H
	DB	' '
	DB	0dH, 02H
	DB	'"'
	DB	'J'
	DB	' '
	DB	01aH
	DB	01aH
	DB	0a1H, 02H
	DB	00H
	DB	'@'
	DB	01aH
	DB	0cH
	DB	04H
	DB	'0'
	DB	016H
	DB	018H
	DB	01aH
	DB	018H
	DB	01cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 022H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	06H
	DB	03eH
	DD	imagerel ?dtor$1@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	092H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	0aH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	0bH
	DB	03aH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	0cH
	DB	0a2H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	0cH
	DB	025H
	DB	02H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	0cH
	DB	0c5H
	DB	03H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	0c1H
	DB	0cH
	DB	042H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	0aH
	DB	0b5H
	DB	04H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DB	041H
	DB	06H
	DB	042H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	0aH
	DB	03cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	02H
	DB	0b2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0b3019H
	DD	0b0341fH
	DD	0a6011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0522H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ETextures@TextureToGoLibrary@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??__FTextures@TextureToGoLibrary@@YAXXZ DD 021H
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+23
	DD	imagerel $unwind$??__FTextures@TextureToGoLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??__FTextures@TextureToGoLibrary@@YAXXZ DD 020521H
	DD	067405H
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ
	DD	imagerel ??__FTextures@TextureToGoLibrary@@YAXXZ+23
	DD	imagerel $unwind$??__FTextures@TextureToGoLibrary@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FTextures@TextureToGoLibrary@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN116
	DD	imagerel $LN116+26
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020521H
	DD	077405H
	DD	imagerel $LN116
	DD	imagerel $LN116+26
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DB 04H
	DB	'*'
	DB	00H
	DB	'f'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
	DD	imagerel $ip2state$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z DD 040f11H
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD 021H
	DD	imagerel $LN113
	DD	imagerel $LN113+27
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD 020521H
	DD	0a7405H
	DD	imagerel $LN113
	DD	imagerel $LN113+27
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD 040801H
	DD	060043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	0c3400H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 081c21H
	DD	04f41cH
	DD	05e417H
	DD	06740aH
	DD	0c3405H
	DD	imagerel $LN83
	DD	imagerel $LN83+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 030f01H
	DD	0600b620fH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN45
	DD	imagerel $LN45+24
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+14
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z DD 020601H
	DD	070023206H
?Textures$initializer$@TextureToGoLibrary@@3P6AXXZEA DQ FLAT:??__ETextures@TextureToGoLibrary@@YAXXZ ; TextureToGoLibrary::Textures$initializer$
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
Name$ = 48
?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; TextureToGoLibrary::IsTextureLoaded, COMDAT

; 210  : {

$LN8:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	mov	rdx, rcx
	mov	rdi, rcx
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
	test	rax, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	setne	bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	movzx	eax, bl

; 212  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?IsTextureLoaded@TextureToGoLibrary@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; TextureToGoLibrary::IsTextureLoaded
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 144
$T6 = 224
Name$GSCopy$ = 256
__$ArrayPad$ = 264
Name$ = 288
?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; TextureToGoLibrary::GetTexture, COMDAT

; 215  : {

$LN143:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 272				; 00000110H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rcx
	mov	QWORD PTR Name$GSCopy$[rsp], rcx

; 216  :     if (!TextureToGoLibrary::IsTextureLoaded(Name))

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rbx, rax

; 211  :     return TextureToGoLibrary::Textures.count(Name);

	mov	rdx, rax
	call	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
	mov	rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 216  :     if (!TextureToGoLibrary::IsTextureLoaded(Name))

	test	rdi, rdi
	jne	$LN113@GetTexture
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rsi+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rcx
	cmp	rax, 8
	jb	$LN141@GetTexture

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN24@GetTexture

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN24@GetTexture:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 8
	lea	r9, OFFSET FLAT:??_C@_08KKONLFDB@TexToGo?1@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 217  :         TextureToGoLibrary::Textures.insert({ Name, Editor::GetRomFSFile("TexToGo/" + Name)});

	mov	r8b, 1
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?GetRomFSFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@_N@Z ; Editor::GetRomFSFile
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR $T4[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR $T4[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rbx+16], 0
	mov	QWORD PTR [rbx+24], 15
	mov	BYTE PTR [rbx], 0
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T5[rsp+32]
	call	??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGo::TextureToGo
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 217  :         TextureToGoLibrary::Textures.insert({ Name, Editor::GetRomFSFile("TexToGo/" + Name)});

	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::insert<0,0>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T5[rsp+40]
	test	rcx, rcx
	je	SHORT $LN73@GetTexture

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T5[rsp+56]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN91@GetTexture

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN91@GetTexture
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN91@GetTexture:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T5[rsp+40], 0
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqa	XMMWORD PTR $T5[rsp+48], xmm0
$LN73@GetTexture:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T5[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T2[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN113@GetTexture

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN125@GetTexture

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN125@GetTexture
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN125@GetTexture:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN113@GetTexture:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 218  :     return &TextureToGoLibrary::Textures[Name];

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 218  :     return &TextureToGoLibrary::Textures[Name];

	mov	rax, rbx

; 219  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
$LN141@GetTexture:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN139@GetTexture:
?GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; TextureToGoLibrary::GetTexture
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 144
$T6 = 224
Name$GSCopy$ = 256
__$ArrayPad$ = 264
Name$ = 288
?dtor$0@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGoLibrary::GetTexture'::`1'::dtor$0
	mov	rcx, QWORD PTR Name$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGoLibrary::GetTexture'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 144
$T6 = 224
Name$GSCopy$ = 256
__$ArrayPad$ = 264
Name$ = 288
?dtor$3@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGoLibrary::GetTexture'::`1'::dtor$3
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGoLibrary::GetTexture'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 144
$T6 = 224
Name$GSCopy$ = 256
__$ArrayPad$ = 264
Name$ = 288
?dtor$7@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGoLibrary::GetTexture'::`1'::dtor$7
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGoLibrary::GetTexture'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 64
$T2 = 80
$T3 = 80
$T4 = 112
$T5 = 144
$T6 = 224
Name$GSCopy$ = 256
__$ArrayPad$ = 264
Name$ = 288
?dtor$4@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGoLibrary::GetTexture'::`1'::dtor$4
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
?dtor$4@?0??GetTexture@TextureToGoLibrary@@YAPEAVTextureToGo@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGoLibrary::GetTexture'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?GetPixels@TextureToGo@@QEAAAEAV?$vector@EV?$allocator@E@std@@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetPixels@TextureToGo@@QEAAAEAV?$vector@EV?$allocator@E@std@@@std@@XZ PROC ; TextureToGo::GetPixels, COMDAT

; 15   :     return this->m_Pixels;

	lea	rax, QWORD PTR [rcx+8]

; 16   : }

	ret	0
?GetPixels@TextureToGo@@QEAAAEAV?$vector@EV?$allocator@E@std@@@std@@XZ ENDP ; TextureToGo::GetPixels
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?GetWidth@TextureToGo@@QEAAAEAGXZ
_TEXT	SEGMENT
this$ = 8
?GetWidth@TextureToGo@@QEAAAEAGXZ PROC			; TextureToGo::GetWidth, COMDAT

; 20   :     return this->m_Width;

	lea	rax, QWORD PTR [rcx+32]

; 21   : }

	ret	0
?GetWidth@TextureToGo@@QEAAAEAGXZ ENDP			; TextureToGo::GetWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?GetHeight@TextureToGo@@QEAAAEAGXZ
_TEXT	SEGMENT
this$ = 8
?GetHeight@TextureToGo@@QEAAAEAGXZ PROC			; TextureToGo::GetHeight, COMDAT

; 25   :     return this->m_Height;

	lea	rax, QWORD PTR [rcx+34]

; 26   : }

	ret	0
?GetHeight@TextureToGo@@QEAAAEAGXZ ENDP			; TextureToGo::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?IsTransparent@TextureToGo@@QEAAAEA_NXZ
_TEXT	SEGMENT
this$ = 8
?IsTransparent@TextureToGo@@QEAAAEA_NXZ PROC		; TextureToGo::IsTransparent, COMDAT

; 45   :     return this->m_Transparent;

	lea	rax, QWORD PTR [rcx+42]

; 46   : }

	ret	0
?IsTransparent@TextureToGo@@QEAAAEA_NXZ ENDP		; TextureToGo::IsTransparent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ?IsFail@TextureToGo@@QEAAAEA_NXZ
_TEXT	SEGMENT
this$ = 8
?IsFail@TextureToGo@@QEAAAEA_NXZ PROC			; TextureToGo::IsFail, COMDAT

; 50   :     return this->m_Fail;

	lea	rax, QWORD PTR [rcx+43]

; 51   : }

	ret	0
?IsFail@TextureToGo@@QEAAAEA_NXZ ENDP			; TextureToGo::IsFail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z
_TEXT	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z PROC ; TextureToGo::TextureToGo, COMDAT

; 54   : {

$LN1347:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-472]
	sub	rsp, 672				; 000002a0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, r8
	mov	QWORD PTR Path$GSCopy$1$[rbp-256], rdx
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rbp-256], rcx
	mov	QWORD PTR Path$GSCopy$[rbp-256], rdx
	mov	QWORD PTR Bytes$GSCopy$[rbp-256], r8
	xor	ebx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR [rcx], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbx
	mov	QWORD PTR [rcx+16], rbx
	mov	QWORD PTR [rcx+24], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rcx+42], bx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 55   :     this->m_Fail = false;

	mov	BYTE PTR [rcx+43], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	r9d, BYTE PTR [rax+1]
	movzx	r10d, BYTE PTR [rax]

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	cmp	BYTE PTR [rax+4], 54			; 00000036H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 63   :     if (Magic[0] != '6' || Magic[1] != 'P' || Magic[2] != 'K' || Magic[3] != '0')

	jne	$LN18@TextureToG
	cmp	BYTE PTR [rax+5], 80			; 00000050H
	jne	$LN18@TextureToG
	cmp	BYTE PTR [rax+6], 75			; 0000004bH
	jne	$LN18@TextureToG
	cmp	BYTE PTR [rax+7], 48			; 00000030H
	jne	$LN18@TextureToG
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+9]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+8]
	or	cx, ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 69   :     this->m_Width = Reader.ReadUInt16();

	mov	WORD PTR [r14+32], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+11]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+10]
	or	cx, ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 70   :     this->m_Height = Reader.ReadUInt16();

	mov	WORD PTR [r14+34], cx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+13]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+12]
	or	cx, ax
	movzx	r8d, cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 71   :     this->m_Depth = Reader.ReadUInt16();

	mov	WORD PTR [r14+36], r8w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	edx, BYTE PTR [rax+14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 72   :     this->m_MipMapCount = Reader.ReadUInt8();

	mov	BYTE PTR [r14+38], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	ecx, BYTE PTR [rax+61]
	shl	cx, 8
	movzx	eax, BYTE PTR [rax+60]
	or	cx, ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 79   :     this->m_Format = Reader.ReadUInt16();

	mov	WORD PTR [r14+40], cx

; 80   : 
; 81   :     Reader.Seek(HeaderSize, BinaryVectorReader::Position::Begin);

	mov	edi, r9d
	shl	edi, 8
	or	edi, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	dec	edi
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 83   :     std::vector<TextureToGo::SurfaceInfo> Surfaces(this->m_MipMapCount * this->m_Depth);

	mov	esi, edx
	imul	rsi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Surfaces$[rbp-256], xmm0
	mov	QWORD PTR Surfaces$[rbp-240], rbx

; 2065 :         if (_Count != 0) {

	test	rsi, rsi
	je	SHORT $LN1322@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rsi*8]

; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, rbx
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Surfaces$[rbp-256], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rbx, rax
	mov	QWORD PTR Surfaces$[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rsi, rsi
	je	SHORT $LN1148@TextureToG

; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	lea	r8, QWORD PTR [rsi*8]
	xor	edx, edx
	mov	rcx, rax
	call	memset
	mov	rax, rbx
$LN1148@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Surfaces$[rbp-248], rax
	xor	ebx, ebx
$LN1322@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 84   :     for (int i = 0; i < this->m_MipMapCount * this->m_Depth; i++)

	mov	r9d, ebx
	movzx	r8d, BYTE PTR [r14+38]
	movzx	edx, WORD PTR [r14+36]
	mov	eax, edx
	imul	eax, r8d
	test	eax, eax
	je	SHORT $LN3@TextureToG
	mov	r8, rbx
	npad	4
$LL4@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rcx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	edx, BYTE PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 86   :         Surfaces[i].ArrayLevel = Reader.ReadUInt16();

	mov	BYTE PTR [r8+rax+2], dl
	lea	edx, DWORD PTR [rdi+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 87   :         Surfaces[i].MipMapLevel = Reader.ReadUInt8();

	movzx	ecx, BYTE PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 87   :         Surfaces[i].MipMapLevel = Reader.ReadUInt8();

	mov	WORD PTR [r8+rax], cx
	lea	edi, DWORD PTR [rdx+1]

; 84   :     for (int i = 0; i < this->m_MipMapCount * this->m_Depth; i++)

	inc	r9d
	lea	r8, QWORD PTR [r8+8]
	movzx	edx, BYTE PTR [r14+38]
	movzx	ecx, WORD PTR [r14+36]
	mov	eax, ecx
	imul	eax, edx
	cmp	r9d, eax
	jl	SHORT $LL4@TextureToG
	movzx	r8d, dl
	movzx	edx, cx
$LN3@TextureToG:

; 88   :         Reader.Seek(1, BinaryVectorReader::Position::Current); //Always 1 - SurfaceCount
; 89   :     }
; 90   : 
; 91   :     for (int i = 0; i < this->m_MipMapCount * this->m_Depth; i++)

	mov	esi, ebx
	movzx	ecx, dx
	movzx	eax, r8b
	imul	ecx, eax
	test	ecx, ecx
	je	SHORT $LN6@TextureToG
$LL7@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	r11d, DWORD PTR [rdi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r10, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	r10, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	lea	eax, DWORD PTR [rdi+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rdi+2]
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	lea	eax, DWORD PTR [rdi+1]
	movsxd	r9, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	r9, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r8d, BYTE PTR [rdx+r8]
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [r10]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [r9]
	or	r8d, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 93   :         Surfaces[i].Size = Reader.ReadUInt32();

	mov	DWORD PTR [rbx+rax+4], r8d
	lea	edi, DWORD PTR [r11+4]

; 88   :         Reader.Seek(1, BinaryVectorReader::Position::Current); //Always 1 - SurfaceCount
; 89   :     }
; 90   : 
; 91   :     for (int i = 0; i < this->m_MipMapCount * this->m_Depth; i++)

	inc	esi
	lea	rbx, QWORD PTR [rbx+8]
	movzx	edx, WORD PTR [r14+36]
	movzx	eax, BYTE PTR [r14+38]
	imul	eax, edx
	cmp	esi, eax
	jl	SHORT $LL7@TextureToG
	xor	ebx, ebx
$LN6@TextureToG:

; 97   :     for (int j = 0; j < this->m_Depth; j++) {

	mov	ecx, ebx
	mov	DWORD PTR j$1$[rsp], ebx
	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	cmp	bx, dx
	jae	$LN1321@TextureToG
	movsd	xmm7, QWORD PTR __real@4000000000000000
	npad	14
$LL10@TextureToG:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR RawImageData$23[rbp-256], xmm0
	mov	QWORD PTR RawImageData$23[rbp-240], rax

; 99   :         std::vector<unsigned char> RawImageData(Surfaces[j].Size);

	movsxd	r12, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 99   :         std::vector<unsigned char> RawImageData(Surfaces[j].Size);

	mov	esi, DWORD PTR [rax+r12*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR RawImageData$23[rbp-256], xmm0
	mov	QWORD PTR RawImageData$23[rbp-240], rbx

; 2065 :         if (_Count != 0) {

	test	rsi, rsi
	je	SHORT $LN1325@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN507@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN1202@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN59@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN505@TextureToG
$LN507@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
$LN505@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR RawImageData$23[rbp-256], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+rsi]
	mov	QWORD PTR RawImageData$23[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rsi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR RawImageData$23[rbp-248], rbx
	xor	ebx, ebx
$LN1325@TextureToG:
	xorps	xmm1, xmm1

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Result$21[rbp-256], xmm1
	mov	QWORD PTR Result$21[rbp-240], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 102  :         for (int i = 0; i < Surfaces[j].Size; i++)

	mov	edx, ebx
	mov	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 102  :         for (int i = 0; i < Surfaces[j].Size; i++)

	cmp	DWORD PTR [rax+r12*8+4], 0
	jbe	SHORT $LN12@TextureToG
$LL13@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	movsxd	rcx, edi
	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 45   : 	return this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 104  :             RawImageData[i] = Reader.ReadUInt8();

	mov	rax, QWORD PTR RawImageData$23[rbp-256]
	mov	BYTE PTR [r8+rax], cl

; 102  :         for (int i = 0; i < Surfaces[j].Size; i++)

	inc	edx
	lea	r8, QWORD PTR [r8+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Surfaces$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 102  :         for (int i = 0; i < Surfaces[j].Size; i++)

	cmp	edx, DWORD PTR [rax+r12*8+4]
	jb	SHORT $LL13@TextureToG
$LN12@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR RawImageData$23[rbp-248]
	mov	rcx, QWORD PTR RawImageData$23[rbp-256]
	sub	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 107  :         Result.resize(ZSTD_getFrameContentSize(RawImageData.data(), RawImageData.size()));

	call	ZSTD_getFrameContentSize
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR Result$21[rbp-248]
	mov	rcx, r9
	mov	rdx, QWORD PTR Result$21[rbp-256]
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rax, rcx
	jae	SHORT $LN133@TextureToG

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	add	rax, rdx
	mov	QWORD PTR Result$21[rbp-248], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN134@TextureToG
$LN133@TextureToG:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN134@TextureToG

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR Result$21[rbp-240]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN135@TextureToG

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR Result$21[rbp-256]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN134@TextureToG
$LN135@TextureToG:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR Result$21[rbp-248], rbx
$LN134@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 108  :         ZSTD_DCtx* const DCtx = ZSTD_createDCtx();

	call	ZSTD_createDCtx
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR RawImageData$23[rbp-248]
	mov	r9, QWORD PTR RawImageData$23[rbp-256]
	sub	rax, r9
	mov	r8, QWORD PTR Result$21[rbp-248]
	mov	rdx, QWORD PTR Result$21[rbp-256]
	sub	r8, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 109  :         ZSTD_decompressDCtx(DCtx, (void*)Result.data(), Result.size(), RawImageData.data(), RawImageData.size());

	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rbx
	call	ZSTD_decompressDCtx

; 110  :         ZSTD_freeDCtx(DCtx);

	mov	rcx, rbx
	call	ZSTD_freeDCtx

; 112  :         Result = TegraSwizzle::GetDirectImageData(this, Result, this->m_Format, this->m_Width, this->m_Height, j);

	movzx	r12d, WORD PTR [r14+34]
	movzx	esi, WORD PTR [r14+32]
	mov	WORD PTR $T8[rsp], si
	movzx	eax, WORD PTR [r14+40]
	mov	WORD PTR $T9[rsp], ax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T19[rbp-256], xmm0
	xor	ebx, ebx
	mov	QWORD PTR $T19[rbp-240], rbx

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR Result$21[rbp-248]
	sub	rbx, QWORD PTR Result$21[rbp-256]

; 2065 :         if (_Count != 0) {

	je	$LN220@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	$LN1203@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN180@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN1204@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN287@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN178@TextureToG
$LN180@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN178@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T19[rbp-256], rsi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR $T19[rbp-248], rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rbx]
	mov	QWORD PTR $T19[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR Result$21[rbp-248]
	mov	rdx, QWORD PTR Result$21[rbp-256]
	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rsi+rbx]
	mov	QWORD PTR $T19[rbp-248], rax
	movzx	esi, WORD PTR $T8[rsp]
$LN220@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 112  :         Result = TegraSwizzle::GetDirectImageData(this, Result, this->m_Format, this->m_Width, this->m_Height, j);

	lea	rax, QWORD PTR $T19[rbp-256]
	mov	QWORD PTR $T17[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 42   : 	return (n + d - 1) / d;

	lea	ecx, DWORD PTR [r12+3]

; 63   : 	uint32_t BlockHeight = Pow2RoundUp(Height / 8);

	shr	ecx, 5

; 47   : 	x -= 1;

	dec	ecx

; 48   : 	x |= x >> 1;

	mov	eax, ecx
	shr	eax, 1
	or	ecx, eax

; 49   : 	x |= x >> 2;

	mov	eax, ecx
	shr	eax, 2
	or	ecx, eax

; 50   : 	x |= x >> 4;

	mov	eax, ecx
	shr	eax, 4
	or	ecx, eax

; 51   : 	x |= x >> 8;

	mov	eax, ecx
	shr	eax, 8
	or	ecx, eax

; 52   : 	x |= x >> 16;

	mov	eax, ecx
	shr	eax, 16
	or	ecx, eax

; 53   : 	return x + 1;

	inc	ecx

; 64   : 	if (BlockHeight > 16)

	cmp	ecx, 16
	jbe	SHORT $LN233@TextureToG

; 65   : 		BlockHeight = 16;

	mov	ecx, 16
	jmp	SHORT $LN224@TextureToG
$LN233@TextureToG:

; 147  : 	if (BlockHeight == 0) BlockHeight = 4;

	test	ecx, ecx
	mov	eax, 4
	cmove	ecx, eax
$LN224@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 662  : _GENERIC_MATH1(log10)

	mov	eax, ecx
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	call	log10
	movaps	xmm6, xmm0
	movaps	xmm0, xmm7
	call	log10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TegraSwizzle.cpp

; 149  : 	return GetDirectImageData(Texture, Pixels, Format, Width, Height, Depth, std::log10(BlockHeight) / std::log10(2), Target, LinearTileMode);

	divsd	xmm6, xmm0
	cvttsd2si rbx, xmm6
	lea	rdx, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR $T10[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR [rsp+56], ebx
	mov	WORD PTR [rsp+40], r12w
	mov	WORD PTR [rsp+32], si
	movzx	r9d, WORD PTR $T9[rsp]
	mov	r8, rax
	mov	rdx, r14
	lea	rcx, QWORD PTR $T14[rsp]
	call	?GetDirectImageData@TegraSwizzle@@YA?AV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@V23@GGGGIH_N@Z ; TegraSwizzle::GetDirectImageData
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T19[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1337@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T19[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN262@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN259@TextureToG
$LN262@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR $T19[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	xor	ebx, ebx
	mov	QWORD PTR $T19[rbp-240], rbx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	SHORT $LN244@TextureToG
$LN1337@TextureToG:
	xor	ebx, ebx
$LN244@TextureToG:
	mov	rcx, QWORD PTR Result$21[rbp-256]
	test	rcx, rcx
	je	SHORT $LN278@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Result$21[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN290@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN287@TextureToG
$LN290@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN278@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 412  :         _Myfirst = _Right._Myfirst;

	movups	xmm2, XMMWORD PTR $T14[rsp]
	movups	XMMWORD PTR Result$21[rbp-256], xmm2
	movsd	xmm0, QWORD PTR $T14[rbp-240]
	movsd	QWORD PTR Result$21[rbp-240], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	movdqa	xmm1, xmm2
	psrldq	xmm1, 8
	movq	r9, xmm1
	movq	r8, xmm2
	sub	r9, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdx, QWORD PTR [r14+16]

; 1243 :             _Insert_counted_range(_Where, _UFirst, _Count);

	lea	rcx, QWORD PTR [r14+8]
	call	??$_Insert_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@PEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_counted_range<unsigned char *>
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Result$21[rbp-256]
	test	rcx, rcx
	je	SHORT $LN71@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Result$21[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN89@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN86@TextureToG
$LN89@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Result$21[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Result$21[rbp-240], rbx
$LN71@TextureToG:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR RawImageData$23[rbp-256]
	test	rcx, rcx
	je	SHORT $LN8@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR RawImageData$23[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN62@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN59@TextureToG
$LN62@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 97   :     for (int j = 0; j < this->m_Depth; j++) {

	mov	ecx, DWORD PTR j$1$[rsp]
	inc	ecx
	mov	DWORD PTR j$1$[rsp], ecx
	movzx	eax, WORD PTR [r14+36]
	cmp	ecx, eax
	jl	$LL10@TextureToG
	mov	r12, 9223372036854775807		; 7fffffffffffffffH
$LN1321@TextureToG:
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Input$[rbp-256], xmm1
	mov	QWORD PTR Input$[rbp-240], rbx

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR [r14+16]
	sub	rbx, QWORD PTR [r14+8]

; 2065 :         if (_Count != 0) {

	je	$LN1326@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rbx, r12
	ja	$LN1340@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN443@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN1341@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN396@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN441@TextureToG
$LN259@TextureToG:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN287@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN86@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN59@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN443@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN441@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Input$[rbp-256], rdi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR Input$[rbp-248], rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR Input$[rbp-240], rax

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [r14+16]
	mov	rdx, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	QWORD PTR Input$[rbp-248], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	jmp	SHORT $LN483@TextureToG
$LN1326@TextureToG:
	mov	rax, QWORD PTR Input$[rbp-248]
$LN483@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 119  :     if (this->DecompressFunction != nullptr && Input.size() > 0)

	cmp	QWORD PTR [r14], 0
	je	$LN19@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	cmp	rax, QWORD PTR Input$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 119  :     if (this->DecompressFunction != nullptr && Input.size() > 0)

	je	$LN19@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1766 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR [r14+8]
	cmp	rax, QWORD PTR [r14+16]
	je	SHORT $LN845@TextureToG

; 1767 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1768 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1769 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1770 :             return;
; 1771 :         }
; 1772 : 
; 1773 :         _My_data._Orphan_all();
; 1774 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1775 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1776 :         _Mylast = _Myfirst;

	mov	QWORD PTR [r14+16], rax
$LN845@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 122  :         DecompressFunction(this->m_Width, this->m_Height, Input, this->m_Pixels, this);

	mov	rax, QWORD PTR [r14]
	movzx	edx, WORD PTR [r14+34]
	movzx	ecx, WORD PTR [r14+32]
	mov	QWORD PTR [rsp+32], r14
	lea	r9, QWORD PTR [r14+8]
	lea	r8, QWORD PTR Input$[rbp-256]
	call	rax

; 123  : 
; 124  :         int Length = 0;

	xor	ebx, ebx
	mov	DWORD PTR Length$7[rsp], ebx

; 125  :         unsigned char* PNG = stbi_write_png_to_mem_forward(this->m_Pixels.data(), this->m_Width * 4, this->m_Width, this->m_Height, 4, &Length);

	movzx	r9d, WORD PTR [r14+34]
	movzx	r8d, WORD PTR [r14+32]
	lea	edx, DWORD PTR [r8*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image_write.h

; 1233 :     return stbi_write_png_to_mem(pixels, stride_bytes, x, y, n, out_len);

	lea	rax, QWORD PTR Length$7[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, QWORD PTR [r14+8]
	call	stbi_write_png_to_mem
	mov	r15, rax
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 127  :         std::vector<unsigned char> FileData(Length + 1);

	movsxd	rsi, DWORD PTR Length$7[rsp]
	lea	eax, DWORD PTR [rsi+1]
	movsxd	rdi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR FileData$18[rbp-256], xmm0
	mov	QWORD PTR FileData$18[rbp-240], rbx

; 2065 :         if (_Count != 0) {

	test	eax, eax
	je	SHORT $LN915@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdi, r12
	ja	$LN1342@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN871@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN1343@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN827@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN869@TextureToG
$LN871@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
$LN869@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR FileData$18[rbp-256], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+rdi]
	mov	QWORD PTR FileData$18[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR FileData$18[rbp-248], rbx
$LN915@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 128  :         FileData[0] = this->m_Transparent;

	movzx	ecx, BYTE PTR [r14+42]
	mov	rax, QWORD PTR FileData$18[rbp-256]
	mov	BYTE PTR [rax], cl

; 129  :         std::copy(PNG, PNG + Length, FileData.data() + 1);

	mov	rcx, QWORD PTR FileData$18[rbp-256]
	inc	rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rsi
	mov	rdx, r15
	call	memmove
	xor	edx, edx
	mov	r8d, 264				; 00000108H
	lea	rcx, QWORD PTR OutputFile$24[rbp-256]
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 131  :         std::ofstream OutputFile(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	lea	rdx, OFFSET FLAT:??_C@_02CFKBDFGI@?1?2@
	mov	rbx, QWORD PTR Path$GSCopy$1$[rbp-256]
	mov	rcx, rbx
	call	?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
	lea	rcx, QWORD PTR [rax+1]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T11[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rsp+24], rax

; 2260 :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR [rbx+16]
	cmp	rax, rcx
	jb	$LN1344@TextureToG

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	sub	rax, rcx
	mov	r8, -1
	mov	rdi, r8
	cmp	rax, r8
	cmovb	rdi, rax

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rbx

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN587@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rbx]
$LN587@TextureToG:

; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

	lea	rsi, QWORD PTR [rcx+rax]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r12
	ja	$LN1345@TextureToG

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T11[rsp+24], 15
	cmp	rdi, 16
	jae	SHORT $LN593@TextureToG

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rsp+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, rsi
	lea	rcx, QWORD PTR $T11[rsp]
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T11[rsp+rdi], 0

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN591@TextureToG
$LN593@TextureToG:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, rdi
	or	rax, 15
	cmp	rax, r12

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN603@TextureToG

; 4716 :             return _Max;
; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	r12, rax
	mov	ecx, 22
	cmp	rax, rcx
	cmovb	r12, rcx
$LN603@TextureToG:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, r12
	add	rdx, 1
	cmovb	rdx, r8
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	rbx, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T11[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T11[rsp+16], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T11[rsp+24], r12

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
$LN591@TextureToG:

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06KINIHAEN@Cache?1@
	lea	rcx, QWORD PTR $T11[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T13[rbp-240], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 131  :         std::ofstream OutputFile(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	xor	ebx, ebx
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T13[rbp-240]
	mov	rdx, QWORD PTR $T13[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 5
	jb	SHORT $LN663@TextureToG

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+5]
	mov	QWORD PTR $T13[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T13[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rbx, QWORD PTR $T13[rsp]

; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+5], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T13[rsp]
	xor	ebx, ebx
	jmp	SHORT $LN662@TextureToG
$LN663@TextureToG:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 5
	lea	r9, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	edx, 5
	lea	rcx, QWORD PTR $T13[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN662@TextureToG:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T22[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T22[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T22[rbp-232], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T22[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T22[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 131  :         std::ofstream OutputFile(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	lea	rdx, QWORD PTR $T22[rbp-256]
	lea	rcx, QWORD PTR $T20[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN841@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN841@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 226  :         : basic_ofstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	r8d, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR OutputFile$24[rbp-256]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR OutputFile$24[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rdi, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR OutputFile$24[rbp+rcx-256], rdi
	mov	rax, QWORD PTR OutputFile$24[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-168]
	mov	DWORD PTR OutputFile$24[rbp+rcx-260], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T20[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN727@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T20[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN739@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN739@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN739@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN727@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T20[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T20[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN756@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T13[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN768@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN768@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN768@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN756@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T13[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T11[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN785@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T11[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN797@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN797@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN797@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN785@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rsp+16], rbx

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR FileData$18[rbp-248]
	mov	rdx, QWORD PTR FileData$18[rbp-256]
	sub	r8, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 132  :         OutputFile.write((char*)FileData.data(), FileData.size());

	lea	rcx, QWORD PTR OutputFile$24[rbp-256]
	call	QWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 376  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR OutputFile$24[rbp-248]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN807@TextureToG

; 377  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR OutputFile$24[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR OutputFile$24[rbp-256]
	add	rcx, rax
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN807@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 135  :         free(PNG);

	mov	rcx, r15
	call	QWORD PTR __imp_free
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 344  :     __CLR_OR_THIS_CALL ~basic_ofstream() noexcept override {}

	mov	rax, QWORD PTR OutputFile$24[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR OutputFile$24[rbp+rcx-256], rdi
	mov	rax, QWORD PTR OutputFile$24[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-168]
	mov	DWORD PTR OutputFile$24[rbp+rcx-260], edx
	lea	rcx, QWORD PTR OutputFile$24[rbp-248]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR OutputFile$24[rbp-240]
	call	QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR OutputFile$24[rbp-88]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR FileData$18[rbp-256]
	test	rcx, rcx
	je	$LN15@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR FileData$18[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN830@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN830@TextureToG
$LN827@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN830@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 138  :     }

	jmp	$LN15@TextureToG
$LN19@TextureToG:

; 139  :     else
; 140  :     {
; 141  :         this->m_Pixels.resize(this->m_Width * this->m_Height * 4);

	movzx	ecx, WORD PTR [r14+34]
	movzx	eax, WORD PTR [r14+32]
	imul	ecx, eax
	shl	ecx, 2
	movsxd	rdx, ecx
	lea	rcx, QWORD PTR [r14+8]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 142  :         for (int i = 0; i < this->m_Width * this->m_Height / 2; i++)

	xor	ebx, ebx
	mov	r9d, ebx
	movzx	ecx, WORD PTR [r14+34]
	movzx	eax, WORD PTR [r14+32]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	test	eax, eax
	jle	SHORT $LN15@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1883 :         auto& _My_data = _Mypair._Myval2;

	mov	r8d, ebx
	npad	6
$LL16@TextureToG:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 145  :             this->m_Pixels[i * 8] = 255;

	mov	BYTE PTR [r8+rax], 255			; 000000ffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 146  :             this->m_Pixels[i * 8 + 1] = 0;

	mov	BYTE PTR [rax+r8+1], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 147  :             this->m_Pixels[i * 8 + 2] = 0;

	mov	BYTE PTR [r8+rax+2], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 148  :             this->m_Pixels[i * 8 + 3] = 255;

	mov	BYTE PTR [r8+rax+3], 255		; 000000ffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 150  :             this->m_Pixels[i * 8 + 4] = 0;

	mov	BYTE PTR [rax+r8+4], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 151  :             this->m_Pixels[i * 8 + 5] = 0;

	mov	BYTE PTR [rax+r8+5], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 152  :             this->m_Pixels[i * 8 + 6] = 0;

	mov	BYTE PTR [r8+rax+6], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 153  :             this->m_Pixels[i * 8 + 7] = 255;

	mov	BYTE PTR [r8+rax+7], 255		; 000000ffH

; 142  :         for (int i = 0; i < this->m_Width * this->m_Height / 2; i++)

	inc	r9d
	lea	r8, QWORD PTR [r8+8]
	movzx	ecx, WORD PTR [r14+34]
	movzx	eax, WORD PTR [r14+32]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	r9d, eax
	jl	SHORT $LL16@TextureToG
$LN15@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Input$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN381@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Input$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN399@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN399@TextureToG
$LN396@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN399@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Input$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Input$[rbp-240], rbx
$LN381@TextureToG:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Surfaces$[rbp-256]
	test	rcx, rcx
	je	$LN355@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Surfaces$[rbp-240]
	sub	rax, rcx
	sar	rax, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*8]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN373@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN373@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN373@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2051 :             _Myend   = nullptr;

	jmp	SHORT $LN355@TextureToG
$LN18@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 65   :         Logger::Error("TexToGoDecoder", "Magic mismatch, expected 6PK0");

	lea	rax, QWORD PTR $T12[rsp]
	mov	QWORD PTR $T16[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 29
	lea	rdx, OFFSET FLAT:??_C@_0BO@PFKENAAJ@Magic?5mismatch?0?5expected?56PK0@
	lea	rcx, QWORD PTR $T12[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T15[rbp-240], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rbp-232], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 14
	lea	rdx, OFFSET FLAT:??_C@_0P@MBKHCCBD@TexToGoDecoder@
	lea	rcx, QWORD PTR $T15[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 65   :         Logger::Error("TexToGoDecoder", "Magic mismatch, expected 6PK0");

	lea	rdx, QWORD PTR $T12[rsp]
	lea	rcx, QWORD PTR $T15[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
$LN355@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR Path$GSCopy$1$[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r13]
	test	rcx, rcx
	je	SHORT $LN329@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r13+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN347@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN344@TextureToG

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN347@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r13], rbx

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r13+8], rbx

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r13+16], rbx
$LN329@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 156  : }

	mov	rax, r14
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+672]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN344@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN1345@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1340@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1202@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1204@TextureToG:
	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN1203@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN1341@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1342@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1343@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1344@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN1338@TextureToG:
??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ENDP ; TextureToGo::TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$0@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$1@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$1
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$2@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$3@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$3
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$5@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$5
	lea	rcx, QWORD PTR Surfaces$[rdx]
	jmp	??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::~vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >
?dtor$5@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$6@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$6
	lea	rcx, QWORD PTR RawImageData$23[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$6@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$7@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$7
	lea	rcx, QWORD PTR Result$21[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$7@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$18@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$18
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$18@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$10@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$10
	lea	rcx, QWORD PTR Input$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$10@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$11@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$11
	lea	rcx, QWORD PTR FileData$18[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$11@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$12@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$12
	lea	rcx, QWORD PTR $T11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$13@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$13
	lea	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$13@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$15@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$15
	lea	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
j$1$ = 80
Length$7 = 80
$T8 = 84
$T9 = 86
$T10 = 88
$T11 = 88
$T12 = 88
$T13 = 120
$T14 = 120
$T15 = 120
$T16 = 152
Path$GSCopy$1$ = 160
$T17 = 168
this$GSCopy$ = 176
Path$GSCopy$ = 192
Bytes$GSCopy$ = 200
FileData$18 = 208
$T19 = 208
$T20 = 232
Result$21 = 232
$T22 = 264
RawImageData$23 = 264
Input$ = 296
Surfaces$ = 320
OutputFile$24 = 352
__$ArrayPad$ = 624
this$ = 736
Path$ = 744
Bytes$ = 752
?dtor$16@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$16
	lea	rcx, QWORD PTR OutputFile$24[rdx]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$16@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; TextureToGo::TextureToGo, COMDAT

; 159  : {

$LN1039:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-1072]
	sub	rsp, 1328				; 00000530H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rdx
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$[rbp-256], rcx
	mov	QWORD PTR Path$GSCopy$[rbp-256], rdx
	xor	r14d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR [rcx], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], r14
	mov	QWORD PTR [rcx+16], r14
	mov	QWORD PTR [rcx+24], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rcx+42], r14w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 160  :     if (Util::FileExists(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng")))

	lea	rdx, OFFSET FLAT:??_C@_02CFKBDFGI@?1?2@
	mov	rcx, rsi
	call	?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
	lea	rcx, QWORD PTR [rax+1]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rbp-232], r14

; 2260 :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR [rsi+16]
	cmp	rax, rcx
	jb	$LN1028@TextureToG

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	sub	rax, rcx
	mov	r8, -1
	mov	rdi, r8
	cmp	rax, r8
	cmovb	rdi, rax

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN54@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN54@TextureToG:

; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

	lea	r12, QWORD PTR [rax+rcx]

; 2620 :         if (_Count > max_size()) {

	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, r15
	ja	$LN1029@TextureToG

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	eax, 22
	mov	QWORD PTR $T6[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN60@TextureToG

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, r12
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T6[rbp+rdi-256], 0

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN58@TextureToG
$LN60@TextureToG:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	r14, rdi
	or	r14, 15
	cmp	r14, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN71@TextureToG

; 4716 :             return _Max;

	mov	r14, r15
	jmp	SHORT $LN70@TextureToG
$LN71@TextureToG:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	r14, rax
	cmovb	r14, rax
$LN70@TextureToG:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, r14
	add	rdx, 1
	cmovb	rdx, r8
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	rbx, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T6[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T6[rbp-232], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, r12
	mov	rcx, rax
	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	xor	r14d, r14d
$LN58@TextureToG:

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06KINIHAEN@Cache?1@
	lea	rcx, QWORD PTR $T6[rbp-256]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T4[rsp+16], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T4[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T4[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 160  :     if (Util::FileExists(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng")))

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T4[rsp+16]
	mov	rdx, QWORD PTR $T4[rsp+24]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 5
	jb	SHORT $LN131@TextureToG

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+5]
	mov	QWORD PTR $T4[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T4[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rbx, QWORD PTR $T4[rsp]

; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+5], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN130@TextureToG
$LN131@TextureToG:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 5
	lea	r9, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	edx, 5
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN130@TextureToG:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T10[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T10[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T10[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 160  :     if (Util::FileExists(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng")))

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	lea	rdx, QWORD PTR $T10[rbp-256]
	lea	rcx, QWORD PTR $T15[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rax

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN188@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rax]
$LN188@TextureToG:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h

; 241  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	lea	rdx, QWORD PTR buffer$25[rbp-256]
	call	QWORD PTR __imp__stat64i32
	mov	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN209@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN221@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN221@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN221@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN209@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T4[rsp+16], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T4[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN238@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN250@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN250@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN250@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN238@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 160  :     if (Util::FileExists(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng")))

	xor	edx, edx
	mov	r8d, 272				; 00000110H
	test	edi, edi
	jne	$LN902@TextureToG
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	memset

; 162  :         std::ifstream File(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	lea	rdx, OFFSET FLAT:??_C@_02CFKBDFGI@?1?2@
	mov	rcx, rsi
	call	?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
	inc	rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T21[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T21[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T21[rbp-232], r14

; 2260 :         if (_Mysize < _Off) {

	mov	rcx, QWORD PTR [rsi+16]
	cmp	rcx, rax
	jb	$LN1030@TextureToG

; 2278 :         return (_STD min)(_Size, _Mysize - _Off);

	sub	rcx, rax
	mov	r8, -1
	mov	rdi, r8
	cmp	rcx, r8
	cmovb	rdi, rcx

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN281@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN281@TextureToG:

; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

	lea	r12, QWORD PTR [rcx+rax]

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN1031@TextureToG

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T21[rbp-232], 15
	cmp	rdi, 16
	jae	SHORT $LN287@TextureToG

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T21[rbp-240], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, r12
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	memcpy

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T21[rbp+rdi-256], 0

; 2638 :             } else { // _Strat == _Construct_strategy::_From_string
; 2639 : #ifdef _INSERT_STRING_ANNOTATION
; 2640 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2641 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2642 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2643 : #endif // !_INSERT_STRING_ANNOTATION
; 2644 :             }
; 2645 : 
; 2646 :             _Proxy._Release();
; 2647 :             return;

	jmp	SHORT $LN285@TextureToG
$LN287@TextureToG:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	r14, rdi
	or	r14, 15
	cmp	r14, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN298@TextureToG

; 4716 :             return _Max;

	mov	r14, r15
	jmp	SHORT $LN297@TextureToG
$LN298@TextureToG:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	r14, 22
	mov	eax, 22
	cmovb	r14, rax
$LN297@TextureToG:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, r14
	add	rdx, 1
	cmovb	rdx, r8
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	rbx, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T21[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T21[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T21[rbp-232], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, rdi
	mov	rdx, r12
	mov	rcx, rax
	call	memcpy

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0
	xor	r14d, r14d
$LN285@TextureToG:

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06KINIHAEN@Cache?1@
	lea	rcx, QWORD PTR $T21[rbp-256]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T5[rsp+16], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T5[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T5[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 162  :         std::ifstream File(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T5[rsp+16]
	mov	rdx, QWORD PTR $T5[rsp+24]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 5
	jb	SHORT $LN357@TextureToG

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+5]
	mov	QWORD PTR $T5[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T5[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rbx, QWORD PTR $T5[rsp]

; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+5], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T5[rsp]
	jmp	SHORT $LN356@TextureToG
$LN357@TextureToG:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 5
	lea	r9, OFFSET FLAT:??_C@_05CBIDHJPB@?4epng@
	mov	edx, 5
	lea	rcx, QWORD PTR $T5[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN356@TextureToG:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 162  :         std::ifstream File(Editor::GetWorkingDirFile("Cache/" + Path.substr(Path.find_last_of("/\\") + 1) + ".epng"), std::ios::binary);

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	lea	rdx, QWORD PTR $T11[rbp-256]
	lea	rcx, QWORD PTR $T26[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN415@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN415@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 43   :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	r8d, 32					; 00000020H
	mov	rdx, rax
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR File$27[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r14, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR File$27[rbp+rcx-256], r14
	mov	rax, QWORD PTR File$27[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR File$27[rbp+rcx-260], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T26[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN431@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T26[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN443@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN443@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN443@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN431@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T26[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN460@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN472@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN472@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN472@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN460@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T5[rsp+16], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T5[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T21[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN489@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T21[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN501@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN501@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN501@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN489@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	r12d, r12d
	mov	QWORD PTR $T21[rbp-240], r12

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T21[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T21[rbp-256], r12b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 163  :         File.seekg(0, std::ios_base::end);

	xor	edx, edx
	lea	r8d, QWORD PTR [r12+2]
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 164  : 
; 165  :         std::streampos FileSize = File.tellg();

	lea	rdx, QWORD PTR FileSize$24[rbp-256]
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	rdi, QWORD PTR FileSize$24[rbp-248]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Bytes$19[rbp-256], xmm0
	mov	QWORD PTR Bytes$19[rbp-240], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	add	rdi, QWORD PTR FileSize$24[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN573@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdi, r15
	ja	$LN1032@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN529@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN1033@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN613@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN527@TextureToG
$LN529@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
$LN527@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Bytes$19[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rdi+rax]
	mov	QWORD PTR Bytes$19[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Bytes$19[rbp-248], rbx
$LN573@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 169  :         File.seekg(0, std::ios_base::beg);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	r8, QWORD PTR FileSize$24[rbp-248]
	add	r8, QWORD PTR FileSize$24[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 170  :         File.read(reinterpret_cast<char*>(Bytes.data()), FileSize);

	mov	rdx, QWORD PTR Bytes$19[rbp-256]
	lea	rcx, QWORD PTR File$27[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 193  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR File$27[rbp-240]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN579@TextureToG

; 194  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR File$27[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$27[rbp-256]
	add	rcx, rax
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN579@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR Bytes$19[rbp-248]
	mov	rax, QWORD PTR Bytes$19[rbp-256]
	sub	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 175  :         unsigned char* Image = (unsigned char*)stbi_load_from_memory(Bytes.data() + 1, Bytes.size() - 1, &Width, &Height, &Components, STBI_rgb_alpha);

	dec	ecx
	lea	rdx, QWORD PTR [rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h

; 826  :    s->io.read = NULL;

	mov	QWORD PTR s$28[rbp-240], r12

; 827  :    s->read_from_callbacks = 0;

	mov	DWORD PTR s$28[rbp-208], r12d

; 828  :    s->callback_already_read = 0;

	mov	DWORD PTR s$28[rbp-72], r12d

; 829  :    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

	mov	QWORD PTR s$28[rbp-48], rdx
	mov	QWORD PTR s$28[rbp-64], rdx

; 830  :    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

	movsxd	rcx, ecx
	add	rcx, rdx
	mov	QWORD PTR s$28[rbp-40], rcx
	mov	QWORD PTR s$28[rbp-56], rcx

; 1431 :    return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

	lea	r9, QWORD PTR Components$22[rbp-256]
	lea	r8, QWORD PTR Height$16[rbp-256]
	lea	rdx, QWORD PTR Width$17[rbp-256]
	lea	rcx, QWORD PTR s$28[rbp-256]
	call	?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 177  :         this->m_Pixels.assign(Image, Image + Width * Height * 4);

	lea	rcx, QWORD PTR [r13+8]
	mov	eax, DWORD PTR Width$17[rbp-256]
	imul	eax, DWORD PTR Height$16[rbp-256]
	shl	eax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1451 :             const auto _Count  = _Convert_size<size_type>(_Length);

	movsxd	r8, eax

; 1452 :             _Assign_counted_range(_UFirst, _Count);

	mov	rdx, rbx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 179  :         this->m_Width = Width;

	movzx	eax, WORD PTR Width$17[rbp-256]
	mov	WORD PTR [r13+32], ax

; 180  :         this->m_Height = Height;

	movzx	eax, WORD PTR Height$16[rbp-256]
	mov	WORD PTR [r13+34], ax

; 181  :         this->m_Transparent = (bool)Bytes[0];

	mov	rax, QWORD PTR Bytes$19[rbp-256]
	cmp	BYTE PTR [rax], 0
	setne	al
	mov	BYTE PTR [r13+42], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\stb\stb_image.h

; 1101 :    STBI_FREE(retval_from_stbi_load);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Bytes$19[rbp-256]
	test	rcx, rcx
	je	SHORT $LN598@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Bytes$19[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN616@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN616@TextureToG
$LN613@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN616@TextureToG:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Bytes$19[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Bytes$19[rbp-240], r12
$LN598@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 161  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	mov	rax, QWORD PTR File$27[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR File$27[rbp+rcx-256], r14
	mov	rax, QWORD PTR File$27[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR File$27[rbp+rcx-260], edx
	lea	rcx, QWORD PTR File$27[rbp-240]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR File$27[rbp-232]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR File$27[rbp-80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 183  :         return;

	jmp	$LN1026@TextureToG
$LN902@TextureToG:
	lea	rcx, QWORD PTR File$[rbp-256]
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1024@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rsi]
$LN1024@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 43   :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) {} // _Prot is an extension

	mov	r8d, 32					; 00000020H
	lea	rcx, QWORD PTR File$[rbp-256]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r14, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR File$[rbp+rcx-256], r14
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR File$[rbp+rcx-260], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 188  :     if (!File.eof() && !File.fail())

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?eof@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN3@TextureToG
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	call	QWORD PTR __imp_?fail@ios_base@std@@QEBA_NXZ
	test	al, al
	jne	$LN3@TextureToG

; 189  :     {
; 190  :         File.seekg(0, std::ios_base::end);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+2]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 191  :         std::streampos FileSize = File.tellg();

	lea	rdx, QWORD PTR FileSize$20[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	rdi, QWORD PTR FileSize$20[rbp-248]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Bytes$18[rbp-256], xmm0
	xor	r12d, r12d
	mov	QWORD PTR Bytes$18[rbp-240], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	add	rdi, QWORD PTR FileSize$20[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN867@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdi, r15
	ja	$LN1034@TextureToG
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN823@TextureToG

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN1035@TextureToG

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN888@TextureToG

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN821@TextureToG
$LN823@TextureToG:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
$LN821@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Bytes$18[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+rdi]
	mov	QWORD PTR Bytes$18[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Bytes$18[rbp-248], rbx
$LN867@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 195  :         File.seekg(0, std::ios_base::beg);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iosfwd

; 68   :         return _Myoff + _Fpos;

	mov	r8, QWORD PTR FileSize$20[rbp-248]
	add	r8, QWORD PTR FileSize$20[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 196  :         File.read(reinterpret_cast<char*>(Bytes.data()), FileSize);

	mov	rdx, QWORD PTR Bytes$18[rbp-256]
	lea	rcx, QWORD PTR File$[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 193  :         if (!_Filebuffer.close()) {

	lea	rcx, QWORD PTR File$[rbp-240]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	rax, rax
	jne	SHORT $LN768@TextureToG

; 194  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, QWORD PTR File$[rbp-256]
	add	rcx, rax
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN768@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 200  :         this->TextureToGo::TextureToGo(Path, Bytes);

	lea	rax, QWORD PTR $T23[rbp-256]
	mov	QWORD PTR $T8[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T23[rbp-256], xmm0
	mov	QWORD PTR $T23[rbp-240], r12

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR Bytes$18[rbp-248]
	sub	rdx, QWORD PTR Bytes$18[rbp-256]

; 2065 :         if (_Count != 0) {

	je	SHORT $LN801@TextureToG

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, r15
	ja	$LN1036@TextureToG

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	lea	rcx, QWORD PTR $T23[rbp-256]
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR $T23[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR Bytes$18[rbp-248]
	mov	rdx, QWORD PTR Bytes$18[rbp-256]
	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	QWORD PTR $T23[rbp-248], rax
$LN801@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 200  :         this->TextureToGo::TextureToGo(Path, Bytes);

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	r8, QWORD PTR $T23[rbp-256]
	mov	rdx, rax
	mov	rcx, r13
	call	??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@EV?$allocator@E@std@@@2@@Z ; TextureToGo::TextureToGo
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Bytes$18[rbp-256]
	test	rcx, rcx
	je	$LN744@TextureToG

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Bytes$18[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN756@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN756@TextureToG
$LN888@TextureToG:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 204  :         Logger::Error("TexToGoDecoder", "Could not open file \"" + Path + "\"");

	lea	rbx, QWORD PTR $T12[rbp-256]
	mov	QWORD PTR $T7[rbp-256], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rsi+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	sub	r15, rcx
	cmp	r15, 21
	jb	$LN1037@TextureToG

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN655@TextureToG

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN655@TextureToG:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 21
	lea	r9, OFFSET FLAT:??_C@_0BG@JPHMGNJI@Could?5not?5open?5file?5?$CC@
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T9[rbp-240]
	mov	rdx, QWORD PTR $T9[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN668@TextureToG

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T9[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T9[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T9[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 34			; 00000022H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T9[rbp-256]
	jmp	SHORT $LN667@TextureToG
$LN668@TextureToG:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC@
	mov	edx, 1
	lea	rcx, QWORD PTR $T9[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN667@TextureToG:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r12d, r12d
	mov	QWORD PTR $T12[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rbp-232], r12

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T12[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T12[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 204  :         Logger::Error("TexToGoDecoder", "Could not open file \"" + Path + "\"");

	mov	QWORD PTR [rax+16], r12
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], r12b
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-232], r12

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r12+14]
	lea	rdx, OFFSET FLAT:??_C@_0P@MBKHCCBD@TexToGoDecoder@
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 204  :         Logger::Error("TexToGoDecoder", "Could not open file \"" + Path + "\"");

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T13[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T9[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN744@TextureToG

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T9[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN756@TextureToG

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN756@TextureToG
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN756@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 206  : }

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN744@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\fstream

; 161  :     __CLR_OR_THIS_CALL ~basic_ifstream() noexcept override {}

	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR File$[rbp+rcx-256], r14
	mov	rax, QWORD PTR File$[rbp-256]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-176]
	mov	DWORD PTR File$[rbp+rdx-260], r8d
	lea	rcx, QWORD PTR File$[rbp-240]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR File$[rbp-232]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR File$[rbp-80]
$LN1026@TextureToG:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 206  : }

	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 206  : }

	mov	rax, r13
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1408]
	add	rsp, 1328				; 00000530H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1037@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1028@TextureToG:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN1029@TextureToG:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1030@TextureToG:

; 2261 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	int	3
$LN1031@TextureToG:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1032@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1033@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1034@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1035@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1036@TextureToG:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1025@TextureToG:
??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; TextureToGo::TextureToGo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$0@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$0
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$1@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$1@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$2@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$2
	lea	rcx, QWORD PTR $T6[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$3@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$3
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$6@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$6
	lea	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$7@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$7
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$9@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$9
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$10@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$10
	lea	rcx, QWORD PTR File$27[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$10@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$11@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$11
	lea	rcx, QWORD PTR Bytes$19[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$11@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$12@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$12
	lea	rcx, QWORD PTR File$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$12@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$13@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$13
	lea	rcx, QWORD PTR Bytes$18[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$13@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$14@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$14
	mov	rcx, QWORD PTR $T8[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$14@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$16@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$16
	lea	rcx, QWORD PTR $T9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 96
$T6 = 128
$T7 = 160
$T8 = 160
$T9 = 168
$T10 = 200
$T11 = 232
$T12 = 264
$T13 = 296
this$GSCopy$ = 336
$T14 = 352
$T15 = 352
Height$16 = 384
Width$17 = 388
Path$GSCopy$ = 392
File$ = 400
Bytes$18 = 672
Bytes$19 = 672
FileSize$20 = 696
$T21 = 696
Components$22 = 728
$T23 = 736
FileSize$24 = 736
buffer$25 = 760
$T26 = 760
File$27 = 816
s$28 = 1088
__$ArrayPad$ = 1312
this$ = 1392
Path$ = 1400
?dtor$17@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `TextureToGo::TextureToGo'::`1'::dtor$17
	mov	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0???0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `TextureToGo::TextureToGo'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp
;	COMDAT ??__ETextures@TextureToGoLibrary@@YAXXZ
text$di	SEGMENT
??__ETextures@TextureToGoLibrary@@YAXXZ PROC		; TextureToGoLibrary::`dynamic initializer for 'Textures'', COMDAT

; 207  : std::map<std::string, TextureToGo> TextureToGoLibrary::Textures;

	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 207  : std::map<std::string, TextureToGo> TextureToGoLibrary::Textures;

	lea	rcx, OFFSET FLAT:??__FTextures@TextureToGoLibrary@@YAXXZ ; TextureToGoLibrary::`dynamic atexit destructor for 'Textures''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.cpp

; 207  : std::map<std::string, TextureToGo> TextureToGoLibrary::Textures;

	add	rsp, 40					; 00000028H
	jmp	atexit
??__ETextures@TextureToGoLibrary@@YAXXZ ENDP		; TextureToGoLibrary::`dynamic initializer for 'Textures''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FTextures@TextureToGoLibrary@@YAXXZ
text$yd	SEGMENT
??__FTextures@TextureToGoLibrary@@YAXXZ PROC		; TextureToGoLibrary::`dynamic atexit destructor for 'Textures'', COMDAT
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rcx, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rcx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN12@dynamic
	mov	QWORD PTR [rsp+48], rdi
	npad	4
$LL11@dynamic:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	lea	rdx, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	lea	rcx, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdi, rbx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL11@dynamic
	mov	rdi, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
$LN12@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
??__FTextures@TextureToGoLibrary@@YAXXZ ENDP		; TextureToGoLibrary::`dynamic atexit destructor for 'Textures''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, xmm0
	ret	0
?__autoclassinit2@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >, COMDAT
	jmp	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >, COMDAT

; 107  :     map() : _Mybase(key_compare()) {}

$LN50:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 107  :     map() : _Mybase(key_compare()) {}

	lea	rbx, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, rax
	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+112]
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 107  :     map() : _Mybase(key_compare()) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAA@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >, COMDAT

; 1080 :     ~_Tree() noexcept {

$LN116:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]

; 1080 :     ~_Tree() noexcept {

	mov	rsi, rcx

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN7@Tree
	mov	QWORD PTR [rsp+56], rdi
	npad	1
$LL6@Tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rsi
	mov	rcx, rsi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdi, rbx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL6@Tree
	mov	rdi, QWORD PTR [rsp+56]
$LN7@Tree:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 112				; 00000070H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1087 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAAEAUSurfaceInfo@TextureToGo@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAAEAUSurfaceInfo@TextureToGo@@_K@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 1890 :     }

	ret	0
??A?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAAEAUSurfaceInfo@TextureToGo@@_K@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::~vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::~vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN84:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbx
	mov	QWORD PTR [rcx+16], rbx

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN64@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	$LN81@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN82@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN33@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax
$LN25@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rbx+rdi]
$LN79@vector:
	mov	rdx, rsi
	lea	r8, QWORD PTR [rbp*8]
	mov	rcx, rbx
	mov	QWORD PTR [rdx], rbx
	xor	edx, edx
	mov	QWORD PTR [rsi+16], rax
	call	memset
	add	rbx, rdi

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN64@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN33@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@vector:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN25@vector

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rdi
	jmp	SHORT $LN79@vector
$LN82@vector:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN81@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength
	int	3
$LN78@vector:
??0?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAA@XZ PROC ; std::allocator<TextureToGo::SurfaceInfo>::allocator<TextureToGo::SurfaceInfo>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAA@XZ ENDP ; std::allocator<TextureToGo::SurfaceInfo>::allocator<TextureToGo::SurfaceInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Parg$dead$ = 56
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >, COMDAT

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN46:
	sub	rsp, 40					; 00000028H
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqu	XMMWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, rax

; 883  :         _Alloc_sentinel_and_proxy();
; 884  :     }

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1939 :     void _Alloc_sentinel_and_proxy() {

$LN36:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1940 :         const auto _Scary = _Get_scary();
; 1941 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1942 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, rax

; 1944 :         _Proxy._Release();
; 1945 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z PROC ; std::allocator<TextureToGo::SurfaceInfo>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAXQEAUSurfaceInfo@TextureToGo@@_K@Z ENDP ; std::allocator<TextureToGo::SurfaceInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAAAEAV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC		; std::copy<unsigned char *,unsigned char *>, COMDAT

; 4619 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

$LN20:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4620 :     _Adl_verify_range(_First, _Last);
; 4621 :     const auto _UFirst = _Get_unwrapped(_First);
; 4622 :     const auto _ULast  = _Get_unwrapped(_Last);
; 4623 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 4624 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
; 4625 :     return _Dest;
; 4626 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$copy@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP		; std::copy<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Idl_distance@PEAEPEAE@std@@YA?A_PAEBQEAE0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEAEPEAE@std@@YA?A_PAEBQEAE0@Z PROC	; std::_Idl_distance<unsigned char *,unsigned char *>, COMDAT

; 1317 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1318 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1319 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]

; 1320 :     } else {
; 1321 :         return _Distance_unknown{};
; 1322 :     }
; 1323 : }

	ret	0
??$_Idl_distance@PEAEPEAE@std@@YA?A_PAEBQEAE0@Z ENDP	; std::_Idl_distance<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAPEAE_J@std@@YA?A_TAEAPEAE_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEAPEAE_J@std@@YA?A_TAEAPEAE_J@Z PROC ; std::_Get_unwrapped_n<unsigned char * &,__int64>, COMDAT

; 1222 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1223 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1224 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1225 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1226 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1227 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1228 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1229 : 
; 1230 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1231 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1232 :             "integer overflow");
; 1233 :         (void) _COff;
; 1234 : 
; 1235 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1236 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1237 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1238 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1239 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1240 :     } else {
; 1241 :         // pass through iterator that doesn't participate in checking
; 1242 :         return static_cast<_Iter&&>(_It);
; 1243 :     }
; 1244 : }

	ret	0
??$_Get_unwrapped_n@AEAPEAE_J@std@@YA?A_TAEAPEAE_J@Z ENDP ; std::_Get_unwrapped_n<unsigned char * &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$assign@PEAE$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAAXPEAE0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
??$assign@PEAE$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAAXPEAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<unsigned char *,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1452 :             _Assign_counted_range(_UFirst, _Count);

	jmp	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
??$assign@PEAE$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAAXPEAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::assign<unsigned char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Val1$ = 88
_Val2$ = 96
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rbx, r8
	mov	rdi, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR $T1[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	XMMWORD PTR $T1[rsp+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rbx+16], 0
	mov	QWORD PTR [rbx+24], 15
	mov	BYTE PTR [rbx], 0
	lea	rdx, QWORD PTR $T1[rsp]
	call	??0TextureToGo@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TextureToGo::TextureToGo
	npad	1

; 243  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Val1$ = 88
_Val2$ = 96
?dtor$0@?0???$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z@4HA PROC ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$?0AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V01@$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@$$QEAV21@@Z@4HA ENDP ; `std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Al$ = 72
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN113:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 32					; 00000020H

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, rdx
	mov	rsi, rcx
	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN5@Erase_head
	mov	QWORD PTR [rsp+80], rdi
$LL4@Erase_head:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rbp
	mov	rcx, rsi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdi, rbx

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 112				; 00000070H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL4@Erase_head
	mov	rdi, QWORD PTR [rsp+80]
$LN5@Erase_head:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rsi]
	mov	edx, 112				; 00000070H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 756  :     }

	add	rsp, 32					; 00000020H
	pop	rsi
	pop	rbp
	pop	rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@$$V@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@$$V@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1><std::allocator<TextureToGo::SurfaceInfo> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@$$V@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1><std::allocator<TextureToGo::SurfaceInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN83:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN76@Construct_
	push	rbp
	push	rsi
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbp, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN80@Construct_
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+48], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rdx*8]
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN81@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN77@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rdi
	jmp	SHORT $LN78@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	ebx, ebx
$LN77@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rbx+rdi]
$LN78@Construct_:
	mov	QWORD PTR [rsi], rbx
	lea	r8, QWORD PTR [rbp*8]
	mov	rcx, rbx
	mov	QWORD PTR [rsi+16], rax
	xor	edx, edx
	call	memset
	mov	r14, QWORD PTR [rsp+40]
	add	rbx, rdi
	mov	rdi, QWORD PTR [rsp+48]
	mov	r15, QWORD PTR [rsp+32]

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rbx
	mov	rbx, QWORD PTR [rsp+96]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbp
$LN76@Construct_:
	ret	0
$LN81@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN80@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength
	int	3
$LN75@Construct_:
??$_Construct_n@$$V@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$dead$ = 32
??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqu	XMMWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAXPEAUSurfaceInfo@TextureToGo@@QEAU12@AEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAXPEAUSurfaceInfo@TextureToGo@@QEAU12@AEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAXPEAUSurfaceInfo@TextureToGo@@QEAU12@AEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >, COMDAT

; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN33:
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >::~_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >::~_Tidy_guard<std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN45:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN43@Buy_nonzer
	mov	QWORD PTR [rsp+48], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN44@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN43@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength
	int	3
$LN44@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN41@Buy_nonzer:
?_Buy_nonzero@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@CAXXZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ PROC ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@USurfaceInfo@TextureToGo@@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@AEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ENDP ; std::vector<TextureToGo::SurfaceInfo,std::allocator<TextureToGo::SurfaceInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SA_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SA_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SA_KAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z PROC ; std::allocator<TextureToGo::SurfaceInfo>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@USurfaceInfo@TextureToGo@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@_K@Z ENDP ; std::allocator<TextureToGo::SurfaceInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@USurfaceInfo@TextureToGo@@@std@@V?$_Vector_val@U?$_Simple_types@USurfaceInfo@TextureToGo@@@std@@@2@$00@std@@QEBAAEBV?$allocator@USurfaceInfo@TextureToGo@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TextureToGo::SurfaceInfo>,std::_Vector_val<std::_Simple_types<TextureToGo::SurfaceInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1><>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	movdqu	XMMWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@PEAEPEAE@std@@YAXAEAPEAE$$QEAPEAE@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@PEAEPEAE@std@@YAXAEAPEAE$$QEAPEAE@Z PROC ; std::_Seek_wrapped<unsigned char *,unsigned char *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@PEAEPEAE@std@@YAXAEAPEAE$$QEAPEAE@Z ENDP ; std::_Seek_wrapped<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAAEBV?$allocator@USurfaceInfo@TextureToGo@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAAEBV?$allocator@USurfaceInfo@TextureToGo@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<TextureToGo::SurfaceInfo> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAAEBV?$allocator@USurfaceInfo@TextureToGo@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<TextureToGo::SurfaceInfo> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx*8]
	mov	r8, rbx
	xor	edx, edx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rbx, QWORD PTR [rsp+48]

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();

	mov	rax, rdi

; 2046 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@_KAEAV?$allocator@USurfaceInfo@TextureToGo@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAPEAUSurfaceInfo@TextureToGo@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::~_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::~_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@PEAUSurfaceInfo@TextureToGo@@AEAV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@PEAUSurfaceInfo@TextureToGo@@AEAV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAA@PEAUSurfaceInfo@TextureToGo@@AEAV?$allocator@USurfaceInfo@TextureToGo@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >, COMDAT

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xorps	xmm0, xmm0
	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	movdqu	XMMWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A, xmm0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	lea	rax, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<TextureToGo::SurfaceInfo> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@AEBQEAU12@$0A@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@QEAPEAU10@AEBQEAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@USurfaceInfo@TextureToGo@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@USurfaceInfo@TextureToGo@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@@Z PROC ; std::_Unfancy<TextureToGo::SurfaceInfo>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@USurfaceInfo@TextureToGo@@@std@@YAPEAUSurfaceInfo@TextureToGo@@PEAU12@@Z ENDP ; std::_Unfancy<TextureToGo::SurfaceInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@USurfaceInfo@TextureToGo@@$$V@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SAXAEAV?$allocator@USurfaceInfo@TextureToGo@@@1@QEAUSurfaceInfo@TextureToGo@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@USurfaceInfo@TextureToGo@@$$V@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SAXAEAV?$allocator@USurfaceInfo@TextureToGo@@@1@QEAUSurfaceInfo@TextureToGo@@@Z PROC ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::construct<TextureToGo::SurfaceInfo>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@USurfaceInfo@TextureToGo@@$$V@?$_Default_allocator_traits@V?$allocator@USurfaceInfo@TextureToGo@@@std@@@std@@SAXAEAV?$allocator@USurfaceInfo@TextureToGo@@@1@QEAUSurfaceInfo@TextureToGo@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TextureToGo::SurfaceInfo> >::construct<TextureToGo::SurfaceInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@USurfaceInfo@TextureToGo@@$$V$0A@@std@@YAPEAUSurfaceInfo@TextureToGo@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@USurfaceInfo@TextureToGo@@$$V$0A@@std@@YAPEAUSurfaceInfo@TextureToGo@@QEAU12@@Z PROC ; std::construct_at<TextureToGo::SurfaceInfo,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@USurfaceInfo@TextureToGo@@$$V$0A@@std@@YAPEAUSurfaceInfo@TextureToGo@@QEAU12@@Z ENDP ; std::construct_at<TextureToGo::SurfaceInfo,0>
_TEXT	ENDS
END
