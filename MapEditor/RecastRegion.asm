; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DA@JEAHFIBK@rcBuildDistanceField?3?5Out?5of?5me@ ; `string'
PUBLIC	??_C@_0GM@DMGHBEJM@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0DK@OBGGBNEE@mergeAndFilterLayerRegions?3?5Out@ ; `string'
PUBLIC	??_C@_0DF@FMOHEMOG@mergeAndFilterRegions?3?5Out?5of?5m@ ; `string'
PUBLIC	??_C@_0CK@MEAHGGHD@rcBuildRegions?3?5Out?5of?5memory?5?8@ ; `string'
PUBLIC	??_C@_0DF@NGOKKNLI@rcBuildRegionsMonotone?3?5Out?5of?5@ ; `string'
PUBLIC	??_C@_0DC@KEFDNIMJ@rcBuildRegionsMonotone?3?5Out?5of?5@ ; `string'
PUBLIC	??_C@_0DA@DEKJMNNE@rcBuildDistanceField?3?5Out?5of?5me@ ; `string'
PUBLIC	??_C@_0DC@EBMPJHLE@rcBuildLayerRegions?3?5Out?5of?5mem@ ; `string'
PUBLIC	??_C@_0CP@MJBDIBBN@rcBuildLayerRegions?3?5Out?5of?5mem@ ; `string'
PUBLIC	??_C@_0CI@FANGPCDB@rcBuildRegions?3?5?$CFd?5overlapping?5@ ; `string'
PUBLIC	??_C@_0CD@FFAAAELN@rcBuildRegions?3?5Region?5ID?5overf@ ; `string'
;	COMDAT ??_C@_0CD@FFAAAELN@rcBuildRegions?3?5Region?5ID?5overf@
CONST	SEGMENT
??_C@_0CD@FFAAAELN@rcBuildRegions?3?5Region?5ID?5overf@ DB 'rcBuildRegion'
	DB	's: Region ID overflow', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FANGPCDB@rcBuildRegions?3?5?$CFd?5overlapping?5@
CONST	SEGMENT
??_C@_0CI@FANGPCDB@rcBuildRegions?3?5?$CFd?5overlapping?5@ DB 'rcBuildReg'
	DB	'ions: %d overlapping regions.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MJBDIBBN@rcBuildLayerRegions?3?5Out?5of?5mem@
CONST	SEGMENT
??_C@_0CP@MJBDIBBN@rcBuildLayerRegions?3?5Out?5of?5mem@ DB 'rcBuildLayerR'
	DB	'egions: Out of memory ''src'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EBMPJHLE@rcBuildLayerRegions?3?5Out?5of?5mem@
CONST	SEGMENT
??_C@_0DC@EBMPJHLE@rcBuildLayerRegions?3?5Out?5of?5mem@ DB 'rcBuildLayerR'
	DB	'egions: Out of memory ''sweeps'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DEKJMNNE@rcBuildDistanceField?3?5Out?5of?5me@
CONST	SEGMENT
??_C@_0DA@DEKJMNNE@rcBuildDistanceField?3?5Out?5of?5me@ DB 'rcBuildDistan'
	DB	'ceField: Out of memory ''dst'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KEFDNIMJ@rcBuildRegionsMonotone?3?5Out?5of?5@
CONST	SEGMENT
??_C@_0DC@KEFDNIMJ@rcBuildRegionsMonotone?3?5Out?5of?5@ DB 'rcBuildRegion'
	DB	'sMonotone: Out of memory ''src'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NGOKKNLI@rcBuildRegionsMonotone?3?5Out?5of?5@
CONST	SEGMENT
??_C@_0DF@NGOKKNLI@rcBuildRegionsMonotone?3?5Out?5of?5@ DB 'rcBuildRegion'
	DB	'sMonotone: Out of memory ''sweeps'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MEAHGGHD@rcBuildRegions?3?5Out?5of?5memory?5?8@
CONST	SEGMENT
??_C@_0CK@MEAHGGHD@rcBuildRegions?3?5Out?5of?5memory?5?8@ DB 'rcBuildRegi'
	DB	'ons: Out of memory ''tmp'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FMOHEMOG@mergeAndFilterRegions?3?5Out?5of?5m@
CONST	SEGMENT
??_C@_0DF@FMOHEMOG@mergeAndFilterRegions?3?5Out?5of?5m@ DB 'mergeAndFilte'
	DB	'rRegions: Out of memory ''regions'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OBGGBNEE@mergeAndFilterLayerRegions?3?5Out@
CONST	SEGMENT
??_C@_0DK@OBGGBNEE@mergeAndFilterLayerRegions?3?5Out@ DB 'mergeAndFilterL'
	DB	'ayerRegions: Out of memory ''regions'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@DMGHBEJM@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0GM@DMGHBEJM@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastRegion.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JEAHFIBK@rcBuildDistanceField?3?5Out?5of?5me@
CONST	SEGMENT
??_C@_0DA@JEAHFIBK@rcBuildDistanceField?3?5Out?5of?5me@ DB 'rcBuildDistan'
	DB	'ceField: Out of memory ''src'' (%d).', 00H	; `string'
PUBLIC	?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z ; rcVectorBase<rcRegion,1>::copy_range
PUBLIC	?copy_range@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@PEBU2@1@Z ; rcVectorBase<DirtyEntry,1>::copy_range
PUBLIC	?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z	; rcVectorBase<int,1>::reserve
PUBLIC	?get_new_capacity@?$rcVectorBase@UrcRegion@@$00@@AEAA_J_J@Z ; rcVectorBase<rcRegion,1>::get_new_capacity
PUBLIC	?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z ; rcVectorBase<rcRegion,1>::allocate_and_copy
PUBLIC	?get_new_capacity@?$rcVectorBase@UDirtyEntry@@$00@@AEAA_J_J@Z ; rcVectorBase<DirtyEntry,1>::get_new_capacity
PUBLIC	?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z ; rcVectorBase<DirtyEntry,1>::allocate_and_copy
PUBLIC	?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z	; rcVectorBase<int,1>::assign
PUBLIC	?begin@?$rcVectorBase@H$00@@QEBAPEBHXZ		; rcVectorBase<int,1>::begin
PUBLIC	?end@?$rcVectorBase@H$00@@QEBAPEBHXZ		; rcVectorBase<int,1>::end
PUBLIC	??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z		; rcVectorBase<int,1>::rcVectorBase<int,1>
PUBLIC	??0?$rcTempVector@H@@QEAA@AEBV0@@Z		; rcTempVector<int>::rcTempVector<int>
PUBLIC	??0rcIntArray@@QEAA@AEBV0@@Z			; rcIntArray::rcIntArray
PUBLIC	??0rcRegion@@QEAA@AEBU0@@Z			; rcRegion::rcRegion
PUBLIC	?construct@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@AEBU2@@Z ; rcVectorBase<DirtyEntry,1>::construct
PUBLIC	?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z ; rcVectorBase<rcRegion,1>::construct
PUBLIC	??_GrcRegion@@QEAAPEAXI@Z			; rcRegion::`scalar deleting destructor'
PUBLIC	??$rcSwap@PEAG@@YAXAEAPEAG0@Z			; rcSwap<unsigned short *>
PUBLIC	?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z ; rcVectorBase<rcRegion,1>::push_back
PUBLIC	?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z ; rcVectorBase<rcRegion,1>::reserve
PUBLIC	?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ; rcVectorBase<rcRegion,1>::destroy_range
PUBLIC	?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z ; rcVectorBase<DirtyEntry,1>::push_back
PUBLIC	?destroy_range@?$rcVectorBase@UDirtyEntry@@$00@@AEAAX_J0@Z ; rcVectorBase<DirtyEntry,1>::destroy_range
PUBLIC	??0?$rcVectorBase@H$00@@QEAA@XZ			; rcVectorBase<int,1>::rcVectorBase<int,1>
PUBLIC	??0?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ	; rcVectorBase<DirtyEntry,1>::rcVectorBase<DirtyEntry,1>
PUBLIC	??0?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ	; rcVectorBase<rcRegion,1>::rcVectorBase<rcRegion,1>
PUBLIC	??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z		; rcVectorBase<int,1>::operator[]
PUBLIC	??0?$rcTempVector@H@@QEAA@XZ			; rcTempVector<int>::rcTempVector<int>
PUBLIC	??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ	; rcVectorBase<DirtyEntry,1>::~rcVectorBase<DirtyEntry,1>
PUBLIC	?clear@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXXZ	; rcVectorBase<DirtyEntry,1>::clear
PUBLIC	?size@?$rcVectorBase@UDirtyEntry@@$00@@QEBA_JXZ	; rcVectorBase<DirtyEntry,1>::size
PUBLIC	??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z ; rcVectorBase<DirtyEntry,1>::operator[]
PUBLIC	??0?$rcTempVector@UDirtyEntry@@@@QEAA@XZ	; rcTempVector<DirtyEntry>::rcTempVector<DirtyEntry>
PUBLIC	??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ	; rcVectorBase<rcRegion,1>::~rcVectorBase<rcRegion,1>
PUBLIC	??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z ; rcVectorBase<rcRegion,1>::operator[]
PUBLIC	??0?$rcTempVector@UrcRegion@@@@QEAA@XZ		; rcTempVector<rcRegion>::rcTempVector<rcRegion>
PUBLIC	??1rcRegion@@QEAA@XZ				; rcRegion::~rcRegion
PUBLIC	?__autoclassinit2@?$rcTempVector@UrcRegion@@@@QEAAX_K@Z ; rcTempVector<rcRegion>::__autoclassinit2
PUBLIC	??1?$rcTempVector@UrcRegion@@@@QEAA@XZ		; rcTempVector<rcRegion>::~rcTempVector<rcRegion>
PUBLIC	??0rcRegion@@QEAA@G@Z				; rcRegion::rcRegion
PUBLIC	?__autoclassinit2@?$rcTempVector@UDirtyEntry@@@@QEAAX_K@Z ; rcTempVector<DirtyEntry>::__autoclassinit2
PUBLIC	??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ	; rcTempVector<DirtyEntry>::~rcTempVector<DirtyEntry>
PUBLIC	??0DirtyEntry@@QEAA@HGG@Z			; DirtyEntry::DirtyEntry
PUBLIC	??ArcIntArray@@QEBAHH@Z				; rcIntArray::operator[]
PUBLIC	??0rcIntArray@@QEAA@XZ				; rcIntArray::rcIntArray
PUBLIC	?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z ; rcBuildRegions
PUBLIC	?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z ; rcBuildDistanceField
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z DD imagerel $LN21
	DD	imagerel $LN21+202
	DD	imagerel $unwind$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA DD imagerel ?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA
	DD	imagerel ?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD imagerel $LN17+35
	DD	imagerel $LN17+69
	DD	imagerel $chain$0$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD imagerel $LN17+69
	DD	imagerel $LN17+110
	DD	imagerel $chain$2$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z DD imagerel $LN35
	DD	imagerel $LN35+282
	DD	imagerel $unwind$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA DD imagerel ?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA
	DD	imagerel ?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z DD imagerel $LN35
	DD	imagerel $LN35+148
	DD	imagerel $unwind$?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z DD imagerel ?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
	DD	imagerel ?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z+159
	DD	imagerel $unwind$?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD imagerel $LN34
	DD	imagerel $LN34+13
	DD	imagerel $unwind$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD imagerel $LN34+13
	DD	imagerel $LN34+47
	DD	imagerel $chain$0$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD imagerel $LN34+47
	DD	imagerel $LN34+93
	DD	imagerel $chain$1$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD imagerel $LN34+93
	DD	imagerel $LN34+110
	DD	imagerel $chain$2$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD imagerel $LN34+110
	DD	imagerel $LN34+144
	DD	imagerel $chain$3$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z DD imagerel $LN39
	DD	imagerel $LN39+166
	DD	imagerel $unwind$??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$rcTempVector@H@@QEAA@AEBV0@@Z DD imagerel $LN43
	DD	imagerel $LN43+169
	DD	imagerel $unwind$??0?$rcTempVector@H@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0rcIntArray@@QEAA@AEBV0@@Z DD imagerel $LN46
	DD	imagerel $LN46+169
	DD	imagerel $unwind$??0rcIntArray@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0rcRegion@@QEAA@AEBU0@@Z DD imagerel $LN7
	DD	imagerel $LN7+126
	DD	imagerel $unwind$??0rcRegion@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z DD imagerel $LN13
	DD	imagerel $LN13+133
	DD	imagerel $unwind$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA DD imagerel ?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA
	DD	imagerel ?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GrcRegion@@QEAAPEAXI@Z DD imagerel $LN42
	DD	imagerel $LN42+50
	DD	imagerel $unwind$??_GrcRegion@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z DD imagerel $LN39
	DD	imagerel $LN39+386
	DD	imagerel $unwind$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA DD imagerel ?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
	DD	imagerel ?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA+32
	DD	imagerel $unwind$?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA DD imagerel ?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
	DD	imagerel ?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA+32
	DD	imagerel $unwind$?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD imagerel $LN17+35
	DD	imagerel $LN17+69
	DD	imagerel $chain$0$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD imagerel $LN17+69
	DD	imagerel $LN17+121
	DD	imagerel $chain$2$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z DD imagerel $LN51
	DD	imagerel $LN51+102
	DD	imagerel $unwind$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD imagerel $LN63
	DD	imagerel $LN63+81
	DD	imagerel $unwind$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD imagerel $LN63+81
	DD	imagerel $LN63+86
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD imagerel $LN63+86
	DD	imagerel $LN63+272
	DD	imagerel $chain$1$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD imagerel $LN63+272
	DD	imagerel $LN63+287
	DD	imagerel $chain$2$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD imagerel $LN63+287
	DD	imagerel $LN63+299
	DD	imagerel $chain$3$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+83
	DD	imagerel $unwind$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+83
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+199
	DD	imagerel $chain$1$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+199
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+214
	DD	imagerel $chain$2$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+214
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+225
	DD	imagerel $chain$3$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+32
	DD	imagerel $unwind$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+32
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+61
	DD	imagerel $chain$0$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+61
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+101
	DD	imagerel $chain$2$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z DD imagerel $LN10
	DD	imagerel $LN10+79
	DD	imagerel $unwind$??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ DD imagerel ??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
	DD	imagerel ??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ+17
	DD	imagerel $unwind$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ DD imagerel ?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ
	DD	imagerel ?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ+98
	DD	imagerel $unwind$?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z DD imagerel ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z
	DD	imagerel ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z+83
	DD	imagerel $unwind$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z DD imagerel ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
	DD	imagerel ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z+83
	DD	imagerel $unwind$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ DD imagerel ?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ
	DD	imagerel ?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ+74
	DD	imagerel $unwind$?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+17
	DD	imagerel $unwind$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z DD imagerel $LN10
	DD	imagerel $LN10+79
	DD	imagerel $unwind$??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+44
	DD	imagerel $unwind$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z DD imagerel $LN10
	DD	imagerel $LN10+82
	DD	imagerel $unwind$??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ DD imagerel ??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	DD	imagerel ??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ+25
	DD	imagerel $unwind$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+20
	DD	imagerel $unwind$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+20
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+209
	DD	imagerel $chain$3$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+209
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+210
	DD	imagerel $chain$4$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1rcRegion@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+47
	DD	imagerel $unwind$??1rcRegion@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+39
	DD	imagerel $unwind$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z DD imagerel ?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
	DD	imagerel ?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z+5235
	DD	imagerel $unwind$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z DD imagerel ?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z
	DD	imagerel ?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z+1308
	DD	imagerel $unwind$?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z DD imagerel ?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z
	DD	imagerel ?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z+144
	DD	imagerel $unwind$?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z DD imagerel ?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z
	DD	imagerel ?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z+136
	DD	imagerel $unwind$?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mergeRegions@@YA_NAEAUrcRegion@@0@Z DD imagerel ?mergeRegions@@YA_NAEAUrcRegion@@0@Z
	DD	imagerel ?mergeRegions@@YA_NAEAUrcRegion@@0@Z+1547
	DD	imagerel $unwind$?mergeRegions@@YA_NAEAUrcRegion@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z DD imagerel ?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z
	DD	imagerel ?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z+142
	DD	imagerel $unwind$?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z DD imagerel ?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z
	DD	imagerel ?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z+268
	DD	imagerel $unwind$?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel $unwind$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+23
	DD	imagerel $chain$0$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+23
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+201
	DD	imagerel $chain$5$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+201
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+358
	DD	imagerel $chain$6$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+358
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+377
	DD	imagerel $chain$7$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+32
	DD	imagerel $unwind$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+32
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+505
	DD	imagerel $chain$3$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+505
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+513
	DD	imagerel $chain$4$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+44
	DD	imagerel $unwind$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+44
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+242
	DD	imagerel $chain$2$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+242
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+257
	DD	imagerel $chain$3$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+151
	DD	imagerel $unwind$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+151
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+471
	DD	imagerel $chain$4$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+471
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+481
	DD	imagerel $chain$5$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+25
	DD	imagerel $unwind$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z DD imagerel ?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
	DD	imagerel ?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z+2100
	DD	imagerel $unwind$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+170
	DD	imagerel $unwind$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+170
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+1353
	DD	imagerel $chain$0$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+1353
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+1373
	DD	imagerel $chain$1$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+53
	DD	imagerel $unwind$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+53
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+841
	DD	imagerel $chain$3$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+841
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+854
	DD	imagerel $chain$4$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+32
	DD	imagerel $unwind$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+32
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+1589
	DD	imagerel $chain$6$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+1589
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+1633
	DD	imagerel $chain$7$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ArcIntArray@@QEBAHH@Z DD imagerel $LN16
	DD	imagerel $LN16+95
	DD	imagerel $unwind$??ArcIntArray@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z DD imagerel $LN783
	DD	imagerel $LN783+2461
	DD	imagerel $unwind$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA DD imagerel ?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA
	DD	imagerel ?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA+45
	DD	imagerel $unwind$?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z DD imagerel $LN98
	DD	imagerel $LN98+476
	DD	imagerel $unwind$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z DB 012H
	DB	098H
	DB	00H
	DB	'H'
	DB	02H
	DB	0b5H, 02H
	DB	08H
	DB	'2'
	DB	0aH
	DB	'*'
	DB	02H
	DB	'h'
	DB	0aH
	DB	'*'
	DB	02H
	DB	':'
	DB	0cH
	DB	'"'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z DB 0cH
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	040H
	DB	038H
	DB	040H
	DB	042H
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	060H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	0a6H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z
	DD	imagerel $ip2state$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z DD 082119H
	DD	0115412H
	DD	0103412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z DB ','
	DB	0d8H
	DB	00H
	DB	'F'
	DB	02H
	DB	'*'
	DB	04H
	DB	0c2H
	DB	0aH
	DB	'e', 08H
	DB	0cH
	DB	')', 0cH
	DB	0eH
	DB	082H
	DB	010H
	DB	','
	DB	0cH
	DB	'B'
	DB	012H
	DB	'}', 03H
	DB	010H
	DB	','
	DB	0cH
	DB	'T'
	DB	012H
	DB	'0'
	DB	010H
	DB	'l'
	DB	0cH
	DB	'v'
	DB	012H
	DB	'j'
	DB	01aH
	DB	'V'
	DB	010H
	DB	'@'
	DB	01aH
	DB	'P'
	DB	010H
	DB	0a8H
	DB	04H
	DB	'N'
	DB	'('
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z DB 028H
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	021H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$rcScopedDelete@G@@QEAA@XZ
	DB	061H
	DB	03H
	DB	070H
	DB	080H
	DB	04eH
	DD	imagerel ?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA
	DB	02aH
	DD	imagerel ??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	DB	0e1H
	DB	03H
	DB	03aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	081H
	DB	03H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	09aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	0f8H
	DB	01H
	DB	03H
	DB	031H
	DB	03H
	DB	062H
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	081H
	DB	03H
	DB	09eH
	DD	imagerel __imp___std_terminate
	DB	01H
	DB	03H
	DB	021H
	DB	04H
	DB	051H
	DB	04H
	DB	06dH
	DB	03H
	DD	imagerel __imp___std_terminate
	DB	0cdH
	DB	04H
	DD	imagerel __imp___std_terminate
	DB	03dH
	DB	05H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z
	DD	imagerel $ip2state$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z DD 0b3019H
	DD	046341fH
	DD	03c011fH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z
	DD	01d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ArcIntArray@@QEBAHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD 021H
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+32
	DD	imagerel $unwind$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD 0e5521H
	DD	07d455H
	DD	08c450H
	DD	097447H
	DD	0a6442H
	DD	0b543dH
	DD	0f3435H
	DD	06f405H
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
	DD	imagerel ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z+32
	DD	imagerel $unwind$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z DD 021001H
	DD	0e00cb210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD 021H
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+53
	DD	imagerel $unwind$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD 081021H
	DD	06f410H
	DD	07e40cH
	DD	08c408H
	DD	0103404H
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
	DD	imagerel ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z+53
	DD	imagerel $unwind$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z DD 051801H
	DD	0d0148218H
	DD	060117012H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD 021H
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+170
	DD	imagerel $unwind$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD 020521H
	DD	07d405H
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
	DD	imagerel ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z+170
	DD	imagerel $unwind$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z DD 080f01H
	DD	0f00b720fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z DB 0cH
	DB	'E', 04H
	DB	00H
	DB	'U', 03H
	DB	02H
	DB	0d1H, 0bH
	DB	00H
	DB	0f1H, 02H
	DB	02H
	DB	'y', 09H
	DB	04H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
	DB	021H
	DB	02H
	DB	046H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
	DD	imagerel $ip2state$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z DD 0d3119H
	DD	01e641fH
	DD	01d541fH
	DD	01c341fH
	DD	016011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
	DD	0a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
	DD	imagerel $ip2state$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD 021H
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+151
	DD	imagerel $unwind$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD 0a1b21H
	DD	08e41bH
	DD	09c417H
	DD	0a740fH
	DD	0b540bH
	DD	0123404H
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
	DD	imagerel ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z+151
	DD	imagerel $unwind$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z DD 041001H
	DD	0f00cb210H
	DD	06008d00aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD 021H
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+44
	DD	imagerel $unwind$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD 061321H
	DD	0ae413H
	DD	09740cH
	DD	083405H
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
	DD	imagerel ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z+44
	DD	imagerel $unwind$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z DD 060e01H
	DD	0b540eH
	DD	0f00a320eH
	DD	06006c008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD 021H
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+32
	DD	imagerel $unwind$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD 081421H
	DD	04e414H
	DD	0a740fH
	DD	09640aH
	DD	085405H
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
	DD	imagerel ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z+32
	DD	imagerel $unwind$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z DD 030801H
	DD	0f0044208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD 021H
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel $unwind$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	0bc400H
	DD	0a7400H
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+23
	DD	imagerel $chain$0$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD 0a1b21H
	DD	04f41bH
	DD	05e416H
	DD	0bc411H
	DD	0a740cH
	DD	096405H
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+23
	DD	imagerel $chain$0$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD 020521H
	DD	085405H
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
	DD	imagerel ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z+16
	DD	imagerel $unwind$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?mergeRegions@@YA_NAEAUrcRegion@@0@Z DB 08H
	DB	'!', 02H
	DB	02H
	DB	'1', 04H
	DB	08H
	DB	'>'
	DB	00H
	DB	0a4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?mergeRegions@@YA_NAEAUrcRegion@@0@Z DB 08H
	DB	0aH
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	070H
	DB	038H
	DB	040H
	DB	04eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?mergeRegions@@YA_NAEAUrcRegion@@0@Z DB 028H
	DD	imagerel $stateUnwindMap$?mergeRegions@@YA_NAEAUrcRegion@@0@Z
	DD	imagerel $ip2state$?mergeRegions@@YA_NAEAUrcRegion@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mergeRegions@@YA_NAEAUrcRegion@@0@Z DD 0a2319H
	DD	0163414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?mergeRegions@@YA_NAEAUrcRegion@@0@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z DB 010H
	DB	'Y', 02H
	DB	02H
	DB	0d2H
	DB	0aH
	DB	01cH
	DB	0cH
	DB	05H, 04H
	DB	02H
	DB	'u', 07H
	DB	0eH
	DB	'4'
	DB	010H
	DB	']?'
	DB	012H
	DB	0eeH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z DB 016H
	DB	0aH
	DD	imagerel ??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
	DB	0e1H
	DB	03H
	DB	038H
	DB	040H
	DB	050H
	DB	052H
	DD	imagerel ??1rcRegion@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	08eH
	DD	imagerel __imp___std_terminate
	DB	0b2H
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	041H
	DB	04H
	DB	03aH
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	0a1H
	DB	04H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	0adH
	DB	02H
	DD	imagerel __imp___std_terminate
	DB	036H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
	DD	imagerel $ip2state$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z DD 0b2a19H
	DD	033341cH
	DD	02a011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
	DD	0142H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
	DD	imagerel $ip2state$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1rcRegion@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1rcRegion@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1rcRegion@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1rcRegion@@QEAA@XZ
	DD	imagerel $ip2state$??1rcRegion@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1rcRegion@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1rcRegion@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD 021H
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+20
	DD	imagerel $unwind$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD 081921H
	DD	06f419H
	DD	057411H
	DD	04540cH
	DD	033405H
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
	DD	imagerel ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z+20
	DD	imagerel $unwind$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z DD 020c01H
	DD	0600ae00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	DD	imagerel $ip2state$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD 020021H
	DD	067400H
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+32
	DD	imagerel $unwind$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD 020521H
	DD	067405H
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
	DD	imagerel ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z+32
	DD	imagerel $unwind$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD 021H
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+83
	DD	imagerel $unwind$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD 020021H
	DD	07e400H
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+83
	DD	imagerel $unwind$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD 041421H
	DD	07e414H
	DD	067405H
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
	DD	imagerel ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z+83
	DD	imagerel $unwind$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+81
	DD	imagerel $unwind$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD 021H
	DD	imagerel $LN63+81
	DD	imagerel $LN63+86
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD 020521H
	DD	077405H
	DD	imagerel $LN63+81
	DD	imagerel $LN63+86
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN63
	DD	imagerel $LN63+81
	DD	imagerel $unwind$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z DD 040b01H
	DD	08340bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z DB 028H
	DD	imagerel $stateUnwindMap$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z
	DD	imagerel $ip2state$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z DD 081911H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD 020021H
	DD	066400H
	DD	imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD 020521H
	DD	066405H
	DD	imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z DB 0aH
	DB	'%', 02H
	DB	02H
	DB	01cH
	DB	04H
	DB	't'
	DB	00H
	DB	0caH
	DB	06H
	DB	01cH
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z
	DD	imagerel $ip2state$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z DD 081211H
	DD	0d5412H
	DD	0b3412H
	DD	0e00e5212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GrcRegion@@QEAAPEAXI@Z DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GrcRegion@@QEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_GrcRegion@@QEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_GrcRegion@@QEAAPEAXI@Z
	DD	imagerel $ip2state$??_GrcRegion@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GrcRegion@@QEAAPEAXI@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_GrcRegion@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z DB 04H
	DB	0ccH
	DB	02H
	DB	01cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z DB 028H
	DD	imagerel $stateUnwindMap$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z
	DD	imagerel $ip2state$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z DD 040f11H
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0rcRegion@@QEAA@AEBU0@@Z DB 04H
	DB	0b8H
	DB	00H
	DB	01cH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0rcRegion@@QEAA@AEBU0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0rcRegion@@QEAA@AEBU0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0rcRegion@@QEAA@AEBU0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0rcRegion@@QEAA@AEBU0@@Z
	DD	imagerel $ip2state$??0rcRegion@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0rcRegion@@QEAA@AEBU0@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0rcRegion@@QEAA@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0rcIntArray@@QEAA@AEBV0@@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$rcTempVector@H@@QEAA@AEBV0@@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+13
	DD	imagerel $unwind$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD 021H
	DD	imagerel $LN34+13
	DD	imagerel $LN34+47
	DD	imagerel $chain$0$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD 020521H
	DD	065405H
	DD	imagerel $LN34+13
	DD	imagerel $LN34+47
	DD	imagerel $chain$0$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD 020521H
	DD	077405H
	DD	imagerel $LN34
	DD	imagerel $LN34+13
	DD	imagerel $unwind$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z DB 08H
	DB	082H
	DB	00H
	DB	09aH
	DB	02H
	DB	0baH
	DB	04H
	DB	'"'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z DB 028H
	DD	imagerel $stateUnwindMap$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z
	DD	imagerel $ip2state$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z DD 060c11H
	DD	0a340cH
	DD	07008520cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD 020021H
	DD	066400H
	DD	imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD 020521H
	DD	066405H
	DD	imagerel $LN17
	DD	imagerel $LN17+35
	DD	imagerel $unwind$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z DB 04H
	DB	'U', 02H
	DB	02H
	DB	'"'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z DB 028H
	DD	imagerel $stateUnwindMap$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z
	DD	imagerel $ip2state$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z DD 060f11H
	DD	0b640fH
	DD	08340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z
_TEXT	SEGMENT
timer$ = 32
timerDist$1 = 48
maxDist$ = 64
__$ArrayPad$ = 72
ctx$ = 112
chf$ = 120
?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z PROC ; rcBuildDistanceField, COMDAT

; 1259 : {

$LN98:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx

; 1260 : 	rcAssert(ctx);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN4@rcBuildDis
	test	rcx, rcx
	jne	SHORT $LN4@rcBuildDis
	mov	r8d, 1260				; 000004ecH
	lea	rdx, OFFSET FLAT:??_C@_0GM@DMGHBEJM@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_03EDDGELHM@ctx@
	call	rax
$LN4@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rsp], rbx
	mov	DWORD PTR timer$[rsp+8], 17

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN18@rcBuildDis
	mov	rax, QWORD PTR [rbx]
	mov	edx, 17
	mov	rcx, rbx
	call	QWORD PTR [rax+32]
	npad	1
$LN18@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1264 : 	if (chf.dist)

	mov	rcx, QWORD PTR [rdi+80]
	xor	ebp, ebp
	test	rcx, rcx
	je	SHORT $LN5@rcBuildDis
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1267 : 		chf.dist = 0;

	mov	QWORD PTR [rdi+80], rbp
$LN5@rcBuildDis:

; 1268 : 	}
; 1269 : 	
; 1270 : 	unsigned short* src = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP);

	movsxd	rcx, DWORD PTR [rdi+8]
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1271 : 	if (!src)

	movsxd	rax, DWORD PTR [rdi+8]
	test	rsi, rsi
	jne	SHORT $LN6@rcBuildDis

; 1272 : 	{
; 1273 : 		ctx->log(RC_LOG_ERROR, "rcBuildDistanceField: Out of memory 'src' (%d).", chf.spanCount);

	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_0DA@JEAHFIBK@rcBuildDistanceField?3?5Out?5of?5me@
	lea	edx, QWORD PTR [rsi+3]
	mov	rcx, rbx
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	dil, dil
	jmp	$LN14@rcBuildDis
$LN6@rcBuildDis:

; 1274 : 		return false;
; 1275 : 	}
; 1276 : 	unsigned short* dst = (unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount, RC_ALLOC_TEMP);

	mov	rcx, rax
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1277 : 	if (!dst)

	test	rax, rax
	jne	SHORT $LN7@rcBuildDis

; 1278 : 	{
; 1279 : 		ctx->log(RC_LOG_ERROR, "rcBuildDistanceField: Out of memory 'dst' (%d).", chf.spanCount);

	mov	r9d, DWORD PTR [rdi+8]
	lea	r8, OFFSET FLAT:??_C@_0DA@DEKJMNNE@rcBuildDistanceField?3?5Out?5of?5me@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, rbx
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	xor	dil, dil
	jmp	$LN14@rcBuildDis
$LN7@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1284 : 	unsigned short maxDist = 0;

	mov	WORD PTR maxDist$[rsp], bp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timerDist$1[rsp], rbx
	mov	DWORD PTR timerDist$1[rsp+8], 18

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [rbx+9], bpl
	je	SHORT $LN55@rcBuildDis
	mov	rax, QWORD PTR [rbx]
	mov	edx, 18
	mov	rcx, rbx
	call	QWORD PTR [rax+32]
	npad	1
$LN55@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1289 : 		calculateDistanceField(chf, src, maxDist);

	lea	r8, QWORD PTR maxDist$[rsp]
	mov	rdx, rsi
	mov	rcx, rdi
	call	?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z ; calculateDistanceField

; 1290 : 		chf.maxDistance = maxDist;

	movzx	eax, WORD PTR maxDist$[rsp]
	mov	WORD PTR [rdi+24], ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN61@rcBuildDis
	mov	rax, QWORD PTR [rbx]
	mov	edx, 18
	mov	rcx, rbx
	call	QWORD PTR [rax+40]
	npad	1
$LN61@rcBuildDis:

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN66@rcBuildDis
	mov	rax, QWORD PTR [rbx]
	mov	edx, 19
	mov	rcx, rbx
	call	QWORD PTR [rax+32]
$LN66@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1297 : 		if (boxBlur(chf, 1, src, dst) != src)

	mov	r9, r14
	mov	r8, rsi
	mov	rcx, rdi
	call	?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z ; boxBlur

; 1298 : 			rcSwap(src, dst);
; 1299 : 
; 1300 : 		// Store distance.
; 1301 : 		chf.dist = src;

	mov	rbp, rsi
	cmp	rax, rsi
	cmove	rbp, r14
	cmove	r14, rsi
	mov	QWORD PTR [rdi+80], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN72@rcBuildDis
	mov	rax, QWORD PTR [rbx]
	mov	edx, 19
	mov	rcx, rbx
	call	QWORD PTR [rax+40]
	npad	1
$LN72@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1306 : 	return true;

	mov	dil, 1
$LN14@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [rbx+9], 0
	je	SHORT $LN95@rcBuildDis
	mov	r8, QWORD PTR [rbx]
	mov	edx, 17
	mov	rcx, rbx
	call	QWORD PTR [r8+40]
	npad	1
$LN95@rcBuildDis:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1307 : }

	movzx	eax, dil
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z ENDP ; rcBuildDistanceField
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
timer$ = 32
timerDist$1 = 48
maxDist$ = 64
__$ArrayPad$ = 72
ctx$ = 112
chf$ = 120
?dtor$0@?0??rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z@4HA PROC ; `rcBuildDistanceField'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z@4HA ENDP ; `rcBuildDistanceField'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
timer$ = 32
timerDist$1 = 48
maxDist$ = 64
__$ArrayPad$ = 72
ctx$ = 112
chf$ = 120
?dtor$1@?0??rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z@4HA PROC ; `rcBuildDistanceField'::`1'::dtor$1
	lea	rcx, QWORD PTR timerDist$1[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$1@?0??rcBuildDistanceField@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@@Z@4HA ENDP ; `rcBuildDistanceField'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z
_TEXT	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z PROC ; rcBuildRegions, COMDAT

; 1532 : {

$LN783:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-224]
	sub	rsp, 480				; 000001e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	esi, r9d
	mov	DWORD PTR minRegionArea$GSCopy$1$[rsp], r9d
	mov	r13, rdx
	mov	QWORD PTR chf$GSCopy$1$[rbp-256], rdx
	mov	r15, rcx
	mov	QWORD PTR ctx$GSCopy$1$[rsp], rcx

; 1533 : 	rcAssert(ctx);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN15@rcBuildReg
	test	rcx, rcx
	jne	SHORT $LN15@rcBuildReg
	mov	r8d, 1533				; 000005fdH
	lea	rdx, OFFSET FLAT:??_C@_0GM@DMGHBEJM@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_03EDDGELHM@ctx@
	call	rax
$LN15@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rbp-256], r15
	mov	DWORD PTR timer$[rbp-248], 20

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN609@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 20
	mov	rcx, r15
	call	QWORD PTR [rax+32]
	npad	1
$LN609@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1540 : 	rcScopedDelete<unsigned short> buf((unsigned short*)rcAlloc(sizeof(unsigned short)*chf.spanCount*2, RC_ALLOC_TEMP));

	movsxd	rcx, DWORD PTR [r13+8]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r12, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR buf$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1541 : 	if (!buf)

	test	rax, rax
	jne	SHORT $LN16@rcBuildReg

; 1542 : 	{
; 1543 : 		ctx->log(RC_LOG_ERROR, "rcBuildRegions: Out of memory 'tmp' (%d).", chf.spanCount*4);

	mov	r9d, DWORD PTR [r13+8]
	shl	r9d, 2
	lea	r8, OFFSET FLAT:??_C@_0CK@MEAHGGHD@rcBuildRegions?3?5Out?5of?5memory?5?8@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, r15
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	$LN36@rcBuildReg
$LN16@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN622@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 21
	mov	rcx, r15
	call	QWORD PTR [rax+32]
$LN622@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1551 : 	rcTempVector<LevelStackEntry> lvlStacks[NB_STACKS];

	lea	rax, OFFSET FLAT:??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:??0?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ ; rcTempVector<`anonymous namespace'::LevelStackEntry>::rcTempVector<`anonymous namespace'::LevelStackEntry>
	mov	edx, 24
	lea	r8d, QWORD PTR [rdx-16]
	lea	rcx, QWORD PTR lvlStacks$[rbp-256]
	call	??_L@YAXPEAX_K1P6AX0@Z2@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-248], 256	; 00000100H
	jge	SHORT $LN2@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-256]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN2@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-240]
	test	rcx, rcx
	je	SHORT $LN564@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN564@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-240], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-248], 256	; 00000100H
$LN2@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-224], 256	; 00000100H
	jge	SHORT $LN722@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-232]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN722@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-216]
	test	rcx, rcx
	je	SHORT $LN721@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN721@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-216], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-224], 256	; 00000100H
$LN722@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-200], 256	; 00000100H
	jge	SHORT $LN726@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-208]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN726@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-192]
	test	rcx, rcx
	je	SHORT $LN725@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN725@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-192], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-200], 256	; 00000100H
$LN726@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-176], 256	; 00000100H
	jge	SHORT $LN730@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-184]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN730@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-168]
	test	rcx, rcx
	je	SHORT $LN729@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN729@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-168], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-176], 256	; 00000100H
$LN730@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-152], 256	; 00000100H
	jge	SHORT $LN734@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-160]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN734@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-144]
	test	rcx, rcx
	je	SHORT $LN733@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN733@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-144], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-152], 256	; 00000100H
$LN734@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-128], 256	; 00000100H
	jge	SHORT $LN738@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-136]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN738@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-120]
	test	rcx, rcx
	je	SHORT $LN737@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN737@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-120], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-128], 256	; 00000100H
$LN738@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-104], 256	; 00000100H
	jge	SHORT $LN742@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-112]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN742@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-96]
	test	rcx, rcx
	je	SHORT $LN741@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN741@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-96], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-104], 256	; 00000100H
$LN742@rcBuildReg:

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR lvlStacks$[rbp-80], 256	; 00000100H
	jge	SHORT $LN746@rcBuildReg

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR lvlStacks$[rbp-88]
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN746@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR lvlStacks$[rbp-72]
	test	rcx, rcx
	je	SHORT $LN745@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN745@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR lvlStacks$[rbp-72], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR lvlStacks$[rbp-80], 256	; 00000100H
$LN746@rcBuildReg:
	xor	eax, eax
	xorps	xmm1, xmm1

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	movdqu	XMMWORD PTR stack$[rbp-256], xmm1
	mov	QWORD PTR stack$[rbp-240], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	ecx, 3072				; 00000c00H
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN570@rcBuildReg

; 181  : 	m_data = new_data;

	mov	QWORD PTR stack$[rbp-240], rax

; 182  : 	m_cap = count;

	mov	QWORD PTR stack$[rbp-248], 256		; 00000100H
$LN570@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1559 : 	unsigned short* srcDist = buf+chf.spanCount;

	movsxd	rax, DWORD PTR [r13+8]
	lea	r8, QWORD PTR [rax+rax]
	lea	rbx, QWORD PTR [r8+r12]
	mov	QWORD PTR srcDist$1$[rsp], rbx

; 1560 : 	
; 1561 : 	memset(srcReg, 0, sizeof(unsigned short)*chf.spanCount);

	xor	edx, edx
	mov	rcx, r12
	call	memset

; 1562 : 	memset(srcDist, 0, sizeof(unsigned short)*chf.spanCount);

	movsxd	r8, DWORD PTR [r13+8]
	add	r8, r8
	xor	edx, edx
	mov	rcx, rbx
	call	memset

; 1563 : 	
; 1564 : 	unsigned short regionId = 1;

	mov	edi, 1
	mov	DWORD PTR tv2953[rsp], edi

; 1565 : 	unsigned short level = (chf.maxDistance+1) & ~1;

	movzx	edx, WORD PTR [r13+24]
	inc	dx
	mov	eax, 65534				; 0000fffeH
	and	dx, ax

; 1566 : 
; 1567 : 	// TODO: Figure better formula, expandIters defines how much the 
; 1568 : 	// watershed "overflows" and simplifies the regions. Tying it to
; 1569 : 	// agent radius was usually good indication how greedy it could be.
; 1570 : //	const int expandIters = 4 + walkableRadius * 2;
; 1571 : 	const int expandIters = 8;
; 1572 : 
; 1573 : 	if (borderSize > 0)
; 1574 : 	{
; 1575 : 		// Make sure border will not overflow.
; 1576 : 		const int bw = rcMin(w, borderSize);
; 1577 : 		const int bh = rcMin(h, borderSize);
; 1578 : 		
; 1579 : 		// Paint regions
; 1580 : 		paintRectRegion(0, bw, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
; 1581 : 		paintRectRegion(w-bw, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
; 1582 : 		paintRectRegion(0, w, 0, bh, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
; 1583 : 		paintRectRegion(0, w, h-bh, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
; 1584 : 	}
; 1585 : 
; 1586 : 	chf.borderSize = borderSize;

	mov	r8d, 0
	mov	DWORD PTR [r13+20], r8d

; 1587 : 	
; 1588 : 	int sId = -1;

	lea	ecx, QWORD PTR [rdi-2]

; 1589 : 	while (level > 0)

	jbe	$LN774@rcBuildReg
	npad	14
$LL5@rcBuildReg:

; 1590 : 	{
; 1591 : 		level = level >= 2 ? level-2 : 0;
; 1592 : 		sId = (sId+1) & (NB_STACKS-1);

	movzx	eax, dx
	sub	dx, 2
	cmp	ax, 2
	cmovb	dx, r8w
	mov	WORD PTR level$1$[rsp], dx
	inc	ecx
	and	ecx, 7
	mov	DWORD PTR sId$1$[rsp], ecx

; 1593 : 
; 1594 : //		ctx->startTimer(RC_TIMER_DIVIDE_TO_LEVELS);
; 1595 : 
; 1596 : 		if (sId == 0)

	mov	r12d, r8d
	jne	$LN18@rcBuildReg

; 476  : 	const int w = chf.width;

	movsxd	rax, DWORD PTR [r13]
	mov	DWORD PTR w$1$[rsp], eax

; 477  : 	const int h = chf.height;

	mov	ecx, DWORD PTR [r13+4]
	mov	DWORD PTR h$1$[rsp], ecx

; 478  : 	startLevel = startLevel >> loglevelsPerStack;

	shr	dx, 1
	mov	WORD PTR startLevel$1$[rsp], dx

; 479  : 
; 480  : 	for (unsigned int j=0; j<nbStacks; ++j)
; 481  : 		stacks[j].clear();

	mov	QWORD PTR lvlStacks$[rbp-256], r8
	mov	QWORD PTR lvlStacks$[rbp-232], r8
	mov	QWORD PTR lvlStacks$[rbp-208], r8
	mov	QWORD PTR lvlStacks$[rbp-184], r8
	mov	QWORD PTR lvlStacks$[rbp-160], r8
	mov	QWORD PTR lvlStacks$[rbp-136], r8
	mov	QWORD PTR lvlStacks$[rbp-112], r8
	mov	QWORD PTR lvlStacks$[rbp-88], r8

; 482  : 
; 483  : 	// put all cells in the level range into the appropriate stacks
; 484  : 	for (int y = 0; y < h; ++y)

	test	ecx, ecx
	jle	$LN465@rcBuildReg
	mov	rcx, r8
	mov	QWORD PTR tv2712[rbp-256], rcx
	mov	r9, rax
	shl	r9, 2
	mov	QWORD PTR tv2711[rbp-256], r9
	mov	r10d, DWORD PTR h$1$[rsp]
	npad	9
$LL466@rcBuildReg:

; 485  : 	{
; 486  : 		for (int x = 0; x < w; ++x)

	mov	r14d, r8d
	test	eax, eax
	jle	$LN464@rcBuildReg
	mov	r15, rcx
	mov	QWORD PTR tv2713[rsp], rcx
	npad	13
$LL469@rcBuildReg:

; 487  : 		{
; 488  : 			const rcCompactCell& c = chf.cells[x+y*w];

	mov	rax, QWORD PTR [r13+64]

; 489  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	ecx, DWORD PTR [r15+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	mov	edi, eax
	shr	ecx, 24
	lea	esi, DWORD PTR [rax+rcx]
	cmp	rdi, rsi
	jae	SHORT $LN467@rcBuildReg
	mov	ebx, edi
	mov	r15, QWORD PTR buf$[rbp-256]
$LL472@rcBuildReg:

; 490  : 			{
; 491  : 				if (chf.areas[i] == RC_NULL_AREA || srcReg[i] != 0)

	mov	rax, QWORD PTR [r13+88]
	cmp	BYTE PTR [rbx+rax], 0
	je	SHORT $LN470@rcBuildReg
	cmp	WORD PTR [r15+rbx*2], 0
	jne	SHORT $LN470@rcBuildReg

; 492  : 					continue;
; 493  : 
; 494  : 				int level = chf.dist[i] >> loglevelsPerStack;

	mov	rax, QWORD PTR [r13+80]
	movzx	ecx, WORD PTR [rax+rbx*2]
	shr	ecx, 1

; 495  : 				int sId = startLevel - level;

	movzx	edx, dx
	sub	edx, ecx

; 496  : 				if (sId >= (int)nbStacks)

	cmp	edx, 8
	jge	SHORT $LN779@rcBuildReg

; 497  : 					continue;
; 498  : 				if (sId < 0)
; 499  : 					sId = 0;
; 500  : 
; 501  : 				stacks[sId].push_back(LevelStackEntry(x, y, i));

	mov	eax, r8d
	test	edx, edx
	cmovns	eax, edx
	cdqe
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR lvlStacks$[rbp-256]
	lea	rcx, QWORD PTR [rax+rcx*8]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rbp-256], r14d
	mov	DWORD PTR $T1[rbp-252], r12d
	mov	DWORD PTR $T1[rbp-248], edi

; 501  : 				stacks[sId].push_back(LevelStackEntry(x, y, i));

	lea	rdx, QWORD PTR $T1[rbp-256]
	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back

; 496  : 				if (sId >= (int)nbStacks)

	xor	r8d, r8d
$LN779@rcBuildReg:

; 489  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	movzx	edx, WORD PTR startLevel$1$[rsp]
$LN470@rcBuildReg:
	inc	edi
	inc	rbx
	cmp	rbx, rsi
	jl	SHORT $LL472@rcBuildReg
	mov	r15, QWORD PTR tv2713[rsp]
$LN467@rcBuildReg:

; 485  : 	{
; 486  : 		for (int x = 0; x < w; ++x)

	inc	r14d
	add	r15, 4
	mov	QWORD PTR tv2713[rsp], r15
	mov	eax, DWORD PTR w$1$[rsp]
	cmp	r14d, eax
	jl	$LL469@rcBuildReg
	mov	rcx, QWORD PTR tv2712[rbp-256]
	mov	r9, QWORD PTR tv2711[rbp-256]
	mov	r10d, DWORD PTR h$1$[rsp]
$LN464@rcBuildReg:

; 482  : 
; 483  : 	// put all cells in the level range into the appropriate stacks
; 484  : 	for (int y = 0; y < h; ++y)

	inc	r12d
	add	rcx, r9
	mov	QWORD PTR tv2712[rbp-256], rcx
	cmp	r12d, r10d
	jl	$LL466@rcBuildReg
	mov	r15, QWORD PTR ctx$GSCopy$1$[rsp]
$LN465@rcBuildReg:

; 1597 : 			sortCellsByLevel(level, chf, srcReg, NB_STACKS, lvlStacks, 1);

	mov	r14d, DWORD PTR sId$1$[rsp]
	jmp	$LN482@rcBuildReg
$LN18@rcBuildReg:

; 1599 : 			appendStacks(lvlStacks[sId-1], lvlStacks[sId], srcReg); // copy left overs from last level

	mov	r14d, ecx
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rdi, QWORD PTR lvlStacks$[rbp+rax*8-280]

; 512  : 	for (int j=0; j<srcStack.size(); j++)

	mov	rsi, r8
	mov	rax, QWORD PTR [rdi]
	test	rax, rax
	jle	$LN482@rcBuildReg
	mov	rbx, r8
	mov	r15, r8
	mov	r13, QWORD PTR buf$[rbp-256]
	npad	10
$LL483@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rcx, rax
	cmp	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA, 0
	je	SHORT $LN490@rcBuildReg
	test	rsi, rsi
	js	SHORT $LN491@rcBuildReg
	cmp	rsi, rax
	jl	SHORT $LN490@rcBuildReg
$LN491@rcBuildReg:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rcx, QWORD PTR [rdi]
$LN490@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 514  : 		int i = srcStack[j].index;

	mov	rax, QWORD PTR [rdi+16]
	movsxd	rdx, DWORD PTR [r15+rax+8]

; 515  : 		if ((i < 0) || (srcReg[i] != 0))

	test	edx, edx
	js	SHORT $LN481@rcBuildReg
	cmp	WORD PTR [r13+rdx*2], 0
	jne	SHORT $LN481@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	cmp	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA, 0
	je	SHORT $LN496@rcBuildReg
	test	rbx, rbx
	js	SHORT $LN497@rcBuildReg
	cmp	rbx, rcx
	jl	SHORT $LN496@rcBuildReg
$LN497@rcBuildReg:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN496@rcBuildReg:
	lea	rcx, QWORD PTR [rbx+rbx*2]
	mov	rax, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1599 : 			appendStacks(lvlStacks[sId-1], lvlStacks[sId], srcReg); // copy left overs from last level

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR lvlStacks$[rbp-256]
	lea	rcx, QWORD PTR [rcx+rax*8]

; 517  : 		dstStack.push_back(srcStack[j]);

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
$LN481@rcBuildReg:

; 502  : 			}
; 503  : 		}
; 504  : 	}
; 505  : }
; 506  : 
; 507  : 
; 508  : static void appendStacks(const rcTempVector<LevelStackEntry>& srcStack,
; 509  : 						 rcTempVector<LevelStackEntry>& dstStack,
; 510  : 						 const unsigned short* srcReg)
; 511  : {
; 512  : 	for (int j=0; j<srcStack.size(); j++)

	inc	r12d
	inc	rsi
	add	r15, 12
	mov	rax, QWORD PTR [rdi]
	movsxd	rbx, r12d
	cmp	rbx, rax
	jl	$LL483@rcBuildReg
	mov	r13, QWORD PTR chf$GSCopy$1$[rbp-256]
	mov	r15, QWORD PTR ctx$GSCopy$1$[rsp]
$LN482@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timerExpand$6[rbp-256], r15
	mov	DWORD PTR timerExpand$6[rbp-248], 22

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN441@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 22
	mov	rcx, r15
	call	QWORD PTR [rax+32]
	npad	1
$LN441@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1607 : 			expandRegions(expandIters, level, chf, srcReg, srcDist, lvlStacks[sId], false);

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rdi, QWORD PTR [rax*8]
	lea	r14, QWORD PTR lvlStacks$[rbp-256]
	add	r14, rdi
	mov	BYTE PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], r14
	mov	rax, QWORD PTR srcDist$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r12, QWORD PTR buf$[rbp-256]
	mov	r9, r12
	mov	r8, r13
	movzx	edx, WORD PTR level$1$[rsp]
	mov	ecx, 8
	call	?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z ; expandRegions
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN447@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 22
	mov	rcx, r15
	call	QWORD PTR [rax+40]
	npad	1
$LN447@rcBuildReg:

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timerFloor$3[rbp-256], r15
	mov	DWORD PTR timerFloor$3[rbp-248], 23

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN452@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 23
	mov	rcx, r15
	call	QWORD PTR [rax+32]
	npad	1
$LN452@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1614 : 			for (int j = 0; j<lvlStacks[sId].size(); j++)

	xor	eax, eax
	mov	esi, eax
	mov	ebx, eax
	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	jle	$LN777@rcBuildReg
	lea	r15, QWORD PTR lvlStacks$[rbp-240]
	add	r15, rdi
	mov	edi, eax
	npad	5
$LL9@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	cmp	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA, 0
	je	SHORT $LN48@rcBuildReg
	test	rbx, rbx
	js	SHORT $LN49@rcBuildReg
	cmp	rbx, rcx
	jl	SHORT $LN48@rcBuildReg
$LN49@rcBuildReg:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN48@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1616 : 				LevelStackEntry current = lvlStacks[sId][j];

	mov	rax, QWORD PTR [r15]
	movsd	xmm0, QWORD PTR [rdi+rax]
	movsd	QWORD PTR current$4[rbp-256], xmm0
	movsxd	r8, DWORD PTR [rdi+rax+8]

; 1617 : 				int x = current.x;
; 1618 : 				int y = current.y;
; 1619 : 				int i = current.index;
; 1620 : 				if (i >= 0 && srcReg[i] == 0)

	test	r8d, r8d
	js	SHORT $LN7@rcBuildReg
	cmp	WORD PTR [r12+r8*2], 0
	jne	SHORT $LN7@rcBuildReg

; 1621 : 				{
; 1622 : 					if (floodRegion(x, y, i, level, regionId, chf, srcReg, srcDist, stack))

	mov	rcx, QWORD PTR current$4[rbp-256]
	mov	rdx, rcx
	shr	rdx, 32					; 00000020H
	lea	rax, QWORD PTR stack$[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR srcDist$1$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	mov	eax, DWORD PTR tv2953[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, WORD PTR level$1$[rsp]
	call	?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z ; floodRegion
	test	al, al
	je	SHORT $LN7@rcBuildReg

; 1623 : 					{
; 1624 : 						if (regionId == 0xFFFF)

	mov	eax, DWORD PTR tv2953[rsp]
	mov	ecx, 65535				; 0000ffffH
	cmp	ax, cx
	je	SHORT $LN708@rcBuildReg

; 1627 : 							return false;
; 1628 : 						}
; 1629 : 						
; 1630 : 						regionId++;

	inc	ax
	mov	DWORD PTR tv2953[rsp], eax
$LN7@rcBuildReg:

; 1614 : 			for (int j = 0; j<lvlStacks[sId].size(); j++)

	inc	esi
	inc	rbx
	add	rdi, 12
	mov	rcx, QWORD PTR [r14]
	movsxd	rax, esi
	cmp	rax, rcx
	jl	$LL9@rcBuildReg
	mov	r15, QWORD PTR ctx$GSCopy$1$[rsp]
$LN777@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN43@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 23
	mov	rcx, r15
	call	QWORD PTR [rax+40]
	npad	1
$LN43@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1589 : 	while (level > 0)

	movzx	edx, WORD PTR level$1$[rsp]
	test	dx, dx
	je	SHORT $LN780@rcBuildReg
	xor	r8d, r8d
	mov	ecx, DWORD PTR sId$1$[rsp]
	jmp	$LL5@rcBuildReg
$LN708@rcBuildReg:

; 1625 : 						{
; 1626 : 							ctx->log(RC_LOG_ERROR, "rcBuildRegions: Region ID overflow");

	lea	r8, OFFSET FLAT:??_C@_0CD@FFAAAELN@rcBuildRegions?3?5Region?5ID?5overf@
	mov	edx, 3
	mov	r15, QWORD PTR ctx$GSCopy$1$[rsp]
	mov	rcx, r15
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN549@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 23
	mov	rcx, r15
	call	QWORD PTR [rax+40]
	npad	1
$LN549@rcBuildReg:
	xor	bl, bl
	jmp	$LN38@rcBuildReg
$LN780@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1589 : 	while (level > 0)

	mov	edi, DWORD PTR tv2953[rsp]
	mov	rbx, QWORD PTR srcDist$1$[rsp]
	mov	esi, DWORD PTR minRegionArea$GSCopy$1$[rsp]
$LN774@rcBuildReg:

; 1631 : 					}
; 1632 : 				}
; 1633 : 			}
; 1634 : 		}
; 1635 : 	}
; 1636 : 	
; 1637 : 	// Expand current regions until no empty connected cells found.
; 1638 : 	expandRegions(expandIters*8, 0, chf, srcReg, srcDist, stack, true);

	xor	edx, edx
	mov	BYTE PTR [rsp+48], 1
	lea	rax, QWORD PTR stack$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbx
	mov	r9, r12
	mov	r8, r13
	lea	ecx, QWORD PTR [rdx+64]
	call	?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z ; expandRegions
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN88@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 21
	mov	rcx, r15
	call	QWORD PTR [rax+40]
$LN88@rcBuildReg:

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timerFilter$2[rbp-256], r15
	mov	DWORD PTR timerFilter$2[rbp-248], 24

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN85@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 24
	mov	rcx, r15
	call	QWORD PTR [rax+32]
	npad	1
$LN85@rcBuildReg:
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	movdqu	XMMWORD PTR overlaps$5[rbp-256], xmm1
	xor	ebx, ebx
	mov	QWORD PTR overlaps$5[rbp-240], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1647 : 		chf.maxRegions = regionId;

	lea	r9, QWORD PTR [r13+26]
	mov	WORD PTR [r9], di

; 1648 : 		if (!mergeAndFilterRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg, overlaps))

	lea	rax, QWORD PTR overlaps$5[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, DWORD PTR mergeRegionArea$[rbp-256]
	mov	edx, esi
	mov	rcx, r15
	call	?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z ; mergeAndFilterRegions
	test	al, al
	jne	SHORT $LN23@rcBuildReg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR overlaps$5[rbp-240]
	test	rcx, rcx
	je	SHORT $LN511@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN511@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN519@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 24
	mov	rcx, r15
	call	QWORD PTR [rax+40]
	npad	1
$LN519@rcBuildReg:
	xor	bl, bl
	jmp	SHORT $LN38@rcBuildReg
$LN23@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1652 : 		if (overlaps.size() > 0)

	mov	r9, QWORD PTR overlaps$5[rbp-256]
	test	r9d, r9d
	jle	SHORT $LN24@rcBuildReg

; 1653 : 		{
; 1654 : 			ctx->log(RC_LOG_ERROR, "rcBuildRegions: %d overlapping regions.", overlaps.size());

	lea	r8, OFFSET FLAT:??_C@_0CI@FANGPCDB@rcBuildRegions?3?5?$CFd?5overlapping?5@
	mov	edx, 3
	mov	rcx, r15
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	npad	1
$LN24@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR overlaps$5[rbp-240]
	test	rcx, rcx
	je	SHORT $LN533@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN533@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN541@rcBuildReg
	mov	rax, QWORD PTR [r15]
	mov	edx, 24
	mov	rcx, r15
	call	QWORD PTR [rax+40]
	npad	1
$LN541@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1659 : 	for (int i = 0; i < chf.spanCount; ++i)

	cmp	DWORD PTR [r13+8], 0
	jle	SHORT $LN11@rcBuildReg
	mov	rdx, rbx
	mov	r8, r12
$LL12@rcBuildReg:

; 1660 : 		chf.spans[i].reg = srcReg[i];

	mov	rcx, QWORD PTR [r13+72]
	movzx	eax, WORD PTR [r8]
	mov	WORD PTR [rdx+rcx+2], ax

; 1659 : 	for (int i = 0; i < chf.spanCount; ++i)

	inc	ebx
	lea	r8, QWORD PTR [r8+2]
	lea	rdx, QWORD PTR [rdx+8]
	cmp	ebx, DWORD PTR [r13+8]
	jl	SHORT $LL12@rcBuildReg
$LN11@rcBuildReg:

; 1662 : 	return true;

	mov	bl, 1
$LN38@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR stack$[rbp-240]
	test	rcx, rcx
	je	SHORT $LN76@rcBuildReg

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN76@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1662 : 	return true;

	lea	r9, OFFSET FLAT:??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	mov	edx, 24
	lea	r8d, QWORD PTR [rdx-16]
	lea	rcx, QWORD PTR lvlStacks$[rbp-256]
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	npad	1
$LN36@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r12, r12
	je	SHORT $LN63@rcBuildReg

; 28   : 	free(ptr);

	mov	rcx, r12
	call	QWORD PTR __imp_free
	npad	1
$LN63@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r15+9], 0
	je	SHORT $LN775@rcBuildReg
	mov	r8, QWORD PTR [r15]
	mov	edx, 20
	mov	rcx, r15
	call	QWORD PTR [r8+40]
	npad	1
$LN775@rcBuildReg:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1663 : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+560]
	add	rsp, 480				; 000001e0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z ENDP ; rcBuildRegions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$0@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$1@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$1
	lea	rcx, QWORD PTR buf$[rdx]
	jmp	??1?$rcScopedDelete@G@@QEAA@XZ		; rcScopedDelete<unsigned short>::~rcScopedDelete<unsigned short>
?dtor$1@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	r9, OFFSET FLAT:??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
	mov	r8d, 8
	mov	edx, 24
	lea	rcx, QWORD PTR lvlStacks$[rbp]
	call	??_M@YAXPEAX_K1P6AX0@Z@Z
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$3@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$3
	lea	rcx, QWORD PTR stack$[rdx]
	jmp	??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
?dtor$3@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$4@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$4
	lea	rcx, QWORD PTR timerExpand$6[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$4@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$5@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$5
	lea	rcx, QWORD PTR timerFloor$3[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$5@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$6@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$6
	lea	rcx, QWORD PTR timerFilter$2[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$6@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
level$1$ = 80
startLevel$1$ = 82
tv2953 = 84
h$1$ = 88
sId$1$ = 92
ctx$GSCopy$1$ = 96
w$1$ = 104
minRegionArea$GSCopy$1$ = 108
srcDist$1$ = 112
tv2713 = 120
tv2712 = 128
$T1 = 136
tv2711 = 152
chf$GSCopy$1$ = 160
timerFilter$2 = 168
timerFloor$3 = 168
current$4 = 184
timer$ = 200
buf$ = 216
overlaps$5 = 224
timerExpand$6 = 224
stack$ = 248
lvlStacks$ = 272
__$ArrayPad$ = 464
ctx$ = 544
chf$ = 552
borderSize$dead$ = 560
minRegionArea$ = 568
mergeRegionArea$ = 576
?dtor$7@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA PROC ; `rcBuildRegions'::`1'::dtor$7
	lea	rcx, QWORD PTR overlaps$5[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$7@?0??rcBuildRegions@@YA_NPEAVrcContext@@AEAUrcCompactHeightfield@@HHH@Z@4HA ENDP ; `rcBuildRegions'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0rcIntArray@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0rcIntArray@@QEAA@XZ PROC				; rcIntArray::rcIntArray, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 331  : 	rcIntArray() {}

	mov	rax, rcx
	ret	0
??0rcIntArray@@QEAA@XZ ENDP				; rcIntArray::rcIntArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??ArcIntArray@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??ArcIntArray@@QEBAHH@Z PROC				; rcIntArray::operator[], COMDAT

; 344  : 	int operator[](int index) const { return m_impl[index]; }

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA

; 344  : 	int operator[](int index) const { return m_impl[index]; }

	mov	rdi, rcx
	movsxd	rbx, edx

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN10@operator
	test	edx, edx
	js	SHORT $LN7@operator
	cmp	rbx, QWORD PTR [rcx]
	jl	SHORT $LN10@operator
$LN7@operator:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax

; 344  : 	int operator[](int index) const { return m_impl[index]; }

	mov	rax, QWORD PTR [rdi+16]
	mov	eax, DWORD PTR [rax+rbx*4]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN10@operator:
	mov	rax, QWORD PTR [rcx+16]
	mov	eax, DWORD PTR [rax+rbx*4]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??ArcIntArray@@QEBAHH@Z ENDP				; rcIntArray::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ??0LevelStackEntry@?A0xb2ab97ce@@QEAA@HHH@Z
_TEXT	SEGMENT
this$ = 8
x_$ = 16
y_$ = 24
index_$ = 32
??0LevelStackEntry@?A0xb2ab97ce@@QEAA@HHH@Z PROC	; `anonymous namespace'::LevelStackEntry::LevelStackEntry, COMDAT

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	mov	DWORD PTR [rcx+8], r9d
	ret	0
??0LevelStackEntry@?A0xb2ab97ce@@QEAA@HHH@Z ENDP	; `anonymous namespace'::LevelStackEntry::LevelStackEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z
_TEXT	SEGMENT
h$1$ = 0
$T1 = 4
y$1$ = 8
tv5949 = 16
tv5935 = 16
tv5974 = 24
tv5955 = 24
tv5944 = 24
tv5941 = 32
chf$ = 112
src$ = 120
maxDist$ = 128
w$1$ = 136
?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z PROC ; calculateDistanceField, COMDAT

; 40   : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 96					; 00000060H

; 41   : 	const int w = chf.width;

	mov	r8d, DWORD PTR [rcx]

; 42   : 	const int h = chf.height;
; 43   : 	
; 44   : 	// Init distance and points.
; 45   : 	for (int i = 0; i < chf.spanCount; ++i)

	xor	r9d, r9d
	mov	r11d, DWORD PTR [rcx+4]
	mov	r14, rdx
	mov	edx, r9d
	mov	QWORD PTR [rsp+48], r15
	mov	r10, rcx
	mov	DWORD PTR w$1$[rsp], r8d
	mov	DWORD PTR h$1$[rsp], r11d
	cmp	DWORD PTR [rcx+8], edx
	jle	SHORT $LN3@calculateD
	mov	rax, r14
	npad	4
$LL4@calculateD:

; 46   : 		src[i] = 0xffff;

	mov	WORD PTR [rax], 65535			; 0000ffffH
	lea	rax, QWORD PTR [rax+2]
	inc	edx
	cmp	edx, DWORD PTR [rcx+8]
	jl	SHORT $LL4@calculateD
$LN3@calculateD:
	mov	QWORD PTR [rsp+120], rbx

; 47   : 	
; 48   : 	// Mark boundary cells.
; 49   : 	for (int y = 0; y < h; ++y)

	mov	r15d, r9d
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+72], rdi
	lea	rdi, QWORD PTR [rcx+64]
	mov	QWORD PTR [rsp+64], r12
	mov	QWORD PTR [rsp+56], r13
	test	r11d, r11d
	jle	$LN188@calculateD
	npad	2
$LL7@calculateD:

; 50   : 	{
; 51   : 		for (int x = 0; x < w; ++x)

	mov	ebp, r9d
	test	r8d, r8d
	jle	$LN5@calculateD
	mov	r13d, r15d
	imul	r13d, r8d
	movsxd	rcx, r13d
	shl	rcx, 2
	mov	QWORD PTR tv5955[rsp], rcx
	npad	1
$LL10@calculateD:

; 52   : 		{
; 53   : 			const rcCompactCell& c = chf.cells[x+y*w];
; 54   : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rcx+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	shr	ecx, 24
	mov	r11d, eax
	lea	r12d, DWORD PTR [rax+rcx]
	cmp	r11, r12
	jae	$LN8@calculateD
$LL13@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rcx, QWORD PTR [r10+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 59   : 				int nc = 0;

	mov	eax, r9d
	mov	rbx, QWORD PTR [r10+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r9d, DWORD PTR [rcx+r11*8+4]
	mov	r10d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 57   : 				const unsigned char area = chf.areas[i];

	movzx	esi, BYTE PTR [rbx+r11]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 62   : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN14@calculateD

; 66   : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	lea	ecx, DWORD PTR [rbp-1]
	add	ecx, r13d
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rcx+rdx*4]

; 67   : 						if (area == chf.areas[ai])

	mov	ecx, 1
	and	r8d, 16777215				; 00ffffffH
	add	r8d, r10d
	cmp	sil, BYTE PTR [r8+rbx]
	mov	r8d, DWORD PTR w$1$[rsp]
	cmove	eax, ecx
$LN14@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, r9d
	shr	r10d, 6
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 62   : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN157@calculateD

; 63   : 					{
; 64   : 						const int ax = x + rcGetDirOffsetX(dir);
; 65   : 						const int ay = y + rcGetDirOffsetY(dir);

	lea	ecx, DWORD PTR [r15+1]

; 66   : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	ecx, r8d
	add	ecx, ebp
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rcx+rdx*4]
	and	r8d, 16777215				; 00ffffffH
	add	r8d, r10d

; 67   : 						if (area == chf.areas[ai])

	cmp	sil, BYTE PTR [r8+rbx]
	jne	SHORT $LN157@calculateD

; 68   : 							nc++;

	inc	eax
$LN157@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, r9d
	shr	r10d, 12
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 62   : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN159@calculateD

; 66   : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	lea	ecx, DWORD PTR [rbp+1]
	add	ecx, r13d
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rcx+rdx*4]
	and	r8d, 16777215				; 00ffffffH
	add	r8d, r10d

; 67   : 						if (area == chf.areas[ai])

	cmp	sil, BYTE PTR [r8+rbx]
	jne	SHORT $LN159@calculateD

; 68   : 							nc++;

	inc	eax
$LN159@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r9d, 18
	and	r9d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 62   : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r9d, 63					; 0000003fH
	je	SHORT $LN161@calculateD

; 63   : 					{
; 64   : 						const int ax = x + rcGetDirOffsetX(dir);
; 65   : 						const int ay = y + rcGetDirOffsetY(dir);

	lea	ecx, DWORD PTR [r15-1]

; 66   : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	ecx, DWORD PTR w$1$[rsp]
	add	ecx, ebp
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rcx+rdx*4]
	and	r8d, 16777215				; 00ffffffH
	add	r8d, r9d

; 67   : 						if (area == chf.areas[ai])

	cmp	sil, BYTE PTR [r8+rbx]
	jne	SHORT $LN161@calculateD

; 68   : 							nc++;

	inc	eax
$LN161@calculateD:

; 69   : 					}
; 70   : 				}
; 71   : 				if (nc != 4)

	xor	r9d, r9d
	cmp	eax, 4
	je	SHORT $LN11@calculateD

; 72   : 					src[i] = 0;

	mov	WORD PTR [r14+r11*2], r9w
$LN11@calculateD:

; 52   : 		{
; 53   : 			const rcCompactCell& c = chf.cells[x+y*w];
; 54   : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r10, QWORD PTR chf$[rsp]
	inc	r11
	mov	r8d, DWORD PTR w$1$[rsp]
	cmp	r11, r12
	jl	$LL13@calculateD
$LN8@calculateD:

; 50   : 	{
; 51   : 		for (int x = 0; x < w; ++x)

	mov	rcx, QWORD PTR tv5955[rsp]
	inc	ebp
	add	rcx, 4
	mov	QWORD PTR tv5955[rsp], rcx
	cmp	ebp, r8d
	jl	$LL10@calculateD
	mov	r11d, DWORD PTR h$1$[rsp]
$LN5@calculateD:

; 47   : 	
; 48   : 	// Mark boundary cells.
; 49   : 	for (int y = 0; y < h; ++y)

	inc	r15d
	cmp	r15d, r11d
	jl	$LL7@calculateD

; 73   : 			}
; 74   : 		}
; 75   : 	}
; 76   : 	
; 77   : 			
; 78   : 	// Pass 1
; 79   : 	for (int y = 0; y < h; ++y)

	mov	r12d, r8d
	movsxd	rax, r8d
	neg	r12d
	mov	r13, r9
	shl	rax, 2
	mov	QWORD PTR tv5944[rsp], rax
	mov	rcx, QWORD PTR tv5944[rsp]
	mov	eax, r11d
	mov	QWORD PTR tv5949[rsp], rax
	mov	DWORD PTR $T1[rsp], r12d
	npad	8
$LL19@calculateD:

; 80   : 	{
; 81   : 		for (int x = 0; x < w; ++x)

	mov	esi, r9d
	test	r8d, r8d
	jle	$LN17@calculateD
	mov	r15, r13
	npad	1
$LL22@calculateD:

; 82   : 		{
; 83   : 			const rcCompactCell& c = chf.cells[x+y*w];
; 84   : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [r15+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	shr	ecx, 24
	mov	r8d, eax
	lea	ebp, DWORD PTR [rax+rcx]
	cmp	r8, rbp
	jae	$LN20@calculateD
$LL25@calculateD:

; 86   : 				const rcCompactSpan& s = chf.spans[i];

	mov	rdx, QWORD PTR [r10+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	ecx, DWORD PTR [rdx+r8*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 86   : 				const rcCompactSpan& s = chf.spans[i];

	lea	r11, QWORD PTR [rdx+r8*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	ecx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 88   : 				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)

	cmp	ecx, 63					; 0000003fH
	je	$LN44@calculateD

; 89   : 				{
; 90   : 					// (-1,0)
; 91   : 					const int ax = x + rcGetDirOffsetX(0);
; 92   : 					const int ay = y + rcGetDirOffsetY(0);
; 93   : 					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 0);

	mov	r9, QWORD PTR [rdi]

; 94   : 					const rcCompactSpan& as = chf.spans[ai];
; 95   : 					if (src[ai]+2 < src[i])

	movzx	r10d, WORD PTR [r14+r8*2]
	mov	eax, DWORD PTR [r9+r15-4]
	and	eax, 16777215				; 00ffffffH
	add	eax, ecx
	movzx	ecx, WORD PTR [r14+rax*2]
	lea	rdx, QWORD PTR [rdx+rax*8]
	lea	eax, DWORD PTR [rcx+2]
	cmp	eax, r10d
	jae	SHORT $LN42@calculateD

; 96   : 						src[i] = src[ai]+2;

	add	cx, 2
	mov	WORD PTR [r14+r8*2], cx
	movzx	r10d, cx
	mov	r9, QWORD PTR [rdi]
$LN42@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rdx+4]
	shr	edx, 18
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 99   : 					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN195@calculateD

; 100  : 					{
; 101  : 						const int aax = ax + rcGetDirOffsetX(3);
; 102  : 						const int aay = ay + rcGetDirOffsetY(3);
; 103  : 						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 3);

	lea	eax, DWORD PTR [r12-1]
	add	eax, esi
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r9+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 104  : 						if (src[aai]+3 < src[i])

	movzx	edx, WORD PTR [r14+rax*2]
	movzx	eax, r10w
	mov	r10, QWORD PTR chf$[rsp]
	lea	ecx, DWORD PTR [rdx+3]
	cmp	ecx, eax
	jae	SHORT $LN44@calculateD

; 105  : 							src[i] = src[aai]+3;

	add	dx, 3
	mov	WORD PTR [r14+r8*2], dx
	jmp	SHORT $LN44@calculateD
$LN195@calculateD:

; 99   : 					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)

	mov	r10, QWORD PTR chf$[rsp]
$LN44@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	shr	edx, 18
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 108  : 				if (rcGetCon(s, 3) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN23@calculateD

; 109  : 				{
; 110  : 					// (0,-1)
; 111  : 					const int ax = x + rcGetDirOffsetX(3);
; 112  : 					const int ay = y + rcGetDirOffsetY(3);
; 113  : 					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 3);

	mov	r9, QWORD PTR [rdi]
	lea	ebx, DWORD PTR [r12+rsi]
	movsxd	rax, ebx
	mov	ecx, DWORD PTR [r9+rax*4]

; 114  : 					const rcCompactSpan& as = chf.spans[ai];

	mov	rax, QWORD PTR [r10+72]
	and	ecx, 16777215				; 00ffffffH

; 115  : 					if (src[ai]+2 < src[i])

	movzx	r10d, WORD PTR [r14+r8*2]
	add	ecx, edx
	movzx	edx, WORD PTR [r14+rcx*2]
	lea	r11, QWORD PTR [rax+rcx*8]
	lea	eax, DWORD PTR [rdx+2]
	cmp	eax, r10d
	jae	SHORT $LN46@calculateD

; 116  : 						src[i] = src[ai]+2;

	add	dx, 2
	mov	WORD PTR [r14+r8*2], dx
	movzx	r10d, dx
	mov	r9, QWORD PTR [rdi]
$LN46@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	shr	edx, 12
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 119  : 					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN23@calculateD

; 120  : 					{
; 121  : 						const int aax = ax + rcGetDirOffsetX(2);
; 122  : 						const int aay = ay + rcGetDirOffsetY(2);
; 123  : 						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 2);

	movsxd	rax, ebx
	mov	ecx, DWORD PTR [r9+rax*4+4]
	and	ecx, 16777215				; 00ffffffH

; 124  : 						if (src[aai]+3 < src[i])

	movzx	eax, r10w
	add	ecx, edx
	movzx	edx, WORD PTR [r14+rcx*2]
	lea	ecx, DWORD PTR [rdx+3]
	cmp	ecx, eax
	jae	SHORT $LN23@calculateD

; 125  : 							src[i] = src[aai]+3;

	add	dx, 3
	mov	WORD PTR [r14+r8*2], dx
$LN23@calculateD:

; 82   : 		{
; 83   : 			const rcCompactCell& c = chf.cells[x+y*w];
; 84   : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r10, QWORD PTR chf$[rsp]
	inc	r8
	cmp	r8, rbp
	jl	$LL25@calculateD
$LN20@calculateD:

; 80   : 	{
; 81   : 		for (int x = 0; x < w; ++x)

	mov	r8d, DWORD PTR w$1$[rsp]
	inc	esi
	mov	r10, QWORD PTR chf$[rsp]
	add	r15, 4
	cmp	esi, r8d
	jl	$LL22@calculateD
	mov	rax, QWORD PTR tv5949[rsp]
	xor	r9d, r9d
	mov	rcx, QWORD PTR tv5944[rsp]
$LN17@calculateD:

; 73   : 			}
; 74   : 		}
; 75   : 	}
; 76   : 	
; 77   : 			
; 78   : 	// Pass 1
; 79   : 	for (int y = 0; y < h; ++y)

	mov	r10, QWORD PTR chf$[rsp]
	add	r13, rcx
	add	r12d, r8d
	sub	rax, 1
	mov	QWORD PTR tv5949[rsp], rax
	jne	$LL19@calculateD
	mov	r8d, DWORD PTR $T1[rsp]
	mov	r11d, DWORD PTR h$1$[rsp]
	jmp	SHORT $LN18@calculateD
$LN188@calculateD:
	neg	r8d
	mov	DWORD PTR $T1[rsp], r8d
$LN18@calculateD:

; 126  : 					}
; 127  : 				}
; 128  : 			}
; 129  : 		}
; 130  : 	}
; 131  : 	
; 132  : 	// Pass 2
; 133  : 	for (int y = h-1; y >= 0; --y)

	lea	eax, DWORD PTR [r11-1]
	mov	DWORD PTR y$1$[rsp], eax
	test	eax, eax
	js	$LN27@calculateD
	mov	r9d, DWORD PTR w$1$[rsp]
	mov	ecx, eax
	imul	ecx, r9d
	imul	r11d, r9d
	lea	edx, DWORD PTR [r9-1]
	mov	DWORD PTR tv5974[rsp], edx
	mov	DWORD PTR tv5935[rsp], ecx
	mov	DWORD PTR h$1$[rsp], r11d
$LL28@calculateD:

; 134  : 	{
; 135  : 		for (int x = w-1; x >= 0; --x)

	mov	ebp, edx
	test	edx, edx
	js	$LN26@calculateD
	lea	eax, DWORD PTR [rcx+rdx]
	mov	r12d, r9d
	movsxd	r13, eax
	shl	r13, 2
	inc	eax
	mov	QWORD PTR tv5941[rsp], r13
	movsxd	r15, eax
	shl	r15, 2
	npad	5
$LL31@calculateD:

; 136  : 		{
; 137  : 			const rcCompactCell& c = chf.cells[x+y*w];
; 138  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	shr	ecx, 24
	mov	r8d, eax
	lea	esi, DWORD PTR [rax+rcx]
	cmp	r8, rsi
	jae	$LN29@calculateD
	mov	r13d, DWORD PTR h$1$[rsp]
	npad	12
$LL34@calculateD:

; 140  : 				const rcCompactSpan& s = chf.spans[i];

	mov	rdx, QWORD PTR [r10+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	ecx, DWORD PTR [rdx+r8*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 140  : 				const rcCompactSpan& s = chf.spans[i];

	lea	r11, QWORD PTR [rdx+r8*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	ecx, 12
	and	ecx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 142  : 				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)

	cmp	ecx, 63					; 0000003fH
	je	SHORT $LN52@calculateD

; 143  : 				{
; 144  : 					// (1,0)
; 145  : 					const int ax = x + rcGetDirOffsetX(2);
; 146  : 					const int ay = y + rcGetDirOffsetY(2);
; 147  : 					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 2);

	mov	r9, QWORD PTR [rdi]

; 148  : 					const rcCompactSpan& as = chf.spans[ai];
; 149  : 					if (src[ai]+2 < src[i])

	movzx	r10d, WORD PTR [r14+r8*2]
	mov	eax, DWORD PTR [r9+r15]
	and	eax, 16777215				; 00ffffffH
	add	eax, ecx
	movzx	ecx, WORD PTR [r14+rax*2]
	lea	rdx, QWORD PTR [rdx+rax*8]
	lea	eax, DWORD PTR [rcx+2]
	cmp	eax, r10d
	jae	SHORT $LN50@calculateD

; 150  : 						src[i] = src[ai]+2;

	add	cx, 2
	mov	WORD PTR [r14+r8*2], cx
	movzx	r10d, cx
	mov	r9, QWORD PTR [rdi]
$LN50@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rdx+4]
	shr	edx, 6
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 153  : 					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN193@calculateD

; 154  : 					{
; 155  : 						const int aax = ax + rcGetDirOffsetX(1);
; 156  : 						const int aay = ay + rcGetDirOffsetY(1);
; 157  : 						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 1);

	lea	eax, DWORD PTR [r12+r13]
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r9+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 158  : 						if (src[aai]+3 < src[i])

	movzx	edx, WORD PTR [r14+rax*2]
	movzx	eax, r10w
	mov	r10, QWORD PTR chf$[rsp]
	lea	ecx, DWORD PTR [rdx+3]
	cmp	ecx, eax
	jae	SHORT $LN52@calculateD

; 159  : 							src[i] = src[aai]+3;

	add	dx, 3
	mov	WORD PTR [r14+r8*2], dx
	jmp	SHORT $LN52@calculateD
$LN193@calculateD:

; 153  : 					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)

	mov	r10, QWORD PTR chf$[rsp]
$LN52@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	shr	edx, 6
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 162  : 				if (rcGetCon(s, 1) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN32@calculateD

; 163  : 				{
; 164  : 					// (0,1)
; 165  : 					const int ax = x + rcGetDirOffsetX(1);
; 166  : 					const int ay = y + rcGetDirOffsetY(1);
; 167  : 					const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, 1);

	mov	r9, QWORD PTR [rdi]
	mov	ebx, r13d
	add	ebx, ebp
	movsxd	rax, ebx
	mov	ecx, DWORD PTR [r9+rax*4]

; 168  : 					const rcCompactSpan& as = chf.spans[ai];

	mov	rax, QWORD PTR [r10+72]
	and	ecx, 16777215				; 00ffffffH

; 169  : 					if (src[ai]+2 < src[i])

	movzx	r10d, WORD PTR [r14+r8*2]
	add	ecx, edx
	movzx	edx, WORD PTR [r14+rcx*2]
	lea	r11, QWORD PTR [rax+rcx*8]
	lea	eax, DWORD PTR [rdx+2]
	cmp	eax, r10d
	jae	SHORT $LN54@calculateD

; 170  : 						src[i] = src[ai]+2;

	add	dx, 2
	mov	WORD PTR [r14+r8*2], dx
	movzx	r10d, dx
	mov	r9, QWORD PTR [rdi]
$LN54@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 173  : 					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN32@calculateD

; 174  : 					{
; 175  : 						const int aax = ax + rcGetDirOffsetX(0);
; 176  : 						const int aay = ay + rcGetDirOffsetY(0);
; 177  : 						const int aai = (int)chf.cells[aax+aay*w].index + rcGetCon(as, 0);

	movsxd	rax, ebx
	mov	ecx, DWORD PTR [r9+rax*4-4]
	and	ecx, 16777215				; 00ffffffH

; 178  : 						if (src[aai]+3 < src[i])

	movzx	eax, r10w
	add	ecx, edx
	movzx	edx, WORD PTR [r14+rcx*2]
	lea	ecx, DWORD PTR [rdx+3]
	cmp	ecx, eax
	jae	SHORT $LN32@calculateD

; 179  : 							src[i] = src[aai]+3;

	add	dx, 3
	mov	WORD PTR [r14+r8*2], dx
$LN32@calculateD:

; 136  : 		{
; 137  : 			const rcCompactCell& c = chf.cells[x+y*w];
; 138  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r10, QWORD PTR chf$[rsp]
	inc	r8
	cmp	r8, rsi
	jl	$LL34@calculateD
	mov	r13, QWORD PTR tv5941[rsp]
$LN29@calculateD:

; 134  : 	{
; 135  : 		for (int x = w-1; x >= 0; --x)

	mov	r10, QWORD PTR chf$[rsp]
	sub	r13, 4
	dec	r12d
	mov	QWORD PTR tv5941[rsp], r13
	sub	r15, 4
	sub	ebp, 1
	jns	$LL31@calculateD
	mov	eax, DWORD PTR y$1$[rsp]
	mov	ecx, DWORD PTR tv5935[rsp]
	mov	edx, DWORD PTR tv5974[rsp]
	mov	r8d, DWORD PTR $T1[rsp]
	mov	r9d, DWORD PTR w$1$[rsp]
	mov	r11d, DWORD PTR h$1$[rsp]
$LN26@calculateD:

; 126  : 					}
; 127  : 				}
; 128  : 			}
; 129  : 		}
; 130  : 	}
; 131  : 	
; 132  : 	// Pass 2
; 133  : 	for (int y = h-1; y >= 0; --y)

	mov	r10, QWORD PTR chf$[rsp]
	dec	eax
	add	ecx, r8d
	mov	DWORD PTR y$1$[rsp], eax
	add	r11d, r8d
	mov	DWORD PTR tv5935[rsp], ecx
	mov	DWORD PTR h$1$[rsp], r11d
	test	eax, eax
	jns	$LL28@calculateD
$LN27@calculateD:

; 180  : 					}
; 181  : 				}
; 182  : 			}
; 183  : 		}
; 184  : 	}	
; 185  : 	
; 186  : 	maxDist = 0;

	mov	r9, QWORD PTR maxDist$[rsp]
	xor	r8d, r8d

; 187  : 	for (int i = 0; i < chf.spanCount; ++i)

	mov	rdx, QWORD PTR chf$[rsp]
	mov	r15, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+120]
	mov	WORD PTR [r9], r8w
	cmp	DWORD PTR [rdx+8], r8d
	jle	SHORT $LN36@calculateD
	movzx	ecx, r8w
	npad	7
$LL37@calculateD:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	WORD PTR [r14], cx
	cmova	cx, WORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 187  : 	for (int i = 0; i < chf.spanCount; ++i)

	inc	r8d

; 188  : 		maxDist = rcMax(src[i], maxDist);

	mov	WORD PTR [r9], cx
	lea	r14, QWORD PTR [r14+2]
	cmp	r8d, DWORD PTR [rdx+8]
	jl	SHORT $LL37@calculateD
$LN36@calculateD:

; 189  : 	
; 190  : }

	add	rsp, 96					; 00000060H
	pop	r14
	ret	0
?calculateDistanceField@@YAXAEAUrcCompactHeightfield@@PEAGAEAG@Z ENDP ; calculateDistanceField
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z
_TEXT	SEGMENT
x$1$ = 0
tv2399 = 4
h$1$ = 8
tv2365 = 16
tv2364 = 24
tv2386 = 32
chf$ = 112
w$1$ = 120
thr$dead$ = 120
src$ = 128
dst$ = 136
?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z PROC	; boxBlur, COMDAT

; 194  : {

	mov	r11, rsp
	mov	QWORD PTR [r11+32], r9
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [r11+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	sub	rsp, 72					; 00000048H

; 195  : 	const int w = chf.width;
; 196  : 	const int h = chf.height;

	mov	eax, DWORD PTR [rcx+4]
	xor	ebp, ebp
	mov	edi, DWORD PTR [rcx]
	mov	r13, r8
	mov	DWORD PTR w$1$[rsp], edi
	mov	rsi, rcx
	mov	DWORD PTR h$1$[rsp], eax

; 197  : 	
; 198  : 	thr *= 2;
; 199  : 	
; 200  : 	for (int y = 0; y < h; ++y)

	test	eax, eax
	jle	$LN69@boxBlur
	mov	QWORD PTR [r11+24], rbx
	mov	QWORD PTR [r11-40], r12
	mov	QWORD PTR [r11-48], r14
	mov	QWORD PTR [r11-56], r15
	npad	11
$LL4@boxBlur:

; 201  : 	{
; 202  : 		for (int x = 0; x < w; ++x)

	xor	r15d, r15d
	mov	DWORD PTR x$1$[rsp], r15d
	test	edi, edi
	jle	$LN2@boxBlur
	mov	r11d, ebp
	imul	r11d, edi
	mov	DWORD PTR tv2399[rsp], r11d
	npad	5
$LL7@boxBlur:

; 203  : 		{
; 204  : 			const rcCompactCell& c = chf.cells[x+y*w];

	lea	eax, DWORD PTR [r11+r15]
	movsxd	rcx, eax

; 205  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [rsi+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	shr	edx, 24
	mov	r14d, eax
	add	eax, edx
	mov	QWORD PTR tv2386[rsp], rax
	cmp	r14, rax
	jae	$LN5@boxBlur
	mov	rcx, r13
	lea	rax, QWORD PTR [r9+r14*2]
	sub	rcx, r9
	mov	QWORD PTR tv2365[rsp], rax
	mov	QWORD PTR tv2364[rsp], rcx
	npad	1
$LL10@boxBlur:

; 206  : 			{
; 207  : 				const rcCompactSpan& s = chf.spans[i];
; 208  : 				const unsigned short cd = src[i];

	movzx	edx, WORD PTR [rcx+rax]
	mov	r12, QWORD PTR [rsi+72]

; 209  : 				if (cd <= thr)

	mov	r9d, edx
	cmp	edx, 2
	jbe	$LN8@boxBlur
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, DWORD PTR [r12+r14*8+4]
	lea	ebx, DWORD PTR [rdx+rdx]
	mov	r8d, r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 215  : 				int d = (int)cd;

	mov	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 218  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	$LN15@boxBlur

; 219  : 					{
; 220  : 						const int ax = x + rcGetDirOffsetX(dir);
; 221  : 						const int ay = y + rcGetDirOffsetY(dir);
; 222  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	mov	rsi, QWORD PTR [rsi+64]
	lea	edi, DWORD PTR [r15-1]
	lea	ecx, DWORD PTR [r11+rdi]
	movsxd	rdx, ecx

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	lea	r11d, DWORD PTR [rbp+1]
	mov	ecx, DWORD PTR [rsi+rdx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [r12+rcx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	movzx	r15d, WORD PTR [r13+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r8d, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	add	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN17@boxBlur

; 228  : 						{
; 229  : 							const int ax2 = ax + rcGetDirOffsetX(dir2);
; 230  : 							const int ay2 = ay + rcGetDirOffsetY(dir2);
; 231  : 							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);

	mov	eax, r11d
	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, edi

; 237  : 						}
; 238  : 					}

	mov	edi, DWORD PTR w$1$[rsp]
	cdqe
	mov	ecx, DWORD PTR [rsi+rax*4]
	mov	rsi, QWORD PTR chf$[rsp]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r8d
	movzx	ecx, WORD PTR [r13+rcx*2]
	lea	eax, DWORD PTR [rcx+r15]
	mov	r15d, DWORD PTR x$1$[rsp]
	jmp	SHORT $LN11@boxBlur
$LN17@boxBlur:
	mov	rsi, QWORD PTR chf$[rsp]
	mov	ecx, r9d
	mov	edi, DWORD PTR w$1$[rsp]
	lea	eax, DWORD PTR [rcx+r15]
	mov	r15d, DWORD PTR x$1$[rsp]
	jmp	SHORT $LN11@boxBlur
$LN15@boxBlur:

; 239  : 					else
; 240  : 					{
; 241  : 						d += cd*2;

	add	eax, ebx
	lea	r11d, DWORD PTR [rbp+1]
$LN11@boxBlur:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, r10d
	shr	r8d, 6
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 218  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN47@boxBlur

; 219  : 					{
; 220  : 						const int ax = x + rcGetDirOffsetX(dir);
; 221  : 						const int ay = y + rcGetDirOffsetY(dir);
; 222  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	r11d, edi
	mov	rdi, QWORD PTR [rsi+64]
	lea	ecx, DWORD PTR [r11+r15]
	movsxd	rdx, ecx
	mov	ecx, DWORD PTR [rdi+rdx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [r12+rcx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	movzx	esi, WORD PTR [r13+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r8d, 12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	add	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN45@boxBlur

; 228  : 						{
; 229  : 							const int ax2 = ax + rcGetDirOffsetX(dir2);
; 230  : 							const int ay2 = ay + rcGetDirOffsetY(dir2);
; 231  : 							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);

	lea	eax, DWORD PTR [r11+1]
	add	eax, r15d
	movsxd	rcx, eax
	mov	eax, DWORD PTR [rdi+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, r8d

; 232  : 							d += (int)src[ai2];

	movzx	ecx, WORD PTR [r13+rax*2]

; 237  : 						}
; 238  : 					}

	lea	eax, DWORD PTR [rcx+rsi]
	jmp	SHORT $LN48@boxBlur
$LN45@boxBlur:

; 233  : 						}
; 234  : 						else
; 235  : 						{
; 236  : 							d += cd;

	mov	ecx, r9d

; 237  : 						}
; 238  : 					}

	lea	eax, DWORD PTR [rcx+rsi]
	jmp	SHORT $LN48@boxBlur
$LN47@boxBlur:

; 239  : 					else
; 240  : 					{
; 241  : 						d += cd*2;

	add	eax, ebx
$LN48@boxBlur:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, r10d
	shr	r8d, 12
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 218  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN52@boxBlur

; 219  : 					{
; 220  : 						const int ax = x + rcGetDirOffsetX(dir);
; 221  : 						const int ay = y + rcGetDirOffsetY(dir);
; 222  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	mov	ecx, DWORD PTR tv2399[rsp]
	lea	edi, DWORD PTR [r15+1]
	mov	rsi, QWORD PTR chf$[rsp]
	add	ecx, edi
	movsxd	rdx, ecx
	mov	rsi, QWORD PTR [rsi+64]
	mov	ecx, DWORD PTR [rsi+rdx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r8d

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	lea	r8d, DWORD PTR [rbp-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r11d, DWORD PTR [r12+rcx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	movzx	r15d, WORD PTR [r13+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r11d, 18
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	add	r15d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r11d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	cmp	r11d, 63				; 0000003fH
	je	SHORT $LN50@boxBlur

; 228  : 						{
; 229  : 							const int ax2 = ax + rcGetDirOffsetX(dir2);
; 230  : 							const int ay2 = ay + rcGetDirOffsetY(dir2);
; 231  : 							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);

	mov	eax, r8d
	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, edi
	cdqe
	mov	ecx, DWORD PTR [rsi+rax*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r11d

; 232  : 							d += (int)src[ai2];

	movzx	ecx, WORD PTR [r13+rcx*2]

; 237  : 						}
; 238  : 					}

	lea	eax, DWORD PTR [rcx+r15]
	jmp	SHORT $LN53@boxBlur
$LN50@boxBlur:

; 233  : 						}
; 234  : 						else
; 235  : 						{
; 236  : 							d += cd;

	mov	ecx, r9d

; 237  : 						}
; 238  : 					}

	lea	eax, DWORD PTR [rcx+r15]
	jmp	SHORT $LN53@boxBlur
$LN52@boxBlur:

; 239  : 					else
; 240  : 					{
; 241  : 						d += cd*2;

	add	eax, ebx
	lea	r8d, DWORD PTR [rbp-1]
$LN53@boxBlur:

; 218  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	mov	edi, DWORD PTR w$1$[rsp]
	mov	rsi, QWORD PTR chf$[rsp]
	mov	r15d, DWORD PTR x$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r10d, 18
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 218  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN57@boxBlur

; 219  : 					{
; 220  : 						const int ax = x + rcGetDirOffsetX(dir);
; 221  : 						const int ay = y + rcGetDirOffsetY(dir);
; 222  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	mov	r11, QWORD PTR [rsi+64]
	imul	r8d, edi
	lea	ecx, DWORD PTR [r8+r15]
	movsxd	rdx, ecx
	mov	ecx, DWORD PTR [r11+rdx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r10d

; 223  : 						d += (int)src[ai];

	movzx	ebx, WORD PTR [r13+rcx*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, DWORD PTR [r12+rcx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 223  : 						d += (int)src[ai];

	add	ebx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 227  : 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN55@boxBlur

; 228  : 						{
; 229  : 							const int ax2 = ax + rcGetDirOffsetX(dir2);
; 230  : 							const int ay2 = ay + rcGetDirOffsetY(dir2);
; 231  : 							const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);

	lea	eax, DWORD PTR [r15-1]
	add	eax, r8d
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r11+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, r10d

; 232  : 							d += (int)src[ai2];

	movzx	r9d, WORD PTR [r13+rax*2]
$LN55@boxBlur:

; 237  : 						}
; 238  : 					}

	lea	eax, DWORD PTR [rbx+r9]
	jmp	SHORT $LN58@boxBlur
$LN57@boxBlur:

; 239  : 					else
; 240  : 					{
; 241  : 						d += cd*2;

	add	eax, ebx
$LN58@boxBlur:
	mov	r11d, DWORD PTR tv2399[rsp]

; 242  : 					}
; 243  : 				}
; 244  : 				dst[i] = (unsigned short)((d+5)/9);

	lea	ecx, DWORD PTR [rax+5]
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	mov	rcx, QWORD PTR tv2364[rsp]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	mov	rax, QWORD PTR tv2365[rsp]
$LN8@boxBlur:

; 205  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	WORD PTR [rax], dx
	inc	r14
	add	rax, 2
	mov	QWORD PTR tv2365[rsp], rax
	cmp	r14, QWORD PTR tv2386[rsp]
	jl	$LL10@boxBlur
	mov	r9, QWORD PTR dst$[rsp]
$LN5@boxBlur:

; 201  : 	{
; 202  : 		for (int x = 0; x < w; ++x)

	inc	r15d
	mov	DWORD PTR x$1$[rsp], r15d
	cmp	r15d, edi
	jl	$LL7@boxBlur
	mov	eax, DWORD PTR h$1$[rsp]
$LN2@boxBlur:

; 197  : 	
; 198  : 	thr *= 2;
; 199  : 	
; 200  : 	for (int y = 0; y < h; ++y)

	inc	ebp
	cmp	ebp, eax
	jl	$LL4@boxBlur
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+56]
	mov	r12, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+128]
$LN69@boxBlur:

; 245  : 			}
; 246  : 		}
; 247  : 	}
; 248  : 	return dst;
; 249  : }

	mov	rax, r9
	add	rsp, 72					; 00000048H
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?boxBlur@@YAPEAGAEAUrcCompactHeightfield@@HPEAG1@Z ENDP	; boxBlur
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
w$1$ = 128
x$ = 128
cx$1$ = 136
y$ = 136
count$1$ = 144
i$ = 144
area$1$ = 152
level$ = 152
tv2139 = 160
r$ = 160
tv1901 = 168
chf$ = 168
cs$1$ = 176
srcReg$ = 176
srcDist$ = 184
stack$ = 192
?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z PROC ; floodRegion, COMDAT

; 257  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 258  : 	const int w = chf.width;

	mov	rsi, QWORD PTR chf$[rsp]

; 261  : 	
; 262  : 	// Flood fill mark region.
; 263  : 	stack.clear();

	xor	r12d, r12d
	mov	r15, QWORD PTR stack$[rsp]
	movzx	edi, r9w
	movsxd	rbx, r8d

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T2[rsp], ecx

; 264  : 	stack.push_back(LevelStackEntry(x, y, i));

	mov	rcx, r15
	mov	eax, DWORD PTR [rsi]
	mov	DWORD PTR w$1$[rsp], eax
	mov	rax, QWORD PTR [rsi+88]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T2[rsp+4], edx

; 264  : 	stack.push_back(LevelStackEntry(x, y, i));

	lea	rdx, QWORD PTR $T2[rsp]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T2[rsp+8], r8d

; 259  : 	
; 260  : 	const unsigned char area = chf.areas[i];

	movzx	eax, BYTE PTR [rbx+rax]
	mov	BYTE PTR area$1$[rsp], al

; 261  : 	
; 262  : 	// Flood fill mark region.
; 263  : 	stack.clear();

	mov	QWORD PTR [r15], r12

; 264  : 	stack.push_back(LevelStackEntry(x, y, i));

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back

; 265  : 	srcReg[i] = r;
; 266  : 	srcDist[i] = 0;

	mov	rax, QWORD PTR srcDist$[rsp]

; 267  : 	
; 268  : 	unsigned short lev = level >= 2 ? level-2 : 0;
; 269  : 	int count = 0;

	cmp	di, 2
	movzx	ebp, WORD PTR r$[rsp]
	mov	r14, QWORD PTR srcReg$[rsp]
	mov	WORD PTR [r14+rbx*2], bp
	mov	WORD PTR [rax+rbx*2], r12w
	lea	eax, DWORD PTR [rdi-2]

; 270  : 	
; 271  : 	while (stack.size() > 0)

	mov	rcx, QWORD PTR [r15]
	cmovb	ax, r12w
	mov	WORD PTR tv2139[rsp], ax
	mov	eax, r12d
	mov	DWORD PTR count$1$[rsp], eax
	test	rcx, rcx
	jle	$LN3@floodRegio
	mov	QWORD PTR [rsp+56], r13
	npad	1
$LL2@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN43@floodRegio
	test	rcx, rcx
	jne	SHORT $LN43@floodRegio
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
$LN43@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 273  : 		LevelStackEntry& back = stack.back();

	mov	rax, QWORD PTR [r15+16]
	mov	rdx, QWORD PTR [r15]
	lea	rcx, QWORD PTR [rdx+rdx*2]

; 274  : 		int cx = back.x;

	mov	r8d, DWORD PTR [rax+rcx*4-12]

; 275  : 		int cy = back.y;

	mov	r13d, DWORD PTR [rax+rcx*4-8]

; 276  : 		int ci = back.index;

	movsxd	rbx, DWORD PTR [rax+rcx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	mov	rcx, rdx
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 274  : 		int cx = back.x;

	mov	DWORD PTR cx$1$[rsp], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	test	rax, rax
	je	SHORT $LN48@floodRegio
	test	rdx, rdx
	jg	SHORT $LN48@floodRegio
	mov	r8d, 143				; 0000008fH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0L@GHLCMNGA@m_size?5?$DO?50@
	call	rax
	mov	rcx, QWORD PTR [r15]
$LN48@floodRegio:

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN53@floodRegio
	test	rcx, rcx
	jne	SHORT $LN53@floodRegio
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
$LN53@floodRegio:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	dec	QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 283  : 		for (int dir = 0; dir < 4; ++dir)

	mov	r8d, r12d
	mov	rax, QWORD PTR [rsi+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r12d, DWORD PTR [rax+rbx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 279  : 		const rcCompactSpan& cs = chf.spans[ci];

	lea	rax, QWORD PTR [rax+rbx*8]
	mov	edi, r12d
	mov	QWORD PTR tv1901[rsp], rbx
	and	edi, 16777215				; 00ffffffH
	mov	QWORD PTR cs$1$[rsp], rax
	npad	7
$LL6@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [r8+r8*2]

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	eax, edi
	add	ecx, ecx
	shr	eax, cl
	and	eax, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 286  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	cmp	eax, 63					; 0000003fH
	je	$LN90@floodRegio

; 288  : 				const int ax = cx + rcGetDirOffsetX(dir);

	mov	r9d, DWORD PTR cx$1$[rsp]
	lea	r10, OFFSET FLAT:__ImageBase

; 290  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);

	mov	r11, QWORD PTR [rsi+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	mov	ecx, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 291  : 				if (chf.areas[ai] != area)

	mov	rbx, QWORD PTR [rsi+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	and	ecx, 3
	lea	rdx, QWORD PTR [rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 288  : 				const int ax = cx + rcGetDirOffsetX(dir);

	add	r9d, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rdx+r10]

; 289  : 				const int ay = cy + rcGetDirOffsetY(dir);

	mov	r10d, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rdx+r10]
	add	r10d, r13d

; 290  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);

	mov	ecx, r10d
	imul	ecx, DWORD PTR w$1$[rsp]
	add	ecx, r9d
	movsxd	rcx, ecx
	mov	edx, DWORD PTR [r11+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, eax

; 291  : 				if (chf.areas[ai] != area)

	movzx	eax, BYTE PTR area$1$[rsp]
	cmp	BYTE PTR [rbx+rdx], al
	jne	$LN93@floodRegio

; 292  : 					continue;
; 293  : 				unsigned short nr = srcReg[ai];

	movzx	eax, WORD PTR [r14+rdx*2]

; 294  : 				if (nr & RC_BORDER_REG) // Do not take borders into account.

	test	ax, ax
	js	$LN90@floodRegio

; 295  : 					continue;
; 296  : 				if (nr != 0 && nr != r)

	je	SHORT $LN13@floodRegio
	cmp	ax, bp
	jne	$LN87@floodRegio
$LN13@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rcx, QWORD PTR [rsi+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 304  : 				const int dir2 = (dir+1) & 0x3;

	lea	eax, DWORD PTR [r8+1]
	and	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rcx+rdx*8+4]
	and	edx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [rax+rax*2]
	add	ecx, ecx
	shr	edx, cl
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 305  : 				if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN90@floodRegio

; 306  : 				{
; 307  : 					const int ax2 = ax + rcGetDirOffsetX(dir2);
; 308  : 					const int ay2 = ay + rcGetDirOffsetY(dir2);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+rax*4]

; 309  : 					const int ai2 = (int)chf.cells[ax2+ay2*w].index + rcGetCon(as, dir2);

	lea	r15, OFFSET FLAT:__ImageBase
	add	ecx, r10d
	mov	r10d, DWORD PTR w$1$[rsp]
	imul	ecx, r10d
	add	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[r15+rax*4]

; 310  : 					if (chf.areas[ai2] != area)

	mov	r15, QWORD PTR stack$[rsp]
	lea	eax, DWORD PTR [r9+rcx]
	cdqe
	mov	ecx, DWORD PTR [r11+rax*4]
	movzx	r11d, BYTE PTR area$1$[rsp]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, edx
	cmp	BYTE PTR [rbx+rcx], r11b
	jne	SHORT $LN4@floodRegio

; 311  : 						continue;
; 312  : 					unsigned short nr2 = srcReg[ai2];

	movzx	eax, WORD PTR [r14+rcx*2]

; 313  : 					if (nr2 != 0 && nr2 != r)

	test	ax, ax
	je	SHORT $LN4@floodRegio
	cmp	ax, bp
	je	SHORT $LN4@floodRegio
$LN87@floodRegio:

; 314  : 					{
; 315  : 						ar = nr2;
; 316  : 						break;
; 317  : 					}
; 318  : 				}				
; 319  : 			}
; 320  : 		}
; 321  : 		if (ar != 0)
; 322  : 		{
; 323  : 			srcReg[ci] = 0;

	mov	rax, QWORD PTR tv1901[rsp]
	xor	r12d, r12d
	mov	WORD PTR [r14+rax*2], r12w

; 324  : 			continue;

	jmp	$LN80@floodRegio
$LN90@floodRegio:

; 283  : 		for (int dir = 0; dir < 4; ++dir)

	movzx	r11d, BYTE PTR area$1$[rsp]
	jmp	SHORT $LN133@floodRegio
$LN93@floodRegio:

; 291  : 				if (chf.areas[ai] != area)

	movzx	r11d, al
$LN133@floodRegio:

; 283  : 		for (int dir = 0; dir < 4; ++dir)

	mov	r10d, DWORD PTR w$1$[rsp]
$LN4@floodRegio:
	inc	r8d
	cmp	r8d, 4
	jl	$LL6@floodRegio

; 325  : 		}
; 326  : 		
; 327  : 		count++;

	inc	DWORD PTR count$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r12d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 332  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	mov	ebx, DWORD PTR cx$1$[rsp]
	cmp	r12d, 63				; 0000003fH
	je	SHORT $LN7@floodRegio

; 336  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);

	mov	eax, r13d
	lea	r8d, DWORD PTR [rbx-1]
	imul	eax, r10d
	add	eax, r8d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+64]
	mov	r9d, DWORD PTR [rax+rcx*4]

; 337  : 				if (chf.areas[ai] != area)

	mov	rax, QWORD PTR [rsi+88]
	and	r9d, 16777215				; 00ffffffH
	add	r9d, r12d
	cmp	BYTE PTR [r9+rax], r11b
	jne	SHORT $LN7@floodRegio

; 338  : 					continue;
; 339  : 				if (chf.dist[ai] >= lev && srcReg[ai] == 0)

	mov	rax, QWORD PTR [rsi+80]
	movzx	edx, WORD PTR tv2139[rsp]
	cmp	WORD PTR [rax+r9*2], dx
	jb	SHORT $LN7@floodRegio
	cmp	WORD PTR [r14+r9*2], 0
	jne	SHORT $LN7@floodRegio

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	rax, QWORD PTR srcDist$[rsp]
	xor	edx, edx
	mov	WORD PTR [r14+r9*2], bp

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	mov	rcx, r15

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp], r8d
	mov	DWORD PTR $T1[rsp+4], r13d

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	WORD PTR [rax+r9*2], dx

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	lea	rdx, QWORD PTR $T1[rsp]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp+8], r9d

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
$LN7@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rdi, QWORD PTR cs$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 332  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	mov	r12d, DWORD PTR w$1$[rsp]
	movzx	r11d, BYTE PTR area$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [rdi+4]
	shr	r8d, 6
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 332  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN76@floodRegio

; 333  : 			{
; 334  : 				const int ax = cx + rcGetDirOffsetX(dir);
; 335  : 				const int ay = cy + rcGetDirOffsetY(dir);

	lea	r9d, DWORD PTR [r13+1]

; 336  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);

	mov	eax, r9d
	imul	eax, r12d
	add	eax, ebx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+64]
	mov	r10d, DWORD PTR [rax+rcx*4]

; 337  : 				if (chf.areas[ai] != area)

	mov	rax, QWORD PTR [rsi+88]
	and	r10d, 16777215				; 00ffffffH
	add	r10d, r8d
	cmp	BYTE PTR [r10+rax], r11b
	jne	SHORT $LN76@floodRegio

; 338  : 					continue;
; 339  : 				if (chf.dist[ai] >= lev && srcReg[ai] == 0)

	mov	rax, QWORD PTR [rsi+80]
	movzx	edx, WORD PTR tv2139[rsp]
	cmp	WORD PTR [rax+r10*2], dx
	jb	SHORT $LN76@floodRegio
	cmp	WORD PTR [r14+r10*2], 0
	jne	SHORT $LN76@floodRegio

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	rax, QWORD PTR srcDist$[rsp]
	xor	edx, edx
	mov	WORD PTR [r14+r10*2], bp

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	mov	rcx, r15

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp], ebx
	mov	DWORD PTR $T1[rsp+4], r9d

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	WORD PTR [rax+r10*2], dx

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	lea	rdx, QWORD PTR $T1[rsp]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp+8], r10d

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
	movzx	r11d, BYTE PTR area$1$[rsp]
$LN76@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [rdi+4]
	shr	r8d, 12
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 332  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN96@floodRegio

; 336  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);

	mov	eax, r13d
	lea	r9d, DWORD PTR [rbx+1]
	imul	eax, r12d
	add	eax, r9d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+64]
	mov	r10d, DWORD PTR [rax+rcx*4]

; 337  : 				if (chf.areas[ai] != area)

	mov	rax, QWORD PTR [rsi+88]
	and	r10d, 16777215				; 00ffffffH
	add	r10d, r8d
	cmp	BYTE PTR [r10+rax], r11b
	movzx	r11d, WORD PTR tv2139[rsp]
	jne	SHORT $LN78@floodRegio

; 338  : 					continue;
; 339  : 				if (chf.dist[ai] >= lev && srcReg[ai] == 0)

	mov	rax, QWORD PTR [rsi+80]
	cmp	WORD PTR [rax+r10*2], r11w
	jb	SHORT $LN78@floodRegio
	cmp	WORD PTR [r14+r10*2], 0
	jne	SHORT $LN78@floodRegio

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	rax, QWORD PTR srcDist$[rsp]
	xor	edx, edx
	mov	WORD PTR [r14+r10*2], bp

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	mov	rcx, r15

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp], r9d
	mov	DWORD PTR $T1[rsp+4], r13d

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	WORD PTR [rax+r10*2], dx

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	lea	rdx, QWORD PTR $T1[rsp]

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp+8], r10d

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
$LN96@floodRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	movzx	r11d, WORD PTR tv2139[rsp]
$LN78@floodRegio:
	mov	r8d, DWORD PTR [rdi+4]
	shr	r8d, 18
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 332  : 			if (rcGetCon(cs, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN100@floodRegio

; 337  : 				if (chf.areas[ai] != area)

	movzx	edx, BYTE PTR area$1$[rsp]
	lea	r9d, DWORD PTR [r13-1]
	mov	eax, r9d
	imul	eax, r12d
	add	eax, ebx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+64]
	mov	r10d, DWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rsi+88]
	and	r10d, 16777215				; 00ffffffH
	add	r10d, r8d
	cmp	BYTE PTR [r10+rax], dl
	jne	SHORT $LN100@floodRegio

; 338  : 					continue;
; 339  : 				if (chf.dist[ai] >= lev && srcReg[ai] == 0)

	mov	rax, QWORD PTR [rsi+80]
	cmp	WORD PTR [rax+r10*2], r11w
	jb	SHORT $LN100@floodRegio
	xor	r12d, r12d
	cmp	WORD PTR [r14+r10*2], r12w
	jne	SHORT $LN80@floodRegio

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	rax, QWORD PTR srcDist$[rsp]

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	lea	rdx, QWORD PTR $T1[rsp]
	mov	WORD PTR [r14+r10*2], bp
	mov	rcx, r15

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp], ebx
	mov	DWORD PTR $T1[rsp+4], r9d

; 340  : 				{
; 341  : 					srcReg[ai] = r;
; 342  : 					srcDist[ai] = 0;

	mov	WORD PTR [rax+r10*2], r12w

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T1[rsp+8], r10d

; 343  : 					stack.push_back(LevelStackEntry(ax, ay, ai));

	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
	jmp	SHORT $LN80@floodRegio
$LN100@floodRegio:

; 270  : 	
; 271  : 	while (stack.size() > 0)

	xor	r12d, r12d
$LN80@floodRegio:
	mov	rcx, QWORD PTR [r15]
	test	rcx, rcx
	jg	$LL2@floodRegio
	mov	r13, QWORD PTR [rsp+56]
	mov	eax, DWORD PTR count$1$[rsp]
$LN3@floodRegio:

; 344  : 				}
; 345  : 			}
; 346  : 		}
; 347  : 	}
; 348  : 	
; 349  : 	return count > 0;

	test	eax, eax
	setg	al

; 350  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?floodRegion@@YA_NHHHGGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@@Z ENDP ; floodRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ??0DirtyEntry@@QEAA@HGG@Z
_TEXT	SEGMENT
this$ = 8
index_$ = 16
region_$ = 24
distance2_$ = 32
??0DirtyEntry@@QEAA@HGG@Z PROC				; DirtyEntry::DirtyEntry, COMDAT

; 356  : 		: index(index_), region(region_), distance2(distance2_) {}

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	WORD PTR [rcx+4], r8w
	mov	WORD PTR [rcx+6], r9w
	ret	0
??0DirtyEntry@@QEAA@HGG@Z ENDP				; DirtyEntry::DirtyEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z
_TEXT	SEGMENT
failed$1$ = 32
level$1$ = 36
w$1$ = 40
srcReg$GSCopy$1$ = 48
iter$1$ = 56
h$1$ = 56
chf$1$ = 64
stack$GSCopy$1$ = 72
j$1$ = 80
tv2538 = 88
srcDist$GSCopy$1$ = 96
$T1 = 104
$T2 = 104
dirtyEntries$2$ = 120
tv2563 = 120
maxIter$1$ = 128
dirtyEntries$ = 136
__$ArrayPad$ = 160
maxIter$ = 224
level$ = 232
chf$ = 240
srcReg$ = 248
srcDist$ = 256
stack$ = 264
fillStack$ = 272
?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z PROC ; expandRegions, COMDAT

; 366  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR srcReg$GSCopy$1$[rsp], r9
	mov	QWORD PTR chf$1$[rsp], r8
	mov	WORD PTR level$1$[rsp], dx
	mov	DWORD PTR maxIter$1$[rsp], ecx
	mov	rax, QWORD PTR srcDist$[rsp]
	mov	QWORD PTR srcDist$GSCopy$1$[rsp], rax
	mov	r12, QWORD PTR stack$[rsp]
	mov	QWORD PTR stack$GSCopy$1$[rsp], r12

; 367  : 	const int w = chf.width;

	movsxd	r10, DWORD PTR [r8]
	mov	DWORD PTR w$1$[rsp], r10d

; 368  : 	const int h = chf.height;

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR h$1$[rsp], eax

; 369  : 
; 370  : 	if (fillStack)

	cmp	BYTE PTR fillStack$[rsp], 0
	je	$LN25@expandRegi

; 371  : 	{
; 372  : 		// Find cells revealed by the raised level.
; 373  : 		stack.clear();

	mov	QWORD PTR [r12], 0
	xor	r14d, r14d
	xor	ecx, ecx

; 374  : 		for (int y = 0; y < h; ++y)

	test	eax, eax
	jle	$LN220@expandRegi

; 371  : 	{
; 372  : 		// Find cells revealed by the raised level.
; 373  : 		stack.clear();

	xor	r12d, r12d
	mov	r13, r10
	shl	r13, 2
	mov	QWORD PTR tv2563[rsp], r13
$LL4@expandRegi:

; 375  : 		{
; 376  : 			for (int x = 0; x < w; ++x)

	xor	esi, esi
	test	r10d, r10d
	jle	$LN2@expandRegi
	mov	r15, r12
	mov	r13, QWORD PTR stack$GSCopy$1$[rsp]
	npad	10
$LL7@expandRegi:

; 377  : 			{
; 378  : 				const rcCompactCell& c = chf.cells[x+y*w];

	mov	rax, QWORD PTR [r8+64]

; 379  : 				for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	ecx, DWORD PTR [r15+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	mov	edi, eax
	shr	ecx, 24
	lea	ebp, DWORD PTR [rax+rcx]
	cmp	rdi, rbp
	jae	SHORT $LN5@expandRegi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	ebx, edi
	npad	2
$LL10@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 381  : 					if (chf.dist[i] >= level && srcReg[i] == 0 && chf.areas[i] != RC_NULL_AREA)

	mov	rax, QWORD PTR [r8+80]
	cmp	WORD PTR [rax+rbx*2], dx
	jb	SHORT $LN8@expandRegi
	cmp	WORD PTR [r9+rbx*2], 0
	jne	SHORT $LN8@expandRegi
	mov	rax, QWORD PTR [r8+88]
	cmp	BYTE PTR [rbx+rax], 0
	je	SHORT $LN8@expandRegi

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	mov	DWORD PTR $T2[rsp], esi
	mov	DWORD PTR $T2[rsp+4], r14d
	mov	DWORD PTR $T2[rsp+8], edi

; 382  : 					{
; 383  : 						stack.push_back(LevelStackEntry(x, y, i));

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, r13
	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
	mov	r8, QWORD PTR chf$1$[rsp]
	mov	r9, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	edx, WORD PTR level$1$[rsp]
$LN8@expandRegi:

; 379  : 				for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	inc	edi
	inc	rbx
	cmp	rbx, rbp
	jl	SHORT $LL10@expandRegi
	mov	r10d, DWORD PTR w$1$[rsp]
$LN5@expandRegi:

; 375  : 		{
; 376  : 			for (int x = 0; x < w; ++x)

	inc	esi
	add	r15, 4
	cmp	esi, r10d
	jl	SHORT $LL7@expandRegi
	mov	r13, QWORD PTR tv2563[rsp]
	mov	eax, DWORD PTR h$1$[rsp]
$LN2@expandRegi:

; 374  : 		for (int y = 0; y < h; ++y)

	inc	r14d
	add	r12, r13
	cmp	r14d, eax
	jl	$LL4@expandRegi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	r12, QWORD PTR stack$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR [r12]
$LN220@expandRegi:

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN12@expandRegi:
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR dirtyEntries$[rsp], xmm1
	xor	r8d, r8d
	mov	QWORD PTR dirtyEntries$[rsp+16], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 401  : 	int iter = 0;

	mov	DWORD PTR iter$1$[rsp], r8d

; 402  : 	while (stack.size() > 0)

	test	rcx, rcx
	jle	$LN182@expandRegi

; 428  : 				if (chf.areas[ai] != area) continue;

	mov	esi, 65535				; 0000ffffH
	mov	rax, QWORD PTR dirtyEntries$[rsp+8]
	mov	QWORD PTR dirtyEntries$2$[rsp], rax
	npad	2
$LL14@expandRegi:

; 403  : 	{
; 404  : 		int failed = 0;

	xor	ebx, ebx
	mov	DWORD PTR failed$1$[rsp], ebx

; 405  : 		dirtyEntries.clear();

	xor	r14d, r14d
	mov	QWORD PTR dirtyEntries$[rsp], r14

; 407  : 		for (int j = 0; j < stack.size(); j++)

	mov	DWORD PTR j$1$[rsp], ebx
	xor	r13d, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	xor	ebp, ebp
	mov	QWORD PTR tv2538[rsp], rbp
	npad	1
$LL18@expandRegi:
	mov	rdx, rcx
	test	r9, r9
	je	SHORT $LN138@expandRegi
	test	r13, r13
	js	SHORT $LN139@expandRegi
	cmp	r13, rcx
	jl	SHORT $LN138@expandRegi
$LN139@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	rdx, QWORD PTR [r12]
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN138@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 409  : 			int x = stack[j].x;

	mov	rax, QWORD PTR [r12+16]
	mov	r15d, DWORD PTR [rax+rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rcx, rdx
	test	r9, r9
	je	SHORT $LN144@expandRegi
	test	r13, r13
	js	SHORT $LN145@expandRegi
	cmp	r13, rdx
	jl	SHORT $LN144@expandRegi
$LN145@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	rcx, QWORD PTR [r12]
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN144@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 410  : 			int y = stack[j].y;

	mov	rax, QWORD PTR [r12+16]
	mov	ebp, DWORD PTR [rax+rbp+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN150@expandRegi
	test	r13, r13
	js	SHORT $LN151@expandRegi
	cmp	r13, rcx
	jl	SHORT $LN150@expandRegi
$LN151@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN150@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 411  : 			int i = stack[j].index;

	mov	rax, QWORD PTR [r12+16]
	mov	r12, QWORD PTR tv2538[rsp]
	movsxd	r12, DWORD PTR [r12+rax+8]

; 412  : 			if (i < 0)

	test	r12d, r12d
	js	$LN234@expandRegi

; 413  : 			{
; 414  : 				failed++;
; 415  : 				continue;
; 416  : 			}
; 417  : 			
; 418  : 			unsigned short r = srcReg[i];

	mov	rax, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	edi, WORD PTR [rax+r12*2]

; 419  : 			unsigned short d2 = 0xffff;

	movzx	ebx, si

; 420  : 			const unsigned char area = chf.areas[i];

	mov	rdx, QWORD PTR chf$1$[rsp]
	mov	r11, QWORD PTR [rdx+88]
	movzx	esi, BYTE PTR [r12+r11]

; 421  : 			const rcCompactSpan& s = chf.spans[i];

	mov	rax, QWORD PTR [rdx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, DWORD PTR [rax+r12*8+4]
	and	r10d, 16777215				; 00ffffffH
	mov	r8d, r10d
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 424  : 				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN19@expandRegi

; 427  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	mov	eax, ebp
	imul	eax, DWORD PTR w$1$[rsp]
	dec	eax
	add	eax, r15d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 428  : 				if (chf.areas[ai] != area) continue;

	mov	eax, edx
	cmp	BYTE PTR [rdx+r11], sil
	jne	SHORT $LN227@expandRegi

; 429  : 				if (srcReg[ai] > 0 && (srcReg[ai] & RC_BORDER_REG) == 0)

	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	ecx, WORD PTR [rcx+rdx*2]
	test	cx, cx
	je	SHORT $LN227@expandRegi
	js	SHORT $LN227@expandRegi

; 430  : 				{
; 431  : 					if ((int)srcDist[ai]+2 < (int)d2)

	mov	rdx, QWORD PTR srcDist$GSCopy$1$[rsp]
	movzx	edx, WORD PTR [rdx+rax*2]
	lea	eax, DWORD PTR [rdx+2]
	cmp	eax, 65535				; 0000ffffH
	jae	SHORT $LN227@expandRegi

; 432  : 					{
; 433  : 						r = srcReg[ai];

	movzx	edi, cx

; 434  : 						d2 = srcDist[ai]+2;

	lea	ebx, DWORD PTR [rdx+2]
$LN227@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rdx, QWORD PTR chf$1$[rsp]
$LN19@expandRegi:
	mov	r8d, r10d
	shr	r8d, 6
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 424  : 				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN193@expandRegi

; 425  : 				const int ax = x + rcGetDirOffsetX(dir);
; 426  : 				const int ay = y + rcGetDirOffsetY(dir);

	lea	eax, DWORD PTR [rbp+1]

; 427  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, r15d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 428  : 				if (chf.areas[ai] != area) continue;

	mov	eax, edx
	cmp	BYTE PTR [rdx+r11], sil
	jne	SHORT $LN193@expandRegi

; 429  : 				if (srcReg[ai] > 0 && (srcReg[ai] & RC_BORDER_REG) == 0)

	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	edx, WORD PTR [rcx+rdx*2]
	test	dx, dx
	je	SHORT $LN193@expandRegi
	js	SHORT $LN193@expandRegi

; 430  : 				{
; 431  : 					if ((int)srcDist[ai]+2 < (int)d2)

	mov	rcx, QWORD PTR srcDist$GSCopy$1$[rsp]
	movzx	r8d, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+2]
	movzx	eax, bx
	cmp	ecx, eax
	jae	SHORT $LN193@expandRegi

; 432  : 					{
; 433  : 						r = srcReg[ai];

	movzx	edi, dx

; 434  : 						d2 = srcDist[ai]+2;

	lea	ebx, DWORD PTR [r8+2]
$LN193@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, r10d
	shr	r8d, 12
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 424  : 				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN232@expandRegi

; 427  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	mov	eax, ebp
	imul	eax, DWORD PTR w$1$[rsp]
	inc	eax
	add	eax, r15d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$1$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 428  : 				if (chf.areas[ai] != area) continue;

	mov	eax, edx
	mov	r8, QWORD PTR srcReg$GSCopy$1$[rsp]
	cmp	BYTE PTR [rdx+r11], sil
	jne	SHORT $LN195@expandRegi

; 429  : 				if (srcReg[ai] > 0 && (srcReg[ai] & RC_BORDER_REG) == 0)

	movzx	edx, WORD PTR [r8+rdx*2]
	test	dx, dx
	je	SHORT $LN195@expandRegi
	js	SHORT $LN195@expandRegi

; 430  : 				{
; 431  : 					if ((int)srcDist[ai]+2 < (int)d2)

	mov	rcx, QWORD PTR srcDist$GSCopy$1$[rsp]
	movzx	r8d, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+2]
	movzx	eax, bx
	cmp	ecx, eax
	jae	SHORT $LN232@expandRegi

; 432  : 					{
; 433  : 						r = srcReg[ai];

	movzx	edi, dx

; 434  : 						d2 = srcDist[ai]+2;

	lea	ebx, DWORD PTR [r8+2]
$LN232@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8, QWORD PTR srcReg$GSCopy$1$[rsp]
$LN195@expandRegi:
	shr	r10d, 18
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 424  : 				if (rcGetCon(s, dir) == RC_NOT_CONNECTED) continue;

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN197@expandRegi

; 425  : 				const int ax = x + rcGetDirOffsetX(dir);
; 426  : 				const int ay = y + rcGetDirOffsetY(dir);

	lea	eax, DWORD PTR [rbp-1]

; 427  : 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, r15d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$1$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r10d

; 428  : 				if (chf.areas[ai] != area) continue;

	mov	eax, edx
	cmp	BYTE PTR [rdx+r11], sil
	jne	SHORT $LN197@expandRegi

; 429  : 				if (srcReg[ai] > 0 && (srcReg[ai] & RC_BORDER_REG) == 0)

	movzx	edx, WORD PTR [r8+rdx*2]
	test	dx, dx
	je	SHORT $LN197@expandRegi
	js	SHORT $LN197@expandRegi

; 430  : 				{
; 431  : 					if ((int)srcDist[ai]+2 < (int)d2)

	mov	rcx, QWORD PTR srcDist$GSCopy$1$[rsp]
	movzx	r8d, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+2]
	movzx	eax, bx
	cmp	ecx, eax
	jae	SHORT $LN197@expandRegi

; 432  : 					{
; 433  : 						r = srcReg[ai];

	movzx	edi, dx

; 434  : 						d2 = srcDist[ai]+2;

	lea	ebx, DWORD PTR [r8+2]
$LN197@expandRegi:

; 435  : 					}
; 436  : 				}
; 437  : 			}
; 438  : 			if (r)

	test	di, di
	je	$LN34@expandRegi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rsi, QWORD PTR stack$GSCopy$1$[rsp]
	test	r9, r9
	je	SHORT $LN83@expandRegi
	test	r13, r13
	js	SHORT $LN84@expandRegi
	cmp	r13, QWORD PTR [rsi]
	jl	SHORT $LN83@expandRegi
$LN84@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN83@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 440  : 				stack[j].index = -1; // mark as used

	mov	rax, QWORD PTR [rsi+16]
	mov	rbp, QWORD PTR tv2538[rsp]
	mov	DWORD PTR [rax+rbp+8], -1

; 356  : 		: index(index_), region(region_), distance2(distance2_) {}

	mov	DWORD PTR $T1[rsp], r12d
	mov	WORD PTR $T1[rsp+4], di
	mov	WORD PTR $T1[rsp+6], bx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rdi, QWORD PTR dirtyEntries$2$[rsp]
	cmp	r14, rdi
	jge	$LN89@expandRegi

; 206  : 		construct(m_data + m_size++, value);

	mov	r8, QWORD PTR dirtyEntries$[rsp+16]
	lea	rcx, QWORD PTR [r8+r14*8]
	inc	r14
	mov	QWORD PTR dirtyEntries$[rsp], r14

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	ebx, DWORD PTR failed$1$[rsp]
	mov	esi, 65535				; 0000ffffH
	test	rcx, rcx
	je	$LN16@expandRegi
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rcx], rax

; 207  : 		return;

	jmp	$LN16@expandRegi
$LN25@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 392  : 		for (int j=0; j<stack.size(); j++)

	xor	esi, esi
	mov	rcx, QWORD PTR [r12]
	test	rcx, rcx
	jle	$LN220@expandRegi
	xor	ebx, ebx
	xor	edi, edi
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LL13@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rdx, rcx
	test	r9, r9
	je	SHORT $LN164@expandRegi
	test	rbx, rbx
	js	SHORT $LN165@expandRegi
	cmp	rbx, rcx
	jl	SHORT $LN164@expandRegi
$LN165@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	rdx, QWORD PTR [r12]
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN164@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 394  : 			int i = stack[j].index;

	mov	rax, QWORD PTR [r12+16]

; 395  : 			if (srcReg[i] != 0)

	movsxd	rcx, DWORD PTR [rax+rdi+8]
	mov	rax, QWORD PTR srcReg$GSCopy$1$[rsp]
	cmp	WORD PTR [rax+rcx*2], 0
	je	SHORT $LN11@expandRegi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN170@expandRegi
	test	rbx, rbx
	js	SHORT $LN171@expandRegi
	cmp	rbx, rdx
	jl	SHORT $LN170@expandRegi
$LN171@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN170@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 396  : 				stack[j].index = -1;

	mov	rax, QWORD PTR [r12+16]
	mov	DWORD PTR [rax+rdi+8], -1
$LN11@expandRegi:

; 392  : 		for (int j=0; j<stack.size(); j++)

	inc	esi
	inc	rbx
	add	rdi, 12
	mov	rcx, QWORD PTR [r12]
	movsxd	rax, esi
	cmp	rax, rcx
	jl	$LL13@expandRegi
	jmp	$LN12@expandRegi
$LN89@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rcx, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdi, rax
	jl	SHORT $LN99@expandRegi

; 226  : 		return RC_SIZE_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rdi, rax
	mov	QWORD PTR dirtyEntries$2$[rsp], rax
	jmp	SHORT $LN101@expandRegi
$LN99@expandRegi:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	mov	rdi, rcx
	cmp	rax, rcx
	cmovg	rdi, rax
	mov	QWORD PTR dirtyEntries$2$[rsp], rdi
$LN101@expandRegi:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN106@expandRegi
	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdi, rax
	jle	SHORT $LN106@expandRegi
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN106@expandRegi:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	mov	r9, QWORD PTR dirtyEntries$[rsp+16]
	test	rax, rax
	je	SHORT $LN117@expandRegi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	lea	rdx, QWORD PTR [r14*8]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sar	rdx, 3
	test	rdx, rdx
	jle	SHORT $LN117@expandRegi
	mov	rcx, rax
	mov	r8, r9
	sub	r8, rax
$LL118@expandRegi:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN116@expandRegi
	mov	rax, QWORD PTR [r8+rcx]
	mov	QWORD PTR [rcx], rax
$LN116@expandRegi:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 8
	sub	rdx, 1
	jne	SHORT $LL118@expandRegi
$LN117@expandRegi:

; 214  : 	construct(data + m_size, value);

	lea	rdx, QWORD PTR [rbx+r14*8]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	SHORT $LN126@expandRegi
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rdx], rax
$LN126@expandRegi:

; 216  : 	m_size++;

	inc	r14
	mov	QWORD PTR dirtyEntries$[rsp], r14

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR dirtyEntries$[rsp+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r9, r9
	je	SHORT $LN131@expandRegi

; 28   : 	free(ptr);

	mov	rcx, r9
	call	QWORD PTR __imp_free
$LN131@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	r8, rbx
	mov	QWORD PTR dirtyEntries$[rsp+16], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 442  : 			}

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ebx, DWORD PTR failed$1$[rsp]
	mov	esi, 65535				; 0000ffffH
	jmp	SHORT $LN16@expandRegi
$LN34@expandRegi:

; 443  : 			else
; 444  : 			{
; 445  : 				failed++;

	mov	ebx, DWORD PTR failed$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	esi, 65535				; 0000ffffH
$LN234@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 407  : 		for (int j = 0; j < stack.size(); j++)

	inc	ebx
	mov	r8, QWORD PTR dirtyEntries$[rsp+16]
	mov	rbp, QWORD PTR tv2538[rsp]
	mov	DWORD PTR failed$1$[rsp], ebx
$LN16@expandRegi:
	mov	r10d, DWORD PTR j$1$[rsp]
	inc	r10d
	mov	DWORD PTR j$1$[rsp], r10d
	inc	r13
	add	rbp, 12
	mov	QWORD PTR tv2538[rsp], rbp
	mov	r12, QWORD PTR stack$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR [r12]
	movsxd	rax, r10d
	cmp	rax, rcx
	jl	$LL18@expandRegi

; 446  : 			}
; 447  : 		}
; 448  : 		
; 449  : 		// Copy entries that differ between src and dst to keep them in sync.
; 450  : 		for (int i = 0; i < dirtyEntries.size(); i++) {

	xor	ebp, ebp
	xor	ebx, ebx
	test	r14, r14
	jle	$LN23@expandRegi
	lea	rdi, QWORD PTR [r8+6]
	mov	r12, QWORD PTR srcReg$GSCopy$1$[rsp]
$LL24@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN44@expandRegi
	test	rbx, rbx
	js	SHORT $LN45@expandRegi
	cmp	rbx, r14
	jl	SHORT $LN44@expandRegi
$LN45@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN44@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 451  : 			int idx = dirtyEntries[i].index;

	movsxd	rsi, DWORD PTR [rdi-6]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN50@expandRegi
	test	rbx, rbx
	js	SHORT $LN51@expandRegi
	cmp	rbx, r14
	jl	SHORT $LN50@expandRegi
$LN51@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN50@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 452  : 			srcReg[idx] = dirtyEntries[i].region;

	add	rsi, rsi
	movzx	eax, WORD PTR [rdi-2]
	mov	WORD PTR [r12+rsi], ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN56@expandRegi
	test	rbx, rbx
	js	SHORT $LN57@expandRegi
	cmp	rbx, r14
	jl	SHORT $LN56@expandRegi
$LN57@expandRegi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN56@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 453  : 			srcDist[idx] = dirtyEntries[i].distance2;

	movzx	eax, WORD PTR [rdi]
	mov	rcx, QWORD PTR srcDist$GSCopy$1$[rsp]
	mov	WORD PTR [rsi+rcx], ax

; 446  : 			}
; 447  : 		}
; 448  : 		
; 449  : 		// Copy entries that differ between src and dst to keep them in sync.
; 450  : 		for (int i = 0; i < dirtyEntries.size(); i++) {

	inc	ebp
	inc	rbx
	add	rdi, 8
	movsxd	rax, ebp
	cmp	rax, r14
	jl	$LL24@expandRegi
	mov	r12, QWORD PTR stack$GSCopy$1$[rsp]
$LN23@expandRegi:

; 454  : 		}
; 455  : 		
; 456  : 		if (failed == stack.size())

	mov	rcx, QWORD PTR [r12]
	movsxd	rax, DWORD PTR failed$1$[rsp]
	cmp	rax, rcx
	je	SHORT $LN221@expandRegi

; 457  : 			break;
; 458  : 		
; 459  : 		if (level > 0)

	cmp	WORD PTR level$1$[rsp], 0
	jbe	SHORT $LN38@expandRegi

; 460  : 		{
; 461  : 			++iter;

	mov	edx, DWORD PTR iter$1$[rsp]
	inc	edx
	mov	DWORD PTR iter$1$[rsp], edx

; 462  : 			if (iter >= maxIter)

	cmp	edx, DWORD PTR maxIter$1$[rsp]
	jge	SHORT $LN221@expandRegi
$LN38@expandRegi:

; 402  : 	while (stack.size() > 0)

	test	rcx, rcx
	mov	esi, 65535				; 0000ffffH
	jg	$LL14@expandRegi
$LN221@expandRegi:
	mov	r8, QWORD PTR dirtyEntries$[rsp+16]
$LN182@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r8, r8
	je	SHORT $LN219@expandRegi

; 28   : 	free(ptr);

	mov	rcx, r8
	call	QWORD PTR __imp_free
	npad	1
$LN219@expandRegi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 466  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z ENDP ; expandRegions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
failed$1$ = 32
level$1$ = 36
w$1$ = 40
srcReg$GSCopy$1$ = 48
iter$1$ = 56
h$1$ = 56
chf$1$ = 64
stack$GSCopy$1$ = 72
j$1$ = 80
tv2538 = 88
srcDist$GSCopy$1$ = 96
$T1 = 104
$T2 = 104
dirtyEntries$2$ = 120
tv2563 = 120
maxIter$1$ = 128
dirtyEntries$ = 136
__$ArrayPad$ = 160
maxIter$ = 224
level$ = 232
chf$ = 240
srcReg$ = 248
srcDist$ = 256
stack$ = 264
fillStack$ = 272
?dtor$0@?0??expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z@4HA PROC ; `expandRegions'::`1'::dtor$0
	lea	rcx, QWORD PTR dirtyEntries$[rdx]
	jmp	??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
?dtor$0@?0??expandRegions@@YAXHGAEAUrcCompactHeightfield@@PEAG1AEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@_N@Z@4HA ENDP ; `expandRegions'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ PROC		; rcTempVector<DirtyEntry>::~rcTempVector<DirtyEntry>, COMDAT
$LN16:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN13@rcTempVect

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN13@rcTempVect:
	add	rsp, 40					; 00000028H
	ret	0
??1?$rcTempVector@UDirtyEntry@@@@QEAA@XZ ENDP		; rcTempVector<DirtyEntry>::~rcTempVector<DirtyEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcTempVector@UDirtyEntry@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcTempVector@UDirtyEntry@@@@QEAAX_K@Z PROC ; rcTempVector<DirtyEntry>::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$rcTempVector@UDirtyEntry@@@@QEAAX_K@Z ENDP ; rcTempVector<DirtyEntry>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z
_TEXT	SEGMENT
tv672 = 32
tv671 = 40
$T1 = 48
startLevel$ = 128
tv675 = 136
chf$ = 136
srcReg$ = 144
w$1$ = 152
nbStacks$dead$ = 152
stacks$ = 160
h$1$ = 168
loglevelsPerStack$dead$ = 168
?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z PROC ; sortCellsByLevel, COMDAT

; 475  : {

	mov	r11, rsp
	mov	DWORD PTR [r11+32], r9d
	push	rsi
	push	r13
	push	r15
	sub	rsp, 96					; 00000060H

; 476  : 	const int w = chf.width;

	movsxd	rax, DWORD PTR [rdx]
	mov	r15, r8

; 477  : 	const int h = chf.height;
; 478  : 	startLevel = startLevel >> loglevelsPerStack;
; 479  : 
; 480  : 	for (unsigned int j=0; j<nbStacks; ++j)
; 481  : 		stacks[j].clear();

	mov	r8, QWORD PTR stacks$[rsp]
	mov	rsi, rdx
	mov	edx, DWORD PTR [rdx+4]

; 482  : 
; 483  : 	// put all cells in the level range into the appropriate stacks
; 484  : 	for (int y = 0; y < h; ++y)

	xor	r13d, r13d
	shr	cx, 1
	mov	DWORD PTR w$1$[rsp], eax
	mov	QWORD PTR [r8], 0
	mov	QWORD PTR [r8+24], 0
	mov	QWORD PTR [r8+48], 0
	mov	QWORD PTR [r8+72], 0
	mov	QWORD PTR [r8+96], 0
	mov	QWORD PTR [r8+120], 0
	mov	QWORD PTR [r8+144], 0
	mov	QWORD PTR [r8+168], 0
	mov	DWORD PTR h$1$[rsp], edx
	mov	WORD PTR startLevel$[rsp], cx
	test	edx, edx
	jle	$LN6@sortCellsB
	mov	r9d, DWORD PTR h$1$[rsp]
	xor	ecx, ecx
	mov	QWORD PTR [r11+24], rbx
	mov	rdx, rax
	mov	QWORD PTR [r11-32], rbp
	mov	QWORD PTR [r11-40], rdi
	shl	rdx, 2
	mov	QWORD PTR [r11-48], r12
	mov	QWORD PTR [r11-56], r14
	mov	QWORD PTR tv671[rsp], rdx
	mov	QWORD PTR tv672[rsp], rcx
	npad	4
$LL7@sortCellsB:

; 485  : 	{
; 486  : 		for (int x = 0; x < w; ++x)

	xor	ebp, ebp
	test	eax, eax
	jle	$LN5@sortCellsB
	mov	r12, rcx
	mov	QWORD PTR tv675[rsp], rcx
	npad	11
$LL10@sortCellsB:

; 487  : 		{
; 488  : 			const rcCompactCell& c = chf.cells[x+y*w];
; 489  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [rsi+64]
	mov	ecx, DWORD PTR [r12+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	shr	ecx, 24
	mov	edi, eax
	lea	r14d, DWORD PTR [rax+rcx]
	cmp	rdi, r14
	jae	SHORT $LN8@sortCellsB
	movzx	r12d, WORD PTR startLevel$[rsp]
	mov	ebx, edi
	npad	8
$LL13@sortCellsB:

; 490  : 			{
; 491  : 				if (chf.areas[i] == RC_NULL_AREA || srcReg[i] != 0)

	mov	rax, QWORD PTR [rsi+88]
	cmp	BYTE PTR [rbx+rax], 0
	je	SHORT $LN11@sortCellsB
	cmp	WORD PTR [r15+rbx*2], 0
	jne	SHORT $LN11@sortCellsB

; 492  : 					continue;
; 493  : 
; 494  : 				int level = chf.dist[i] >> loglevelsPerStack;
; 495  : 				int sId = startLevel - level;

	mov	rax, QWORD PTR [rsi+80]
	mov	edx, r12d
	movzx	ecx, WORD PTR [rax+rbx*2]
	shr	ecx, 1
	sub	edx, ecx

; 496  : 				if (sId >= (int)nbStacks)

	cmp	edx, 8
	jge	SHORT $LN11@sortCellsB

; 32   : 	LevelStackEntry(int x_, int y_, int index_) : x(x_), y(y_), index(index_) {}

	xor	eax, eax
	mov	DWORD PTR $T1[rsp], ebp
	test	edx, edx
	mov	DWORD PTR $T1[rsp+4], r13d
	mov	DWORD PTR $T1[rsp+8], edi
	cmovns	eax, edx

; 497  : 					continue;
; 498  : 				if (sId < 0)
; 499  : 					sId = 0;
; 500  : 
; 501  : 				stacks[sId].push_back(LevelStackEntry(x, y, i));

	lea	rdx, QWORD PTR $T1[rsp]
	cdqe
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [r8+rcx*8]
	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
	mov	r8, QWORD PTR stacks$[rsp]
$LN11@sortCellsB:

; 487  : 		{
; 488  : 			const rcCompactCell& c = chf.cells[x+y*w];
; 489  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	inc	edi
	inc	rbx
	cmp	rbx, r14
	jl	SHORT $LL13@sortCellsB
	mov	r12, QWORD PTR tv675[rsp]
$LN8@sortCellsB:

; 485  : 	{
; 486  : 		for (int x = 0; x < w; ++x)

	mov	eax, DWORD PTR w$1$[rsp]
	add	r12, 4
	inc	ebp
	mov	QWORD PTR tv675[rsp], r12
	cmp	ebp, eax
	jl	$LL10@sortCellsB
	mov	rcx, QWORD PTR tv672[rsp]
	mov	rdx, QWORD PTR tv671[rsp]
	mov	r9d, DWORD PTR h$1$[rsp]
$LN5@sortCellsB:

; 482  : 
; 483  : 	// put all cells in the level range into the appropriate stacks
; 484  : 	for (int y = 0; y < h; ++y)

	add	rcx, rdx
	inc	r13d
	mov	QWORD PTR tv672[rsp], rcx
	cmp	r13d, r9d
	jl	$LL7@sortCellsB
	mov	r14, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+144]
$LN6@sortCellsB:

; 502  : 			}
; 503  : 		}
; 504  : 	}
; 505  : }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r13
	pop	rsi
	ret	0
?sortCellsByLevel@@YAXGAEAUrcCompactHeightfield@@PEBGIPEAV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@G@Z ENDP ; sortCellsByLevel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z
_TEXT	SEGMENT
srcStack$ = 64
dstStack$ = 72
srcReg$ = 80
?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z PROC ; appendStacks, COMDAT

; 511  : {

	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H

; 512  : 	for (int j=0; j<srcStack.size(); j++)

	mov	rax, QWORD PTR [rcx]
	xor	ebp, ebp
	mov	r15, r8
	mov	r12, rdx
	mov	rsi, rcx
	test	rax, rax
	jle	$LN3@appendStac
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rsp+64], rbx
	mov	ebx, ebp
	mov	QWORD PTR [rsp+72], rdi
	mov	edi, ebp
	mov	QWORD PTR [rsp+80], r14
	mov	r14d, ebp
$LL4@appendStac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rcx, rax
	test	r9, r9
	je	SHORT $LN11@appendStac
	test	rdi, rdi
	js	SHORT $LN12@appendStac
	cmp	rdi, rax
	jl	SHORT $LN11@appendStac
$LN12@appendStac:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	rcx, QWORD PTR [rsi]
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN11@appendStac:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 514  : 		int i = srcStack[j].index;

	mov	rax, QWORD PTR [rsi+16]
	movsxd	rdx, DWORD PTR [rax+r14+8]

; 515  : 		if ((i < 0) || (srcReg[i] != 0))

	test	edx, edx
	js	SHORT $LN2@appendStac
	cmp	WORD PTR [r15+rdx*2], 0
	jne	SHORT $LN2@appendStac
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN17@appendStac
	test	rbx, rbx
	js	SHORT $LN18@appendStac
	cmp	rbx, rcx
	jl	SHORT $LN17@appendStac
$LN18@appendStac:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
$LN17@appendStac:
	mov	rax, QWORD PTR [rsi+16]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR [rax+rcx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 517  : 		dstStack.push_back(srcStack[j]);

	mov	rcx, r12
	call	?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN2@appendStac:

; 512  : 	for (int j=0; j<srcStack.size(); j++)

	mov	rax, QWORD PTR [rsi]
	inc	ebp
	movsxd	rbx, ebp
	inc	rdi
	add	r14, 12
	cmp	rbx, rax
	jl	$LL4@appendStac
	mov	r14, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN3@appendStac:

; 518  : 	}
; 519  : }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	ret	0
?appendStacks@@YAXAEBV?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@AEAV1@PEBG@Z ENDP ; appendStacks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ??0rcRegion@@QEAA@G@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??0rcRegion@@QEAA@G@Z PROC				; rcRegion::rcRegion, COMDAT

; 524  : 		spanCount(0),

	xor	r8d, r8d

; 525  : 		id(i),

	mov	WORD PTR [rcx+4], dx
	mov	DWORD PTR [rcx], r8d

; 533  : 	{}

	mov	rax, rcx
	mov	DWORD PTR [rcx+6], r8d
	mov	BYTE PTR [rcx+10], r8b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r8
	mov	QWORD PTR [rcx+32], r8
	mov	QWORD PTR [rcx+40], r8
	mov	QWORD PTR [rcx+48], r8
	mov	QWORD PTR [rcx+56], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 531  : 		ymin(0xffff),

	mov	DWORD PTR [rcx+12], 65535		; 0000ffffH

; 533  : 	{}

	ret	0
??0rcRegion@@QEAA@G@Z ENDP				; rcRegion::rcRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z
_TEXT	SEGMENT
reg$ = 64
?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z PROC	; removeAdjacentNeighbours, COMDAT

; 548  : {

	push	rbx
	push	r15
	sub	rsp, 40					; 00000028H
	mov	rbx, rcx

; 549  : 	// Remove adjacent duplicates.
; 550  : 	for (int i = 0; i < reg.connections.size() && reg.connections.size() > 1; )

	xor	r15d, r15d
	mov	ecx, DWORD PTR [rcx+16]
	test	ecx, ecx
	jle	$LN83@removeAdja
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+32], r14
	mov	r14d, r15d
$LL2@removeAdja:
	cmp	ecx, 1
	jle	$LN105@removeAdja

; 551  : 	{
; 552  : 		int ni = (i+1) % reg.connections.size();

	lea	eax, DWORD PTR [r15+1]
	cdq
	idiv	ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, edx

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN22@removeAdja
	test	edx, edx
	js	SHORT $LN79@removeAdja
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN22@removeAdja
$LN79@removeAdja:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN22@removeAdja:
	mov	rax, QWORD PTR [rbx+32]
	lea	rdi, QWORD PTR [rax+rdi*4]
	test	r9, r9
	je	SHORT $LN30@removeAdja
	test	r14, r14
	js	SHORT $LN80@removeAdja
	cmp	r14, QWORD PTR [rbx+16]
	jl	SHORT $LN30@removeAdja
$LN80@removeAdja:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN30@removeAdja:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 553  : 		if (reg.connections[i] == reg.connections[ni])

	mov	rcx, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rdi]
	cmp	DWORD PTR [rcx+r14*4], eax
	jne	$LN8@removeAdja

; 554  : 		{
; 555  : 			// Remove duplicate
; 556  : 			for (int j = i; j < reg.connections.size()-1; ++j)

	mov	eax, DWORD PTR [rbx+16]
	mov	ebp, r15d
	dec	eax
	mov	rdi, r14
	cmp	r15d, eax
	jge	$LN6@removeAdja
$LL7@removeAdja:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN40@removeAdja
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN82@removeAdja
	cmp	rax, QWORD PTR [rbx+16]
	jl	SHORT $LN40@removeAdja
$LN82@removeAdja:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN40@removeAdja:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 557  : 				reg.connections[j] = reg.connections[j+1];

	mov	rax, QWORD PTR [rbx+32]
	mov	esi, DWORD PTR [rax+rdi*4+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN48@removeAdja
	test	rdi, rdi
	js	SHORT $LN81@removeAdja
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN48@removeAdja
$LN81@removeAdja:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN48@removeAdja:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 557  : 				reg.connections[j] = reg.connections[j+1];

	mov	rax, QWORD PTR [rbx+32]
	inc	ebp
	mov	DWORD PTR [rax+rdi*4], esi
	inc	rdi
	mov	eax, DWORD PTR [rbx+16]
	dec	eax
	cmp	ebp, eax
	jl	SHORT $LL7@removeAdja
$LN6@removeAdja:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	r9, r9
	je	SHORT $LN66@removeAdja
	cmp	QWORD PTR [rbx+16], 0
	jne	SHORT $LN56@removeAdja
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN56@removeAdja:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	test	r9, r9
	je	SHORT $LN66@removeAdja
	cmp	QWORD PTR [rbx+16], 0
	jg	SHORT $LN61@removeAdja
	mov	r8d, 143				; 0000008fH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0L@GHLCMNGA@m_size?5?$DO?50@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN61@removeAdja:

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	r9, r9
	je	SHORT $LN66@removeAdja
	cmp	QWORD PTR [rbx+16], 0
	jne	SHORT $LN66@removeAdja
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN66@removeAdja:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	dec	QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 559  : 		}

	jmp	SHORT $LN108@removeAdja
$LN8@removeAdja:

; 560  : 		else
; 561  : 			++i;

	inc	r15d
	inc	r14
$LN108@removeAdja:

; 549  : 	// Remove adjacent duplicates.
; 550  : 	for (int i = 0; i < reg.connections.size() && reg.connections.size() > 1; )

	mov	rcx, QWORD PTR [rbx+16]
	cmp	r15d, ecx
	jl	$LL2@removeAdja
$LN105@removeAdja:
	mov	rdi, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+32]
$LN83@removeAdja:

; 562  : 	}
; 563  : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	rbx
	ret	0
?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z ENDP	; removeAdjacentNeighbours
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z
_TEXT	SEGMENT
reg$ = 64
oldId$ = 72
newId$ = 80
?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z PROC		; replaceNeighbour, COMDAT

; 566  : {

	push	rbx
	sub	rsp, 48					; 00000030H

; 567  : 	bool neiChanged = false;
; 568  : 	for (int i = 0; i < reg.connections.size(); ++i)

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rcx
	mov	QWORD PTR [rsp+64], rbp
	xor	ebp, ebp
	mov	QWORD PTR [rsp+72], rsi
	mov	esi, ebp
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+88], r12
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15
	xor	r15b, r15b
	movzx	r12d, r8w
	movzx	r14d, dx
	cmp	DWORD PTR [rcx+16], ebp
	jle	SHORT $LN3@replaceNei
	mov	edi, ebp
$LL4@replaceNei:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN19@replaceNei
	test	rdi, rdi
	js	SHORT $LN61@replaceNei
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN19@replaceNei
$LN61@replaceNei:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN19@replaceNei:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 570  : 		if (reg.connections[i] == oldId)

	mov	rax, QWORD PTR [rbx+32]
	cmp	DWORD PTR [rax+rdi*4], r14d
	jne	SHORT $LN2@replaceNei
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN27@replaceNei
	test	rdi, rdi
	js	SHORT $LN60@replaceNei
	cmp	rdi, QWORD PTR [rbx+16]
	jl	SHORT $LN27@replaceNei
$LN60@replaceNei:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN27@replaceNei:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 572  : 			reg.connections[i] = newId;

	mov	rax, QWORD PTR [rbx+32]

; 573  : 			neiChanged = true;

	mov	r15b, 1
	mov	DWORD PTR [rax+rdi*4], r12d
$LN2@replaceNei:

; 567  : 	bool neiChanged = false;
; 568  : 	for (int i = 0; i < reg.connections.size(); ++i)

	inc	esi
	inc	rdi
	cmp	esi, DWORD PTR [rbx+16]
	jl	SHORT $LL4@replaceNei
$LN3@replaceNei:
	mov	rsi, QWORD PTR [rsp+72]

; 574  : 		}
; 575  : 	}
; 576  : 	for (int i = 0; i < reg.floors.size(); ++i)

	cmp	DWORD PTR [rbx+40], ebp
	jle	SHORT $LN6@replaceNei
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rdi, rbp
	npad	4
$LL7@replaceNei:
	test	r9, r9
	je	SHORT $LN37@replaceNei
	test	rdi, rdi
	js	SHORT $LN64@replaceNei
	cmp	rdi, QWORD PTR [rbx+40]
	jl	SHORT $LN37@replaceNei
$LN64@replaceNei:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN37@replaceNei:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 578  : 		if (reg.floors[i] == oldId)

	mov	rax, QWORD PTR [rbx+56]
	cmp	DWORD PTR [rax+rdi*4], r14d
	jne	SHORT $LN5@replaceNei
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN45@replaceNei
	test	rdi, rdi
	js	SHORT $LN63@replaceNei
	cmp	rdi, QWORD PTR [rbx+40]
	jl	SHORT $LN45@replaceNei
$LN63@replaceNei:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN45@replaceNei:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 579  : 			reg.floors[i] = newId;

	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+rdi*4], r12d
$LN5@replaceNei:

; 574  : 		}
; 575  : 	}
; 576  : 	for (int i = 0; i < reg.floors.size(); ++i)

	inc	ebp
	inc	rdi
	cmp	ebp, DWORD PTR [rbx+40]
	jl	SHORT $LL7@replaceNei
$LN6@replaceNei:
	mov	r14, QWORD PTR [rsp+40]

; 580  : 	}
; 581  : 	if (neiChanged)

	test	r15b, r15b
	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+64]
	je	SHORT $LN10@replaceNei

; 582  : 		removeAdjacentNeighbours(reg);

	mov	rcx, rbx

; 583  : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 582  : 		removeAdjacentNeighbours(reg);

	jmp	?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z ; removeAdjacentNeighbours
$LN10@replaceNei:

; 583  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?replaceNeighbour@@YAXAEAUrcRegion@@GG@Z ENDP		; replaceNeighbour
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z
_TEXT	SEGMENT
rega$ = 64
regb$ = 72
?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z PROC		; canMergeWithRegion, COMDAT

; 586  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 587  : 	if (rega.areaType != regb.areaType)

	movzx	eax, BYTE PTR [rdx+6]
	mov	rbp, rdx
	mov	rdi, rcx
	cmp	BYTE PTR [rcx+6], al
	jne	$LN35@canMergeWi

; 590  : 	for (int i = 0; i < rega.connections.size(); ++i)

	mov	r8d, DWORD PTR [rcx+16]
	xor	esi, esi
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r14d, esi
	mov	r15d, esi
	test	r8d, r8d
	jle	SHORT $LN10@canMergeWi
	mov	ebx, esi
$LL4@canMergeWi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN20@canMergeWi
	test	rbx, rbx
	js	SHORT $LN43@canMergeWi
	mov	r8, QWORD PTR [rdi+16]
	cmp	rbx, r8
	jl	SHORT $LN20@canMergeWi
$LN43@canMergeWi:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r8d, DWORD PTR [rdi+16]
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN20@canMergeWi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 590  : 	for (int i = 0; i < rega.connections.size(); ++i)

	mov	rax, QWORD PTR [rdi+32]
	lea	edx, DWORD PTR [r14+1]

; 591  : 	{
; 592  : 		if (rega.connections[i] == regb.id)

	movzx	ecx, WORD PTR [rbp+4]
	cmp	DWORD PTR [rax+rbx*4], ecx
	cmovne	edx, r14d
	inc	r15d
	inc	rbx
	mov	r14d, edx
	cmp	r15d, r8d
	jl	SHORT $LL4@canMergeWi

; 593  : 			n++;
; 594  : 	}
; 595  : 	if (n > 1)

	cmp	edx, 1
	jg	SHORT $LN35@canMergeWi
$LN10@canMergeWi:

; 596  : 		return false;
; 597  : 	for (int i = 0; i < rega.floors.size(); ++i)

	cmp	DWORD PTR [rdi+40], esi
	jle	SHORT $LN6@canMergeWi
	mov	rbx, rsi
$LL7@canMergeWi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN30@canMergeWi
	test	rbx, rbx
	js	SHORT $LN31@canMergeWi
	cmp	rbx, QWORD PTR [rdi+40]
	jl	SHORT $LN30@canMergeWi
$LN31@canMergeWi:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN30@canMergeWi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 599  : 		if (rega.floors[i] == regb.id)

	mov	rcx, QWORD PTR [rdi+56]
	movzx	eax, WORD PTR [rbp+4]
	cmp	DWORD PTR [rcx+rbx*4], eax
	je	SHORT $LN35@canMergeWi

; 596  : 		return false;
; 597  : 	for (int i = 0; i < rega.floors.size(); ++i)

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR [rdi+40]
	jl	SHORT $LL7@canMergeWi
$LN6@canMergeWi:

; 601  : 	}
; 602  : 	return true;

	mov	al, 1
	jmp	SHORT $LN1@canMergeWi
$LN35@canMergeWi:

; 600  : 			return false;

	xor	al, al
$LN1@canMergeWi:

; 603  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z ENDP		; canMergeWithRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z
_TEXT	SEGMENT
reg$ = 48
n$ = 56
?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z PROC	; addUniqueFloorRegion, COMDAT

; 606  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)

	xor	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 342  : 	int size() const { return static_cast<int>(m_impl.size()); }

	lea	rdi, QWORD PTR [rcx+40]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 606  : {

	mov	ebp, edx

; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)

	cmp	DWORD PTR [rdi], esi
	jle	SHORT $LN3@addUniqueF
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ebx, esi
	npad	7
$LL4@addUniqueF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN14@addUniqueF
	test	rbx, rbx
	js	SHORT $LN15@addUniqueF
	cmp	rbx, QWORD PTR [rdi]
	jl	SHORT $LN14@addUniqueF
$LN15@addUniqueF:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN14@addUniqueF:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 608  : 		if (reg.floors[i] == n)

	mov	rax, QWORD PTR [rdi+16]
	cmp	DWORD PTR [rax+rbx*4], ebp
	je	SHORT $LN1@addUniqueF

; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR [rdi]
	jl	SHORT $LL4@addUniqueF
$LN3@addUniqueF:

; 609  : 			return;
; 610  : 	reg.floors.push(n);

	mov	edx, ebp
	mov	rcx, rdi
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push
$LN1@addUniqueF:

; 611  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z ENDP	; addUniqueFloorRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?mergeRegions@@YA_NAEAUrcRegion@@0@Z
_TEXT	SEGMENT
i$1$ = 32
bcon$1$ = 40
regb$GSCopy$1$ = 48
acon$ = 56
__$ArrayPad$ = 80
rega$ = 160
regb$ = 168
?mergeRegions@@YA_NAEAUrcRegion@@0@Z PROC		; mergeRegions, COMDAT

; 614  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r12, rdx
	mov	QWORD PTR regb$GSCopy$1$[rsp], rdx
	mov	r13, rcx

; 615  : 	unsigned short aid = rega.id;

	movzx	r14d, WORD PTR [rcx+4]

; 616  : 	unsigned short bid = regb.id;

	movzx	ebp, WORD PTR [rdx+4]
	xor	eax, eax
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	movdqu	XMMWORD PTR acon$[rsp], xmm1
	mov	QWORD PTR acon$[rsp+16], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 620  : 	acon.resize(rega.connections.size());

	movsxd	r15, DWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 232  : 	if (size < m_size) {

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	test	r15, r15
	jns	SHORT $LN388@mergeRegio

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;

	mov	QWORD PTR acon$[rsp], r15
	jmp	SHORT $LN245@mergeRegio
$LN388@mergeRegio:

; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN386@mergeRegio

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN271@mergeRegio
	cmp	r15, rcx
	jle	SHORT $LN271@mergeRegio
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN271@mergeRegio:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 255  : 			m_data = new_data;

	mov	QWORD PTR acon$[rsp+16], rax

; 256  : 			m_cap = new_cap;

	mov	QWORD PTR acon$[rsp+8], r15

; 257  : 			m_size = size;

	mov	QWORD PTR acon$[rsp], r15

; 235  : 	} else if (size > m_size) {

	jmp	SHORT $LN245@mergeRegio
$LN386@mergeRegio:
	mov	r15, QWORD PTR acon$[rsp]
$LN245@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 621  : 	for (int i = 0; i < rega.connections.size(); ++i)

	xor	edi, edi
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	cmp	DWORD PTR [r13+16], edi
	jle	SHORT $LN3@mergeRegio
	xor	ebx, ebx
	npad	1
$LL4@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN215@mergeRegio
	test	rbx, rbx
	js	SHORT $LN216@mergeRegio
	cmp	rbx, QWORD PTR [r13+16]
	jl	SHORT $LN215@mergeRegio
$LN216@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN215@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 622  : 		acon[i] = rega.connections[i];

	mov	rax, QWORD PTR [r13+32]
	mov	esi, DWORD PTR [rax+rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN223@mergeRegio
	test	rbx, rbx
	js	SHORT $LN224@mergeRegio
	cmp	rbx, r15
	jl	SHORT $LN223@mergeRegio
$LN224@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN223@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 622  : 		acon[i] = rega.connections[i];

	mov	rax, QWORD PTR acon$[rsp+16]
	mov	DWORD PTR [rax+rbx*4], esi

; 621  : 	for (int i = 0; i < rega.connections.size(); ++i)

	inc	edi
	inc	rbx
	cmp	edi, DWORD PTR [r13+16]
	jl	SHORT $LL4@mergeRegio
$LN3@mergeRegio:

; 623  : 	rcIntArray& bcon = regb.connections;

	lea	rsi, QWORD PTR [r12+16]
	mov	QWORD PTR bcon$1$[rsp], rsi

; 624  : 	
; 625  : 	// Find insertion point on A.
; 626  : 	int insa = -1;
; 627  : 	for (int i = 0; i < acon.size(); ++i)

	xor	r12d, r12d
	test	r15d, r15d
	jle	SHORT $LN382@mergeRegio
	xor	ebx, ebx
	npad	7
$LL7@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN203@mergeRegio
	test	rbx, rbx
	js	SHORT $LN204@mergeRegio
	cmp	rbx, r15
	jl	SHORT $LN203@mergeRegio
$LN204@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rax, QWORD PTR acon$[rsp+16]
$LN203@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 629  : 		if (acon[i] == bid)

	cmp	DWORD PTR [rax+rbx*4], ebp
	je	SHORT $LN347@mergeRegio

; 624  : 	
; 625  : 	// Find insertion point on A.
; 626  : 	int insa = -1;
; 627  : 	for (int i = 0; i < acon.size(); ++i)

	inc	r12d
	inc	rbx
	cmp	r12d, r15d
	jl	SHORT $LL7@mergeRegio
$LN382@mergeRegio:
	xor	bl, bl
$LN27@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rax, QWORD PTR acon$[rsp+16]
	test	rax, rax
	je	SHORT $LN385@mergeRegio

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	npad	1
$LN385@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 668  : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN347@mergeRegio:

; 630  : 		{
; 631  : 			insa = i;
; 632  : 			break;
; 633  : 		}
; 634  : 	}
; 635  : 	if (insa == -1)

	cmp	r12d, -1
	je	SHORT $LN382@mergeRegio

; 636  : 		return false;
; 637  : 	
; 638  : 	// Find insertion point on B.
; 639  : 	int insb = -1;
; 640  : 	for (int i = 0; i < bcon.size(); ++i)

	xor	ecx, ecx
	mov	DWORD PTR i$1$[rsp], ecx
	cmp	DWORD PTR [rsi], ecx
	jle	SHORT $LN382@mergeRegio
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	xor	ebx, ebx
$LL10@mergeRegio:

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN191@mergeRegio
	test	rbx, rbx
	js	SHORT $LN192@mergeRegio
	cmp	rbx, QWORD PTR [rsi]
	jl	SHORT $LN191@mergeRegio
$LN192@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ecx, DWORD PTR i$1$[rsp]
$LN191@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 642  : 		if (bcon[i] == aid)

	mov	rax, QWORD PTR [rsi+16]
	cmp	DWORD PTR [rax+rbx*4], r14d
	je	SHORT $LN348@mergeRegio

; 636  : 		return false;
; 637  : 	
; 638  : 	// Find insertion point on B.
; 639  : 	int insb = -1;
; 640  : 	for (int i = 0; i < bcon.size(); ++i)

	inc	ecx
	mov	DWORD PTR i$1$[rsp], ecx
	inc	rbx
	cmp	ecx, DWORD PTR [rsi]
	jl	SHORT $LL10@mergeRegio

; 608  : 		if (reg.floors[i] == n)

	jmp	$LN382@mergeRegio
$LN348@mergeRegio:

; 643  : 		{
; 644  : 			insb = i;
; 645  : 			break;
; 646  : 		}
; 647  : 	}
; 648  : 	if (insb == -1)

	cmp	ecx, -1
	je	$LN382@mergeRegio

; 649  : 		return false;
; 650  : 	
; 651  : 	// Merge neighbours.
; 652  : 	rega.connections.clear();

	mov	QWORD PTR [r13+16], 0

; 653  : 	for (int i = 0, ni = acon.size(); i < ni-1; ++i)

	lea	r14d, DWORD PTR [r15-1]

; 649  : 		return false;
; 650  : 	
; 651  : 	// Merge neighbours.
; 652  : 	rega.connections.clear();

	xor	ebp, ebp

; 653  : 	for (int i = 0, ni = acon.size(); i < ni-1; ++i)

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	test	r14d, r14d
	jle	$LN12@mergeRegio
$LL13@mergeRegio:

; 654  : 		rega.connections.push(acon[(insa+1+i) % ni]);

	lea	eax, DWORD PTR [rbp+1]
	add	eax, r12d
	cdq
	idiv	r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rbx, edx

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN132@mergeRegio
	test	edx, edx
	js	SHORT $LN133@mergeRegio
	cmp	rbx, r15
	jl	SHORT $LN132@mergeRegio
$LN133@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8, 4611686018427387903			; 3fffffffffffffffH
$LN132@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 654  : 		rega.connections.push(acon[(insa+1+i) % ni]);

	mov	rax, QWORD PTR acon$[rsp+16]
	mov	esi, DWORD PTR [rax+rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [r13+16]
	mov	rax, QWORD PTR [r13+24]
	cmp	rcx, rax
	jge	SHORT $LN138@mergeRegio

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [r13+32]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [r13+16], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN11@mergeRegio
	mov	DWORD PTR [rdx], esi

; 207  : 		return;

	jmp	$LN11@mergeRegio
$LN138@mergeRegio:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rbx, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, r8
	jl	SHORT $LN148@mergeRegio

; 226  : 		return RC_SIZE_MAX;

	mov	rbx, rdi
	jmp	SHORT $LN150@mergeRegio
$LN148@mergeRegio:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rbx
	cmovg	rbx, rax
$LN150@mergeRegio:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN155@mergeRegio
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rax
	jle	SHORT $LN155@mergeRegio
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN155@mergeRegio:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN166@mergeRegio

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [r13+32]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [r13+16]
	test	rdx, rdx
	jle	SHORT $LN166@mergeRegio

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL167@mergeRegio:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN165@mergeRegio
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN165@mergeRegio:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL167@mergeRegio
$LN166@mergeRegio:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [r13+16]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN175@mergeRegio
	mov	DWORD PTR [rcx], esi
$LN175@mergeRegio:

; 216  : 	m_size++;

	inc	QWORD PTR [r13+16]

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR [r13+24], rbx

; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [r13+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN180@mergeRegio

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN180@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [r13+32], rdi
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
$LN11@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 653  : 	for (int i = 0, ni = acon.size(); i < ni-1; ++i)

	inc	ebp
	cmp	ebp, r14d
	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	jl	$LL13@mergeRegio
	mov	ecx, DWORD PTR i$1$[rsp]
	mov	rsi, QWORD PTR bcon$1$[rsp]
$LN12@mergeRegio:

; 656  : 	for (int i = 0, ni = bcon.size(); i < ni-1; ++i)

	mov	r15d, DWORD PTR [rsi]
	lea	r14d, DWORD PTR [r15-1]
	xor	ebp, ebp
	test	r14d, r14d
	jle	$LN15@mergeRegio
	mov	r12, 4611686018427387903		; 3fffffffffffffffH
$LL16@mergeRegio:

; 657  : 		rega.connections.push(bcon[(insb+1+i) % ni]);

	lea	eax, DWORD PTR [rbp+1]
	add	eax, ecx
	cdq
	idiv	r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rbx, edx

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN75@mergeRegio
	test	edx, edx
	js	SHORT $LN76@mergeRegio
	cmp	rbx, QWORD PTR [rsi]
	jl	SHORT $LN75@mergeRegio
$LN76@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN75@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 657  : 		rega.connections.push(bcon[(insb+1+i) % ni]);

	mov	rax, QWORD PTR [rsi+16]
	mov	esi, DWORD PTR [rax+rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [r13+16]
	mov	rax, QWORD PTR [r13+24]
	cmp	rcx, rax
	jge	SHORT $LN81@mergeRegio

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [r13+32]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [r13+16], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN14@mergeRegio
	mov	DWORD PTR [rdx], esi

; 207  : 		return;

	jmp	$LN14@mergeRegio
$LN81@mergeRegio:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rbx, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, r12
	jl	SHORT $LN91@mergeRegio

; 226  : 		return RC_SIZE_MAX;

	mov	rbx, rdi
	jmp	SHORT $LN93@mergeRegio
$LN91@mergeRegio:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rbx
	cmovg	rbx, rax
$LN93@mergeRegio:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN98@mergeRegio
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rax
	jle	SHORT $LN98@mergeRegio
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN98@mergeRegio:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN109@mergeRegio

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [r13+32]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [r13+16]
	test	rdx, rdx
	jle	SHORT $LN109@mergeRegio

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	7
$LL110@mergeRegio:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN108@mergeRegio
	mov	eax, DWORD PTR [rcx+r8]
	mov	DWORD PTR [rcx], eax
$LN108@mergeRegio:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL110@mergeRegio
$LN109@mergeRegio:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [r13+16]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN118@mergeRegio
	mov	DWORD PTR [rcx], esi
$LN118@mergeRegio:

; 216  : 	m_size++;

	inc	QWORD PTR [r13+16]

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR [r13+24], rbx

; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [r13+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN123@mergeRegio

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN123@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [r13+32], rdi
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN14@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 656  : 	for (int i = 0, ni = bcon.size(); i < ni-1; ++i)

	inc	ebp
	cmp	ebp, r14d
	mov	ecx, DWORD PTR i$1$[rsp]
	mov	rsi, QWORD PTR bcon$1$[rsp]
	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jl	$LL16@mergeRegio
$LN15@mergeRegio:

; 658  : 	
; 659  : 	removeAdjacentNeighbours(rega);

	mov	rcx, r13
	call	?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z ; removeAdjacentNeighbours

; 660  : 	
; 661  : 	for (int j = 0; j < regb.floors.size(); ++j)

	xor	r15d, r15d
	mov	r12, QWORD PTR regb$GSCopy$1$[rsp]
	cmp	DWORD PTR [r12+40], r15d
	jle	$LN18@mergeRegio
	xor	r14d, r14d
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	npad	7
$LL19@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN51@mergeRegio
	test	r14, r14
	js	SHORT $LN384@mergeRegio
	cmp	r14, QWORD PTR [r12+40]
	jl	SHORT $LN51@mergeRegio
$LN384@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN51@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 662  : 		addUniqueFloorRegion(rega, regb.floors[j]);

	mov	rax, QWORD PTR [r12+56]
	mov	ebp, DWORD PTR [rax+r14*4]

; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)

	xor	esi, esi
	xor	ebx, ebx
	cmp	DWORD PTR [r13+40], ebx
	jle	SHORT $LN56@mergeRegio
$LL57@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN67@mergeRegio
	test	rbx, rbx
	js	SHORT $LN68@mergeRegio
	cmp	rbx, QWORD PTR [r13+40]
	jl	SHORT $LN67@mergeRegio
$LN68@mergeRegio:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN67@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 608  : 		if (reg.floors[i] == n)

	mov	rax, QWORD PTR [r13+56]
	cmp	DWORD PTR [rax+rbx*4], ebp
	je	SHORT $LN17@mergeRegio

; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR [r13+40]
	jl	SHORT $LL57@mergeRegio
$LN56@mergeRegio:

; 609  : 			return;
; 610  : 	reg.floors.push(n);

	mov	edx, ebp
	lea	rcx, QWORD PTR [r13+40]
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN17@mergeRegio:

; 660  : 	
; 661  : 	for (int j = 0; j < regb.floors.size(); ++j)

	inc	r15d
	inc	r14
	cmp	r15d, DWORD PTR [r12+40]
	jl	$LL19@mergeRegio
$LN18@mergeRegio:

; 663  : 	rega.spanCount += regb.spanCount;

	mov	eax, DWORD PTR [r12]
	add	DWORD PTR [r13], eax

; 664  : 	regb.spanCount = 0;

	mov	DWORD PTR [r12], 0

; 665  : 	regb.connections.resize(0);

	xor	edx, edx
	mov	rcx, QWORD PTR bcon$1$[rsp]
	call	?resize@rcIntArray@@QEAAXH@Z		; rcIntArray::resize

; 666  : 
; 667  : 	return true;

	mov	bl, 1
	jmp	$LN27@mergeRegio
	int	3
?mergeRegions@@YA_NAEAUrcRegion@@0@Z ENDP		; mergeRegions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
bcon$1$ = 40
regb$GSCopy$1$ = 48
acon$ = 56
__$ArrayPad$ = 80
rega$ = 160
regb$ = 168
?dtor$0@?0??mergeRegions@@YA_NAEAUrcRegion@@0@Z@4HA PROC ; `mergeRegions'::`1'::dtor$0
	lea	rcx, QWORD PTR acon$[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$0@?0??mergeRegions@@YA_NAEAUrcRegion@@0@Z@4HA ENDP ; `mergeRegions'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z
_TEXT	SEGMENT
reg$ = 48
?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z PROC	; isRegionConnectedToBorder, COMDAT

; 671  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 672  : 	// Region is connected to border if
; 673  : 	// one of the neighbours is null id.
; 674  : 	for (int i = 0; i < reg.connections.size(); ++i)

	xor	esi, esi
	mov	rdi, rcx
	cmp	DWORD PTR [rcx+16], esi
	jle	SHORT $LN3@isRegionCo
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ebx, esi
$LL4@isRegionCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN14@isRegionCo
	test	rbx, rbx
	js	SHORT $LN15@isRegionCo
	cmp	rbx, QWORD PTR [rdi+16]
	jl	SHORT $LN14@isRegionCo
$LN15@isRegionCo:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN14@isRegionCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 676  : 		if (reg.connections[i] == 0)

	mov	rax, QWORD PTR [rdi+32]
	cmp	DWORD PTR [rax+rbx*4], 0
	je	SHORT $LN18@isRegionCo

; 672  : 	// Region is connected to border if
; 673  : 	// one of the neighbours is null id.
; 674  : 	for (int i = 0; i < reg.connections.size(); ++i)

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR [rdi+16]
	jl	SHORT $LL4@isRegionCo
$LN3@isRegionCo:

; 677  : 			return true;
; 678  : 	}
; 679  : 	return false;

	xor	al, al

; 680  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@isRegionCo:
	mov	rbx, QWORD PTR [rsp+48]
	mov	al, 1
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?isRegionConnectedToBorder@@YA_NAEBUrcRegion@@@Z ENDP	; isRegionConnectedToBorder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z
_TEXT	SEGMENT
chf$ = 8
srcReg$ = 16
x$ = 24
y$ = 32
i$ = 40
dir$ = 48
?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z PROC ; isSolidEdge, COMDAT

; 684  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rax, QWORD PTR [rcx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 684  : {

	mov	rdi, rcx

; 685  : 	const rcCompactSpan& s = chf.spans[i];

	movsxd	r11, DWORD PTR i$[rsp]
	mov	rbx, rdx

; 686  : 	unsigned short r = 0;

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, DWORD PTR [rax+r11*8+4]
	mov	eax, DWORD PTR dir$[rsp]
	and	r10d, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [rax+rax*2]
	add	ecx, ecx
	shr	r10d, cl
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 687  : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN2@isSolidEdg
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	and	eax, 3
	lea	rdx, OFFSET FLAT:__ImageBase
	lea	rcx, QWORD PTR [rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 690  : 		const int ay = y + rcGetDirOffsetY(dir);

	mov	eax, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+rdx]
	add	eax, r9d

; 691  : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR [rdi]
	add	eax, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+rdx]
	add	eax, r8d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r10d

; 692  : 		r = srcReg[ai];

	movzx	edx, WORD PTR [rbx+rdx*2]
$LN2@isSolidEdg:

; 693  : 	}
; 694  : 	if (r == srcReg[i])

	cmp	dx, WORD PTR [rbx+r11*2]

; 695  : 		return false;
; 696  : 	return true;
; 697  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	setne	al
	ret	0
?isSolidEdge@@YA_NAEAUrcCompactHeightfield@@PEBGHHHH@Z ENDP ; isSolidEdge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z
_TEXT	SEGMENT
curReg$1$ = 32
y$1$ = 36
x$1$ = 40
starti$1$ = 44
startDir$1$ = 48
$T1 = 56
x$ = 112
y$ = 120
i$ = 128
dir$ = 136
chf$ = 144
srcReg$ = 152
cont$ = 160
?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z PROC ; walkContour, COMDAT

; 703  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rbp, QWORD PTR chf$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 708  : 	unsigned short curReg = 0;

	xor	r12d, r12d
	mov	rbx, QWORD PTR cont$[rsp]
	mov	esi, ecx
	movsxd	r15, r8d
	mov	edi, edx
	movsxd	r14, r9d
	movzx	r10d, r12w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rax, QWORD PTR [rbp+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 709  : 	if (rcGetCon(ss, dir) != RC_NOT_CONNECTED)

	lea	r9, OFFSET FLAT:__ImageBase
	mov	DWORD PTR x$1$[rsp], ecx
	mov	DWORD PTR y$1$[rsp], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	lea	rdx, QWORD PTR [rbp+64]
	lea	ecx, DWORD PTR [r14+r14*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 704  : 	int startDir = dir;

	mov	DWORD PTR startDir$1$[rsp], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [rax+r15*8+4]
	add	ecx, ecx
	and	r8d, 16777215				; 00ffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 705  : 	int starti = i;

	mov	DWORD PTR starti$1$[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r8d, cl
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 708  : 	unsigned short curReg = 0;

	mov	WORD PTR curReg$1$[rsp], r12w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	QWORD PTR $T1[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 709  : 	if (rcGetCon(ss, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN189@walkContou

; 714  : 		curReg = srcReg[ai];

	mov	r10, QWORD PTR srcReg$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	mov	rax, r14
	and	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 712  : 		const int ay = y + rcGetDirOffsetY(dir);

	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[r9+rax*4]
	add	ecx, edi

; 713  : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(ss, dir);

	imul	ecx, DWORD PTR [rbp]
	add	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[r9+rax*4]
	mov	rax, QWORD PTR [rdx]
	add	ecx, esi
	movsxd	rcx, ecx
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 714  : 		curReg = srcReg[ai];

	movzx	r10d, WORD PTR [r10+rdx*2]
	mov	WORD PTR curReg$1$[rsp], r10w
	jmp	SHORT $LN177@walkContou
$LN189@walkContou:
	mov	QWORD PTR $T1[rsp], rdx
$LN177@walkContou:

; 715  : 	}
; 716  : 	cont.push(curReg);

	movzx	edx, r10w
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 717  : 			
; 718  : 	int iter = 0;
; 719  : 	while (++iter < 40000)

	mov	r13d, 1
	npad	12
$LL2@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rax, QWORD PTR [rbp+72]
	lea	ecx, DWORD PTR [r14+r14*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 687  : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	mov	r11, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	add	ecx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 721  : 		const rcCompactSpan& s = chf.spans[i];

	movsxd	r10, r15d

; 686  : 	unsigned short r = 0;

	movzx	edx, r12w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	movsxd	r9, r14d
	mov	r8d, DWORD PTR [rax+r10*8+4]
	and	r8d, 16777215				; 00ffffffH
	shr	r8d, cl
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 687  : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN179@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	mov	rax, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 690  : 		const int ay = y + rcGetDirOffsetY(dir);

	lea	rdx, OFFSET FLAT:__ImageBase
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	and	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 690  : 		const int ay = y + rcGetDirOffsetY(dir);

	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rdx+rax*4]
	add	ecx, edi

; 691  : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	imul	ecx, DWORD PTR [rbp]
	add	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rdx+rax*4]
	mov	rax, QWORD PTR [r11]
	add	ecx, esi
	movsxd	rcx, ecx
	mov	edx, DWORD PTR [rax+rcx*4]

; 692  : 		r = srcReg[ai];

	mov	rcx, QWORD PTR srcReg$[rsp]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d
	movzx	edx, WORD PTR [rcx+rdx*2]
$LN179@walkContou:

; 693  : 	}
; 694  : 	if (r == srcReg[i])

	mov	rax, QWORD PTR srcReg$[rsp]
	cmp	dx, WORD PTR [rax+r10*2]
	jne	SHORT $LN24@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	and	r9d, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 745  : 			const int nx = x + rcGetDirOffsetX(dir);

	lea	rcx, OFFSET FLAT:__ImageBase
	add	esi, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+r9*4]

; 746  : 			const int ny = y + rcGetDirOffsetY(dir);

	add	edi, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+r9*4]
	mov	DWORD PTR x$1$[rsp], esi
	mov	DWORD PTR y$1$[rsp], edi

; 747  : 			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	$LN5@walkContou

; 748  : 			{
; 749  : 				const rcCompactCell& nc = chf.cells[nx+ny*chf.width];

	mov	eax, edi
	imul	eax, DWORD PTR [rbp]
	add	eax, esi
	movsxd	rcx, eax

; 750  : 				ni = (int)nc.index + rcGetCon(s, dir);

	mov	rax, QWORD PTR [r11]
	mov	r15d, DWORD PTR [rax+rcx*4]

; 751  : 			}
; 752  : 			if (ni == -1)
; 753  : 			{
; 754  : 				// Should not happen.
; 755  : 				return;
; 756  : 			}
; 757  : 			x = nx;
; 758  : 			y = ny;
; 759  : 			i = ni;
; 760  : 			dir = (dir+3) & 0x3;	// Rotate CCW

	mov	eax, 3
	and	r15d, 16777215				; 00ffffffH
	add	r15d, r8d
	jmp	$LN12@walkContou
$LN24@walkContou:

; 722  : 		
; 723  : 		if (isSolidEdge(chf, srcReg, x, y, i, dir))
; 724  : 		{
; 725  : 			// Choose the edge corner
; 726  : 			unsigned short r = 0;

	movzx	eax, r12w

; 727  : 			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN188@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	and	r9d, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 730  : 				const int ay = y + rcGetDirOffsetY(dir);

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+r9*4]
	add	eax, edi

; 731  : 				const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR [rbp]
	add	eax, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+r9*4]
	add	eax, esi
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r11]
	mov	edx, DWORD PTR [rax+rcx*4]

; 732  : 				r = srcReg[ai];

	mov	rcx, QWORD PTR srcReg$[rsp]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d
	movzx	eax, WORD PTR [rcx+rdx*2]
$LN188@walkContou:

; 733  : 			}
; 734  : 			if (r != curReg)

	cmp	ax, WORD PTR curReg$1$[rsp]
	je	$LN87@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 736  : 				curReg = r;

	mov	WORD PTR curReg$1$[rsp], ax

; 737  : 				cont.push(curReg);

	movzx	ebp, ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN88@walkContou

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN194@walkContou
	mov	DWORD PTR [rdx], ebp

; 207  : 		return;

	jmp	$LN194@walkContou
$LN88@walkContou:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN98@walkContou

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN100@walkContou
$LN98@walkContou:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN100@walkContou:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN105@walkContou
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN105@walkContou
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN105@walkContou:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN116@walkContou

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN116@walkContou

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL117@walkContou:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN115@walkContou
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN115@walkContou:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL117@walkContou
$LN116@walkContou:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN125@walkContou
	mov	DWORD PTR [rcx], ebp
$LN125@walkContou:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN130@walkContou

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN130@walkContou:
	mov	edi, DWORD PTR y$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
	mov	esi, DWORD PTR x$1$[rsp]
$LN194@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 740  : 			dir = (dir+1) & 0x3;  // Rotate CW

	mov	rbp, QWORD PTR chf$[rsp]
$LN87@walkContou:
	mov	eax, 1
$LN12@walkContou:

; 761  : 		}
; 762  : 		
; 763  : 		if (starti == i && startDir == dir)

	add	r14d, eax
	and	r14d, 3
	cmp	DWORD PTR starti$1$[rsp], r15d
	jne	SHORT $LN17@walkContou
	cmp	DWORD PTR startDir$1$[rsp], r14d
	je	SHORT $LN169@walkContou
$LN17@walkContou:

; 717  : 			
; 718  : 	int iter = 0;
; 719  : 	while (++iter < 40000)

	inc	r13d
	cmp	r13d, 40000				; 00009c40H
	jl	$LL2@walkContou
$LN169@walkContou:

; 764  : 		{
; 765  : 			break;
; 766  : 		}
; 767  : 	}
; 768  : 
; 769  : 	// Remove adjacent duplicates.
; 770  : 	if (cont.size() > 1)

	mov	ecx, DWORD PTR [rbx]
	cmp	ecx, 1
	jle	$LN5@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 339  : 		m_impl.pop_back();

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r14, r12
	npad	4
$LL4@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 774  : 			int nj = (j+1) % cont.size();

	lea	eax, DWORD PTR [r12+1]
	cdq
	idiv	ecx
	movsxd	rdi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN143@walkContou
	test	r14, r14
	js	SHORT $LN190@walkContou
	cmp	r14, QWORD PTR [rbx]
	jl	SHORT $LN143@walkContou
$LN190@walkContou:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN143@walkContou:
	mov	rax, QWORD PTR [rbx+16]
	lea	rbp, QWORD PTR [rax+r14*4]
	test	r9, r9
	je	SHORT $LN151@walkContou
	test	rdi, rdi
	js	SHORT $LN191@walkContou
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN151@walkContou
$LN191@walkContou:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN151@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 775  : 			if (cont[j] == cont[nj])

	mov	rax, QWORD PTR [rbx+16]
	mov	ecx, DWORD PTR [rax+rdi*4]
	cmp	DWORD PTR [rbp], ecx
	jne	$LN19@walkContou

; 776  : 			{
; 777  : 				for (int k = j; k < cont.size()-1; ++k)

	mov	eax, DWORD PTR [rbx]
	mov	esi, r12d
	dec	eax
	mov	rdi, r14
	cmp	r12d, eax
	jge	SHORT $LN8@walkContou
	npad	4
$LL9@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN51@walkContou
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN193@walkContou
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN51@walkContou
$LN193@walkContou:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN51@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 778  : 					cont[k] = cont[k+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	ebp, DWORD PTR [rax+rdi*4+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN59@walkContou
	test	rdi, rdi
	js	SHORT $LN192@walkContou
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN59@walkContou
$LN192@walkContou:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN59@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 778  : 					cont[k] = cont[k+1];

	mov	rax, QWORD PTR [rbx+16]
	inc	esi
	mov	DWORD PTR [rax+rdi*4], ebp
	inc	rdi
	mov	eax, DWORD PTR [rbx]
	dec	eax
	cmp	esi, eax
	jl	SHORT $LL9@walkContou
$LN8@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	r9, r9
	je	SHORT $LN77@walkContou
	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN67@walkContou
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN67@walkContou:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	test	r9, r9
	je	SHORT $LN77@walkContou
	cmp	QWORD PTR [rbx], 0
	jg	SHORT $LN72@walkContou
	mov	r8d, 143				; 0000008fH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0L@GHLCMNGA@m_size?5?$DO?50@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN72@walkContou:

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	r9, r9
	je	SHORT $LN77@walkContou
	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN77@walkContou
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN77@walkContou:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	dec	QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 780  : 			}

	jmp	SHORT $LN232@walkContou
$LN19@walkContou:

; 781  : 			else
; 782  : 				++j;

	inc	r12d
	inc	r14
$LN232@walkContou:

; 771  : 	{
; 772  : 		for (int j = 0; j < cont.size(); )

	mov	rcx, QWORD PTR [rbx]
	cmp	r12d, ecx
	jl	$LL4@walkContou
$LN5@walkContou:

; 783  : 		}
; 784  : 	}
; 785  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z ENDP ; walkContour
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z
_TEXT	SEGMENT
mergeCount$1$ = 64
i$1$ = 64
x$1$ = 64
oldId$1$ = 68
connectsToBorder$1$ = 68
y$1$ = 68
j$1$ = 72
h$1$ = 72
trace$3$ = 80
tv5396 = 80
stack$3$ = 88
c$1$ = 88
spanCount$1$ = 96
w$1$ = 96
srcReg$GSCopy$1$ = 104
chf$GSCopy$1$ = 112
count$1$ = 120
$T1 = 128
$T2 = 128
tv5395 = 128
$T3 = 136
tv5414 = 136
minRegionArea$1$ = 144
mergeRegionSize$1$ = 148
$T4 = 152
tv5394 = 160
maxRegionId$GSCopy$1$ = 168
overlaps$GSCopy$1$ = 176
$T5 = 184
regions$ = 248
stack$ = 272
trace$ = 296
__$ArrayPad$ = 320
ctx$ = 400
minRegionArea$ = 408
mergeRegionSize$ = 416
maxRegionId$ = 424
chf$ = 432
srcReg$ = 440
overlaps$ = 448
?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z PROC ; mergeAndFilterRegions, COMDAT

; 792  : {

	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-80]
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR maxRegionId$GSCopy$1$[rbp-256], r9
	mov	DWORD PTR mergeRegionSize$1$[rbp-256], r8d
	mov	DWORD PTR minRegionArea$1$[rbp-256], edx
	mov	rbx, rcx
	mov	r15, QWORD PTR chf$[rbp-256]
	mov	QWORD PTR chf$GSCopy$1$[rsp], r15
	mov	r11, QWORD PTR srcReg$[rbp-256]
	mov	QWORD PTR srcReg$GSCopy$1$[rsp], r11
	mov	rax, QWORD PTR overlaps$[rbp-256]
	mov	QWORD PTR overlaps$GSCopy$1$[rbp-256], rax

; 793  : 	const int w = chf.width;

	movsxd	rsi, DWORD PTR [r15]
	mov	DWORD PTR w$1$[rsp], esi

; 794  : 	const int h = chf.height;

	mov	edi, DWORD PTR [r15+4]
	mov	DWORD PTR h$1$[rsp], edi

; 795  : 	
; 796  : 	const int nreg = maxRegionId+1;

	movzx	r12d, WORD PTR [r9]
	inc	r12d
	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	movdqu	XMMWORD PTR regions$[rbp-256], xmm1
	xor	r14d, r14d
	mov	QWORD PTR $T4[rbp-256], r14
	mov	r13d, r14d
	mov	QWORD PTR regions$[rbp-240], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 798  : 	if (!regions.reserve(nreg)) {

	mov	eax, r12d
	mov	QWORD PTR count$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, r12d
	lea	rcx, QWORD PTR regions$[rbp-256]
	call	?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z ; rcVectorBase<rcRegion,1>::allocate_and_copy

; 176  : 	if (!new_data) {

	test	rax, rax
	jne	SHORT $LN750@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 799  : 		ctx->log(RC_LOG_ERROR, "mergeAndFilterRegions: Out of memory 'regions' (%d).", nreg);

	mov	r9d, r12d
	lea	r8, OFFSET FLAT:??_C@_0DF@FMOHEMOG@mergeAndFilterRegions?3?5Out?5of?5m@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, rbx
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	dil, dil
	jmp	$LN1126@mergeAndFi
$LN750@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR regions$[rbp-240], rax

; 182  : 	m_cap = count;

	mov	r13d, r12d
	mov	QWORD PTR regions$[rbp-248], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 804  : 	for (int i = 0; i < nreg; ++i)

	mov	ebx, r14d
	test	r12d, r12d
	je	SHORT $LN3@mergeAndFi
$LL4@mergeAndFi:

; 524  : 		spanCount(0),

	mov	DWORD PTR $T5[rbp-256], r14d

; 525  : 		id(i),

	mov	WORD PTR $T5[rbp-252], bx

; 526  : 		areaType(0),

	mov	DWORD PTR $T5[rbp-250], 0

; 527  : 		remap(false),
; 528  : 		visited(false),
; 529  : 		overlap(false),
; 530  : 		connectsToBorder(false),

	mov	BYTE PTR $T5[rbp-246], 0

; 531  : 		ymin(0xffff),

	mov	DWORD PTR $T5[rbp-244], 65535		; 0000ffffH
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	movdqu	XMMWORD PTR $T5[rbp-240], xmm0
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR $T5[rbp-224], xmm1
	movdqu	XMMWORD PTR $T5[rbp-208], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 805  : 		regions.push_back(rcRegion((unsigned short) i));

	lea	rdx, QWORD PTR $T5[rbp-256]
	lea	rcx, QWORD PTR regions$[rbp-256]
	call	?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z ; rcVectorBase<rcRegion,1>::push_back
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR $T5[rbp-200]
	test	rcx, rcx
	je	SHORT $LN712@mergeAndFi

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN712@mergeAndFi:

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR $T5[rbp-224]
	test	rcx, rcx
	je	SHORT $LN728@mergeAndFi

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN728@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 804  : 	for (int i = 0; i < nreg; ++i)

	inc	ebx
	cmp	ebx, r12d
	jl	SHORT $LL4@mergeAndFi
	mov	r15, QWORD PTR chf$GSCopy$1$[rsp]
$LN3@mergeAndFi:

; 806  : 	
; 807  : 	// Find edge of a region and find connections around the contour.
; 808  : 	for (int y = 0; y < h; ++y)

	mov	eax, r14d
	mov	DWORD PTR y$1$[rsp], eax
	mov	r9, QWORD PTR regions$[rbp-256]
	test	edi, edi
	jle	$LN6@mergeAndFi

; 691  : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	mov	rcx, r14
	mov	QWORD PTR tv5395[rbp-256], rcx
	mov	rdx, rsi
	shl	rdx, 2
	mov	QWORD PTR tv5394[rbp-256], rdx
	mov	r8d, DWORD PTR h$1$[rsp]
	npad	13
$LL7@mergeAndFi:

; 809  : 	{
; 810  : 		for (int x = 0; x < w; ++x)

	mov	edi, r14d
	mov	DWORD PTR x$1$[rsp], r14d
	test	esi, esi
	jle	$LN5@mergeAndFi
	mov	QWORD PTR tv5396[rsp], rcx
	npad	11
$LL10@mergeAndFi:

; 811  : 		{
; 812  : 			const rcCompactCell& c = chf.cells[x+y*w];

	mov	rbx, QWORD PTR [r15+64]
	add	rbx, rcx
	mov	QWORD PTR c$1$[rsp], rbx

; 813  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	ecx, DWORD PTR [rbx]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	mov	r13d, eax
	mov	QWORD PTR tv5414[rbp-256], r13
	shr	ecx, 24
	lea	r15d, DWORD PTR [rcx+rax]
	cmp	r13, r15
	jae	$LN8@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	r14d, r13d
	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
	npad	12
$LL13@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 815  : 				unsigned short r = srcReg[i];

	movzx	esi, WORD PTR [rcx+r14*2]

; 816  : 				if (r == 0 || r >= nreg)

	test	si, si
	je	$LN11@mergeAndFi
	cmp	esi, r12d
	jae	$LN11@mergeAndFi

; 817  : 					continue;
; 818  : 				
; 819  : 				rcRegion& reg = regions[r];

	mov	edi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN470@mergeAndFi
	cmp	rsi, r9
	jl	SHORT $LN470@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN470@mergeAndFi:
	shl	rdi, 6
	add	rdi, QWORD PTR regions$[rbp-240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 820  : 				reg.spanCount++;

	inc	DWORD PTR [rdi]

; 821  : 				
; 822  : 				// Update floors.
; 823  : 				for (int j = (int)c.index; j < ni; ++j)

	mov	ebx, DWORD PTR [rbx]
	and	ebx, 16777215				; 00ffffffH
	cmp	rbx, r15
	jae	SHORT $LN15@mergeAndFi
	mov	r13, QWORD PTR srcReg$GSCopy$1$[rsp]
	npad	4
$LL16@mergeAndFi:

; 824  : 				{
; 825  : 					if (i == j) continue;

	cmp	r14, rbx
	je	SHORT $LN14@mergeAndFi

; 826  : 					unsigned short floorId = srcReg[j];

	movzx	eax, WORD PTR [r13+rbx*2]

; 827  : 					if (floorId == 0 || floorId >= nreg)

	test	ax, ax
	je	SHORT $LN14@mergeAndFi
	mov	edx, eax
	cmp	eax, r12d
	jae	SHORT $LN14@mergeAndFi

; 828  : 						continue;
; 829  : 					if (floorId == r)

	cmp	ax, si
	jne	SHORT $LN64@mergeAndFi

; 830  : 						reg.overlap = true;

	mov	BYTE PTR [rdi+9], 1
$LN64@mergeAndFi:

; 831  : 					addUniqueFloorRegion(reg, floorId);

	mov	rcx, rdi
	call	?addUniqueFloorRegion@@YAXAEAUrcRegion@@H@Z ; addUniqueFloorRegion
$LN14@mergeAndFi:

; 821  : 				
; 822  : 				// Update floors.
; 823  : 				for (int j = (int)c.index; j < ni; ++j)

	inc	rbx
	cmp	rbx, r15
	jl	SHORT $LL16@mergeAndFi
	mov	r13, QWORD PTR tv5414[rbp-256]
$LN15@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 342  : 	int size() const { return static_cast<int>(m_impl.size()); }

	lea	rbx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 835  : 				if (reg.connections.size() > 0)

	cmp	DWORD PTR [rbx], 0
	jg	$LN1109@mergeAndFi

; 836  : 					continue;
; 837  : 				
; 838  : 				reg.areaType = chf.areas[i];

	mov	rdx, QWORD PTR chf$GSCopy$1$[rsp]
	mov	rax, QWORD PTR [rdx+88]
	movzx	ecx, BYTE PTR [r14+rax]
	mov	BYTE PTR [rdi+6], cl

; 839  : 				
; 840  : 				// Check if this cell is next to a border.
; 841  : 				int ndir = -1;
; 842  : 				for (int dir = 0; dir < 4; ++dir)

	xor	ecx, ecx
	mov	r9d, ecx

; 694  : 	if (r == srcReg[i])

	mov	r11, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	r11d, WORD PTR [r11+r14*2]
	mov	rax, QWORD PTR [rdx+72]
	mov	r10d, DWORD PTR [rax+r14*8+4]
	and	r10d, 16777215				; 00ffffffH
$LL19@mergeAndFi:

; 677  : 			return true;
; 678  : 	}
; 679  : 	return false;
; 680  : }
; 681  : 
; 682  : static bool isSolidEdge(rcCompactHeightfield& chf, const unsigned short* srcReg,
; 683  : 						int x, int y, int i, int dir)
; 684  : {
; 685  : 	const rcCompactSpan& s = chf.spans[i];
; 686  : 	unsigned short r = 0;

	movzx	eax, cx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [r9+r9*2]
	add	ecx, ecx

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, r10d
	shr	r8d, cl
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 687  : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	mov	edi, DWORD PTR x$1$[rsp]
	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN1110@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	mov	eax, r9d
	and	eax, 3
	lea	rcx, QWORD PTR [rax*4]
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 689  : 		const int ax = x + rcGetDirOffsetX(dir);

	add	edx, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 690  : 		const int ay = y + rcGetDirOffsetY(dir);

	mov	esi, DWORD PTR y$1$[rsp]
	add	ecx, esi

; 691  : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	mov	rax, QWORD PTR chf$GSCopy$1$[rsp]
	imul	ecx, DWORD PTR [rax]
	add	ecx, edx
	movsxd	rcx, ecx
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 692  : 		r = srcReg[ai];

	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
	movzx	eax, WORD PTR [rcx+rdx*2]

; 687  : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	jmp	SHORT $LN319@mergeAndFi
$LN1110@mergeAndFi:
	mov	esi, DWORD PTR y$1$[rsp]
	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
$LN319@mergeAndFi:

; 693  : 	}
; 694  : 	if (r == srcReg[i])

	cmp	ax, r11w
	jne	SHORT $LN855@mergeAndFi

; 839  : 				
; 840  : 				// Check if this cell is next to a border.
; 841  : 				int ndir = -1;
; 842  : 				for (int dir = 0; dir < 4; ++dir)

	inc	r9d
	cmp	r9d, 4
	jge	SHORT $LN1112@mergeAndFi
	xor	ecx, ecx
	jmp	$LL19@mergeAndFi
$LN855@mergeAndFi:

; 843  : 				{
; 844  : 					if (isSolidEdge(chf, srcReg, x, y, i, dir))
; 845  : 					{
; 846  : 						ndir = dir;
; 847  : 						break;
; 848  : 					}
; 849  : 				}
; 850  : 				
; 851  : 				if (ndir != -1)

	cmp	r9d, -1
	je	SHORT $LN1112@mergeAndFi

; 852  : 				{
; 853  : 					// The cell is at border.
; 854  : 					// Walk around the contour to find all the neighbours.
; 855  : 					walkContour(x, y, i, ndir, chf, srcReg, reg.connections);

	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+40], rcx
	mov	rax, QWORD PTR chf$GSCopy$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, r13d
	mov	edx, esi
	mov	ecx, edi
	call	?walkContour@@YAXHHHHAEAUrcCompactHeightfield@@PEBGAEAVrcIntArray@@@Z ; walkContour

; 835  : 				if (reg.connections.size() > 0)

	jmp	SHORT $LN1129@mergeAndFi
$LN1109@mergeAndFi:
	mov	edi, DWORD PTR x$1$[rsp]
$LN1129@mergeAndFi:

; 813  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rcx, QWORD PTR srcReg$GSCopy$1$[rsp]
$LN1112@mergeAndFi:
	mov	r9, QWORD PTR regions$[rbp-256]
	mov	rbx, QWORD PTR c$1$[rsp]
$LN11@mergeAndFi:
	inc	r13d
	mov	QWORD PTR tv5414[rbp-256], r13
	inc	r14
	cmp	r14, r15
	jl	$LL13@mergeAndFi
	mov	esi, DWORD PTR w$1$[rsp]
$LN8@mergeAndFi:

; 809  : 	{
; 810  : 		for (int x = 0; x < w; ++x)

	inc	edi
	mov	DWORD PTR x$1$[rsp], edi
	mov	rcx, QWORD PTR tv5396[rsp]
	add	rcx, 4
	mov	QWORD PTR tv5396[rsp], rcx
	cmp	edi, esi
	mov	r15, QWORD PTR chf$GSCopy$1$[rsp]
	jl	$LL10@mergeAndFi
	mov	eax, DWORD PTR y$1$[rsp]
	mov	rcx, QWORD PTR tv5395[rbp-256]
	mov	rdx, QWORD PTR tv5394[rbp-256]
	mov	r8d, DWORD PTR h$1$[rsp]
	xor	r14d, r14d
$LN5@mergeAndFi:

; 806  : 	
; 807  : 	// Find edge of a region and find connections around the contour.
; 808  : 	for (int y = 0; y < h; ++y)

	inc	eax
	mov	DWORD PTR y$1$[rsp], eax
	add	rcx, rdx
	mov	QWORD PTR tv5395[rbp-256], rcx
	cmp	eax, r8d
	jl	$LL7@mergeAndFi
	mov	r13, QWORD PTR count$1$[rsp]
$LN6@mergeAndFi:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR stack$[rbp-256], xmm0
	mov	QWORD PTR stack$[rbp-240], rax

; 856  : 				}
; 857  : 			}
; 858  : 		}
; 859  : 	}
; 860  : 
; 861  : 	// Remove too small regions.
; 862  : 	rcIntArray stack(32);

	lea	edx, QWORD PTR [rax+32]
	lea	rcx, QWORD PTR stack$[rbp-256]
	call	??0rcIntArray@@QEAA@H@Z			; rcIntArray::rcIntArray
	npad	1
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR trace$[rbp-256], xmm0
	mov	QWORD PTR trace$[rbp-240], rax

; 863  : 	rcIntArray trace(32);

	lea	edx, QWORD PTR [rax+32]
	lea	rcx, QWORD PTR trace$[rbp-256]
	call	??0rcIntArray@@QEAA@H@Z			; rcIntArray::rcIntArray
	npad	1

; 856  : 				}
; 857  : 			}
; 858  : 		}
; 859  : 	}
; 860  : 
; 861  : 	// Remove too small regions.
; 862  : 	rcIntArray stack(32);

	xor	r9d, r9d
	mov	r8d, r9d
	mov	DWORD PTR i$1$[rsp], r9d

; 864  : 	for (int i = 0; i < nreg; ++i)

	mov	r14, 4611686018427387903		; 3fffffffffffffffH
	mov	r10, 9223372036854775807		; 7fffffffffffffffH
	mov	r11, 2305843009213693951		; 1fffffffffffffffH
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	r13, r13
	je	$LL33@mergeAndFi
	mov	ecx, r9d
	mov	QWORD PTR $T3[rbp-256], rcx
	mov	r12, QWORD PTR stack$[rbp-248]
	mov	QWORD PTR stack$3$[rsp], r12
	mov	rbx, QWORD PTR trace$[rbp-248]
	mov	QWORD PTR trace$3$[rsp], rbx
	mov	rdi, QWORD PTR regions$[rbp-240]
	jmp	SHORT $LN22@mergeAndFi
	npad	3
$LL1125@mergeAndFi:
	mov	r10, 9223372036854775807		; 7fffffffffffffffH
	mov	r11, 2305843009213693951		; 1fffffffffffffffH
$LN22@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN476@mergeAndFi
	cmp	rcx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN476@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rcx, QWORD PTR $T3[rbp-256]
	mov	r8d, DWORD PTR i$1$[rsp]
	xor	r9d, r9d
	mov	r10, 9223372036854775807		; 7fffffffffffffffH
	mov	r11, 2305843009213693951		; 1fffffffffffffffH
$LN476@mergeAndFi:
	shl	rcx, 6
	add	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 867  : 		if (reg.id == 0 || (reg.id & RC_BORDER_REG))

	movzx	edx, WORD PTR [rcx+4]
	test	dx, dx
	je	$LN20@mergeAndFi
	js	$LN20@mergeAndFi

; 868  : 			continue;                       
; 869  : 		if (reg.spanCount == 0)

	cmp	DWORD PTR [rcx], 0
	je	$LN20@mergeAndFi

; 870  : 			continue;
; 871  : 		if (reg.visited)

	cmp	BYTE PTR [rcx+8], 0
	jne	$LN20@mergeAndFi

; 872  : 			continue;
; 873  : 		
; 874  : 		// Count the total size of all the connected regions.
; 875  : 		// Also keep track of the regions connects to a tile border.
; 876  : 		bool connectsToBorder = false;

	xor	dl, dl
	mov	BYTE PTR connectsToBorder$1$[rsp], dl

; 877  : 		int spanCount = 0;

	mov	r15d, r9d

; 878  : 		stack.clear();

	mov	QWORD PTR stack$[rbp-256], r9

; 879  : 		trace.clear();

	mov	rsi, r9
	mov	QWORD PTR trace$[rbp-256], r9

; 880  : 
; 881  : 		reg.visited = true;

	mov	BYTE PTR [rcx+8], 1

; 882  : 		stack.push(i);

	test	r12, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	jle	SHORT $LN651@mergeAndFi

; 206  : 		construct(m_data + m_size++, value);

	mov	r14d, 1
	mov	QWORD PTR stack$[rbp-256], r14

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	rdi, QWORD PTR stack$[rbp-240]
	test	rdi, rdi
	je	$LN23@mergeAndFi
	mov	DWORD PTR [rdi], r8d

; 207  : 		return;

	jmp	$LN23@mergeAndFi
$LN651@mergeAndFi:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdx, QWORD PTR [r12+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	r12, r14
	jl	SHORT $LN661@mergeAndFi

; 226  : 		return RC_SIZE_MAX;

	mov	r12, r10
	mov	QWORD PTR stack$3$[rsp], r10
	jmp	SHORT $LN663@mergeAndFi
$LN661@mergeAndFi:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rcx, QWORD PTR [r12+r12]
	mov	r12, rdx
	cmp	rcx, rdx
	cmovg	r12, rcx
	mov	QWORD PTR stack$3$[rsp], r12
$LN663@mergeAndFi:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	rax, rax
	je	SHORT $LN668@mergeAndFi
	cmp	r12, r11
	jle	SHORT $LN668@mergeAndFi
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN668@mergeAndFi:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [r12*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rax, rax
	je	SHORT $LN688@mergeAndFi
	mov	eax, DWORD PTR i$1$[rsp]
	mov	DWORD PTR [rbx], eax
$LN688@mergeAndFi:

; 216  : 	m_size++;

	mov	r14d, 1
	mov	QWORD PTR stack$[rbp-256], r14

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR stack$[rbp-248], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rax, QWORD PTR stack$[rbp-240]
	test	rax, rax
	je	SHORT $LN693@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
$LN693@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	rdi, rbx
	mov	QWORD PTR stack$[rbp-240], rbx
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, QWORD PTR trace$3$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 884  : 		while (stack.size())

	jmp	SHORT $LN23@mergeAndFi
	npad	3
$LL1120@mergeAndFi:
	mov	rdi, QWORD PTR stack$[rbp-240]
$LN23@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	rax, rax
	je	SHORT $LN534@mergeAndFi
	test	r14, r14
	jne	SHORT $LN534@mergeAndFi
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN534@mergeAndFi:

; 338  : 		int v = m_impl.back();

	movsxd	rdi, DWORD PTR [rdi+r14*4-4]

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	test	rax, rax
	je	SHORT $LN544@mergeAndFi
	test	r14, r14
	jg	SHORT $LN539@mergeAndFi
	mov	r8d, 143				; 0000008fH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0L@GHLCMNGA@m_size?5?$DO?50@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN539@mergeAndFi:

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	rax, rax
	je	SHORT $LN544@mergeAndFi
	test	r14, r14
	jne	SHORT $LN544@mergeAndFi
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN544@mergeAndFi:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	dec	r14
	mov	QWORD PTR stack$[rbp-256], r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 889  : 			rcRegion& creg = regions[ri];

	mov	r13, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN526@mergeAndFi
	test	edi, edi
	js	SHORT $LN527@mergeAndFi
	cmp	rdi, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN526@mergeAndFi
$LN527@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN526@mergeAndFi:
	shl	r13, 6
	add	r13, QWORD PTR regions$[rbp-240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 891  : 			spanCount += creg.spanCount;

	add	r15d, DWORD PTR [r13]
	mov	DWORD PTR spanCount$1$[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	rsi, rbx
	jge	SHORT $LN549@mergeAndFi

; 206  : 		construct(m_data + m_size++, value);

	mov	rcx, QWORD PTR trace$[rbp-240]
	lea	rcx, QWORD PTR [rcx+rsi*4]
	inc	rsi
	mov	QWORD PTR trace$[rbp-256], rsi

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	$LN548@mergeAndFi
	mov	DWORD PTR [rcx], edi

; 207  : 		return;

	jmp	$LN548@mergeAndFi
$LN549@mergeAndFi:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdx, QWORD PTR [rbx+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rbx, rcx
	jl	SHORT $LN559@mergeAndFi

; 226  : 		return RC_SIZE_MAX;

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	r15, rcx
	mov	QWORD PTR trace$3$[rsp], rcx
	jmp	SHORT $LN561@mergeAndFi
$LN559@mergeAndFi:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rcx, QWORD PTR [rbx+rbx]
	mov	r15, rdx
	cmp	rcx, rdx
	cmovg	r15, rcx
	mov	QWORD PTR trace$3$[rsp], r15
$LN561@mergeAndFi:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	rax, rax
	je	SHORT $LN566@mergeAndFi
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	r15, rcx
	jle	SHORT $LN566@mergeAndFi
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN566@mergeAndFi:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	mov	r8, QWORD PTR trace$[rbp-240]
	test	rax, rax
	je	SHORT $LN577@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	lea	rdx, QWORD PTR [r8+rsi*4]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	rdx, r8
	sar	rdx, 2
	test	rdx, rdx
	jle	SHORT $LN577@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	3
$LL578@mergeAndFi:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN576@mergeAndFi
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN576@mergeAndFi:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL578@mergeAndFi

; 189  : 	if (new_data) {

	mov	r8, QWORD PTR trace$[rbp-240]
$LN577@mergeAndFi:

; 214  : 	construct(data + m_size, value);

	lea	rax, QWORD PTR [rbx+rsi*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rax, rax
	je	SHORT $LN586@mergeAndFi
	mov	DWORD PTR [rax], edi
$LN586@mergeAndFi:

; 216  : 	m_size++;

	inc	rsi
	mov	QWORD PTR trace$[rbp-256], rsi

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR trace$[rbp-248], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r8, r8
	je	SHORT $LN591@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, r8
	call	QWORD PTR __imp_free
$LN591@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR trace$[rbp-240], rbx
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN548@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 894  : 			for (int j = 0; j < creg.connections.size(); ++j)

	xor	r9d, r9d
	mov	ebx, r9d
	mov	DWORD PTR j$1$[rsp], ebx
	mov	r15d, r9d
	cmp	DWORD PTR [r13+16], r9d
	jle	$LN26@mergeAndFi
	npad	1
$LL27@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN448@mergeAndFi
	test	r15, r15
	js	SHORT $LN1000@mergeAndFi
	cmp	r15, QWORD PTR [r13+16]
	jl	SHORT $LN448@mergeAndFi
$LN1000@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN448@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 896  : 				if (creg.connections[j] & RC_BORDER_REG)

	mov	rcx, QWORD PTR [r13+32]
	test	DWORD PTR [rcx+r15*4], 32768		; 00008000H
	je	SHORT $LN72@mergeAndFi

; 897  : 				{
; 898  : 					connectsToBorder = true;

	mov	BYTE PTR connectsToBorder$1$[rsp], 1

; 899  : 					continue;

	jmp	$LN25@mergeAndFi
$LN72@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN490@mergeAndFi
	test	r15, r15
	js	SHORT $LN999@mergeAndFi
	cmp	r15, QWORD PTR [r13+16]
	jl	SHORT $LN490@mergeAndFi
$LN999@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN490@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 901  : 				rcRegion& neireg = regions[creg.connections[j]];

	mov	rcx, QWORD PTR [r13+32]
	movsxd	rdi, DWORD PTR [rcx+r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN482@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN483@mergeAndFi
	cmp	rdi, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN482@mergeAndFi
$LN483@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN482@mergeAndFi:
	shl	rdi, 6
	add	rdi, QWORD PTR regions$[rbp-240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 902  : 				if (neireg.visited)

	cmp	BYTE PTR [rdi+8], 0
	jne	$LN25@mergeAndFi

; 903  : 					continue;
; 904  : 				if (neireg.id == 0 || (neireg.id & RC_BORDER_REG))

	movzx	ecx, WORD PTR [rdi+4]
	test	cx, cx
	je	$LN25@mergeAndFi
	js	$LN25@mergeAndFi

; 905  : 					continue;
; 906  : 				// Visit
; 907  : 				stack.push(neireg.id);

	mov	esi, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	r14, r12
	jge	SHORT $LN602@mergeAndFi

; 206  : 		construct(m_data + m_size++, value);

	mov	rcx, QWORD PTR stack$[rbp-240]
	lea	rcx, QWORD PTR [rcx+r14*4]
	inc	r14
	mov	QWORD PTR stack$[rbp-256], r14

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	$LN601@mergeAndFi
	mov	DWORD PTR [rcx], esi

; 207  : 		return;

	jmp	$LN601@mergeAndFi
$LN602@mergeAndFi:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdx, QWORD PTR [r12+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	r12, rcx
	jl	SHORT $LN612@mergeAndFi

; 226  : 		return RC_SIZE_MAX;

	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN614@mergeAndFi
$LN612@mergeAndFi:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rcx, QWORD PTR [r12+r12]
	mov	r12, rdx
	cmp	rcx, rdx
	cmovg	r12, rcx
$LN614@mergeAndFi:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	rax, rax
	je	SHORT $LN619@mergeAndFi
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	r12, rcx
	jle	SHORT $LN619@mergeAndFi
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN619@mergeAndFi:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [r12*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	mov	r8, QWORD PTR stack$[rbp-240]
	test	rax, rax
	je	SHORT $LN630@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	lea	rdx, QWORD PTR [r8+r14*4]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	rdx, r8
	sar	rdx, 2
	test	rdx, rdx
	jle	SHORT $LN630@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	6
$LL631@mergeAndFi:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN629@mergeAndFi
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN629@mergeAndFi:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL631@mergeAndFi

; 189  : 	if (new_data) {

	mov	r8, QWORD PTR stack$[rbp-240]
$LN630@mergeAndFi:

; 214  : 	construct(data + m_size, value);

	lea	rax, QWORD PTR [rbx+r14*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rax, rax
	je	SHORT $LN639@mergeAndFi
	mov	DWORD PTR [rax], esi
$LN639@mergeAndFi:

; 216  : 	m_size++;

	inc	r14
	mov	QWORD PTR stack$[rbp-256], r14

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR stack$[rbp-248], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r8, r8
	je	SHORT $LN644@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, r8
	call	QWORD PTR __imp_free
$LN644@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR stack$[rbp-240], rbx
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ebx, DWORD PTR j$1$[rsp]
$LN601@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 908  : 				neireg.visited = true;

	mov	BYTE PTR [rdi+8], 1
$LN25@mergeAndFi:

; 894  : 			for (int j = 0; j < creg.connections.size(); ++j)

	inc	ebx
	mov	DWORD PTR j$1$[rsp], ebx
	inc	r15
	cmp	ebx, DWORD PTR [r13+16]
	jl	$LL27@mergeAndFi
	mov	QWORD PTR stack$3$[rsp], r12
	mov	rsi, QWORD PTR trace$[rbp-256]
	xor	r9d, r9d
$LN26@mergeAndFi:

; 884  : 		while (stack.size())

	test	r14d, r14d
	mov	rbx, QWORD PTR trace$3$[rsp]
	mov	r15d, DWORD PTR spanCount$1$[rsp]
	jne	$LL1120@mergeAndFi

; 909  : 			}
; 910  : 		}
; 911  : 		
; 912  : 		// If the accumulated regions size is too small, remove it.
; 913  : 		// Do not remove areas which connect to tile borders
; 914  : 		// as their size cannot be estimated correctly and removing them
; 915  : 		// can potentially remove necessary areas.
; 916  : 		if (spanCount < minRegionArea && !connectsToBorder)

	cmp	r15d, DWORD PTR minRegionArea$1$[rbp-256]
	jge	$LN1115@mergeAndFi
	cmp	BYTE PTR connectsToBorder$1$[rsp], 0
	jne	$LN1115@mergeAndFi

; 917  : 		{
; 918  : 			// Kill all visited regions.
; 919  : 			for (int j = 0; j < trace.size(); ++j)

	mov	rdi, r9
	test	esi, esi
	jle	$LN1115@mergeAndFi
	mov	esi, esi
	mov	r14, QWORD PTR trace$[rbp-256]
	mov	r15, QWORD PTR trace$[rbp-240]
	mov	r12, QWORD PTR regions$[rbp-256]
	mov	r13, QWORD PTR regions$[rbp-240]
$LL30@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN520@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN521@mergeAndFi
	cmp	rdi, r14
	jl	SHORT $LN520@mergeAndFi
$LN521@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN520@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 921  : 				regions[trace[j]].spanCount = 0;

	movsxd	rbx, DWORD PTR [r15+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN512@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN513@mergeAndFi
	cmp	rbx, r12
	jl	SHORT $LN512@mergeAndFi
$LN513@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN512@mergeAndFi:
	shl	rbx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 921  : 				regions[trace[j]].spanCount = 0;

	mov	DWORD PTR [rbx+r13], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN506@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN507@mergeAndFi
	cmp	rdi, r14
	jl	SHORT $LN506@mergeAndFi
$LN507@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN506@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 922  : 				regions[trace[j]].id = 0;

	movsxd	rbx, DWORD PTR [r15+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN498@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN499@mergeAndFi
	cmp	rbx, r12
	jl	SHORT $LN498@mergeAndFi
$LN499@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN498@mergeAndFi:
	shl	rbx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 922  : 				regions[trace[j]].id = 0;

	xor	r9d, r9d
	mov	WORD PTR [rbx+r13+4], r9w

; 917  : 		{
; 918  : 			// Kill all visited regions.
; 919  : 			for (int j = 0; j < trace.size(); ++j)

	inc	rdi
	sub	rsi, 1
	jne	$LL30@mergeAndFi
	mov	r12, QWORD PTR stack$3$[rsp]
$LN1115@mergeAndFi:

; 864  : 	for (int i = 0; i < nreg; ++i)

	mov	r14, 4611686018427387903		; 3fffffffffffffffH
	mov	r13, QWORD PTR count$1$[rsp]
	mov	rdi, QWORD PTR regions$[rbp-240]
	mov	r8d, DWORD PTR i$1$[rsp]
	mov	rbx, QWORD PTR trace$3$[rsp]
$LN20@mergeAndFi:
	inc	r8d
	mov	DWORD PTR i$1$[rsp], r8d
	mov	rcx, QWORD PTR $T3[rbp-256]
	inc	rcx
	mov	QWORD PTR $T3[rbp-256], rcx
	cmp	rcx, r13
	jl	$LL1125@mergeAndFi
$LL33@mergeAndFi:

; 923  : 			}
; 924  : 		}
; 925  : 	}
; 926  : 	
; 927  : 	// Merge too small regions to neighbour regions.
; 928  : 	int mergeCount = 0 ;
; 929  : 	do
; 930  : 	{
; 931  : 		mergeCount = 0;

	mov	ecx, r9d
	mov	DWORD PTR mergeCount$1$[rsp], ecx
	mov	rdi, r9
	mov	QWORD PTR $T1[rbp-256], r9

; 932  : 		for (int i = 0; i < nreg; ++i)

	test	r13, r13
	je	$LN44@mergeAndFi
$LL36@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN309@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN310@mergeAndFi
	cmp	rdi, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN309@mergeAndFi
$LN310@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	ecx, DWORD PTR mergeCount$1$[rsp]
	xor	r9d, r9d
$LN309@mergeAndFi:
	shl	rdi, 6
	mov	r12, QWORD PTR regions$[rbp-240]
	add	rdi, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 935  : 			if (reg.id == 0 || (reg.id & RC_BORDER_REG))

	movzx	r13d, WORD PTR [rdi+4]
	test	r13w, r13w
	je	$LN34@mergeAndFi
	js	$LN34@mergeAndFi

; 936  : 				continue;
; 937  : 			if (reg.overlap)

	cmp	BYTE PTR [rdi+9], 0
	jne	$LN34@mergeAndFi

; 938  : 				continue;
; 939  : 			if (reg.spanCount == 0)

	mov	ecx, DWORD PTR [rdi]
	test	ecx, ecx
	je	$LN1119@mergeAndFi

; 940  : 				continue;
; 941  : 			
; 942  : 			// Check to see if the region should be merged.
; 943  : 			if (reg.spanCount > mergeRegionSize && isRegionConnectedToBorder(reg))

	cmp	ecx, DWORD PTR mergeRegionSize$1$[rbp-256]
	jle	SHORT $LN81@mergeAndFi

; 674  : 	for (int i = 0; i < reg.connections.size(); ++i)

	mov	esi, r9d
	mov	rbx, r9
	cmp	DWORD PTR [rdi+16], 0
	jle	SHORT $LN81@mergeAndFi
$LL454@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN464@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN939@mergeAndFi
	cmp	rbx, QWORD PTR [rdi+16]
	jl	SHORT $LN464@mergeAndFi
$LN939@mergeAndFi:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN464@mergeAndFi:

; 344  : 	int operator[](int index) const { return m_impl[index]; }

	mov	rcx, QWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 676  : 		if (reg.connections[i] == 0)

	cmp	DWORD PTR [rcx+rbx*4], 0
	je	$LN1119@mergeAndFi

; 583  : }
; 584  : 
; 585  : static bool canMergeWithRegion(const rcRegion& rega, const rcRegion& regb)
; 586  : {
; 587  : 	if (rega.areaType != regb.areaType)
; 588  : 		return false;
; 589  : 	int n = 0;
; 590  : 	for (int i = 0; i < rega.connections.size(); ++i)
; 591  : 	{
; 592  : 		if (rega.connections[i] == regb.id)
; 593  : 			n++;
; 594  : 	}
; 595  : 	if (n > 1)
; 596  : 		return false;
; 597  : 	for (int i = 0; i < rega.floors.size(); ++i)
; 598  : 	{
; 599  : 		if (rega.floors[i] == regb.id)
; 600  : 			return false;
; 601  : 	}
; 602  : 	return true;
; 603  : }
; 604  : 
; 605  : static void addUniqueFloorRegion(rcRegion& reg, int n)
; 606  : {
; 607  : 	for (int i = 0; i < reg.floors.size(); ++i)
; 608  : 		if (reg.floors[i] == n)
; 609  : 			return;
; 610  : 	reg.floors.push(n);
; 611  : }
; 612  : 
; 613  : static bool mergeRegions(rcRegion& rega, rcRegion& regb)
; 614  : {
; 615  : 	unsigned short aid = rega.id;
; 616  : 	unsigned short bid = regb.id;
; 617  : 	
; 618  : 	// Duplicate current neighbourhood.
; 619  : 	rcIntArray acon;
; 620  : 	acon.resize(rega.connections.size());
; 621  : 	for (int i = 0; i < rega.connections.size(); ++i)
; 622  : 		acon[i] = rega.connections[i];
; 623  : 	rcIntArray& bcon = regb.connections;
; 624  : 	
; 625  : 	// Find insertion point on A.
; 626  : 	int insa = -1;
; 627  : 	for (int i = 0; i < acon.size(); ++i)
; 628  : 	{
; 629  : 		if (acon[i] == bid)
; 630  : 		{
; 631  : 			insa = i;
; 632  : 			break;
; 633  : 		}
; 634  : 	}
; 635  : 	if (insa == -1)
; 636  : 		return false;
; 637  : 	
; 638  : 	// Find insertion point on B.
; 639  : 	int insb = -1;
; 640  : 	for (int i = 0; i < bcon.size(); ++i)
; 641  : 	{
; 642  : 		if (bcon[i] == aid)
; 643  : 		{
; 644  : 			insb = i;
; 645  : 			break;
; 646  : 		}
; 647  : 	}
; 648  : 	if (insb == -1)
; 649  : 		return false;
; 650  : 	
; 651  : 	// Merge neighbours.
; 652  : 	rega.connections.clear();
; 653  : 	for (int i = 0, ni = acon.size(); i < ni-1; ++i)
; 654  : 		rega.connections.push(acon[(insa+1+i) % ni]);
; 655  : 		
; 656  : 	for (int i = 0, ni = bcon.size(); i < ni-1; ++i)
; 657  : 		rega.connections.push(bcon[(insb+1+i) % ni]);
; 658  : 	
; 659  : 	removeAdjacentNeighbours(rega);
; 660  : 	
; 661  : 	for (int j = 0; j < regb.floors.size(); ++j)
; 662  : 		addUniqueFloorRegion(rega, regb.floors[j]);
; 663  : 	rega.spanCount += regb.spanCount;
; 664  : 	regb.spanCount = 0;
; 665  : 	regb.connections.resize(0);
; 666  : 
; 667  : 	return true;
; 668  : }
; 669  : 
; 670  : static bool isRegionConnectedToBorder(const rcRegion& reg)
; 671  : {
; 672  : 	// Region is connected to border if
; 673  : 	// one of the neighbours is null id.
; 674  : 	for (int i = 0; i < reg.connections.size(); ++i)

	inc	esi
	inc	rbx
	cmp	esi, DWORD PTR [rdi+16]
	jl	SHORT $LL454@mergeAndFi

; 676  : 		if (reg.connections[i] == 0)

	movzx	r13d, WORD PTR [rdi+4]
	xor	r9d, r9d
$LN81@mergeAndFi:

; 944  : 				continue;
; 945  : 			
; 946  : 			// Small region with more than 1 connection.
; 947  : 			// Or region which is not connected to a border at all.
; 948  : 			// Find smallest neighbour region that connects to this one.
; 949  : 			int smallest = 0xfffffff;

	mov	r15d, 268435455				; 0fffffffH

; 950  : 			unsigned short mergeId = reg.id;
; 951  : 			for (int j = 0; j < reg.connections.size(); ++j)

	mov	r14d, r9d
	mov	rsi, r9
	cmp	DWORD PTR [rdi+16], 0
	jle	$LN38@mergeAndFi
$LL39@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN343@mergeAndFi
	test	rsi, rsi
	js	SHORT $LN1004@mergeAndFi
	cmp	rsi, QWORD PTR [rdi+16]
	jl	SHORT $LN343@mergeAndFi
$LN1004@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN343@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 953  : 				if (reg.connections[j] & RC_BORDER_REG) continue;

	mov	rcx, QWORD PTR [rdi+32]
	test	DWORD PTR [rcx+rsi*4], 32768		; 00008000H
	jne	$LN37@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN371@mergeAndFi
	test	rsi, rsi
	js	SHORT $LN1003@mergeAndFi
	cmp	rsi, QWORD PTR [rdi+16]
	jl	SHORT $LN371@mergeAndFi
$LN1003@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN371@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 954  : 				rcRegion& mreg = regions[reg.connections[j]];

	mov	rcx, QWORD PTR [rdi+32]
	movsxd	rbx, DWORD PTR [rcx+rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN363@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN364@mergeAndFi
	cmp	rbx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN363@mergeAndFi
$LN364@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN363@mergeAndFi:
	shl	rbx, 6
	add	rbx, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 955  : 				if (mreg.id == 0 || (mreg.id & RC_BORDER_REG) || mreg.overlap) continue;

	movzx	ecx, WORD PTR [rbx+4]
	test	cx, cx
	je	SHORT $LN37@mergeAndFi
	js	SHORT $LN37@mergeAndFi
	cmp	BYTE PTR [rbx+9], 0
	jne	SHORT $LN37@mergeAndFi

; 956  : 				if (mreg.spanCount < smallest &&
; 957  : 					canMergeWithRegion(reg, mreg) &&

	cmp	DWORD PTR [rbx], r15d
	jge	SHORT $LN37@mergeAndFi
	mov	rdx, rbx
	mov	rcx, rdi
	call	?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z ; canMergeWithRegion
	test	al, al
	je	SHORT $LN1088@mergeAndFi
	mov	rdx, rdi
	mov	rcx, rbx
	call	?canMergeWithRegion@@YA_NAEBUrcRegion@@0@Z ; canMergeWithRegion
	test	al, al
	je	SHORT $LN1088@mergeAndFi

; 958  : 					canMergeWithRegion(mreg, reg))
; 959  : 				{
; 960  : 					smallest = mreg.spanCount;

	mov	r15d, DWORD PTR [rbx]

; 961  : 					mergeId = mreg.id;

	movzx	r13d, WORD PTR [rbx+4]
$LN1088@mergeAndFi:

; 950  : 			unsigned short mergeId = reg.id;
; 951  : 			for (int j = 0; j < reg.connections.size(); ++j)

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN37@mergeAndFi:
	inc	r14d
	inc	rsi
	cmp	r14d, DWORD PTR [rdi+16]
	jl	$LL39@mergeAndFi
$LN38@mergeAndFi:

; 962  : 				}
; 963  : 			}
; 964  : 			// Found new id.
; 965  : 			if (mergeId != reg.id)

	movzx	r15d, WORD PTR [rdi+4]
	mov	WORD PTR oldId$1$[rsp], r15w
	cmp	r13w, r15w
	je	$LN1119@mergeAndFi

; 966  : 			{
; 967  : 				unsigned short oldId = reg.id;
; 968  : 				rcRegion& target = regions[mergeId];

	movzx	ebx, r13w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rsi, QWORD PTR regions$[rbp-256]
	test	rax, rax
	je	SHORT $LN357@mergeAndFi
	cmp	rbx, rsi
	jl	SHORT $LN357@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN357@mergeAndFi:
	shl	rbx, 6
	lea	rcx, QWORD PTR [r12+rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 971  : 				if (mergeRegions(target, reg))

	mov	rdx, rdi
	call	?mergeRegions@@YA_NAEAUrcRegion@@0@Z	; mergeRegions
	test	al, al
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	je	$LN1119@mergeAndFi

; 972  : 				{
; 973  : 					// Fixup regions pointing to current region.
; 974  : 					for (int j = 0; j < nreg; ++j)

	xor	r12d, r12d
	mov	rbx, QWORD PTR regions$[rbp-240]
	add	rbx, 40					; 00000028H
$LL42@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN333@mergeAndFi
	cmp	r12, rsi
	jl	SHORT $LN333@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN333@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 976  : 						if (regions[j].id == 0 || (regions[j].id & RC_BORDER_REG)) continue;

	cmp	WORD PTR [rbx-36], 0
	je	$LN40@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN349@mergeAndFi
	cmp	r12, rsi
	jl	SHORT $LN349@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN349@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 976  : 						if (regions[j].id == 0 || (regions[j].id & RC_BORDER_REG)) continue;

	cmp	WORD PTR [rbx-36], 0
	jl	$LN40@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN430@mergeAndFi
	cmp	r12, rsi
	jl	SHORT $LN430@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN430@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 979  : 						if (regions[j].id == oldId)

	cmp	WORD PTR [rbx-36], r15w
	jne	SHORT $LN90@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN438@mergeAndFi
	cmp	r12, rsi
	jl	SHORT $LN438@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN438@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 980  : 							regions[j].id = mergeId;

	mov	WORD PTR [rbx-36], r13w
$LN90@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN424@mergeAndFi
	cmp	r12, rsi
	jl	SHORT $LN424@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN424@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 567  : 	bool neiChanged = false;

	xor	r14b, r14b

; 568  : 	for (int i = 0; i < reg.connections.size(); ++i)

	xor	ecx, ecx
	mov	esi, ecx
	mov	edi, ecx
	movzx	r15d, r15w
	cmp	DWORD PTR [rbx-24], ecx
	jle	$LN376@mergeAndFi
	npad	1
$LL377@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN392@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN1006@mergeAndFi
	cmp	rdi, QWORD PTR [rbx-24]
	jl	SHORT $LN392@mergeAndFi
$LN1006@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN392@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 570  : 		if (reg.connections[i] == oldId)

	mov	rcx, QWORD PTR [rbx-8]
	cmp	DWORD PTR [rcx+rdi*4], r15d
	jne	SHORT $LN375@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN400@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN1005@mergeAndFi
	cmp	rdi, QWORD PTR [rbx-24]
	jl	SHORT $LN400@mergeAndFi
$LN1005@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN400@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 572  : 			reg.connections[i] = newId;

	movzx	edx, r13w
	mov	rcx, QWORD PTR [rbx-8]
	mov	DWORD PTR [rcx+rdi*4], edx

; 573  : 			neiChanged = true;

	mov	r14b, 1
$LN375@mergeAndFi:

; 568  : 	for (int i = 0; i < reg.connections.size(); ++i)

	inc	esi
	inc	rdi
	cmp	esi, DWORD PTR [rbx-24]
	jl	SHORT $LL377@mergeAndFi
	xor	ecx, ecx
$LN376@mergeAndFi:

; 574  : 		}
; 575  : 	}
; 576  : 	for (int i = 0; i < reg.floors.size(); ++i)

	mov	esi, ecx
	mov	rdi, rcx
	cmp	DWORD PTR [rbx], 0
	jle	SHORT $LN379@mergeAndFi
$LL380@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN410@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN1008@mergeAndFi
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN410@mergeAndFi
$LN1008@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN410@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 578  : 		if (reg.floors[i] == oldId)

	mov	rcx, QWORD PTR [rbx+16]
	cmp	DWORD PTR [rcx+rdi*4], r15d
	jne	SHORT $LN378@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN418@mergeAndFi
	test	rdi, rdi
	js	SHORT $LN1007@mergeAndFi
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN418@mergeAndFi
$LN1007@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN418@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 579  : 			reg.floors[i] = newId;

	movzx	edx, r13w
	mov	rcx, QWORD PTR [rbx+16]
	mov	DWORD PTR [rcx+rdi*4], edx
$LN378@mergeAndFi:

; 574  : 		}
; 575  : 	}
; 576  : 	for (int i = 0; i < reg.floors.size(); ++i)

	inc	esi
	inc	rdi
	cmp	esi, DWORD PTR [rbx]
	jl	SHORT $LL380@mergeAndFi
$LN379@mergeAndFi:

; 580  : 	}
; 581  : 	if (neiChanged)

	test	r14b, r14b
	je	SHORT $LN1116@mergeAndFi

; 582  : 		removeAdjacentNeighbours(reg);

	lea	rcx, QWORD PTR [rbx-40]
	call	?removeAdjacentNeighbours@@YAXAEAUrcRegion@@@Z ; removeAdjacentNeighbours
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN1116@mergeAndFi:

; 972  : 				{
; 973  : 					// Fixup regions pointing to current region.
; 974  : 					for (int j = 0; j < nreg; ++j)

	movzx	r15d, WORD PTR oldId$1$[rsp]
$LN40@mergeAndFi:
	inc	r12
	add	rbx, 64					; 00000040H
	cmp	r12, QWORD PTR count$1$[rsp]
	mov	rsi, QWORD PTR regions$[rbp-256]
	jl	$LL42@mergeAndFi

; 981  : 						// Replace the current region with the new one if the
; 982  : 						// current regions is neighbour.
; 983  : 						replaceNeighbour(regions[j], oldId, mergeId);
; 984  : 					}
; 985  : 					mergeCount++;

	mov	ecx, DWORD PTR mergeCount$1$[rsp]
	inc	ecx
	mov	DWORD PTR mergeCount$1$[rsp], ecx

; 971  : 				if (mergeRegions(target, reg))

	mov	r12, QWORD PTR regions$[rbp-240]

; 676  : 		if (reg.connections[i] == 0)

	jmp	SHORT $LN34@mergeAndFi
$LN1119@mergeAndFi:

; 932  : 		for (int i = 0; i < nreg; ++i)

	mov	ecx, DWORD PTR mergeCount$1$[rsp]
$LN34@mergeAndFi:
	mov	rdi, QWORD PTR $T1[rbp-256]
	inc	rdi
	mov	QWORD PTR $T1[rbp-256], rdi
	mov	r13, QWORD PTR count$1$[rsp]
	cmp	rdi, r13
	mov	r9d, 0
	jl	$LL36@mergeAndFi

; 986  : 				}
; 987  : 			}
; 988  : 		}
; 989  : 	}
; 990  : 	while (mergeCount > 0);

	test	ecx, ecx
	jg	$LL33@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	xor	esi, esi
	mov	ebx, esi
	lea	rdi, QWORD PTR [r12+7]
$LL45@mergeAndFi:
	test	rax, rax
	je	SHORT $LN297@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN298@mergeAndFi
	cmp	rbx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN297@mergeAndFi
$LN298@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN297@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 995  : 		regions[i].remap = false;

	mov	BYTE PTR [rdi], sil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN291@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN292@mergeAndFi
	cmp	rbx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN291@mergeAndFi
$LN292@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN291@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 996  : 		if (regions[i].id == 0) continue;       // Skip nil regions.

	cmp	WORD PTR [rdi-3], si
	je	SHORT $LN43@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN303@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN304@mergeAndFi
	cmp	rbx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN303@mergeAndFi
$LN304@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN303@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 997  : 		if (regions[i].id & RC_BORDER_REG) continue;    // Skip external regions.

	cmp	WORD PTR [rdi-3], si
	jl	SHORT $LN43@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN315@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN316@mergeAndFi
	cmp	rbx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN315@mergeAndFi
$LN316@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN315@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 998  : 		regions[i].remap = true;

	mov	BYTE PTR [rdi], 1
$LN43@mergeAndFi:

; 991  : 	
; 992  : 	// Compress region Ids.
; 993  : 	for (int i = 0; i < nreg; ++i)

	inc	rbx
	add	rdi, 64					; 00000040H
	cmp	rbx, r13
	jl	$LL45@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	movzx	r14d, si
	mov	QWORD PTR $T2[rbp-256], rsi
	add	r12, 4
$LL48@mergeAndFi:
	test	rax, rax
	je	SHORT $LN279@mergeAndFi
	test	rsi, rsi
	js	SHORT $LN280@mergeAndFi
	cmp	rsi, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN279@mergeAndFi
$LN280@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN279@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1004 : 		if (!regions[i].remap)

	cmp	BYTE PTR [r12+3], 0
	je	$LN46@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN285@mergeAndFi
	test	rsi, rsi
	js	SHORT $LN286@mergeAndFi
	cmp	rsi, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN285@mergeAndFi
$LN286@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN285@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1006 : 		unsigned short oldId = regions[i].id;

	movzx	r15d, WORD PTR [r12]

; 1007 : 		unsigned short newId = ++regIdGen;

	inc	r14w

; 1008 : 		for (int j = i; j < nreg; ++j)

	mov	rbx, rsi
	cmp	rsi, r13
	jge	$LN46@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rdi, r12
	mov	rsi, QWORD PTR regions$[rbp-256]
$LL51@mergeAndFi:
	test	rax, rax
	je	SHORT $LN255@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN256@mergeAndFi
	cmp	rbx, rsi
	jl	SHORT $LN255@mergeAndFi
$LN256@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN255@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1010 : 			if (regions[j].id == oldId)

	cmp	WORD PTR [rdi], r15w
	jne	SHORT $LN49@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN273@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN274@mergeAndFi
	cmp	rbx, rsi
	jl	SHORT $LN273@mergeAndFi
$LN274@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN273@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1012 : 				regions[j].id = newId;

	mov	WORD PTR [rdi], r14w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN267@mergeAndFi
	test	rbx, rbx
	js	SHORT $LN268@mergeAndFi
	cmp	rbx, rsi
	jl	SHORT $LN267@mergeAndFi
$LN268@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN267@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1013 : 				regions[j].remap = false;

	mov	BYTE PTR [rdi+3], 0
$LN49@mergeAndFi:

; 1008 : 		for (int j = i; j < nreg; ++j)

	inc	rbx
	add	rdi, 64					; 00000040H
	cmp	rbx, r13
	jl	$LL51@mergeAndFi
	mov	rsi, QWORD PTR $T2[rbp-256]
$LN46@mergeAndFi:

; 1002 : 	for (int i = 0; i < nreg; ++i)

	inc	rsi
	mov	QWORD PTR $T2[rbp-256], rsi
	add	r12, 64					; 00000040H
	cmp	rsi, r13
	jl	$LL48@mergeAndFi
	xor	r9d, r9d
	jmp	SHORT $LN47@mergeAndFi
$LN44@mergeAndFi:

; 999  : 	}
; 1000 : 	
; 1001 : 	unsigned short regIdGen = 0;

	mov	r14d, r9d
$LN47@mergeAndFi:

; 1014 : 			}
; 1015 : 		}
; 1016 : 	}
; 1017 : 	maxRegionId = regIdGen;

	mov	rcx, QWORD PTR maxRegionId$GSCopy$1$[rbp-256]
	mov	WORD PTR [rcx], r14w

; 1018 : 	
; 1019 : 	// Remap regions.
; 1020 : 	for (int i = 0; i < chf.spanCount; ++i)

	mov	edi, r9d
	mov	rdx, QWORD PTR chf$GSCopy$1$[rsp]
	cmp	DWORD PTR [rdx+8], 0
	jle	SHORT $LN53@mergeAndFi
	mov	rsi, QWORD PTR srcReg$GSCopy$1$[rsp]
$LL54@mergeAndFi:

; 1021 : 	{
; 1022 : 		if ((srcReg[i] & RC_BORDER_REG) == 0)

	movzx	ecx, WORD PTR [rsi]
	test	cx, cx
	js	SHORT $LN52@mergeAndFi

; 1023 : 			srcReg[i] = regions[srcReg[i]].id;

	mov	ebx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN261@mergeAndFi
	cmp	rcx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN261@mergeAndFi
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdx, QWORD PTR chf$GSCopy$1$[rsp]
$LN261@mergeAndFi:
	shl	rbx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1023 : 			srcReg[i] = regions[srcReg[i]].id;

	mov	rcx, QWORD PTR regions$[rbp-240]
	movzx	ecx, WORD PTR [rbx+rcx+4]
	mov	WORD PTR [rsi], cx
$LN52@mergeAndFi:

; 1018 : 	
; 1019 : 	// Remap regions.
; 1020 : 	for (int i = 0; i < chf.spanCount; ++i)

	inc	edi
	add	rsi, 2
	cmp	edi, DWORD PTR [rdx+8]
	jl	SHORT $LL54@mergeAndFi
	xor	r9d, r9d
$LN53@mergeAndFi:

; 1027 : 	for (int i = 0; i < nreg; ++i)

	test	r13, r13
	je	$LN1124@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	rsi, QWORD PTR regions$[rbp-240]
	add	rsi, 4
	mov	r13, QWORD PTR overlaps$GSCopy$1$[rbp-256]
	mov	r15, 4611686018427387903		; 3fffffffffffffffH
$LL57@mergeAndFi:

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN162@mergeAndFi
	test	r9, r9
	js	SHORT $LN163@mergeAndFi
	cmp	r9, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN162@mergeAndFi
$LN163@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN162@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1028 : 		if (regions[i].overlap)

	cmp	BYTE PTR [rsi+5], 0
	je	$LN55@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN200@mergeAndFi
	mov	rcx, QWORD PTR $T4[rbp-256]
	test	rcx, rcx
	js	SHORT $LN201@mergeAndFi
	cmp	rcx, QWORD PTR regions$[rbp-256]
	jl	SHORT $LN200@mergeAndFi
$LN201@mergeAndFi:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN200@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1029 : 			overlaps.push(regions[i].id);

	movzx	r14d, WORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rdx, QWORD PTR [r13]
	mov	rcx, QWORD PTR [r13+8]
	cmp	rdx, rcx
	jge	SHORT $LN206@mergeAndFi

; 206  : 		construct(m_data + m_size++, value);

	mov	rcx, QWORD PTR [r13+16]
	lea	r8, QWORD PTR [rcx+rdx*4]
	lea	rcx, QWORD PTR [rdx+1]
	mov	QWORD PTR [r13], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	r8, r8
	je	$LN55@mergeAndFi
	mov	DWORD PTR [r8], r14d

; 207  : 		return;

	jmp	$LN55@mergeAndFi
$LN206@mergeAndFi:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rbx, QWORD PTR [rcx+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rcx, r15
	jl	SHORT $LN216@mergeAndFi

; 226  : 		return RC_SIZE_MAX;

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN218@mergeAndFi
$LN216@mergeAndFi:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rcx, rcx
	cmp	rcx, rbx
	cmovg	rbx, rcx
$LN218@mergeAndFi:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	rax, rax
	je	SHORT $LN223@mergeAndFi
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rcx
	jle	SHORT $LN223@mergeAndFi
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN223@mergeAndFi:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rbx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN234@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [r13+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [r13]
	test	rdx, rdx
	jle	SHORT $LN234@mergeAndFi

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL235@mergeAndFi:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN233@mergeAndFi
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN233@mergeAndFi:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL235@mergeAndFi
$LN234@mergeAndFi:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [r13]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN243@mergeAndFi
	mov	DWORD PTR [rcx], r14d
$LN243@mergeAndFi:

; 216  : 	m_size++;

	inc	QWORD PTR [r13]

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR [r13+8], rbx

; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [r13+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN248@mergeAndFi

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN248@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [r13+16], rdi
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN55@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1027 : 	for (int i = 0; i < nreg; ++i)

	mov	r9, QWORD PTR $T4[rbp-256]
	inc	r9
	mov	QWORD PTR $T4[rbp-256], r9
	add	rsi, 64					; 00000040H
	cmp	r9, QWORD PTR count$1$[rsp]
	jl	$LL57@mergeAndFi
$LN1124@mergeAndFi:

; 1031 : 	return true;

	mov	r13, QWORD PTR regions$[rbp-240]
	mov	dil, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rax, QWORD PTR trace$[rbp-240]
	test	rax, rax
	je	SHORT $LN177@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	npad	1
$LN177@mergeAndFi:

; 47   : 	if (ptr != NULL)

	mov	rax, QWORD PTR stack$[rbp-240]
	test	rax, rax
	je	SHORT $LN193@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	npad	1
$LN193@mergeAndFi:
$LN1126@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1031 : 	return true;

	mov	rsi, QWORD PTR regions$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 299  : 	for (rcSizeType i = begin; i < end; i++) {

	test	rsi, rsi
	jle	SHORT $LN111@mergeAndFi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1031 : 	return true;

	lea	rbx, QWORD PTR [r13+32]
	npad	1
$LL112@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN132@mergeAndFi

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN132@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN148@mergeAndFi

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN148@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 299  : 	for (rcSizeType i = begin; i < end; i++) {

	add	rbx, 64					; 00000040H
	sub	rsi, 1
	jne	SHORT $LL112@mergeAndFi
$LN111@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r13, r13
	je	SHORT $LN1086@mergeAndFi

; 28   : 	free(ptr);

	mov	rcx, r13
	call	QWORD PTR __imp_free
	npad	1
$LN1086@mergeAndFi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp

; 1032 : }

	movzx	eax, dil
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+408]
	add	rsp, 336				; 00000150H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z ENDP ; mergeAndFilterRegions
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
mergeCount$1$ = 64
i$1$ = 64
x$1$ = 64
oldId$1$ = 68
connectsToBorder$1$ = 68
y$1$ = 68
j$1$ = 72
h$1$ = 72
trace$3$ = 80
tv5396 = 80
stack$3$ = 88
c$1$ = 88
spanCount$1$ = 96
w$1$ = 96
srcReg$GSCopy$1$ = 104
chf$GSCopy$1$ = 112
count$1$ = 120
$T1 = 128
$T2 = 128
tv5395 = 128
$T3 = 136
tv5414 = 136
minRegionArea$1$ = 144
mergeRegionSize$1$ = 148
$T4 = 152
tv5394 = 160
maxRegionId$GSCopy$1$ = 168
overlaps$GSCopy$1$ = 176
$T5 = 184
regions$ = 248
stack$ = 272
trace$ = 296
__$ArrayPad$ = 320
ctx$ = 400
minRegionArea$ = 408
mergeRegionSize$ = 416
maxRegionId$ = 424
chf$ = 432
srcReg$ = 440
overlaps$ = 448
?dtor$0@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA PROC ; `mergeAndFilterRegions'::`1'::dtor$0
	lea	rcx, QWORD PTR regions$[rdx]
	jmp	??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
?dtor$0@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA ENDP ; `mergeAndFilterRegions'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
mergeCount$1$ = 64
i$1$ = 64
x$1$ = 64
oldId$1$ = 68
connectsToBorder$1$ = 68
y$1$ = 68
j$1$ = 72
h$1$ = 72
trace$3$ = 80
tv5396 = 80
stack$3$ = 88
c$1$ = 88
spanCount$1$ = 96
w$1$ = 96
srcReg$GSCopy$1$ = 104
chf$GSCopy$1$ = 112
count$1$ = 120
$T1 = 128
$T2 = 128
tv5395 = 128
$T3 = 136
tv5414 = 136
minRegionArea$1$ = 144
mergeRegionSize$1$ = 148
$T4 = 152
tv5394 = 160
maxRegionId$GSCopy$1$ = 168
overlaps$GSCopy$1$ = 176
$T5 = 184
regions$ = 248
stack$ = 272
trace$ = 296
__$ArrayPad$ = 320
ctx$ = 400
minRegionArea$ = 408
mergeRegionSize$ = 416
maxRegionId$ = 424
chf$ = 432
srcReg$ = 440
overlaps$ = 448
?dtor$1@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA PROC ; `mergeAndFilterRegions'::`1'::dtor$1
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1rcRegion@@QEAA@XZ
?dtor$1@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA ENDP ; `mergeAndFilterRegions'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
mergeCount$1$ = 64
i$1$ = 64
x$1$ = 64
oldId$1$ = 68
connectsToBorder$1$ = 68
y$1$ = 68
j$1$ = 72
h$1$ = 72
trace$3$ = 80
tv5396 = 80
stack$3$ = 88
c$1$ = 88
spanCount$1$ = 96
w$1$ = 96
srcReg$GSCopy$1$ = 104
chf$GSCopy$1$ = 112
count$1$ = 120
$T1 = 128
$T2 = 128
tv5395 = 128
$T3 = 136
tv5414 = 136
minRegionArea$1$ = 144
mergeRegionSize$1$ = 148
$T4 = 152
tv5394 = 160
maxRegionId$GSCopy$1$ = 168
overlaps$GSCopy$1$ = 176
$T5 = 184
regions$ = 248
stack$ = 272
trace$ = 296
__$ArrayPad$ = 320
ctx$ = 400
minRegionArea$ = 408
mergeRegionSize$ = 416
maxRegionId$ = 424
chf$ = 432
srcReg$ = 440
overlaps$ = 448
?dtor$2@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA PROC ; `mergeAndFilterRegions'::`1'::dtor$2
	lea	rcx, QWORD PTR stack$[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$2@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA ENDP ; `mergeAndFilterRegions'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
mergeCount$1$ = 64
i$1$ = 64
x$1$ = 64
oldId$1$ = 68
connectsToBorder$1$ = 68
y$1$ = 68
j$1$ = 72
h$1$ = 72
trace$3$ = 80
tv5396 = 80
stack$3$ = 88
c$1$ = 88
spanCount$1$ = 96
w$1$ = 96
srcReg$GSCopy$1$ = 104
chf$GSCopy$1$ = 112
count$1$ = 120
$T1 = 128
$T2 = 128
tv5395 = 128
$T3 = 136
tv5414 = 136
minRegionArea$1$ = 144
mergeRegionSize$1$ = 148
$T4 = 152
tv5394 = 160
maxRegionId$GSCopy$1$ = 168
overlaps$GSCopy$1$ = 176
$T5 = 184
regions$ = 248
stack$ = 272
trace$ = 296
__$ArrayPad$ = 320
ctx$ = 400
minRegionArea$ = 408
mergeRegionSize$ = 416
maxRegionId$ = 424
chf$ = 432
srcReg$ = 440
overlaps$ = 448
?dtor$3@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA PROC ; `mergeAndFilterRegions'::`1'::dtor$3
	lea	rcx, QWORD PTR trace$[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$3@?0??mergeAndFilterRegions@@YA_NPEAVrcContext@@HHAEAGAEAUrcCompactHeightfield@@PEAGAEAVrcIntArray@@@Z@4HA ENDP ; `mergeAndFilterRegions'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1?$rcTempVector@UrcRegion@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$rcTempVector@UrcRegion@@@@QEAA@XZ PROC		; rcTempVector<rcRegion>::~rcTempVector<rcRegion>, COMDAT
$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	r8, QWORD PTR [rcx]
	call	?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ; rcVectorBase<rcRegion,1>::destroy_range
	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN13@rcTempVect

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN13@rcTempVect:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$rcTempVector@UrcRegion@@@@QEAA@XZ ENDP		; rcTempVector<rcRegion>::~rcTempVector<rcRegion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcTempVector@UrcRegion@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcTempVector@UrcRegion@@@@QEAAX_K@Z PROC ; rcTempVector<rcRegion>::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$rcTempVector@UrcRegion@@@@QEAAX_K@Z ENDP ; rcTempVector<rcRegion>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1rcRegion@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1rcRegion@@QEAA@XZ PROC				; rcRegion::~rcRegion, COMDAT
$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN15@rcRegion

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN15@rcRegion:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN35@rcRegion

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN35@rcRegion:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1rcRegion@@QEAA@XZ ENDP				; rcRegion::~rcRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRegion.cpp
;	COMDAT ?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z
_TEXT	SEGMENT
minx$ = 24
maxx$ = 32
miny$ = 40
maxy$ = 48
regId$ = 56
chf$ = 64
srcReg$ = 72
?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z PROC ; paintRectRegion, COMDAT

; 1313 : 	for (int y = miny; y < maxy; ++y)

	cmp	r8d, r9d
	jge	$LN29@paintRectR
	push	rsi
	push	r14

; 1312 : 	const int w = chf.width;	

	mov	r10, QWORD PTR chf$[rsp]
	mov	r14d, edx

; 1313 : 	for (int y = miny; y < maxy; ++y)

	mov	QWORD PTR [rsp+24], rbx
	mov	esi, ecx
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+40], rdi
	movsxd	r11, DWORD PTR [r10]
	mov	QWORD PTR [rsp+48], r15
	mov	eax, r11d
	imul	eax, r8d
	mov	r15, r11
	shl	r15, 2
	add	eax, ecx
	movsxd	rdi, eax
	shl	rdi, 2
	sub	r9d, r8d
	mov	r8, QWORD PTR srcReg$[rsp]
	mov	ebp, r9d
	movzx	r9d, WORD PTR regId$[rsp]
$LL4@paintRectR:

; 1314 : 	{
; 1315 : 		for (int x = minx; x < maxx; ++x)

	cmp	esi, r14d
	jge	SHORT $LN2@paintRectR
	mov	ebx, r14d
	mov	r11, rdi
	sub	ebx, esi
	npad	14
$LL7@paintRectR:

; 1316 : 		{
; 1317 : 			const rcCompactCell& c = chf.cells[x+y*w];
; 1318 : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	rax, QWORD PTR [r10+64]
	mov	ecx, DWORD PTR [r11+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	shr	ecx, 24
	lea	edx, DWORD PTR [rax+rcx]
	cmp	rax, rdx
	jae	SHORT $LN5@paintRectR
	npad	6
$LL10@paintRectR:

; 1319 : 			{
; 1320 : 				if (chf.areas[i] != RC_NULL_AREA)

	mov	rcx, QWORD PTR [r10+88]
	cmp	BYTE PTR [rax+rcx], 0
	je	SHORT $LN8@paintRectR

; 1321 : 					srcReg[i] = regId;

	mov	WORD PTR [r8+rax*2], r9w
$LN8@paintRectR:

; 1316 : 		{
; 1317 : 			const rcCompactCell& c = chf.cells[x+y*w];
; 1318 : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	inc	rax
	cmp	rax, rdx
	jl	SHORT $LL10@paintRectR
$LN5@paintRectR:

; 1314 : 	{
; 1315 : 		for (int x = minx; x < maxx; ++x)

	add	r11, 4
	sub	rbx, 1
	jne	SHORT $LL7@paintRectR
$LN2@paintRectR:

; 1313 : 	for (int y = miny; y < maxy; ++y)

	add	rdi, r15
	sub	rbp, 1
	jne	SHORT $LL4@paintRectR
	mov	r15, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+24]

; 1322 : 			}
; 1323 : 		}
; 1324 : 	}
; 1325 : }

	pop	r14
	pop	rsi
$LN29@paintRectR:
	ret	0
?paintRectRegion@@YAXHHHHGAEAUrcCompactHeightfield@@PEAG@Z ENDP ; paintRectRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ PROC ; rcTempVector<`anonymous namespace'::LevelStackEntry>::~rcTempVector<`anonymous namespace'::LevelStackEntry>, COMDAT
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN13@rcTempVect

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN13@rcTempVect:
	add	rsp, 40					; 00000028H
	ret	0
??1?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ ENDP ; rcTempVector<`anonymous namespace'::LevelStackEntry>::~rcTempVector<`anonymous namespace'::LevelStackEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAAX_K@Z PROC ; rcTempVector<`anonymous namespace'::LevelStackEntry>::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAAX_K@Z ENDP ; rcTempVector<`anonymous namespace'::LevelStackEntry>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@UrcRegion@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcTempVector@UrcRegion@@@@QEAA@XZ PROC		; rcTempVector<rcRegion>::rcTempVector<rcRegion>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 308  : 	rcTempVector() : Base() {}

	mov	rax, rcx
	ret	0
??0?$rcTempVector@UrcRegion@@@@QEAA@XZ ENDP		; rcTempVector<rcRegion>::rcTempVector<rcRegion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z PROC ; rcVectorBase<rcRegion,1>::operator[], COMDAT

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	shl	rbx, 6
	add	rbx, QWORD PTR [rdi+16]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@UrcRegion@@$00@@QEAAAEAUrcRegion@@_J@Z ENDP ; rcVectorBase<rcRegion,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ PROC		; rcVectorBase<rcRegion,1>::~rcVectorBase<rcRegion,1>, COMDAT

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	r8, QWORD PTR [rcx]
	call	?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ; rcVectorBase<rcRegion,1>::destroy_range
	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcVectorBa
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	add	rsp, 32					; 00000020H
	pop	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcVectorBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ ENDP		; rcVectorBase<rcRegion,1>::~rcVectorBase<rcRegion,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@UDirtyEntry@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcTempVector@UDirtyEntry@@@@QEAA@XZ PROC		; rcTempVector<DirtyEntry>::rcTempVector<DirtyEntry>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 308  : 	rcTempVector() : Base() {}

	mov	rax, rcx
	ret	0
??0?$rcTempVector@UDirtyEntry@@@@QEAA@XZ ENDP		; rcTempVector<DirtyEntry>::rcTempVector<DirtyEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z PROC ; rcVectorBase<DirtyEntry,1>::operator[], COMDAT

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rax+rbx*8]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@UDirtyEntry@@$00@@QEAAAEAUDirtyEntry@@_J@Z ENDP ; rcVectorBase<DirtyEntry,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?size@?$rcVectorBase@UDirtyEntry@@$00@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$rcVectorBase@UDirtyEntry@@$00@@QEBA_JXZ PROC	; rcVectorBase<DirtyEntry,1>::size, COMDAT

; 145  : 	rcSizeType size() const { return m_size; }

	mov	rax, QWORD PTR [rcx]
	ret	0
?size@?$rcVectorBase@UDirtyEntry@@$00@@QEBA_JXZ ENDP	; rcVectorBase<DirtyEntry,1>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?clear@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXXZ PROC	; rcVectorBase<DirtyEntry,1>::clear, COMDAT

; 140  : 	void clear() { destroy_range(0, m_size); m_size = 0; }

	mov	QWORD PTR [rcx], 0
	ret	0
?clear@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXXZ ENDP	; rcVectorBase<DirtyEntry,1>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ PROC	; rcVectorBase<DirtyEntry,1>::~rcVectorBase<DirtyEntry,1>, COMDAT

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

$LN12:
	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcVectorBa

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcVectorBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	ret	0
??1?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ ENDP	; rcVectorBase<DirtyEntry,1>::~rcVectorBase<DirtyEntry,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ PROC ; rcTempVector<`anonymous namespace'::LevelStackEntry>::rcTempVector<`anonymous namespace'::LevelStackEntry>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 308  : 	rcTempVector() : Base() {}

	mov	rax, rcx
	ret	0
??0?$rcTempVector@ULevelStackEntry@?A0xb2ab97ce@@@@QEAA@XZ ENDP ; rcTempVector<`anonymous namespace'::LevelStackEntry>::rcTempVector<`anonymous namespace'::LevelStackEntry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ
_TEXT	SEGMENT
this$ = 48
?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::back, COMDAT

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN4@back
	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LN4@back
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
$LN4@back:
	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rbx+16]
	lea	rax, QWORD PTR [rax+rcx*4]
	add	rax, -12
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@XZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::operator[], COMDAT

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	mov	rbx, QWORD PTR [rsp+48]
	lea	rax, QWORD PTR [rax+rcx*4]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAAEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::operator[], COMDAT

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	mov	rbx, QWORD PTR [rsp+48]
	lea	rax, QWORD PTR [rax+rcx*4]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBAAEBULevelStackEntry@?A0xb2ab97ce@@_J@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?size@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBA_JXZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::size, COMDAT

; 145  : 	rcSizeType size() const { return m_size; }

	mov	rax, QWORD PTR [rcx]
	ret	0
?size@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEBA_JXZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::pop_back, COMDAT

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN12@pop_back
	cmp	QWORD PTR [rcx], 0
	jg	SHORT $LN4@pop_back
	mov	r8d, 143				; 0000008fH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0L@GHLCMNGA@m_size?5?$DO?50@
	call	rax
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN4@pop_back:

; 155  : 	T& back() { rcAssert(m_size); return m_data[m_size - 1]; }

	test	rax, rax
	je	SHORT $LN12@pop_back
	cmp	QWORD PTR [rbx], 0
	jne	SHORT $LN12@pop_back
	mov	r8d, 155				; 0000009bH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_06MMJKOHHE@m_size@
	call	rax
$LN12@pop_back:

; 143  : 	void pop_back() { rcAssert(m_size > 0); back().~T(); m_size--; }

	dec	QWORD PTR [rbx]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?pop_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?clear@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::clear, COMDAT

; 140  : 	void clear() { destroy_range(0, m_size); m_size = 0; }

	mov	QWORD PTR [rcx], 0
	ret	0
?clear@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXXZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::~rcVectorBase<`anonymous namespace'::LevelStackEntry,1>, COMDAT

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcVectorBa

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcVectorBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	ret	0
??1?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::~rcVectorBase<`anonymous namespace'::LevelStackEntry,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcTempVector@H@@QEAA@XZ PROC			; rcTempVector<int>::rcTempVector<int>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 308  : 	rcTempVector() : Base() {}

	mov	rax, rcx
	ret	0
??0?$rcTempVector@H@@QEAA@XZ ENDP			; rcTempVector<int>::rcTempVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z PROC		; rcVectorBase<int,1>::operator[], COMDAT

; 149  : 	const T& operator[](rcSizeType i) const { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rax+rbx*4]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@H$00@@QEBAAEBH_J@Z ENDP		; rcVectorBase<int,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ PROC		; rcVectorBase<rcRegion,1>::rcVectorBase<rcRegion,1>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$rcVectorBase@UrcRegion@@$00@@QEAA@XZ ENDP		; rcVectorBase<rcRegion,1>::rcVectorBase<rcRegion,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ PROC	; rcVectorBase<DirtyEntry,1>::rcVectorBase<DirtyEntry,1>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$rcVectorBase@UDirtyEntry@@$00@@QEAA@XZ ENDP	; rcVectorBase<DirtyEntry,1>::rcVectorBase<DirtyEntry,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::rcVectorBase<`anonymous namespace'::LevelStackEntry,1>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA@XZ ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::rcVectorBase<`anonymous namespace'::LevelStackEntry,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@H$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$rcVectorBase@H$00@@QEAA@XZ PROC			; rcVectorBase<int,1>::rcVectorBase<int,1>, COMDAT

; 124  : 	rcVectorBase() : m_size(0), m_cap(0), m_data(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$rcVectorBase@H$00@@QEAA@XZ ENDP			; rcVectorBase<int,1>::rcVectorBase<int,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?destroy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAX_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
begin$dead$ = 16
end$dead$ = 24
?destroy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAX_J0@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::destroy_range, COMDAT

; 299  : 	for (rcSizeType i = begin; i < end; i++) {
; 300  : 		m_data[i].~T();
; 301  : 	}
; 302  : }

	ret	0
?destroy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAX_J0@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::destroy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z
_TEXT	SEGMENT
this$ = 48
count$dead$ = 56
?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::reserve, COMDAT

; 171  : bool rcVectorBase<T, H>::reserve(rcSizeType count) {

	push	rbx
	sub	rsp, 32					; 00000020H

; 172  : 	if (count <= m_cap) {

	cmp	QWORD PTR [rcx+8], 256			; 00000100H
	mov	rbx, rcx
	jl	SHORT $LN2@reserve

; 173  : 		return true;

	mov	al, 1

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@reserve:

; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	edx, 256				; 00000100H
	mov	QWORD PTR [rsp+48], rdi
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
	mov	rdi, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	jne	SHORT $LN3@reserve
	mov	rdi, QWORD PTR [rsp+48]

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@reserve:

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN8@reserve

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN8@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rbx+16], rdi

; 182  : 	m_cap = count;
; 183  : 	return true;

	mov	al, 1
	mov	rdi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbx+8], 256			; 00000100H

; 184  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?reserve@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAA_N_J@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z
_TEXT	SEGMENT
this$ = 48
value$ = 56
?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back, COMDAT

; 202  : void rcVectorBase<T, H>::push_back(const T& value) {

	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, rdx

; 203  : 	// rcLikely increases performance by ~50% on BM_rcVector_PushPreallocated,
; 204  : 	// and by ~2-5% on BM_rcVector_Push.
; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN2@push_back

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rcx+rcx*2]
	lea	r9, QWORD PTR [rax+r8*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	r9, r9
	je	$LN1@push_back
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r9+8], eax

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@push_back:
	mov	QWORD PTR [rsp+48], rdi

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR [rsp+56], r14

; 207  : 		return;
; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN12@push_back

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN14@push_back
$LN12@push_back:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN14@push_back:

; 211  : 	T* data = allocate_and_copy(new_cap);

	mov	rdx, rdi
	mov	rcx, rbx
	call	?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy

; 212  : 	// construct between allocate and destroy+free in case value is
; 213  : 	// in this vector.
; 214  : 	construct(data + m_size, value);

	mov	rcx, QWORD PTR [rbx]
	mov	r14, rax
	lea	rdx, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax+rdx*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rax, rax
	je	SHORT $LN18@push_back
	movsd	xmm0, QWORD PTR [rsi]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rsi+8]
	mov	DWORD PTR [rax+8], ecx
$LN18@push_back:

; 215  : 	destroy_range(0, m_size);
; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
	mov	rdi, QWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN23@push_back

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN23@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], r14
	mov	r14, QWORD PTR [rsp+56]
$LN1@push_back:

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?push_back@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@QEAAXAEBULevelStackEntry@?A0xb2ab97ce@@@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?destroy_range@?$rcVectorBase@UDirtyEntry@@$00@@AEAAX_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
begin$dead$ = 16
end$dead$ = 24
?destroy_range@?$rcVectorBase@UDirtyEntry@@$00@@AEAAX_J0@Z PROC ; rcVectorBase<DirtyEntry,1>::destroy_range, COMDAT

; 299  : 	for (rcSizeType i = begin; i < end; i++) {
; 300  : 		m_data[i].~T();
; 301  : 	}
; 302  : }

	ret	0
?destroy_range@?$rcVectorBase@UDirtyEntry@@$00@@AEAAX_J0@Z ENDP ; rcVectorBase<DirtyEntry,1>::destroy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z
_TEXT	SEGMENT
this$ = 48
value$ = 56
?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z PROC ; rcVectorBase<DirtyEntry,1>::push_back, COMDAT

; 202  : void rcVectorBase<T, H>::push_back(const T& value) {

$LN63:
	mov	QWORD PTR [rsp+24], rbx
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	r14, rdx

; 203  : 	// rcLikely increases performance by ~50% on BM_rcVector_PushPreallocated,
; 204  : 	// and by ~2-5% on BM_rcVector_Push.
; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN2@push_back

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rax+rcx*8]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	r8, r8
	je	$LN1@push_back
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@push_back:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi

; 207  : 		return;
; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN12@push_back

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN14@push_back
$LN12@push_back:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN14@push_back:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN19@push_back
	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN19@push_back
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN19@push_back:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN30@push_back

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN30@push_back

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL31@push_back:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN29@push_back
	mov	rax, QWORD PTR [r8+rcx]
	mov	QWORD PTR [rcx], rax
$LN29@push_back:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 8
	sub	rdx, 1
	jne	SHORT $LL31@push_back
$LN30@push_back:

; 211  : 	T* data = allocate_and_copy(new_cap);
; 212  : 	// construct between allocate and destroy+free in case value is
; 213  : 	// in this vector.
; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*8]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN39@push_back
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rcx], rax
$LN39@push_back:

; 215  : 	destroy_range(0, m_size);
; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
	mov	rdi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN44@push_back

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN44@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
	mov	rsi, QWORD PTR [rsp+48]
$LN1@push_back:

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?push_back@?$rcVectorBase@UDirtyEntry@@$00@@QEAAXAEBUDirtyEntry@@@Z ENDP ; rcVectorBase<DirtyEntry,1>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z
_TEXT	SEGMENT
this$ = 48
begin$dead$ = 56
end$ = 64
?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z PROC ; rcVectorBase<rcRegion,1>::destroy_range, COMDAT

; 298  : void rcVectorBase<T, H>::destroy_range(rcSizeType begin, rcSizeType end) {

$LN51:

; 299  : 	for (rcSizeType i = begin; i < end; i++) {

	test	r8, r8
	jle	SHORT $LN48@destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 298  : void rcVectorBase<T, H>::destroy_range(rcSizeType begin, rcSizeType end) {

	mov	rdi, r8
	mov	rbp, rcx

; 299  : 	for (rcSizeType i = begin; i < end; i++) {

	xor	ebx, ebx
$LL4@destroy_ra:

; 300  : 		m_data[i].~T();

	mov	rsi, QWORD PTR [rbp+16]

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rsi+rbx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN24@destroy_ra

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN24@destroy_ra:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rsi+rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN40@destroy_ra

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN40@destroy_ra:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 299  : 	for (rcSizeType i = begin; i < end; i++) {

	add	rbx, 64					; 00000040H
	sub	rdi, 1
	jne	SHORT $LL4@destroy_ra

; 301  : 	}
; 302  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN48@destroy_ra:
	ret	0
?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ENDP ; rcVectorBase<rcRegion,1>::destroy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z
_TEXT	SEGMENT
this$ = 48
count$ = 56
?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z PROC	; rcVectorBase<rcRegion,1>::reserve, COMDAT

; 171  : bool rcVectorBase<T, H>::reserve(rcSizeType count) {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 172  : 	if (count <= m_cap) {

	cmp	rdx, QWORD PTR [rcx+8]
	jg	SHORT $LN2@reserve

; 173  : 		return true;

	mov	al, 1

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@reserve:
	mov	QWORD PTR [rsp+48], rsi

; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	call	?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z ; rcVectorBase<rcRegion,1>::allocate_and_copy
	mov	rsi, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	jne	SHORT $LN3@reserve
	mov	rsi, QWORD PTR [rsp+48]

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@reserve:

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);

	mov	r8, QWORD PTR [rbx]
	mov	rcx, rbx
	call	?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ; rcVectorBase<rcRegion,1>::destroy_range

; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN8@reserve

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN8@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rbx+16], rsi

; 182  : 	m_cap = count;
; 183  : 	return true;

	mov	al, 1
	mov	rsi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbx+8], rdi

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$rcVectorBase@UrcRegion@@$00@@QEAA_N_J@Z ENDP	; rcVectorBase<rcRegion,1>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 80
p$ = 80
this$ = 80
value$ = 88
$T4 = 96
$T5 = 96
?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z PROC ; rcVectorBase<rcRegion,1>::push_back, COMDAT

; 202  : void rcVectorBase<T, H>::push_back(const T& value) {

$LN39:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rbx, rcx

; 203  : 	// rcLikely increases performance by ~50% on BM_rcVector_PushPreallocated,
; 204  : 	// and by ~2-5% on BM_rcVector_Push.
; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN2@push_back

; 206  : 		construct(m_data + m_size++, value);

	mov	rdi, rcx
	shl	rdi, 6
	add	rdi, QWORD PTR [rbx+16]
	mov	QWORD PTR $T3[rsp], rdi
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	QWORD PTR $T5[rsp], rdi
	je	SHORT $LN6@push_back
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rdi], eax
	movzx	eax, WORD PTR [rdx+4]
	mov	WORD PTR [rdi+4], ax
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rdi+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rdi+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rdi+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rdi+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rdi+10], al
	movzx	eax, WORD PTR [rdx+12]
	mov	WORD PTR [rdi+12], ax
	movzx	eax, WORD PTR [rdx+14]
	mov	WORD PTR [rdi+14], ax
	lea	rcx, QWORD PTR [rdi+16]
	add	rdx, 16
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rsi+40]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
$LN6@push_back:

; 207  : 		return;

	jmp	$LN1@push_back
$LN2@push_back:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rbp, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN17@push_back

; 226  : 		return RC_SIZE_MAX;

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN19@push_back
$LN17@push_back:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rbp
	cmovg	rbp, rax
$LN19@push_back:

; 211  : 	T* data = allocate_and_copy(new_cap);

	mov	rdx, rbp
	mov	rcx, rbx
	call	?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z ; rcVectorBase<rcRegion,1>::allocate_and_copy
	mov	r14, rax

; 212  : 	// construct between allocate and destroy+free in case value is
; 213  : 	// in this vector.
; 214  : 	construct(data + m_size, value);

	mov	rdi, QWORD PTR [rbx]
	shl	rdi, 6
	add	rdi, rax
	mov	QWORD PTR p$[rsp], rdi

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	QWORD PTR $T4[rsp], rdi
	je	SHORT $LN23@push_back
	mov	ecx, DWORD PTR [rsi]
	mov	DWORD PTR [rdi], ecx
	movzx	ecx, WORD PTR [rsi+4]
	mov	WORD PTR [rdi+4], cx
	movzx	eax, BYTE PTR [rsi+6]
	mov	BYTE PTR [rdi+6], al
	movzx	eax, BYTE PTR [rsi+7]
	mov	BYTE PTR [rdi+7], al
	movzx	eax, BYTE PTR [rsi+8]
	mov	BYTE PTR [rdi+8], al
	movzx	eax, BYTE PTR [rsi+9]
	mov	BYTE PTR [rdi+9], al
	movzx	eax, BYTE PTR [rsi+10]
	mov	BYTE PTR [rdi+10], al
	movzx	eax, WORD PTR [rsi+12]
	mov	WORD PTR [rdi+12], ax
	movzx	eax, WORD PTR [rsi+14]
	mov	WORD PTR [rdi+14], ax
	lea	rcx, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rsi+16]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rsi+40]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
$LN23@push_back:

; 215  : 	destroy_range(0, m_size);

	mov	r8, QWORD PTR [rbx]
	mov	rcx, rbx
	call	?destroy_range@?$rcVectorBase@UrcRegion@@$00@@AEAAX_J0@Z ; rcVectorBase<rcRegion,1>::destroy_range

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;

	mov	QWORD PTR [rbx+8], rbp

; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN33@push_back

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN33@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], r14
$LN1@push_back:

; 220  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z ENDP ; rcVectorBase<rcRegion,1>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 80
p$ = 80
this$ = 80
value$ = 88
$T4 = 96
$T5 = 96
?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR $T3[rbp]
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAXAEBUrcNewTag@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 80
p$ = 80
this$ = 80
value$ = 88
$T4 = 96
$T5 = 96
?dtor$1@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$1
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$1@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 80
p$ = 80
this$ = 80
value$ = 88
$T4 = 96
$T5 = 96
?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR p$[rbp]
	lea	rdx, QWORD PTR $T2[rbp]
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAXAEBUrcNewTag@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
$T3 = 80
p$ = 80
this$ = 80
value$ = 88
$T4 = 96
$T5 = 96
?dtor$4@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$4
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$4@?0??push_back@?$rcVectorBase@UrcRegion@@$00@@QEAAXAEBUrcRegion@@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::push_back'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcSwap@PEAG@@YAXAEAPEAG0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcSwap@PEAG@@YAXAEAPEAG0@Z PROC			; rcSwap<unsigned short *>, COMDAT

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rdx], r8
	ret	0
??$rcSwap@PEAG@@YAXAEAPEAG0@Z ENDP			; rcSwap<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??_GrcRegion@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GrcRegion@@QEAAPEAXI@Z PROC				; rcRegion::`scalar deleting destructor', COMDAT
$LN42:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN19@scalar

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN19@scalar:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN39@scalar

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN39@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GrcRegion@@QEAAPEAXI@Z ENDP				; rcRegion::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z
_TEXT	SEGMENT
$T1 = 32
p$ = 64
v$ = 72
$T2 = 80
?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z PROC ; rcVectorBase<rcRegion,1>::construct, COMDAT

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR $T2[rsp], rcx
	test	rcx, rcx
	je	SHORT $LN10@construct
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR [rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, WORD PTR [rdx+12]
	mov	WORD PTR [rcx+12], ax
	movzx	eax, WORD PTR [rdx+14]
	mov	WORD PTR [rcx+14], ax
	add	rcx, 16
	add	rdx, 16
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rdi+40]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
$LN10@construct:
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z ENDP ; rcVectorBase<rcRegion,1>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
p$ = 64
v$ = 72
$T2 = 80
?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::construct'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR p$[rbp]
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXAEBUrcNewTag@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::construct'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
p$ = 64
v$ = 72
$T2 = 80
?dtor$1@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::construct'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$1@?0??construct@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@AEBU2@@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::construct'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@AEBU2@@Z
_TEXT	SEGMENT
p$ = 8
v$ = 16
?construct@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@AEBU2@@Z PROC ; rcVectorBase<DirtyEntry,1>::construct, COMDAT

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN3@construct
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@construct:
	ret	0
?construct@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@AEBU2@@Z ENDP ; rcVectorBase<DirtyEntry,1>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@AEBU23@@Z
_TEXT	SEGMENT
p$ = 8
v$ = 16
?construct@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@AEBU23@@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::construct, COMDAT

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN3@construct
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
$LN3@construct:
	ret	0
?construct@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@AEBU23@@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0rcRegion@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0rcRegion@@QEAA@AEBU0@@Z PROC				; rcRegion::rcRegion, COMDAT
$LN7:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR [rdx+4]
	mov	WORD PTR [rcx+4], ax
	movzx	eax, BYTE PTR [rdx+6]
	mov	BYTE PTR [rcx+6], al
	movzx	eax, BYTE PTR [rdx+7]
	mov	BYTE PTR [rcx+7], al
	movzx	eax, BYTE PTR [rdx+8]
	mov	BYTE PTR [rcx+8], al
	movzx	eax, BYTE PTR [rdx+9]
	mov	BYTE PTR [rcx+9], al
	movzx	eax, BYTE PTR [rdx+10]
	mov	BYTE PTR [rcx+10], al
	movzx	eax, WORD PTR [rdx+12]
	mov	WORD PTR [rcx+12], ax
	movzx	eax, WORD PTR [rdx+14]
	mov	WORD PTR [rcx+14], ax
	add	rcx, 16
	add	rdx, 16
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rbx+40]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0rcRegion@@QEAA@AEBU0@@Z ENDP				; rcRegion::rcRegion
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
__that$ = 56
?dtor$0@?0???0rcRegion@@QEAA@AEBU0@@Z@4HA PROC		; `rcRegion::rcRegion'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$0@?0???0rcRegion@@QEAA@AEBU0@@Z@4HA ENDP		; `rcRegion::rcRegion'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0rcIntArray@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0rcIntArray@@QEAA@AEBV0@@Z PROC			; rcIntArray::rcIntArray, COMDAT
$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	xor	edi, edi
	mov	rsi, rcx
	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi

; 162  : 	const T* end() const { return m_data + m_size; }

	mov	rbp, QWORD PTR [rdx]

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	mov	r14, QWORD PTR [rdx+16]

; 196  : 	clear();

	mov	QWORD PTR [rcx], rdi

; 172  : 	if (count <= m_cap) {

	test	rbp, rbp
	jle	SHORT $LN13@rcIntArray

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	rdx, rbp
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN13@rcIntArray

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rsi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN20@rcIntArray

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN20@rcIntArray:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rsi+16], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR [rsi+8], rbp
	mov	QWORD PTR [rsi], rbp
	jmp	SHORT $LN37@rcIntArray
$LN13@rcIntArray:

; 199  : 	copy_range(m_data, begin, end);

	mov	rbx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi], rbp

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rbp, rbp
	jle	SHORT $LN38@rcIntArray
$LN37@rcIntArray:

; 198  : 	m_size = end - begin;

	sub	r14, rbx
$LL27@rcIntArray:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rbx, rbx
	je	SHORT $LN25@rcIntArray
	mov	eax, DWORD PTR [r14+rbx]
	mov	DWORD PTR [rbx], eax
$LN25@rcIntArray:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	inc	rdi
	add	rbx, 4
	cmp	rdi, rbp
	jl	SHORT $LL27@rcIntArray
$LN38@rcIntArray:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??0rcIntArray@@QEAA@AEBV0@@Z ENDP			; rcIntArray::rcIntArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@H@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0?$rcTempVector@H@@QEAA@AEBV0@@Z PROC			; rcTempVector<int>::rcTempVector<int>, COMDAT

; 311  : 	rcTempVector(const rcTempVector<T>& other) : Base(other) {}

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	xor	edi, edi

; 311  : 	rcTempVector(const rcTempVector<T>& other) : Base(other) {}

	mov	rsi, rcx

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi

; 162  : 	const T* end() const { return m_data + m_size; }

	mov	rbp, QWORD PTR [rdx]

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	mov	r14, QWORD PTR [rdx+16]

; 196  : 	clear();

	mov	QWORD PTR [rcx], rdi

; 172  : 	if (count <= m_cap) {

	test	rbp, rbp
	jle	SHORT $LN10@rcTempVect

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	rdx, rbp
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN10@rcTempVect

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rsi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN17@rcTempVect

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN17@rcTempVect:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rsi+16], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR [rsi+8], rbp
	mov	QWORD PTR [rsi], rbp
	jmp	SHORT $LN34@rcTempVect
$LN10@rcTempVect:

; 199  : 	copy_range(m_data, begin, end);

	mov	rbx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi], rbp

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rbp, rbp
	jle	SHORT $LN35@rcTempVect
$LN34@rcTempVect:

; 198  : 	m_size = end - begin;

	sub	r14, rbx
$LL24@rcTempVect:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rbx, rbx
	je	SHORT $LN22@rcTempVect
	mov	eax, DWORD PTR [r14+rbx]
	mov	DWORD PTR [rbx], eax
$LN22@rcTempVect:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	inc	rdi
	add	rbx, 4
	cmp	rdi, rbp
	jl	SHORT $LL24@rcTempVect
$LN35@rcTempVect:

; 311  : 	rcTempVector(const rcTempVector<T>& other) : Base(other) {}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??0?$rcTempVector@H@@QEAA@AEBV0@@Z ENDP			; rcTempVector<int>::rcTempVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z PROC		; rcVectorBase<int,1>::rcVectorBase<int,1>, COMDAT

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	xor	edi, edi
	mov	rsi, rcx
	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi

; 162  : 	const T* end() const { return m_data + m_size; }

	mov	rbp, QWORD PTR [rdx]

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	mov	r14, QWORD PTR [rdx+16]

; 172  : 	if (count <= m_cap) {

	test	rbp, rbp
	jle	SHORT $LN7@rcVectorBa

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	rdx, rbp
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	rbx, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN7@rcVectorBa

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rsi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN14@rcVectorBa

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN14@rcVectorBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rsi+16], rbx

; 182  : 	m_cap = count;

	mov	QWORD PTR [rsi+8], rbp
	mov	QWORD PTR [rsi], rbp
	jmp	SHORT $LN31@rcVectorBa
$LN7@rcVectorBa:

; 199  : 	copy_range(m_data, begin, end);

	mov	rbx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsi], rbp

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rbp, rbp
	jle	SHORT $LN32@rcVectorBa
$LN31@rcVectorBa:

; 198  : 	m_size = end - begin;

	sub	r14, rbx
$LL21@rcVectorBa:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rbx, rbx
	je	SHORT $LN19@rcVectorBa
	mov	eax, DWORD PTR [r14+rbx]
	mov	DWORD PTR [rbx], eax
$LN19@rcVectorBa:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	inc	rdi
	add	rbx, 4
	cmp	rdi, rbp
	jl	SHORT $LL21@rcVectorBa
$LN32@rcVectorBa:

; 125  : 	rcVectorBase(const rcVectorBase<T, H>& other) : m_size(0), m_cap(0), m_data(0) { assign(other.begin(), other.end()); }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??0?$rcVectorBase@H$00@@QEAA@AEBV0@@Z ENDP		; rcVectorBase<int,1>::rcVectorBase<int,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?end@?$rcVectorBase@H$00@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?end@?$rcVectorBase@H$00@@QEBAPEBHXZ PROC		; rcVectorBase<int,1>::end, COMDAT

; 162  : 	const T* end() const { return m_data + m_size; }

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rax+rdx*4]
	ret	0
?end@?$rcVectorBase@H$00@@QEBAPEBHXZ ENDP		; rcVectorBase<int,1>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?begin@?$rcVectorBase@H$00@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$rcVectorBase@H$00@@QEBAPEBHXZ PROC		; rcVectorBase<int,1>::begin, COMDAT

; 161  : 	const T* begin() const { return m_data; }

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?begin@?$rcVectorBase@H$00@@QEBAPEBHXZ ENDP		; rcVectorBase<int,1>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z
_TEXT	SEGMENT
this$ = 48
begin$ = 56
end$ = 64
?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z PROC		; rcVectorBase<int,1>::assign, COMDAT

; 195  : void rcVectorBase<T, H>::assign(const T* begin, const T* end) {

$LN34:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	QWORD PTR [rsp+56], rdi

; 196  : 	clear();
; 197  : 	reserve(end - begin);

	sub	rbx, rdx
	mov	QWORD PTR [rcx], 0
	sar	rbx, 2
	mov	rsi, rdx
	mov	rdi, rcx

; 172  : 	if (count <= m_cap) {

	cmp	rbx, QWORD PTR [rcx+8]
	jle	SHORT $LN3@assign

; 173  : 		return true;
; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	mov	rdx, rbx
	mov	QWORD PTR [rsp+48], rbp
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	rbp, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	je	SHORT $LN32@assign

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN10@assign

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN10@assign:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rdi+16], rbp

; 182  : 	m_cap = count;

	mov	QWORD PTR [rdi+8], rbx
$LN32@assign:
	mov	rbp, QWORD PTR [rsp+48]
$LN3@assign:

; 199  : 	copy_range(m_data, begin, end);

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rdi], rbx
	mov	rdi, QWORD PTR [rsp+56]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rbx, rbx
	jle	SHORT $LN16@assign

; 198  : 	m_size = end - begin;

	sub	rsi, rax
$LL17@assign:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rax, rax
	je	SHORT $LN15@assign
	mov	ecx, DWORD PTR [rsi+rax]
	mov	DWORD PTR [rax], ecx
$LN15@assign:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rax, 4
	sub	rbx, 1
	jne	SHORT $LL17@assign
$LN16@assign:

; 200  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?assign@?$rcVectorBase@H$00@@QEAAXPEBH0@Z ENDP		; rcVectorBase<int,1>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy, COMDAT

; 186  : T* rcVectorBase<T, H>::allocate_and_copy(rcSizeType size) {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@allocate_a
	mov	rcx, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdx, rcx
	jle	SHORT $LN4@allocate_a
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN4@allocate_a:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rbx+rbx*2]
	shl	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN15@allocate_a

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rdi]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r9, QWORD PTR [rdi+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN15@allocate_a

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r9, rax
	npad	7
$LL16@allocate_a:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN14@allocate_a
	movsd	xmm0, QWORD PTR [r9+rcx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [r9+rcx+8]
	mov	DWORD PTR [rcx+8], eax
$LN14@allocate_a:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 12
	sub	rdx, 1
	jne	SHORT $LL16@allocate_a

; 191  : 	}
; 192  : 	return new_data;

	mov	rax, r8
$LN15@allocate_a:

; 193  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?allocate_and_copy@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAAPEAULevelStackEntry@?A0xb2ab97ce@@_J@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::allocate_and_copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?get_new_capacity@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAA_J_J@Z
_TEXT	SEGMENT
this$ = 8
min_capacity$ = 16
?get_new_capacity@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAA_J_J@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::get_new_capacity, COMDAT

; 224  : 	rcAssert(min_capacity <= RC_SIZE_MAX);
; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, QWORD PTR [rcx+8]
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN5@get_new_ca

; 226  : 		return RC_SIZE_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 228  : }

	ret	0
$LN5@get_new_ca:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdx
	cmovg	rdx, rax
	mov	rax, rdx

; 228  : }

	ret	0
?get_new_capacity@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@AEAA_J_J@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::get_new_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z PROC ; rcVectorBase<DirtyEntry,1>::allocate_and_copy, COMDAT

; 186  : T* rcVectorBase<T, H>::allocate_and_copy(rcSizeType size) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdi, rdx
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN4@allocate_a
	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdx, rcx
	jle	SHORT $LN4@allocate_a
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN4@allocate_a:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN15@allocate_a

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r9, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN15@allocate_a

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r9, rax
	npad	7
$LL16@allocate_a:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN14@allocate_a
	mov	rax, QWORD PTR [r9+rcx]
	mov	QWORD PTR [rcx], rax
$LN14@allocate_a:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 8
	sub	rdx, 1
	jne	SHORT $LL16@allocate_a

; 191  : 	}
; 192  : 	return new_data;

	mov	rax, r8
$LN15@allocate_a:

; 193  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?allocate_and_copy@?$rcVectorBase@UDirtyEntry@@$00@@AEAAPEAUDirtyEntry@@_J@Z ENDP ; rcVectorBase<DirtyEntry,1>::allocate_and_copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?get_new_capacity@?$rcVectorBase@UDirtyEntry@@$00@@AEAA_J_J@Z
_TEXT	SEGMENT
this$ = 8
min_capacity$ = 16
?get_new_capacity@?$rcVectorBase@UDirtyEntry@@$00@@AEAA_J_J@Z PROC ; rcVectorBase<DirtyEntry,1>::get_new_capacity, COMDAT

; 224  : 	rcAssert(min_capacity <= RC_SIZE_MAX);
; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, QWORD PTR [rcx+8]
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN5@get_new_ca

; 226  : 		return RC_SIZE_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 228  : }

	ret	0
$LN5@get_new_ca:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdx
	cmovg	rdx, rax
	mov	rax, rdx

; 228  : }

	ret	0
?get_new_capacity@?$rcVectorBase@UDirtyEntry@@$00@@AEAA_J_J@Z ENDP ; rcVectorBase<DirtyEntry,1>::get_new_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
p$ = 88
size$ = 88
$T2 = 96
?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z PROC ; rcVectorBase<rcRegion,1>::allocate_and_copy, COMDAT

; 186  : T* rcVectorBase<T, H>::allocate_and_copy(rcSizeType size) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx
	mov	rdi, rcx

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN4@allocate_a
	mov	rcx, 144115188075855871			; 01ffffffffffffffH
	cmp	rdx, rcx
	jle	SHORT $LN4@allocate_a
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN4@allocate_a:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	shl	rbx, 6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	$LN15@allocate_a

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rsi, QWORD PTR [rdi+16]
	mov	rdi, QWORD PTR [rdi]
	shl	rdi, 6

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sar	rdi, 6
	test	rdi, rdi
	jle	$LN15@allocate_a

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	lea	rbx, QWORD PTR [rax+4]
	sub	rsi, rax
	npad	5
$LL16@allocate_a:

; 294  : 		construct(dst + i, begin[i]);

	lea	rcx, QWORD PTR [rbx-4]
	mov	QWORD PTR p$[rsp], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	QWORD PTR $T2[rsp], rcx
	test	rcx, rcx
	je	SHORT $LN20@allocate_a
	mov	eax, DWORD PTR [rsi+rbx-4]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR [rsi+rbx]
	mov	WORD PTR [rbx], ax
	movzx	eax, BYTE PTR [rsi+rbx+2]
	mov	BYTE PTR [rbx+2], al
	movzx	eax, BYTE PTR [rsi+rbx+3]
	mov	BYTE PTR [rbx+3], al
	movzx	eax, BYTE PTR [rsi+rbx+4]
	mov	BYTE PTR [rbx+4], al
	movzx	eax, BYTE PTR [rsi+rbx+5]
	mov	BYTE PTR [rbx+5], al
	movzx	eax, BYTE PTR [rsi+rbx+6]
	mov	BYTE PTR [rbx+6], al
	movzx	eax, WORD PTR [rsi+rbx+8]
	mov	WORD PTR [rbx+8], ax
	movzx	eax, WORD PTR [rsi+rbx+10]
	mov	WORD PTR [rbx+10], ax
	lea	rdx, QWORD PTR [rsi+12]
	add	rdx, rbx
	lea	rcx, QWORD PTR [rbx+12]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rdx, QWORD PTR [rsi+36]
	add	rdx, rbx
	lea	rcx, QWORD PTR [rbx+36]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
$LN20@allocate_a:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rbx, 64					; 00000040H
	sub	rdi, 1
	jne	$LL16@allocate_a

; 191  : 	}
; 192  : 	return new_data;

	mov	rax, rbp
$LN15@allocate_a:

; 193  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z ENDP ; rcVectorBase<rcRegion,1>::allocate_and_copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
p$ = 88
size$ = 88
$T2 = 96
?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::allocate_and_copy'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR p$[rbp]
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXAEBUrcNewTag@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::allocate_and_copy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
p$ = 88
size$ = 88
$T2 = 96
?dtor$1@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::allocate_and_copy'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$1@?0??allocate_and_copy@?$rcVectorBase@UrcRegion@@$00@@AEAAPEAUrcRegion@@_J@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::allocate_and_copy'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?get_new_capacity@?$rcVectorBase@UrcRegion@@$00@@AEAA_J_J@Z
_TEXT	SEGMENT
this$ = 8
min_capacity$ = 16
?get_new_capacity@?$rcVectorBase@UrcRegion@@$00@@AEAA_J_J@Z PROC ; rcVectorBase<rcRegion,1>::get_new_capacity, COMDAT

; 224  : 	rcAssert(min_capacity <= RC_SIZE_MAX);
; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, QWORD PTR [rcx+8]
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN5@get_new_ca

; 226  : 		return RC_SIZE_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 228  : }

	ret	0
$LN5@get_new_ca:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdx
	cmovg	rdx, rax
	mov	rax, rdx

; 228  : }

	ret	0
?get_new_capacity@?$rcVectorBase@UrcRegion@@$00@@AEAA_J_J@Z ENDP ; rcVectorBase<rcRegion,1>::get_new_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z
_TEXT	SEGMENT
this$ = 48
count$ = 56
?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z PROC		; rcVectorBase<int,1>::reserve, COMDAT

; 171  : bool rcVectorBase<T, H>::reserve(rcSizeType count) {

$LN17:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 172  : 	if (count <= m_cap) {

	cmp	rdx, QWORD PTR [rcx+8]
	jg	SHORT $LN2@reserve

; 173  : 		return true;

	mov	al, 1

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@reserve:
	mov	QWORD PTR [rsp+48], rsi

; 174  : 	}
; 175  : 	T* new_data = allocate_and_copy(count);

	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	rsi, rax

; 176  : 	if (!new_data) {

	test	rax, rax
	jne	SHORT $LN3@reserve
	mov	rsi, QWORD PTR [rsp+48]

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@reserve:

; 177  : 	  return false;
; 178  : 	}
; 179  : 	destroy_range(0, m_size);
; 180  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN8@reserve

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN8@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 181  : 	m_data = new_data;

	mov	QWORD PTR [rbx+16], rsi

; 182  : 	m_cap = count;
; 183  : 	return true;

	mov	al, 1
	mov	rsi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbx+8], rdi

; 184  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$rcVectorBase@H$00@@QEAA_N_J@Z ENDP		; rcVectorBase<int,1>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?copy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@PEBU23@1@Z
_TEXT	SEGMENT
dst$ = 8
begin$ = 16
end$ = 24
?copy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@PEBU23@1@Z PROC ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::copy_range, COMDAT

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	r8, rdx
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	r8, 2
	imul	r8, rax
	test	r8, r8
	jle	SHORT $LN3@copy_range
	sub	rdx, rcx
	npad	3
$LL4@copy_range:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN2@copy_range
	movsd	xmm0, QWORD PTR [rdx+rcx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+rcx+8]
	mov	DWORD PTR [rcx+8], eax
$LN2@copy_range:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 12
	sub	r8, 1
	jne	SHORT $LL4@copy_range
$LN3@copy_range:

; 294  : 		construct(dst + i, begin[i]);
; 295  : 	}
; 296  : }

	ret	0
?copy_range@?$rcVectorBase@ULevelStackEntry@?A0xb2ab97ce@@$00@@CAXPEAULevelStackEntry@?A0xb2ab97ce@@PEBU23@1@Z ENDP ; rcVectorBase<`anonymous namespace'::LevelStackEntry,1>::copy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?copy_range@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@PEBU2@1@Z
_TEXT	SEGMENT
dst$ = 8
begin$ = 16
end$ = 24
?copy_range@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@PEBU2@1@Z PROC ; rcVectorBase<DirtyEntry,1>::copy_range, COMDAT

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	r8, rdx
	sar	r8, 3
	test	r8, r8
	jle	SHORT $LN3@copy_range
	sub	rdx, rcx
	npad	1
$LL4@copy_range:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN2@copy_range
	mov	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR [rcx], rax
$LN2@copy_range:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 8
	sub	r8, 1
	jne	SHORT $LL4@copy_range
$LN3@copy_range:

; 294  : 		construct(dst + i, begin[i]);
; 295  : 	}
; 296  : }

	ret	0
?copy_range@?$rcVectorBase@UDirtyEntry@@$00@@CAXPEAUDirtyEntry@@PEBU2@1@Z ENDP ; rcVectorBase<DirtyEntry,1>::copy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z
_TEXT	SEGMENT
$T1 = 32
dst$ = 64
p$ = 72
begin$ = 72
$T2 = 80
end$ = 80
?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z PROC ; rcVectorBase<rcRegion,1>::copy_range, COMDAT

; 292  : void rcVectorBase<T, H>::copy_range(T* dst, const T* begin, const T* end) {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rsi, rdx

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	rdi, rdx
	sar	rdi, 6
	test	rdi, rdi
	jle	$LN3@copy_range
	lea	rbx, QWORD PTR [rcx+4]
	sub	rsi, rcx
	npad	4
$LL4@copy_range:

; 294  : 		construct(dst + i, begin[i]);

	lea	rcx, QWORD PTR [rbx-4]
	mov	QWORD PTR p$[rsp], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	mov	QWORD PTR $T2[rsp], rcx
	test	rcx, rcx
	je	SHORT $LN8@copy_range
	mov	eax, DWORD PTR [rsi+rbx-4]
	mov	DWORD PTR [rcx], eax
	movzx	eax, WORD PTR [rsi+rbx]
	mov	WORD PTR [rbx], ax
	movzx	eax, BYTE PTR [rsi+rbx+2]
	mov	BYTE PTR [rbx+2], al
	movzx	eax, BYTE PTR [rsi+rbx+3]
	mov	BYTE PTR [rbx+3], al
	movzx	eax, BYTE PTR [rsi+rbx+4]
	mov	BYTE PTR [rbx+4], al
	movzx	eax, BYTE PTR [rsi+rbx+5]
	mov	BYTE PTR [rbx+5], al
	movzx	eax, BYTE PTR [rsi+rbx+6]
	mov	BYTE PTR [rbx+6], al
	movzx	eax, WORD PTR [rsi+rbx+8]
	mov	WORD PTR [rbx+8], ax
	movzx	eax, WORD PTR [rsi+rbx+10]
	mov	WORD PTR [rbx+10], ax
	lea	rdx, QWORD PTR [rsi+12]
	add	rdx, rbx
	lea	rcx, QWORD PTR [rbx+12]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
	lea	rdx, QWORD PTR [rsi+36]
	add	rdx, rbx
	lea	rcx, QWORD PTR [rbx+36]
	call	??0rcIntArray@@QEAA@AEBV0@@Z
	npad	1
$LN8@copy_range:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rbx, 64					; 00000040H
	sub	rdi, 1
	jne	$LL4@copy_range
$LN3@copy_range:

; 295  : 	}
; 296  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z ENDP ; rcVectorBase<rcRegion,1>::copy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
dst$ = 64
p$ = 72
begin$ = 72
$T2 = 80
end$ = 80
?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::copy_range'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	r8, QWORD PTR p$[rbp]
	lea	rdx, QWORD PTR $T1[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAXAEBUrcNewTag@@0@Z		; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::copy_range'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
dst$ = 64
p$ = 72
begin$ = 72
$T2 = 80
end$ = 80
?dtor$1@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA PROC ; `rcVectorBase<rcRegion,1>::copy_range'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 16
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$1@?0??copy_range@?$rcVectorBase@UrcRegion@@$00@@CAXPEAUrcRegion@@PEBU2@1@Z@4HA ENDP ; `rcVectorBase<rcRegion,1>::copy_range'::`1'::dtor$1
text$x	ENDS
END
