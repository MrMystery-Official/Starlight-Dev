; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@DPJHMNHK@inVertsCount?5?$DM?$DN?512@	; `string'
PUBLIC	??_C@_0BK@NCDOIBNH@rcAddSpan?3?5Out?5of?5memory?4@ ; `string'
PUBLIC	??_C@_0HD@IMPAODNN@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0CF@GMPBBABG@rcRasterizeTriangles?3?5Out?5of?5me@ ; `string'
PUBLIC	??_C@_0CE@NAJOGMKP@rcRasterizeTriangle?3?5Out?5of?5mem@ ; `string'
;	COMDAT ??_C@_0CE@NAJOGMKP@rcRasterizeTriangle?3?5Out?5of?5mem@
CONST	SEGMENT
??_C@_0CE@NAJOGMKP@rcRasterizeTriangle?3?5Out?5of?5mem@ DB 'rcRasterizeTr'
	DB	'iangle: Out of memory.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GMPBBABG@rcRasterizeTriangles?3?5Out?5of?5me@
CONST	SEGMENT
??_C@_0CF@GMPBBABG@rcRasterizeTriangles?3?5Out?5of?5me@ DB 'rcRasterizeTr'
	DB	'iangles: Out of memory.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@IMPAODNN@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0HD@IMPAODNN@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastRasterization.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NCDOIBNH@rcAddSpan?3?5Out?5of?5memory?4@
CONST	SEGMENT
??_C@_0BK@NCDOIBNH@rcAddSpan?3?5Out?5of?5memory?4@ DB 'rcAddSpan: Out of '
	DB	'memory.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DPJHMNHK@inVertsCount?5?$DM?$DN?512@
CONST	SEGMENT
??_C@_0BD@DPJHMNHK@inVertsCount?5?$DM?$DN?512@ DB 'inVertsCount <= 12', 00H ; `string'
PUBLIC	??$rcSwap@PEAM@@YAXAEAPEAM0@Z			; rcSwap<float *>
PUBLIC	??$rcMax@I@@YAIII@Z				; rcMax<unsigned int>
PUBLIC	?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z ; rcRasterizeTriangles
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z DD imagerel ?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z
	DD	imagerel ?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z+1297
	DD	imagerel $unwind$?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+259
	DD	imagerel $unwind$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+259
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+630
	DD	imagerel $chain$2$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+630
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+657
	DD	imagerel $chain$3$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z DD imagerel ?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z
	DD	imagerel ?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z+554
	DD	imagerel $unwind$?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z DD imagerel ?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z
	DD	imagerel ?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z+114
	DD	imagerel $unwind$?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z DD imagerel $LN37
	DD	imagerel $LN37+408
	DD	imagerel $unwind$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z DB 0aH
	DB	0aaH
	DB	00H
	DB	'H'
	DB	02H
	DB	0fdH, 02H
	DB	06H
	DB	'2'
	DB	00H
	DB	'z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z DB 06H
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	0c0H
	DB	038H
	DB	046H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z
	DD	imagerel $ip2state$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z DD 0112711H
	DD	077827H
	DD	086823H
	DD	01a641fH
	DD	019541fH
	DD	018341fH
	DD	012011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD 021H
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+259
	DD	imagerel $unwind$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD 061d21H
	DD	012f41dH
	DD	011e412H
	DD	0106408H
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
	DD	imagerel ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z+259
	DD	imagerel $unwind$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z DD 060c01H
	DD	0d008920cH
	DD	07004c006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z DD 01f6e19H
	DD	01fe85dH
	DD	020d855H
	DD	021c84dH
	DD	022b845H
	DD	023a83dH
	DD	0249838H
	DD	0258833H
	DD	026782eH
	DD	027682aH
	DD	0587426H
	DD	0576426H
	DD	0563426H
	DD	0500126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z
_TEXT	SEGMENT
timer$ = 96
context$ = 192
verts$ = 200
__formal$dead$ = 208
tris$ = 216
triAreaIDs$ = 224
numTris$ = 232
heightfield$ = 240
flagMergeThreshold$ = 248
?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z PROC ; rcRasterizeTriangles, COMDAT

; 481  : {

$LN37:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	mov	rsi, r9
	mov	r15, rdx
	mov	rdi, rcx

; 482  : 	rcAssert(context != NULL);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN7@rcRasteriz
	test	rcx, rcx
	jne	SHORT $LN7@rcRasteriz
	mov	r8d, 482				; 000001e2H
	lea	rdx, OFFSET FLAT:??_C@_0HD@IMPAODNN@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BA@GEKLAGIM@context?5?$CB?$DN?5NULL@
	call	rax
$LN7@rcRasteriz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rsp], rdi
	mov	DWORD PTR timer$[rsp+8], 2

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [rdi+9], 0
	je	SHORT $LN15@rcRasteriz
	mov	rax, QWORD PTR [rdi]
	mov	edx, 2
	mov	rcx, rdi
	call	QWORD PTR [rax+32]
	npad	1
$LN15@rcRasteriz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 487  : 	const float inverseCellSize = 1.0f / heightfield.cs;

	mov	rbp, QWORD PTR heightfield$[rsp]
	movss	xmm6, DWORD PTR __real@3f800000
	movaps	xmm7, xmm6
	divss	xmm7, DWORD PTR [rbp+32]

; 488  : 	const float inverseCellHeight = 1.0f / heightfield.ch;

	divss	xmm6, DWORD PTR [rbp+36]

; 489  : 	for (int triIndex = 0; triIndex < numTris; ++triIndex)

	movsxd	r14, DWORD PTR numTris$[rsp]
	test	r14, r14
	jle	$LN3@rcRasteriz
	xor	ebx, ebx
	lea	r12, QWORD PTR [rbp+20]
	lea	r13, QWORD PTR [rbp+8]
	add	rsi, 8
	npad	11
$LL4@rcRasteriz:

; 490  : 	{
; 491  : 		const float* v0 = &verts[tris[triIndex * 3 + 0] * 3];

	mov	eax, DWORD PTR [rsi-8]
	lea	eax, DWORD PTR [rax+rax*2]
	cdqe
	lea	rcx, QWORD PTR [r15+rax*4]

; 492  : 		const float* v1 = &verts[tris[triIndex * 3 + 1] * 3];

	mov	eax, DWORD PTR [rsi-4]
	lea	eax, DWORD PTR [rax+rax*2]
	cdqe
	lea	rdx, QWORD PTR [r15+rax*4]

; 493  : 		const float* v2 = &verts[tris[triIndex * 3 + 2] * 3];

	mov	eax, DWORD PTR [rsi]
	lea	eax, DWORD PTR [rax+rax*2]
	cdqe
	lea	r8, QWORD PTR [r15+rax*4]

; 494  : 		if (!rasterizeTri(v0, v1, v2, triAreaIDs[triIndex], heightfield, heightfield.bmin, heightfield.bmax, heightfield.cs, inverseCellSize, inverseCellHeight, flagMergeThreshold))

	mov	eax, DWORD PTR flagMergeThreshold$[rsp]
	mov	DWORD PTR [rsp+80], eax
	movss	DWORD PTR [rsp+72], xmm6
	movss	DWORD PTR [rsp+64], xmm7
	movss	xmm0, DWORD PTR [rbp+32]
	movss	DWORD PTR [rsp+56], xmm0
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], rbp
	mov	rax, QWORD PTR triAreaIDs$[rsp]
	movzx	r9d, BYTE PTR [rbx+rax]
	call	?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z ; rasterizeTri
	test	al, al
	je	SHORT $LN30@rcRasteriz

; 489  : 	for (int triIndex = 0; triIndex < numTris; ++triIndex)

	inc	rbx
	add	rsi, 12
	cmp	rbx, r14
	jl	SHORT $LL4@rcRasteriz
$LN3@rcRasteriz:

; 497  : 			return false;
; 498  : 		}
; 499  : 	}
; 500  : 
; 501  : 	return true;

	mov	bl, 1
$LN11@rcRasteriz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [rdi+9], 0
	je	SHORT $LN34@rcRasteriz
	mov	rcx, QWORD PTR [rdi]
	mov	r8, QWORD PTR [rcx+40]
	mov	edx, 2
	mov	rcx, rdi
	call	r8
	npad	1
$LN34@rcRasteriz:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 502  : }

	movzx	eax, bl
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN30@rcRasteriz:

; 495  : 		{
; 496  : 			context->log(RC_LOG_ERROR, "rcRasterizeTriangles: Out of memory.");

	lea	r8, OFFSET FLAT:??_C@_0CF@GMPBBABG@rcRasterizeTriangles?3?5Out?5of?5me@
	mov	edx, 3
	mov	rcx, rdi
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	SHORT $LN11@rcRasteriz
	int	3
?rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z ENDP ; rcRasterizeTriangles
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
timer$ = 96
context$ = 192
verts$ = 200
__formal$dead$ = 208
tris$ = 216
triAreaIDs$ = 224
numTris$ = 232
heightfield$ = 240
flagMergeThreshold$ = 248
?dtor$0@?0??rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z@4HA PROC ; `rcRasterizeTriangles'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcRasterizeTriangles@@YA_NPEAVrcContext@@PEBMHPEBHPEBEHAEAUrcHeightfield@@H@Z@4HA ENDP ; `rcRasterizeTriangles'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?overlapBounds@@YA_NPEBM000@Z
_TEXT	SEGMENT
aMin$ = 8
aMax$ = 16
bMin$ = 24
bMax$ = 32
?overlapBounds@@YA_NPEBM000@Z PROC			; overlapBounds, COMDAT

; 33   : 	return

	movss	xmm0, DWORD PTR [r9]
	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN3@overlapBou
	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, DWORD PTR [r8]
	jb	SHORT $LN3@overlapBou
	movss	xmm0, DWORD PTR [r9+4]
	comiss	xmm0, DWORD PTR [rcx+4]
	jb	SHORT $LN3@overlapBou
	movss	xmm0, DWORD PTR [rdx+4]
	comiss	xmm0, DWORD PTR [r8+4]
	jb	SHORT $LN3@overlapBou
	movss	xmm0, DWORD PTR [r9+8]
	comiss	xmm0, DWORD PTR [rcx+8]
	jb	SHORT $LN3@overlapBou
	movss	xmm0, DWORD PTR [rdx+8]
	comiss	xmm0, DWORD PTR [r8+8]
	jb	SHORT $LN3@overlapBou
	mov	al, 1

; 34   : 		aMin[0] <= bMax[0] && aMax[0] >= bMin[0] &&
; 35   : 		aMin[1] <= bMax[1] && aMax[1] >= bMin[1] &&
; 36   : 		aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
; 37   : }

	ret	0
$LN3@overlapBou:

; 33   : 	return

	xor	al, al

; 34   : 		aMin[0] <= bMax[0] && aMax[0] >= bMin[0] &&
; 35   : 		aMin[1] <= bMax[1] && aMax[1] >= bMin[1] &&
; 36   : 		aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
; 37   : }

	ret	0
?overlapBounds@@YA_NPEBM000@Z ENDP			; overlapBounds
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z
_TEXT	SEGMENT
heightfield$ = 48
?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z PROC	; allocSpan, COMDAT

; 45   : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 46   : 	// If necessary, allocate new page and update the freelist.
; 47   : 	if (heightfield.freelist == NULL || heightfield.freelist->next == NULL)

	mov	rax, QWORD PTR [rcx+56]
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN6@allocSpan
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN5@allocSpan
$LN6@allocSpan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	ecx, 32776				; 00008008H
	call	QWORD PTR __imp_malloc
	mov	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 52   : 		if (spanPool == NULL)

	test	rax, rax
	jne	SHORT $LN7@allocSpan

; 78   : 	return newSpan;
; 79   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN7@allocSpan:

; 53   : 		{
; 54   : 			return NULL;
; 55   : 		}
; 56   : 
; 57   : 		// Add the pool into the list of pools.
; 58   : 		spanPool->next = heightfield.pools;

	mov	rax, QWORD PTR [rbx+48]

; 59   : 		heightfield.pools = spanPool;
; 60   : 		
; 61   : 		// Add new spans to the free list.
; 62   : 		rcSpan* freeList = heightfield.freelist;
; 63   : 		rcSpan* head = &spanPool->items[0];

	lea	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdx], rax

; 64   : 		rcSpan* it = &spanPool->items[RC_SPANS_PER_POOL];

	lea	rax, QWORD PTR [rdx+32776]
	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rbx+48], rdx
	npad	4
$LL4@allocSpan:

; 65   : 		do
; 66   : 		{
; 67   : 			--it;
; 68   : 			it->next = freeList;

	mov	QWORD PTR [rax-8], rcx

; 69   : 			freeList = it;

	add	rax, -16
	mov	rcx, rax

; 70   : 		}
; 71   : 		while (it != head);

	cmp	rax, r8
	jne	SHORT $LL4@allocSpan

; 72   : 		heightfield.freelist = it;

	mov	QWORD PTR [rbx+56], rax
$LN5@allocSpan:

; 73   : 	}
; 74   : 
; 75   : 	// Pop item from the front of the free list.
; 76   : 	rcSpan* newSpan = heightfield.freelist;
; 77   : 	heightfield.freelist = heightfield.freelist->next;

	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rbx+56], rcx

; 78   : 	return newSpan;
; 79   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?allocSpan@@YAPEAUrcSpan@@AEAUrcHeightfield@@@Z ENDP	; allocSpan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?freeSpan@@YAXAEAUrcHeightfield@@PEAUrcSpan@@@Z
_TEXT	SEGMENT
heightfield$ = 8
span$ = 16
?freeSpan@@YAXAEAUrcHeightfield@@PEAUrcSpan@@@Z PROC	; freeSpan, COMDAT

; 86   : 	if (span == NULL)

	test	rdx, rdx
	je	SHORT $LN1@freeSpan

; 87   : 	{
; 88   : 		return;
; 89   : 	}
; 90   : 	// Add the span to the front of the free list.
; 91   : 	span->next = heightfield.freelist;

	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rdx+8], rax

; 92   : 	heightfield.freelist = span;

	mov	QWORD PTR [rcx+56], rdx
$LN1@freeSpan:

; 93   : }

	ret	0
?freeSpan@@YAXAEAUrcHeightfield@@PEAUrcSpan@@@Z ENDP	; freeSpan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z
_TEXT	SEGMENT
heightfield$ = 48
x$ = 56
z$ = 64
min$ = 72
max$ = 80
areaID$ = 88
flagMergeThreshold$ = 96
?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z PROC		; addSpan, COMDAT

; 109  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 47   : 	if (heightfield.freelist == NULL || heightfield.freelist->next == NULL)

	mov	r10, QWORD PTR [rcx+56]

; 109  : {

	mov	esi, r8d
	movzx	edi, r9w
	mov	ebp, edx
	mov	rbx, rcx

; 47   : 	if (heightfield.freelist == NULL || heightfield.freelist->next == NULL)

	test	r10, r10
	je	SHORT $LN21@addSpan
	cmp	QWORD PTR [r10+8], 0
	jne	SHORT $LN20@addSpan
$LN21@addSpan:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	ecx, 32776				; 00008008H
	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 52   : 		if (spanPool == NULL)

	test	rax, rax
	je	$LN45@addSpan

; 53   : 		{
; 54   : 			return NULL;
; 55   : 		}
; 56   : 
; 57   : 		// Add the pool into the list of pools.
; 58   : 		spanPool->next = heightfield.pools;

	mov	rcx, QWORD PTR [rbx+48]

; 59   : 		heightfield.pools = spanPool;
; 60   : 		
; 61   : 		// Add new spans to the free list.
; 62   : 		rcSpan* freeList = heightfield.freelist;
; 63   : 		rcSpan* head = &spanPool->items[0];

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rax], rcx

; 64   : 		rcSpan* it = &spanPool->items[RC_SPANS_PER_POOL];

	lea	r10, QWORD PTR [rax+32776]
	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rbx+48], rax
	npad	2
$LL19@addSpan:

; 65   : 		do
; 66   : 		{
; 67   : 			--it;
; 68   : 			it->next = freeList;

	mov	QWORD PTR [r10-8], rcx

; 69   : 			freeList = it;

	add	r10, -16
	mov	rcx, r10

; 70   : 		}
; 71   : 		while (it != head);

	cmp	r10, rdx
	jne	SHORT $LL19@addSpan

; 72   : 		heightfield.freelist = it;

	mov	QWORD PTR [rbx+56], r10
$LN20@addSpan:

; 73   : 	}
; 74   : 
; 75   : 	// Pop item from the front of the free list.
; 76   : 	rcSpan* newSpan = heightfield.freelist;
; 77   : 	heightfield.freelist = heightfield.freelist->next;

	mov	rax, QWORD PTR [r10+8]
	mov	QWORD PTR [rbx+56], rax

; 110  : 	// Create the new span.
; 111  : 	rcSpan* newSpan = allocSpan(heightfield);
; 112  : 	if (newSpan == NULL)

	test	r10, r10
	je	$LN45@addSpan

; 115  : 	}
; 116  : 	newSpan->smin = min;
; 117  : 	newSpan->smax = max;
; 118  : 	newSpan->area = areaID;

	movzx	eax, BYTE PTR areaID$[rsp]
	mov	edx, edi
	xor	edx, DWORD PTR [r10]

; 119  : 	newSpan->next = NULL;

	xor	edi, edi
	movzx	ecx, WORD PTR max$[rsp]
	and	edx, 8191				; 00001fffH
	xor	edx, DWORD PTR [r10]
	shl	eax, 26
	and	edx, 8191				; 00001fffH
	shl	ecx, 13
	xor	ecx, edx
	mov	QWORD PTR [r10+8], rdi
	and	ecx, 67108863				; 03ffffffH
	or	ecx, eax
	mov	DWORD PTR [r10], ecx

; 120  : 	
; 121  : 	const int columnIndex = x + z * heightfield.width;

	imul	esi, DWORD PTR [rbx]
	lea	eax, DWORD PTR [rsi+rbp]

; 122  : 	rcSpan* previousSpan = NULL;
; 123  : 	rcSpan* currentSpan = heightfield.spans[columnIndex];

	cdqe
	lea	rsi, QWORD PTR [rax*8]
	mov	rax, QWORD PTR [rbx+40]
	mov	r8, QWORD PTR [rsi+rax]

; 124  : 	
; 125  : 	// Insert the new span, possibly merging it with existing spans.
; 126  : 	while (currentSpan != NULL)

	test	r8, r8
	je	$LN13@addSpan
	mov	ebp, DWORD PTR flagMergeThreshold$[rsp]
	npad	15
$LL2@addSpan:

; 127  : 	{
; 128  : 		if (currentSpan->smin > newSpan->smax)

	mov	edx, DWORD PTR [r8]
	mov	eax, ecx
	shr	eax, 13
	mov	r9d, edx
	and	eax, 8191				; 00001fffH
	and	r9d, 8191				; 00001fffH
	cmp	r9d, eax
	ja	$LN39@addSpan

; 129  : 		{
; 130  : 			// Current span is completely after the new span, break.
; 131  : 			break;
; 132  : 		}
; 133  : 		
; 134  : 		if (currentSpan->smax < newSpan->smin)

	mov	eax, edx
	mov	r11d, ecx
	shr	eax, 13
	and	r11d, 8191				; 00001fffH
	and	eax, 8191				; 00001fffH
	cmp	eax, r11d
	jae	SHORT $LN6@addSpan

; 135  : 		{
; 136  : 			// Current span is completely before the new span.  Keep going.
; 137  : 			previousSpan = currentSpan;

	mov	rdi, r8

; 138  : 			currentSpan = currentSpan->next;

	mov	r8, QWORD PTR [r8+8]

; 139  : 		}

	jmp	$LN7@addSpan
$LN6@addSpan:

; 140  : 		else
; 141  : 		{
; 142  : 			// The new span overlaps with an existing span.  Merge them.
; 143  : 			if (currentSpan->smin < newSpan->smin)

	cmp	r9d, r11d
	jae	SHORT $LN46@addSpan

; 144  : 			{
; 145  : 				newSpan->smin = currentSpan->smin;

	xor	edx, ecx
	and	edx, 8191				; 00001fffH
	xor	edx, ecx
	mov	ecx, edx
	mov	DWORD PTR [r10], edx
$LN46@addSpan:

; 146  : 			}
; 147  : 			if (currentSpan->smax > newSpan->smax)

	mov	r9d, DWORD PTR [r8]
	mov	edx, ecx
	mov	eax, r9d
	and	edx, 67100672				; 03ffe000H
	and	eax, 67100672				; 03ffe000H
	cmp	eax, edx
	jbe	SHORT $LN9@addSpan

; 148  : 			{
; 149  : 				newSpan->smax = currentSpan->smax;

	xor	r9d, ecx
	and	r9d, 67100672				; 03ffe000H
	xor	ecx, r9d
	mov	DWORD PTR [r10], ecx
$LN9@addSpan:

; 153  : 			if (rcAbs((int)newSpan->smax - (int)currentSpan->smax) <= flagMergeThreshold)

	mov	r9d, DWORD PTR [r8]
	mov	eax, ecx
	shr	eax, 13
	mov	edx, r9d
	and	eax, 8191				; 00001fffH
	shr	edx, 13
	and	edx, 8191				; 00001fffH
	sub	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 669  : template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }

	cdq
	xor	eax, edx
	sub	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 153  : 			if (rcAbs((int)newSpan->smax - (int)currentSpan->smax) <= flagMergeThreshold)

	cmp	eax, ebp
	jg	SHORT $LN10@addSpan

; 156  : 				newSpan->area = rcMax(newSpan->area, currentSpan->area);

	shr	r9d, 26
	mov	eax, ecx
	shr	eax, 26
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	eax, r9d
	cmova	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 156  : 				newSpan->area = rcMax(newSpan->area, currentSpan->area);

	and	ecx, 67108863				; 03ffffffH
	shl	r9d, 26
	or	r9d, ecx
	mov	DWORD PTR [r10], r9d
$LN10@addSpan:

; 91   : 	span->next = heightfield.freelist;

	mov	rax, QWORD PTR [rbx+56]

; 157  : 			}
; 158  : 			
; 159  : 			// Remove the current span since it's now merged with newSpan.
; 160  : 			// Keep going because there might be other overlapping spans that also need to be merged.
; 161  : 			rcSpan* next = currentSpan->next;

	mov	rcx, QWORD PTR [r8+8]

; 91   : 	span->next = heightfield.freelist;

	mov	QWORD PTR [r8+8], rax

; 92   : 	heightfield.freelist = span;

	mov	QWORD PTR [rbx+56], r8

; 162  : 			freeSpan(heightfield, currentSpan);
; 163  : 			if (previousSpan)

	test	rdi, rdi
	je	SHORT $LN11@addSpan

; 164  : 			{
; 165  : 				previousSpan->next = next;

	mov	QWORD PTR [rdi+8], rcx

; 166  : 			}

	jmp	SHORT $LN12@addSpan
$LN11@addSpan:

; 167  : 			else
; 168  : 			{
; 169  : 				heightfield.spans[columnIndex] = next;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rsi+rax], rcx
$LN12@addSpan:

; 170  : 			}
; 171  : 			currentSpan = next;

	mov	r8, rcx
	mov	ecx, DWORD PTR [r10]
$LN7@addSpan:

; 124  : 	
; 125  : 	// Insert the new span, possibly merging it with existing spans.
; 126  : 	while (currentSpan != NULL)

	test	r8, r8
	jne	$LL2@addSpan
$LN39@addSpan:

; 172  : 		}
; 173  : 	}
; 174  : 	
; 175  : 	// Insert new span after prev
; 176  : 	if (previousSpan != NULL)

	test	rdi, rdi
	je	SHORT $LN13@addSpan

; 177  : 	{
; 178  : 		newSpan->next = previousSpan->next;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [r10+8], rax

; 186  : 	}
; 187  : 
; 188  : 	return true;

	mov	al, 1
	mov	QWORD PTR [rdi+8], r10
	jmp	SHORT $LN1@addSpan
$LN13@addSpan:

; 179  : 		previousSpan->next = newSpan;
; 180  : 	}
; 181  : 	else
; 182  : 	{
; 183  : 		// This span should go before the others in the list
; 184  : 		newSpan->next = heightfield.spans[columnIndex];

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rsi+rax]
	mov	QWORD PTR [r10+8], rcx

; 185  : 		heightfield.spans[columnIndex] = newSpan;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rsi+rax], r10

; 186  : 	}
; 187  : 
; 188  : 	return true;

	mov	al, 1
	jmp	SHORT $LN1@addSpan
$LN45@addSpan:

; 113  : 	{
; 114  : 		return false;

	xor	al, al
$LN1@addSpan:

; 189  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z ENDP		; addSpan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z
_TEXT	SEGMENT
inVertAxisDelta$ = 32
inVerts$ = 128
inVertsCount$ = 136
outVerts1$ = 144
outVerts1Count$ = 152
outVerts2$ = 160
outVerts2Count$ = 168
axisOffset$ = 176
axis$ = 184
?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z PROC	; dividePoly, COMDAT

; 229  : {

	push	rbx
	push	rbp
	push	rdi
	push	r12
	push	r13
	sub	rsp, 80					; 00000050H

; 230  : 	rcAssert(inVertsCount <= 12);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r13, r9
	mov	ebp, edx
	mov	rbx, r8
	mov	r12, rcx
	test	rax, rax
	je	SHORT $LN10@dividePoly
	cmp	ebp, 12
	jle	SHORT $LN10@dividePoly
	mov	r8d, 230				; 000000e6H
	lea	rdx, OFFSET FLAT:??_C@_0HD@IMPAODNN@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BD@DPJHMNHK@inVertsCount?5?$DM?$DN?512@
	call	rax
$LN10@dividePoly:

; 231  : 	
; 232  : 	// How far positive or negative away from the separating axis is each vertex.
; 233  : 	float inVertAxisDelta[12];
; 234  : 	for (int inVert = 0; inVert < inVertsCount; ++inVert)

	movsxd	r9, DWORD PTR axis$[rsp]
	xor	edx, edx
	movss	xmm2, DWORD PTR axisOffset$[rsp]
	movsxd	r8, ebp
	cmp	r8, 4
	jl	SHORT $LN40@dividePoly
	lea	rax, QWORD PTR [r9+6]
	lea	rax, QWORD PTR [r12+rax*4]
	lea	rcx, QWORD PTR [r8-3]
	npad	10
$LL37@dividePoly:

; 235  : 	{
; 236  : 		inVertAxisDelta[inVert] = axisOffset - inVerts[inVert * 3 + axis];

	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	subss	xmm0, DWORD PTR [rax-24]
	subss	xmm1, DWORD PTR [rax-12]
	movss	DWORD PTR inVertAxisDelta$[rsp+rdx*4], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR inVertAxisDelta$[rsp+rdx*4+4], xmm1
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR [rax+12]
	add	rax, 48					; 00000030H
	movss	DWORD PTR inVertAxisDelta$[rsp+rdx*4+8], xmm0
	movss	DWORD PTR inVertAxisDelta$[rsp+rdx*4+12], xmm1
	add	rdx, 4
	cmp	rdx, rcx
	jl	SHORT $LL37@dividePoly

; 231  : 	
; 232  : 	// How far positive or negative away from the separating axis is each vertex.
; 233  : 	float inVertAxisDelta[12];
; 234  : 	for (int inVert = 0; inVert < inVertsCount; ++inVert)

	cmp	rdx, r8
	jl	SHORT $LN45@dividePoly
	jmp	SHORT $LN35@dividePoly
$LN40@dividePoly:
	test	ebp, ebp
	jle	SHORT $LN35@dividePoly
$LN45@dividePoly:
	lea	rcx, QWORD PTR [r9+rdx*2]
	add	rcx, rdx
	lea	rax, QWORD PTR [r12+rcx*4]
$LC38@dividePoly:

; 235  : 	{
; 236  : 		inVertAxisDelta[inVert] = axisOffset - inVerts[inVert * 3 + axis];

	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [rax]
	add	rax, 12
	movss	DWORD PTR inVertAxisDelta$[rsp+rdx*4], xmm0
	inc	rdx
	cmp	rdx, r8
	jl	SHORT $LC38@dividePoly
$LN35@dividePoly:

; 237  : 	}
; 238  : 
; 239  : 	int poly1Vert = 0;

	xor	edi, edi

; 240  : 	int poly2Vert = 0;

	xor	r11d, r11d

; 241  : 	for (int inVertA = 0, inVertB = inVertsCount - 1; inVertA < inVertsCount; inVertB = inVertA, ++inVertA)

	test	ebp, ebp
	jle	$LN48@dividePoly
	mov	rdx, QWORD PTR outVerts2$[rsp]
	lea	r8, QWORD PTR [r12+8]
	movsxd	rcx, ebp
	xorps	xmm4, xmm4
	mov	QWORD PTR [rsp+128], rsi
	xor	esi, esi
	mov	QWORD PTR [rsp+136], r14
	mov	r14, rbp
	mov	QWORD PTR [rsp+144], r15
	mov	r15, -8
	lea	rax, QWORD PTR [rcx+rcx*2]
	sub	r15, r12
	lea	rbp, QWORD PTR [rax*4-12]
	lea	rcx, QWORD PTR [rcx*4-4]
	npad	2
$LL7@dividePoly:

; 242  : 	{
; 243  : 		// If the two vertices are on the same side of the separating axis
; 244  : 		bool sameSide = (inVertAxisDelta[inVertA] >= 0) == (inVertAxisDelta[inVertB] >= 0);

	movss	xmm5, DWORD PTR inVertAxisDelta$[rsp+rcx]
	xor	ecx, ecx
	movss	xmm3, DWORD PTR inVertAxisDelta$[rsp+rsi]
	comiss	xmm3, xmm4
	setae	cl
	xor	eax, eax
	comiss	xmm5, xmm4
	setae	al
	cmp	ecx, eax

; 245  : 
; 246  : 		if (!sameSide)

	je	$LN11@dividePoly

; 247  : 		{
; 248  : 			float s = inVertAxisDelta[inVertB] / (inVertAxisDelta[inVertB] - inVertAxisDelta[inVertA]);
; 249  : 			outVerts1[poly1Vert * 3 + 0] = inVerts[inVertB * 3 + 0] + (inVerts[inVertA * 3 + 0] - inVerts[inVertB * 3 + 0]) * s;

	movss	xmm2, DWORD PTR [r8-8]
	movaps	xmm0, xmm5
	subss	xmm2, DWORD PTR [r12+rbp]
	subss	xmm0, xmm3

; 253  : 			poly1Vert++;

	inc	edi

; 254  : 			poly2Vert++;

	inc	r11d
	divss	xmm5, xmm0
	mulss	xmm2, xmm5
	addss	xmm2, DWORD PTR [r12+rbp]
	movss	DWORD PTR [rbx], xmm2
	movss	xmm0, DWORD PTR [r8-4]
	subss	xmm0, DWORD PTR [r12+rbp+4]
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [r12+rbp+4]
	movss	DWORD PTR [rbx+4], xmm0
	movss	xmm0, DWORD PTR [r8]
	subss	xmm0, DWORD PTR [r12+rbp+8]
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [r12+rbp+8]
	movss	DWORD PTR [rbx+8], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	movss	DWORD PTR [rdx], xmm2

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR [rdx+4], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 253  : 			poly1Vert++;

	add	rbx, 12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 776  : 	dest[2] = v[2];

	mov	DWORD PTR [rdx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 254  : 			poly2Vert++;

	add	rdx, 12

; 255  : 			
; 256  : 			// add the inVertA point to the right polygon. Do NOT add points that are on the dividing line
; 257  : 			// since these were already added above
; 258  : 			if (inVertAxisDelta[inVertA] > 0)

	comiss	xmm3, xmm4
	jbe	SHORT $LN13@dividePoly
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	mov	eax, DWORD PTR [r8-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 261  : 				poly1Vert++;

	inc	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	mov	DWORD PTR [rbx], eax

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [r8-4]
	mov	DWORD PTR [rbx+4], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 261  : 				poly1Vert++;

	add	rbx, 12

; 262  : 			}

	jmp	SHORT $LN5@dividePoly
$LN13@dividePoly:

; 263  : 			else if (inVertAxisDelta[inVertA] < 0)

	comiss	xmm4, xmm3
	jbe	SHORT $LN5@dividePoly

; 264  : 			{
; 265  : 				rcVcopy(&outVerts2[poly2Vert * 3], &inVerts[inVertA * 3]);
; 266  : 				poly2Vert++;
; 267  : 			}
; 268  : 		}

	jmp	SHORT $LN47@dividePoly
$LN11@dividePoly:

; 269  : 		else
; 270  : 		{
; 271  : 			// add the inVertA point to the right polygon. Addition is done even for points on the dividing line
; 272  : 			if (inVertAxisDelta[inVertA] >= 0)

	comiss	xmm3, xmm4
	jb	SHORT $LN47@dividePoly
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	mov	eax, DWORD PTR [r8-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 275  : 				poly1Vert++;

	inc	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	mov	DWORD PTR [rbx], eax

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [r8-4]
	mov	DWORD PTR [rbx+4], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 275  : 				poly1Vert++;

	add	rbx, 12

; 276  : 				if (inVertAxisDelta[inVertA] != 0)

	ucomiss	xmm3, xmm4
	jp	SHORT $LN5@dividePoly
	jne	SHORT $LN5@dividePoly
$LN47@dividePoly:

; 241  : 	for (int inVertA = 0, inVertB = inVertsCount - 1; inVertA < inVertsCount; inVertB = inVertA, ++inVertA)

	mov	eax, DWORD PTR [r8-8]
	inc	r11d
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8-4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx+8], eax
	add	rdx, 12
$LN5@dividePoly:
	mov	rcx, rsi
	lea	rbp, QWORD PTR [r15+r8]
	add	rsi, 4
	add	r8, 12
	sub	r14, 1
	jne	$LL7@dividePoly
	mov	r15, QWORD PTR [rsp+144]
	mov	r14, QWORD PTR [rsp+136]
	mov	rsi, QWORD PTR [rsp+128]
$LN48@dividePoly:

; 277  : 				{
; 278  : 					continue;
; 279  : 				}
; 280  : 			}
; 281  : 			rcVcopy(&outVerts2[poly2Vert * 3], &inVerts[inVertA * 3]);
; 282  : 			poly2Vert++;
; 283  : 		}
; 284  : 	}
; 285  : 
; 286  : 	*outVerts1Count = poly1Vert;
; 287  : 	*outVerts2Count = poly2Vert;
; 288  : }

	mov	rax, QWORD PTR outVerts2Count$[rsp]
	mov	DWORD PTR [r13], edi
	mov	DWORD PTR [rax], r11d
	add	rsp, 80					; 00000050H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z ENDP	; dividePoly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp
;	COMDAT ?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z
_TEXT	SEGMENT
areaID$1$ = 64
nv2$1 = 68
z1$2$ = 72
nvIn$ = 76
in$1$ = 80
nvRow$ = 96
w$1$ = 100
nv$2 = 104
heightfield$GSCopy$1$ = 112
inRow$1$ = 120
p2$1$ = 128
buf$ = 144
__$ArrayPad$ = 480
v0$ = 688
v1$ = 696
v2$ = 704
areaID$ = 712
heightfield$ = 720
heightfieldBBMin$ = 728
heightfieldBBMax$ = 736
cellSize$ = 744
inverseCellSize$ = 752
inverseCellHeight$ = 760
flagMergeThreshold$ = 768
?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z PROC ; rasterizeTri, COMDAT

; 311  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-424]
	sub	rsp, 640				; 00000280H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	movaps	XMMWORD PTR [rax-184], xmm14
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 776  : 	dest[2] = v[2];

	movss	xmm10, DWORD PTR [rcx+8]

; 756  : 	mn[2] = rcMin(mn[2], v[2]);

	movss	xmm11, DWORD PTR [rdx+8]

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	movaps	xmm3, xmm10

; 756  : 	mn[2] = rcMin(mn[2], v[2]);

	movss	xmm12, DWORD PTR [r8+8]

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	minss	xmm3, xmm11

; 774  : 	dest[0] = v[0];

	movss	xmm7, DWORD PTR [rcx]

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	movaps	xmm2, xmm10

; 754  : 	mn[0] = rcMin(mn[0], v[0]);

	movss	xmm8, DWORD PTR [rdx]

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	maxss	xmm2, xmm11

; 754  : 	mn[0] = rcMin(mn[0], v[0]);

	movss	xmm9, DWORD PTR [r8]

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	movaps	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 33   : 	return

	mov	rax, QWORD PTR heightfieldBBMax$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	minss	xmm1, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 311  : {

	mov	r13, QWORD PTR heightfieldBBMin$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	minss	xmm3, xmm12

; 775  : 	dest[1] = v[1];

	movss	xmm4, DWORD PTR [rcx+4]

; 755  : 	mn[1] = rcMin(mn[1], v[1]);

	movss	xmm5, DWORD PTR [rdx+4]

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	maxss	xmm2, xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 33   : 	return

	movss	xmm0, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 755  : 	mn[1] = rcMin(mn[1], v[1]);

	movss	xmm6, DWORD PTR [r8+4]

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	minss	xmm1, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 311  : {

	mov	BYTE PTR areaID$1$[rsp], r9b
	mov	r9, QWORD PTR heightfield$[rbp-256]
	mov	QWORD PTR heightfield$GSCopy$1$[rsp], r9

; 33   : 	return

	comiss	xmm0, xmm1
	jb	$LN153@rasterizeT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	movaps	xmm0, xmm7
	maxss	xmm0, xmm8
	maxss	xmm0, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 33   : 	return

	comiss	xmm0, DWORD PTR [r13]
	jb	$LN153@rasterizeT
	movss	xmm0, DWORD PTR [rax+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	movaps	xmm1, xmm4
	minss	xmm1, xmm5
	minss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 33   : 	return

	comiss	xmm0, xmm1
	jb	$LN153@rasterizeT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	movaps	xmm0, xmm4
	maxss	xmm0, xmm5
	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 33   : 	return

	comiss	xmm0, DWORD PTR [r13+4]
	jb	$LN153@rasterizeT
	movss	xmm0, DWORD PTR [rax+8]
	comiss	xmm0, xmm3
	jb	$LN153@rasterizeT
	comiss	xmm2, DWORD PTR [r13+8]
	jb	$LN153@rasterizeT

; 312  : 	// Calculate the bounding box of the triangle.
; 313  : 	float triBBMin[3];
; 314  : 	rcVcopy(triBBMin, v0);
; 315  : 	rcVmin(triBBMin, v1);
; 316  : 	rcVmin(triBBMin, v2);
; 317  : 
; 318  : 	float triBBMax[3];
; 319  : 	rcVcopy(triBBMax, v0);
; 320  : 	rcVmax(triBBMax, v1);
; 321  : 	rcVmax(triBBMax, v2);
; 322  : 
; 323  : 	// If the triangle does not touch the bounding box of the heightfield, skip the triangle.
; 324  : 	if (!overlapBounds(triBBMin, triBBMax, heightfieldBBMin, heightfieldBBMax))
; 325  : 	{
; 326  : 		return true;
; 327  : 	}
; 328  : 
; 329  : 	const int w = heightfield.width;
; 330  : 	const int h = heightfield.height;
; 331  : 	const float by = heightfieldBBMax[1] - heightfieldBBMin[1];
; 332  : 
; 333  : 	// Calculate the footprint of the triangle on the grid's z-axis
; 334  : 	int z0 = (int)((triBBMin[2] - heightfieldBBMin[2]) * inverseCellSize);

	movss	xmm13, DWORD PTR [rax+4]
	movss	xmm14, DWORD PTR inverseCellSize$[rbp-256]
	mov	ecx, DWORD PTR [r9]
	subss	xmm3, DWORD PTR [r13+8]

; 335  : 	int z1 = (int)((triBBMax[2] - heightfieldBBMin[2]) * inverseCellSize);

	subss	xmm2, DWORD PTR [r13+8]

; 336  : 
; 337  : 	// use -1 rather than 0 to cut the polygon properly at the start of the tile
; 338  : 	z0 = rcClamp(z0, -1, h - 1);

	mov	eax, DWORD PTR [r9+4]
	subss	xmm13, DWORD PTR [r13+4]
	dec	eax
	mov	DWORD PTR w$1$[rsp], ecx
	mulss	xmm3, xmm14
	mulss	xmm2, xmm14
	cvttss2si r12d, xmm3
	cvttss2si ecx, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);

	cmp	r12d, -1
	jge	SHORT $LN123@rasterizeT
	mov	r12d, -1
	jmp	SHORT $LN124@rasterizeT
$LN123@rasterizeT:
	cmp	r12d, eax
	cmovg	r12d, eax
$LN124@rasterizeT:
	xor	edx, edx
	test	ecx, ecx
	jns	SHORT $LN127@rasterizeT
	mov	ecx, edx
	jmp	SHORT $LN191@rasterizeT
$LN127@rasterizeT:
	cmp	ecx, eax
	cmovg	ecx, eax
$LN191@rasterizeT:

; 774  : 	dest[0] = v[0];

	movss	DWORD PTR buf$[rbp-256], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 352  : 	int nvIn = 3;

	mov	edx, 3
	mov	DWORD PTR nvIn$[rsp], edx
	lea	rsi, QWORD PTR buf$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 775  : 	dest[1] = v[1];

	movss	DWORD PTR buf$[rbp-252], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 344  : 	float* inRow = buf + 7 * 3;

	lea	rbx, QWORD PTR buf$[rbp-172]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 776  : 	dest[2] = v[2];

	movss	DWORD PTR buf$[rbp-248], xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 345  : 	float* p1 = inRow + 7 * 3;

	lea	r14, QWORD PTR buf$[rbp-88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 774  : 	dest[0] = v[0];

	movss	DWORD PTR buf$[rbp-244], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 346  : 	float* p2 = p1 + 7 * 3;

	lea	rdi, QWORD PTR buf$[rbp-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 775  : 	dest[1] = v[1];

	movss	DWORD PTR buf$[rbp-240], xmm5

; 776  : 	dest[2] = v[2];

	movss	DWORD PTR buf$[rbp-236], xmm11

; 774  : 	dest[0] = v[0];

	movss	DWORD PTR buf$[rbp-232], xmm9

; 775  : 	dest[1] = v[1];

	movss	DWORD PTR buf$[rbp-228], xmm6

; 776  : 	dest[2] = v[2];

	movss	DWORD PTR buf$[rbp-224], xmm12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 343  : 	float* in = buf;

	mov	DWORD PTR z1$2$[rsp], ecx

; 353  : 
; 354  : 	for (int z = z0; z <= z1; ++z)

	cmp	r12d, ecx
	jg	$LN153@rasterizeT
	movss	xmm8, DWORD PTR inverseCellHeight$[rbp-256]
	xorps	xmm7, xmm7
	movss	xmm9, DWORD PTR cellSize$[rbp-256]
	npad	8
$LL4@rasterizeT:

; 355  : 	{
; 356  : 		// Clip polygon to row. Store the remaining polygon as well
; 357  : 		const float cellZ = heightfieldBBMin[2] + (float)z * cellSize;
; 358  : 		dividePoly(in, nvIn, inRow, &nvRow, p1, &nvIn, cellZ + cellSize, RC_AXIS_Z);

	mov	DWORD PTR [rsp+56], 2
	lea	rax, QWORD PTR nvIn$[rsp]
	movd	xmm0, r12d
	lea	r9, QWORD PTR nvRow$[rsp]
	cvtdq2ps xmm0, xmm0
	mov	r8, rbx
	mov	rcx, rsi
	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r13+8]
	addss	xmm0, xmm9
	movss	DWORD PTR [rsp+48], xmm0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r14
	call	?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z ; dividePoly

; 361  : 		if (nvRow < 3)

	mov	edx, DWORD PTR nvRow$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	r15, rsi
	mov	QWORD PTR in$1$[rsp], r14
	mov	rsi, r14
	mov	r14, r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 361  : 		if (nvRow < 3)

	cmp	edx, 3
	jl	$LN2@rasterizeT

; 362  : 		{
; 363  : 			continue;
; 364  : 		}
; 365  : 		if (z < 0)

	test	r12d, r12d
	js	$LN2@rasterizeT

; 366  : 		{
; 367  : 			continue;
; 368  : 		}
; 369  : 		
; 370  : 		// find X-axis bounds of the row
; 371  : 		float minX = inRow[0];

	movss	xmm2, DWORD PTR [rbx]

; 372  : 		float maxX = inRow[0];

	movaps	xmm3, xmm2

; 373  : 		for (int vert = 1; vert < nvRow; ++vert)

	cmp	edx, 1
	jle	SHORT $LN6@rasterizeT

; 366  : 		{
; 367  : 			continue;
; 368  : 		}
; 369  : 		
; 370  : 		// find X-axis bounds of the row
; 371  : 		float minX = inRow[0];

	lea	rcx, QWORD PTR [rbx+12]
	lea	r8d, DWORD PTR [rdx-1]
	npad	3
$LL7@rasterizeT:

; 374  : 		{
; 375  : 			if (minX > inRow[vert * 3])

	movss	xmm1, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+12]
	movaps	xmm0, xmm1

; 376  : 			{
; 377  : 				minX = inRow[vert * 3];
; 378  : 			}
; 379  : 			if (maxX < inRow[vert * 3])

	maxss	xmm1, xmm3
	minss	xmm0, xmm2

; 380  : 			{
; 381  : 				maxX = inRow[vert * 3];

	movaps	xmm3, xmm1
	movaps	xmm2, xmm0
	sub	r8, 1
	jne	SHORT $LL7@rasterizeT
$LN6@rasterizeT:

; 382  : 			}
; 383  : 		}
; 384  : 		int x0 = (int)((minX - heightfieldBBMin[0]) * inverseCellSize);
; 385  : 		int x1 = (int)((maxX - heightfieldBBMin[0]) * inverseCellSize);

	subss	xmm3, DWORD PTR [r13]
	subss	xmm2, DWORD PTR [r13]
	mulss	xmm3, xmm14
	mulss	xmm2, xmm14
	cvttss2si r14d, xmm3
	cvttss2si esi, xmm2

; 386  : 		if (x1 < 0 || x0 >= w)

	test	r14d, r14d
	js	$LN161@rasterizeT
	mov	eax, DWORD PTR w$1$[rsp]
	cmp	esi, eax
	jge	$LN161@rasterizeT

; 387  : 		{
; 388  : 			continue;
; 389  : 		}
; 390  : 		x0 = rcClamp(x0, -1, w - 1);

	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);

	cmp	esi, -1
	jge	SHORT $LN115@rasterizeT
	mov	esi, -1
	jmp	SHORT $LN116@rasterizeT
$LN115@rasterizeT:
	cmp	esi, eax
	cmovg	esi, eax
$LN116@rasterizeT:
	cmp	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 394  : 		int nv2 = nvRow;

	mov	DWORD PTR nv2$1[rsp], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);

	cmovg	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 396  : 		for (int x = x0; x <= x1; ++x)

	cmp	esi, r14d
	jg	$LN161@rasterizeT
	npad	6
$LL10@rasterizeT:

; 397  : 		{
; 398  : 			// Clip polygon to column. store the remaining polygon as well
; 399  : 			const float cx = heightfieldBBMin[0] + (float)x * cellSize;
; 400  : 			dividePoly(inRow, nv2, p1, &nv, p2, &nv2, cx + cellSize, RC_AXIS_X);

	xor	eax, eax
	movd	xmm0, esi
	mov	DWORD PTR [rsp+56], eax
	lea	r9, QWORD PTR nv$2[rsp]
	cvtdq2ps xmm0, xmm0
	lea	rax, QWORD PTR nv2$1[rsp]
	mov	r8, r15
	mov	rcx, rbx
	mulss	xmm0, xmm9
	addss	xmm0, DWORD PTR [r13]
	addss	xmm0, xmm9
	movss	DWORD PTR [rsp+48], xmm0
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rdi
	call	?dividePoly@@YAXPEBMHPEAMPEAH12MW4rcAxis@@@Z ; dividePoly
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	rax, rbx
	mov	rbx, rdi
	mov	rdi, rax
	mov	QWORD PTR p2$1$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 403  : 			if (nv < 3)

	mov	eax, DWORD PTR nv$2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	QWORD PTR inRow$1$[rsp], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 403  : 			if (nv < 3)

	cmp	eax, 3
	jl	$LN8@rasterizeT

; 404  : 			{
; 405  : 				continue;
; 406  : 			}
; 407  : 			if (x < 0)

	test	esi, esi
	js	$LN8@rasterizeT

; 408  : 			{
; 409  : 				continue;
; 410  : 			}
; 411  : 			
; 412  : 			// Calculate min and max of the span.
; 413  : 			float spanMin = p1[1];

	movss	xmm1, DWORD PTR [r15+4]

; 414  : 			float spanMax = p1[1];

	movaps	xmm2, xmm1

; 415  : 			for (int vert = 1; vert < nv; ++vert)

	cmp	eax, 1
	jle	SHORT $LN12@rasterizeT

; 408  : 			{
; 409  : 				continue;
; 410  : 			}
; 411  : 			
; 412  : 			// Calculate min and max of the span.
; 413  : 			float spanMin = p1[1];

	lea	rcx, QWORD PTR [r15+16]
	lea	edx, DWORD PTR [rax-1]
	npad	2
$LL13@rasterizeT:

; 416  : 			{
; 417  : 				spanMin = rcMin(spanMin, p1[vert * 3 + 1]);

	movss	xmm0, DWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	comiss	xmm0, xmm1
	ja	SHORT $LN32@rasterizeT
	movaps	xmm1, xmm0
$LN32@rasterizeT:

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	comiss	xmm2, xmm0
	ja	SHORT $LN36@rasterizeT
	movaps	xmm2, xmm0
$LN36@rasterizeT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 415  : 			for (int vert = 1; vert < nv; ++vert)

	add	rcx, 12
	sub	rdx, 1
	jne	SHORT $LL13@rasterizeT
$LN12@rasterizeT:

; 418  : 				spanMax = rcMax(spanMax, p1[vert * 3 + 1]);
; 419  : 			}
; 420  : 			spanMin -= heightfieldBBMin[1];
; 421  : 			spanMax -= heightfieldBBMin[1];

	subss	xmm2, DWORD PTR [r13+4]
	subss	xmm1, DWORD PTR [r13+4]

; 422  : 			
; 423  : 			// Skip the span if it's completely outside the heightfield bounding box
; 424  : 			if (spanMax < 0.0f)

	comiss	xmm7, xmm2
	ja	$LN8@rasterizeT

; 425  : 			{
; 426  : 				continue;
; 427  : 			}
; 428  : 			if (spanMin > by)

	comiss	xmm1, xmm13
	ja	$LN8@rasterizeT

; 429  : 			{
; 430  : 				continue;
; 431  : 			}
; 432  : 			
; 433  : 			// Clamp the span to the heightfield bounding box.
; 434  : 			if (spanMin < 0.0f)

	movaps	xmm0, xmm7

; 435  : 			{
; 436  : 				spanMin = 0;
; 437  : 			}
; 438  : 			if (spanMax > by)

	movaps	xmm6, xmm13
	maxss	xmm0, xmm1
	minss	xmm6, xmm2

; 439  : 			{
; 440  : 				spanMax = by;
; 441  : 			}
; 442  : 
; 443  : 			// Snap the span to the heightfield height grid.
; 444  : 			unsigned short spanMinCellIndex = (unsigned short)rcClamp((int)floorf(spanMin * inverseCellHeight), 0, RC_SPAN_MAX_HEIGHT);

	mulss	xmm0, xmm8
	call	floorf
	cvttss2si ebx, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);

	test	ebx, ebx
	jns	SHORT $LN43@rasterizeT
	xor	eax, eax
	movzx	ebx, ax
	jmp	SHORT $LN44@rasterizeT
$LN43@rasterizeT:
	mov	eax, 8191				; 00001fffH
	cmp	ebx, eax
	cmovg	bx, ax
$LN44@rasterizeT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 445  : 			unsigned short spanMaxCellIndex = (unsigned short)rcClamp((int)ceilf(spanMax * inverseCellHeight), (int)spanMinCellIndex + 1, RC_SPAN_MAX_HEIGHT);

	mulss	xmm6, xmm8
	movzx	edi, bx
	inc	edi
	movaps	xmm0, xmm6
	call	ceilf
	cvttss2si eax, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);

	cmp	eax, edi
	jl	SHORT $LN48@rasterizeT
	mov	ecx, 8191				; 00001fffH
	cmp	eax, ecx
	cmovg	ax, cx
	movzx	edi, ax
$LN48@rasterizeT:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastRasterization.cpp

; 447  : 			if (!addSpan(heightfield, x, z, spanMinCellIndex, spanMaxCellIndex, areaID, flagMergeThreshold))

	mov	eax, DWORD PTR flagMergeThreshold$[rbp-256]
	movzx	r9d, bx
	mov	rcx, QWORD PTR heightfield$GSCopy$1$[rsp]
	mov	r8d, r12d
	mov	DWORD PTR [rsp+48], eax
	mov	edx, esi
	movzx	eax, BYTE PTR areaID$1$[rsp]
	mov	BYTE PTR [rsp+40], al
	mov	WORD PTR [rsp+32], di
	call	?addSpan@@YA_NAEAUrcHeightfield@@HHGGEH@Z ; addSpan
	test	al, al
	je	SHORT $LN139@rasterizeT
	mov	rbx, QWORD PTR inRow$1$[rsp]
	mov	rdi, QWORD PTR p2$1$[rbp-256]
$LN8@rasterizeT:

; 396  : 		for (int x = x0; x <= x1; ++x)

	inc	esi
	cmp	esi, r14d
	jg	SHORT $LN161@rasterizeT
	mov	edx, DWORD PTR nv2$1[rsp]
	jmp	$LL10@rasterizeT
$LN161@rasterizeT:

; 353  : 
; 354  : 	for (int z = z0; z <= z1; ++z)

	mov	rsi, QWORD PTR in$1$[rsp]
	mov	r14, r15
$LN2@rasterizeT:
	inc	r12d
	cmp	r12d, DWORD PTR z1$2$[rsp]
	jg	SHORT $LN153@rasterizeT
	mov	edx, DWORD PTR nvIn$[rsp]
	jmp	$LL4@rasterizeT
$LN139@rasterizeT:

; 448  : 			{
; 449  : 				return false;

	xor	al, al
	jmp	SHORT $LN1@rasterizeT
$LN153@rasterizeT:

; 450  : 			}
; 451  : 		}
; 452  : 	}
; 453  : 
; 454  : 	return true;

	mov	al, 1
$LN1@rasterizeT:

; 455  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+640]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?rasterizeTri@@YA_NPEBM00EAEAUrcHeightfield@@00MMMH@Z ENDP ; rasterizeTri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcMax@I@@YAIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcMax@I@@YAIII@Z PROC				; rcMax<unsigned int>, COMDAT

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	ecx, edx
	cmova	edx, ecx
	mov	eax, edx
	ret	0
??$rcMax@I@@YAIII@Z ENDP				; rcMax<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcSwap@PEAM@@YAXAEAPEAM0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcSwap@PEAM@@YAXAEAPEAM0@Z PROC			; rcSwap<float *>, COMDAT

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	r8, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rdx], r8
	ret	0
??$rcSwap@PEAM@@YAXAEAPEAM0@Z ENDP			; rcSwap<float *>
_TEXT	ENDS
END
