; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?IsOpen@PopupSettings@@3_NA			; PopupSettings::IsOpen
PUBLIC	??_C@_0CA@EDFKNK@?1Pack?1Bootup?4Nin_NX_NVN?4pack?4zs@ ; `string'
PUBLIC	??_C@_0L@IGFMFAAA@RomFS?5Path@			; `string'
PUBLIC	??_C@_05EAGKIPDA@Paths@				; `string'
PUBLIC	??_C@_0M@KLCJGHIH@?$CD?$CDModelPath@		; `string'
PUBLIC	??_C@_0CJ@BPIHFLLE@?1Weapon_Sword_020?4Weapon_Sword_@ ; `string'
PUBLIC	??_C@_0L@DOCDGGFI@Model?5Path@			; `string'
PUBLIC	??_C@_0M@GJLKDALA@?$CD?$CDRomFSPath@		; `string'
PUBLIC	??_C@_07KOKNCBKO@?$CD?$CDColor@			; `string'
PUBLIC	??_C@_0L@GOENPNKG@Add?$CD?$CDColor@		; `string'
PUBLIC	??_C@_0P@NNAIGJCE@?$CD?$CDAddColorName@		; `string'
PUBLIC	??_C@_0BI@MMFLADEG@String?5in?5actor?5name?4?4?4@ ; `string'
PUBLIC	??_C@_05HOHECJHI@Del?$CD?$CD@			; `string'
?IsOpen@PopupSettings@@3_NA DB 01H DUP (?)		; PopupSettings::IsOpen
_BSS	ENDS
;	COMDAT ??_C@_05HOHECJHI@Del?$CD?$CD@
CONST	SEGMENT
??_C@_05HOHECJHI@Del?$CD?$CD@ DB 'Del##', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MMFLADEG@String?5in?5actor?5name?4?4?4@
CONST	SEGMENT
??_C@_0BI@MMFLADEG@String?5in?5actor?5name?4?4?4@ DB 'String in actor nam'
	DB	'e...', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNAIGJCE@?$CD?$CDAddColorName@
CONST	SEGMENT
??_C@_0P@NNAIGJCE@?$CD?$CDAddColorName@ DB '##AddColorName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GOENPNKG@Add?$CD?$CDColor@
CONST	SEGMENT
??_C@_0L@GOENPNKG@Add?$CD?$CDColor@ DB 'Add##Color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOKNCBKO@?$CD?$CDColor@
CONST	SEGMENT
??_C@_07KOKNCBKO@?$CD?$CDColor@ DB '##Color', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJLKDALA@?$CD?$CDRomFSPath@
CONST	SEGMENT
??_C@_0M@GJLKDALA@?$CD?$CDRomFSPath@ DB '##RomFSPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DOCDGGFI@Model?5Path@
CONST	SEGMENT
??_C@_0L@DOCDGGFI@Model?5Path@ DB 'Model Path', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BPIHFLLE@?1Weapon_Sword_020?4Weapon_Sword_@
CONST	SEGMENT
??_C@_0CJ@BPIHFLLE@?1Weapon_Sword_020?4Weapon_Sword_@ DB '/Weapon_Sword_0'
	DB	'20.Weapon_Sword_020.bfres', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLCJGHIH@?$CD?$CDModelPath@
CONST	SEGMENT
??_C@_0M@KLCJGHIH@?$CD?$CDModelPath@ DB '##ModelPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAGKIPDA@Paths@
CONST	SEGMENT
??_C@_05EAGKIPDA@Paths@ DB 'Paths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGFMFAAA@RomFS?5Path@
CONST	SEGMENT
??_C@_0L@IGFMFAAA@RomFS?5Path@ DB 'RomFS Path', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EDFKNK@?1Pack?1Bootup?4Nin_NX_NVN?4pack?4zs@
CONST	SEGMENT
??_C@_0CA@EDFKNK@?1Pack?1Bootup?4Nin_NX_NVN?4pack?4zs@ DB '/Pack/Bootup.N'
	DB	'in_NX_NVN.pack.zs', 00H			; `string'
PUBLIC	??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
PUBLIC	??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
PUBLIC	??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
PUBLIC	??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,bool,0>
PUBLIC	??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Max
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Orphan_ptr
PUBLIC	?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_ptr2
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Erase_unchecked
PUBLIC	?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Unwrapped
PUBLIC	?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_erase
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase_bucket
PUBLIC	??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,0>
PUBLIC	??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase<TextureToGo *>
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> *>::pointer_to
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::end
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator==
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator->
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++
PUBLIC	?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
PUBLIC	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::erase
PUBLIC	?Open@PopupSettings@@YAXXZ			; PopupSettings::Open
PUBLIC	?__autoclassinit2@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::__autoclassinit2
PUBLIC	?Render@PopupSettings@@YAXXZ			; PopupSettings::Render
PUBLIC	?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupSettings::ColorActorName
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+50
	DD	imagerel $unwind$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DD imagerel $LN18
	DD	imagerel $LN18+50
	DD	imagerel $unwind$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD imagerel $LN22
	DD	imagerel $LN22+50
	DD	imagerel $unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN24
	DD	imagerel $LN24+50
	DD	imagerel $unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD imagerel $LN71
	DD	imagerel $LN71+157
	DD	imagerel $unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN156
	DD	imagerel $LN156+435
	DD	imagerel $unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN156+435
	DD	imagerel $LN156+935
	DD	imagerel $chain$0$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN156+935
	DD	imagerel $LN156+970
	DD	imagerel $chain$1$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD imagerel $LN102
	DD	imagerel $LN102+195
	DD	imagerel $unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z DD imagerel $LN68
	DD	imagerel $LN68+71
	DD	imagerel $unwind$?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN153
	DD	imagerel $LN153+326
	DD	imagerel $unwind$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z DD imagerel $LN117
	DD	imagerel $LN117+228
	DD	imagerel $unwind$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z DD imagerel $LN133
	DD	imagerel $LN133+309
	DD	imagerel $unwind$??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN5
	DD	imagerel $LN5+20
	DD	imagerel $unwind$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN7
	DD	imagerel $LN7+20
	DD	imagerel $unwind$??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN30
	DD	imagerel $LN30+130
	DD	imagerel $unwind$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN155
	DD	imagerel $LN155+318
	DD	imagerel $unwind$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z DD imagerel $LN136
	DD	imagerel $LN136+309
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@PopupSettings@@YAXXZ DD imagerel $LN1456
	DD	imagerel $LN1456+5575
	DD	imagerel $unwind$?Render@PopupSettings@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FColorActorName@PopupSettings@@YAXXZ DD imagerel ??__FColorActorName@PopupSettings@@YAXXZ
	DD	imagerel ??__FColorActorName@PopupSettings@@YAXXZ+100
	DD	imagerel $unwind$??__FColorActorName@PopupSettings@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FColorActorName@PopupSettings@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@PopupSettings@@YAXXZ DB '4'
	DB	015H, 02H
	DB	00H
	DB	0c1H, 012H
	DB	02H
	DB	'2'
	DB	04H
	DB	01eH
	DB	02H
	DB	0e1H, 02H
	DB	00H
	DB	0ecH
	DB	06H
	DB	' '
	DB	08H
	DB	'B'
	DB	0aH
	DB	'$'
	DB	06H
	DB	0a0H
	DB	00H
	DB	0c9H, 0bH
	DB	0cH
	DB	'J'
	DB	00H
	DB	08dH, 0cH
	DB	0eH
	DB	'<'
	DB	00H
	DB	0adH, 06H
	DB	06H
	DB	' '
	DB	08H
	DB	'B'
	DB	0aH
	DB	'('
	DB	06H
	DB	0faH
	DB	00H
	DB	0ddH, 07H
	DB	0cH
	DB	0c0H
	DB	010H
	DB	08eH
	DB	012H
	DB	019H, 02H
	DB	014H
	DB	','
	DB	016H
	DB	':'
	DB	014H
	DB	'M', 06H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@PopupSettings@@YAXXZ DB 016H
	DB	0aH
	DD	imagerel ??1BfresFile@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	07aH
	DD	imagerel ??1ActorInformation@ActorMgr@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	072H
	DD	imagerel ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@QEAA@XZ
	DB	0c1H
	DB	06H
	DB	045H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0d0H
	DB	0b5H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	07aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@PopupSettings@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@PopupSettings@@YAXXZ
	DD	imagerel $ip2state$?Render@PopupSettings@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@PopupSettings@@YAXXZ DD 0f3b19H
	DD	02a682aH
	DD	05e7426H
	DD	05d6426H
	DD	05c3426H
	DD	0560126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Render@PopupSettings@@YAXXZ
	DD	0292H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	0edH, 02H
	DB	02H
	DB	'('
	DB	04H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0a1811H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z DD 082119H
	DD	0c5412H
	DD	0a3412H
	DD	0e00e5212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	0dH, 03H
	DB	02H
	DB	'('
	DB	04H
	DB	0d2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0a1611H
	DD	0125416H
	DD	0103416H
	DD	0f0129216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 021H
	DD	imagerel $LN156
	DD	imagerel $LN156+435
	DD	imagerel $unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 020521H
	DD	073405H
	DD	imagerel $LN156
	DD	imagerel $LN156+435
	DD	imagerel $unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 04H
	DB	'V'
	DB	02H
	DB	'0'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
	DD	imagerel $ip2state$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 081411H
	DD	0b6414H
	DD	0a5414H
	DD	093414H
	DD	070105214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z DD 020601H
	DD	030023206H
?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; PopupSettings::ColorActorName
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DQ	0000000000000000H
	DQ	000000000000000fH
?ColorActorName$initializer$@PopupSettings@@3P6AXXZEA DQ FLAT:??__FColorActorName@PopupSettings@@YAXXZ ; PopupSettings::ColorActorName$initializer$
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
;	COMDAT ??__FColorActorName@PopupSettings@@YAXXZ
text$di	SEGMENT
??__FColorActorName@PopupSettings@@YAXXZ PROC		; PopupSettings::`dynamic atexit destructor for 'ColorActorName'', COMDAT

; 14   : std::string PopupSettings::ColorActorName = "";

	lea	rcx, OFFSET FLAT:??__FColorActorName@PopupSettings@@YAXXZ ; PopupSettings::`dynamic atexit destructor for 'ColorActorName''
	jmp	atexit
??__FColorActorName@PopupSettings@@YAXXZ ENDP		; PopupSettings::`dynamic atexit destructor for 'ColorActorName''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FColorActorName@PopupSettings@@YAXXZ
text$yd	SEGMENT
??__FColorActorName@PopupSettings@@YAXXZ PROC		; PopupSettings::`dynamic atexit destructor for 'ColorActorName'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@dynamic

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqa	XMMWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
	add	rsp, 40					; 00000028H
	ret	0
$LN24@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@dynamic:
??__FColorActorName@PopupSettings@@YAXXZ ENDP		; PopupSettings::`dynamic atexit destructor for 'ColorActorName''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
;	COMDAT ?Render@PopupSettings@@YAXXZ
_TEXT	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?Render@PopupSettings@@YAXXZ PROC			; PopupSettings::Render, COMDAT

; 17   : {

$LN1456:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-472]
	sub	rsp, 688				; 000002b0H
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	xor	r12d, r12d

; 18   : 	if (IsOpen)

	cmp	BYTE PTR ?IsOpen@PopupSettings@@3_NA, r12b ; PopupSettings::IsOpen
	je	$LN11@Render

; 19   : 	{
; 20   : 		UIMapView::RenderSettings.AllowSelectingActor = false;

	mov	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+5, r12b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8124 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8125 :     IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
; 8126 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;

	or	DWORD PTR [rax+18680], 2

; 8127 :     g.NextWindowData.SizeVal = size;

	mov	DWORD PTR [rax+18716], 1143275520	; 44250000H
	mov	DWORD PTR [rax+18720], 1133903872	; 43960000H

; 8128 :     g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rax+18688], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 22   : 		ImGui::OpenPopup("Settings");

	lea	rcx, OFFSET FLAT:??_C@_08EEOHOBEO@Settings@
	call	?OpenPopup@ImGui@@YAXPEBDH@Z		; ImGui::OpenPopup

; 23   : 		if (ImGui::BeginPopupModal("Settings"))

	xor	r8d, r8d
	lea	rcx, OFFSET FLAT:??_C@_08EEOHOBEO@Settings@
	call	?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z ; ImGui::BeginPopupModal
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	al, al
	je	$LN148@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3135 :     backup.Col = idx;

	mov	DWORD PTR backup$29[rbp-256], 27

; 3136 :     backup.BackupValue = g.Style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rbx+15208]
	movups	XMMWORD PTR backup$29[rbp-252], xmm0

; 3137 :     g.ColorStack.push_back(backup);

	lea	rcx, QWORD PTR [rbx+18824]
	lea	rdx, QWORD PTR backup$29[rbp-256]
	call	?push_back@?$ImVector@UImGuiColorMod@@@@QEAAXAEBUImGuiColorMod@@@Z ; ImVector<ImGuiColorMod>::push_back

; 3138 :     g.Style.Colors[idx] = col;

	mov	DWORD PTR [rbx+15208], 1061010878	; 3f3dbdbeH
	mov	DWORD PTR [rbx+15212], 1061405636	; 3f43c3c4H
	mov	DWORD PTR [rbx+15216], 1061668808	; 3f47c7c8H
	mov	DWORD PTR [rbx+15220], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 30   : 			ImGui::Text("Paths");

	lea	rcx, OFFSET FLAT:??_C@_05EAGKIPDA@Paths@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rbx+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], r12b
	jne	SHORT $LN1105@Render

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6

; 1473 :     SeparatorEx(flags, 1.0f);

	movss	xmm1, DWORD PTR __real@3f800000
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN1105@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4128 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 4129 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

	test	rdx, rdx
	je	SHORT $LN1110@Render
	cmp	DWORD PTR [rdx+16], 2
	jne	SHORT $LN1109@Render
	cmp	DWORD PTR [rdx+4], r12d
	je	SHORT $LN1111@Render
$LN1109@Render:

; 4130 :         return;
; 4131 : 
; 4132 :     if (columns != NULL)
; 4133 :         EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
$LN1110@Render:

; 4134 : 
; 4135 :     if (columns_count != 1)
; 4136 :         BeginColumns(id, columns_count, flags);

	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	lea	rcx, OFFSET FLAT:??_C@_05EAGKIPDA@Paths@
	call	?BeginColumns@ImGui@@YAXPEBDHH@Z	; ImGui::BeginColumns
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN1111@Render:
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 34   : 			ImGui::Indent();

	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r12
	lea	rdi, OFFSET FLAT:??_C@_0L@IGFMFAAA@RomFS?5Path@
	mov	QWORD PTR [rsp+40], rdi
	movss	xmm6, DWORD PTR __real@bf800000
	movss	DWORD PTR [rsp+32], xmm6
	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$6[rsp]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$6[rsp]
	addss	xmm0, DWORD PTR __real@3f7fff58
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 36   : 			ImGui::SetColumnWidth(0, ImGui::CalcTextSize("RomFS Path").x + ImGui::GetStyle().ItemSpacing.x * 2 + ImGui::GetStyle().IndentSpacing);

	movss	xmm2, DWORD PTR [rbx+14628]
	addss	xmm2, xmm2
	addss	xmm2, xmm1
	addss	xmm2, DWORD PTR [rbx+14660]
	movaps	xmm1, xmm2
	xor	ecx, ecx
	call	?SetColumnWidth@ImGui@@YAXHM@Z		; ImGui::SetColumnWidth

; 37   : 
; 38   : 			ImGui::Text("RomFS Path");

	mov	rcx, rdi
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 39   : 			ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 40   : 			ImGui::PushItemWidth(ImGui::GetColumnWidth() - ImGui::GetStyle().ScrollbarSize);

	mov	r13d, -1
	mov	ecx, r13d
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	subss	xmm0, DWORD PTR [rax+14668]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 41   : 			bool RomFSValid = !Editor::RomFSDir.empty();

	mov	rcx, QWORD PTR ?RomFSDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
	test	rcx, rcx
	setne	al

; 42   : 			if (RomFSValid)

	mov	r14, 9223372036854775807		; 7fffffffffffffffH
	test	rcx, rcx
	je	SHORT $LN13@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 31
	jb	$LN1453@Render

; 2236 :         if (_Large_string_engaged()) {

	lea	r9, OFFSET FLAT:?RomFSDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::RomFSDir
	cmp	QWORD PTR ?RomFSDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	r9, QWORD PTR ?RomFSDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 31
	lea	rax, OFFSET FLAT:??_C@_0CA@EDFKNK@?1Pack?1Bootup?4Nin_NX_NVN?4pack?4zs@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 43   : 				RomFSValid = Util::FileExists(Editor::RomFSDir + "/Pack/Bootup.Nin_NX_NVN.pack.zs");

	lea	rcx, QWORD PTR $T23[rsp]
	call	?FileExists@Util@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::FileExists
$LN13@Render:

; 45   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, RomFSValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	lea	rdx, QWORD PTR $T16[rsp]
	test	al, al
	je	SHORT $LN29@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003d8f5c293e851eb83d75c28f
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 45   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, RomFSValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	jmp	SHORT $LN1450@Render
$LN29@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003d8f5c293d75c28f3e851eb8
$LN1450@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 45   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, RomFSValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	movups	XMMWORD PTR $T15[rsp], xmm0
	mov	ecx, 7
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 46   : 			ImGui::InputText("##RomFSPath", &Editor::RomFSDir);

	lea	rdx, OFFSET FLAT:?RomFSDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::RomFSDir
	lea	rcx, OFFSET FLAT:??_C@_0M@GJLKDALA@?$CD?$CDRomFSPath@
	call	?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText

; 47   : 			ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [r10+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 49   : 			ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 50   : 
; 51   : 			ImGui::Text("Model Path");

	lea	rcx, OFFSET FLAT:??_C@_0L@DOCDGGFI@Model?5Path@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 52   : 			ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 53   : 			ImGui::PushItemWidth(ImGui::GetColumnWidth() - ImGui::GetStyle().ScrollbarSize);

	mov	ecx, r13d
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	subss	xmm0, DWORD PTR [rax+14668]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 54   : 			bool ModelValid = !Editor::BfresDir.empty();

	mov	rcx, QWORD PTR ?BfresDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
	test	rcx, rcx
	setne	al

; 55   : 			if (ModelValid)

	test	rcx, rcx
	je	SHORT $LN14@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 40					; 00000028H
	jb	$LN1454@Render

; 2236 :         if (_Large_string_engaged()) {

	lea	r9, OFFSET FLAT:?BfresDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::BfresDir
	cmp	QWORD PTR ?BfresDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	r9, QWORD PTR ?BfresDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 40			; 00000028H
	lea	rax, OFFSET FLAT:??_C@_0CJ@BPIHFLLE@?1Weapon_Sword_020?4Weapon_Sword_@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T22[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 56   : 				ModelValid = Util::FileExists(Editor::BfresDir + "/Weapon_Sword_020.Weapon_Sword_020.bfres");

	lea	rcx, QWORD PTR $T22[rsp]
	call	?FileExists@Util@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::FileExists
$LN14@Render:

; 58   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, ModelValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	lea	rdx, QWORD PTR $T14[rsp]
	test	al, al
	je	SHORT $LN31@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003d8f5c293e851eb83d75c28f
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 58   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, ModelValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	jmp	SHORT $LN1451@Render
$LN31@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@3f8000003d8f5c293d75c28f3e851eb8
$LN1451@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 58   : 			ImGui::PushStyleColor(ImGuiCol_FrameBg, ModelValid ? ImVec4(0.06f, 0.26f, 0.07f, 1.0f) : ImVec4(0.26f, 0.06f, 0.07f, 1.0f));

	movups	XMMWORD PTR $T13[rsp], xmm0
	mov	ecx, 7
	call	?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z ; ImGui::PushStyleColor

; 59   : 			ImGui::InputText("##ModelPath", &Editor::BfresDir);

	lea	rdx, OFFSET FLAT:?BfresDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::BfresDir
	lea	rcx, OFFSET FLAT:??_C@_0M@KLCJGHIH@?$CD?$CDModelPath@
	call	?InputText@ImGui@@YA_NPEBDPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputText

; 60   : 			ImGui::PopStyleColor();

	mov	ecx, 1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [r10+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 63   : 			ImGui::Unindent();

	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdx, QWORD PTR [r10+16408]
	mov	BYTE PTR [rdx+237], 1
	mov	rax, QWORD PTR [r10+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4128 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rcx, QWORD PTR [rax+480]

; 4129 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

	test	rcx, rcx
	je	SHORT $LN1133@Render
	cmp	DWORD PTR [rcx+16], 1
	jne	SHORT $LN1132@Render
	cmp	DWORD PTR [rcx+4], r12d
	je	SHORT $LN1133@Render
$LN1132@Render:

; 4130 :         return;
; 4131 : 
; 4132 :     if (columns != NULL)
; 4133 :         EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
$LN1133@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 66   : 			ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine

; 67   : 			ImGui::Text("Colors");

	lea	rcx, OFFSET FLAT:??_C@_06ICDCBJPI@Colors@
	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 68   : 			ImGui::SameLine();

	movaps	xmm1, xmm6
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 69   : 			ImGui::InputTextWithHint("##AddColorName", "String in actor name...", &ColorActorName);

	lea	r15, OFFSET FLAT:?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupSettings::ColorActorName
	mov	r8, r15
	lea	rdx, OFFSET FLAT:??_C@_0BI@MMFLADEG@String?5in?5actor?5name?4?4?4@
	lea	rcx, OFFSET FLAT:??_C@_0P@NNAIGJCE@?$CD?$CDAddColorName@
	call	?InputTextWithHint@ImGui@@YA_NPEBD0PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z ; ImGui::InputTextWithHint

; 70   : 			ImGui::SameLine();

	movaps	xmm1, xmm6
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T9[rsp], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0L@GOENPNKG@Add?$CD?$CDColor@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 71   : 			if (ImGui::Button("Add##Color"))

	test	al, al
	je	$LN16@Render

; 72   : 			{
; 73   : 				if (!ColorActorName.empty())

	cmp	QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, r12
	je	$LN16@Render

; 75   : 					BfresLibrary::Models.insert({ ColorActorName, BfresFile::CreateDefaultModel(ColorActorName, 255, 255, 255, 255) });

	mov	rdx, r15
	lea	rcx, QWORD PTR $T21[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [rsp+48], xmm0
	mov	BYTE PTR [rsp+40], 255			; 000000ffH
	mov	BYTE PTR [rsp+32], 255			; 000000ffH
	mov	r9b, 255				; 000000ffH
	movzx	r8d, r9b
	mov	rdx, rax
	lea	rcx, QWORD PTR $T37[rbp-256]
	call	?CreateDefaultModel@BfresFile@@SA?AV1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@EEEEM@Z ; BfresFile::CreateDefaultModel
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdx, r15
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T28[rbp-224]
	call	??0BfresFile@@QEAA@$$QEAV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 75   : 					BfresLibrary::Models.insert({ ColorActorName, BfresFile::CreateDefaultModel(ColorActorName, 255, 255, 255, 255) });

	lea	r8, QWORD PTR $T28[rbp-256]
	lea	rdx, QWORD PTR $T12[rsp]
	call	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::insert<0,0>
	npad	1
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T37[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T37[rbp-208]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T37[rbp-232]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T37[rbp-256]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 77   : 					for (Actor& SceneActor : ActorMgr::GetActors())

	mov	rsi, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	mov	r14, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	cmp	rsi, r14
	je	$LN3@Render

; 75   : 					BfresLibrary::Models.insert({ ColorActorName, BfresFile::CreateDefaultModel(ColorActorName, 255, 255, 255, 255) });

	lea	rdi, QWORD PTR [rsi+8]
$LL4@Render:

; 78   : 					{
; 79   : 						if (!SceneActor.Model->IsDefaultModel()) continue;

	mov	rax, QWORD PTR [rdi+416]
	cmp	BYTE PTR [rax+72], 0
	je	$LN2@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2236 :         if (_Large_string_engaged()) {

	mov	r9, r15
	cmp	QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	r9, QWORD PTR ?ColorActorName@PopupSettings@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rdi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rdi+24], 16
	jb	SHORT $LN1175@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdi]
$LN1175@Render:

; 4343 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	mov	rdx, QWORD PTR [rdi+16]
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 80   : 						if (SceneActor.Gyml.find(ColorActorName) != std::string::npos)

	cmp	rax, -1
	je	$LN2@Render

; 81   : 						{
; 82   : 							ActorMgr::ActorInfo.erase(SceneActor.Gyml);

	mov	rdx, rdi
	call	?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::erase

; 83   : 							ActorMgr::ActorInfo.insert({ SceneActor.Gyml, { BfresLibrary::GetModel(ColorActorName) } });

	mov	rdx, r15
	lea	rcx, QWORD PTR $T20[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rcx, rax
	call	?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresLibrary::GetModel
	mov	rbx, rax
	mov	QWORD PTR $T27[rbp-256], rax
	mov	WORD PTR $T27[rbp-248], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T27[rbp-240], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T27[rbp-224], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T27[rbp-216], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T27[rbp-240], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T27[rbp-208], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T27[rbp-192], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T27[rbp-184], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T27[rbp-208], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T27[rbp-176], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T27[rbp-160], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T27[rbp-152], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T27[rbp-176], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T27[rbp-144], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T27[rbp-128], r12

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T27[rbp-120], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T27[rbp-144], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR $T27[rbp-112], xmm0
	mov	QWORD PTR $T27[rbp-96], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 231  :         : first(_Val1), second(_Val2) {}

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T36[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	QWORD PTR $T36[rbp-224], rbx
	mov	WORD PTR $T36[rbp-216], 0
	lea	rdx, QWORD PTR $T27[rbp-240]
	lea	rcx, QWORD PTR $T36[rbp-208]
	call	??0UMii@@QEAA@AEBV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 83   : 							ActorMgr::ActorInfo.insert({ SceneActor.Gyml, { BfresLibrary::GetModel(ColorActorName) } });

	lea	r8, QWORD PTR $T36[rbp-256]
	lea	rdx, QWORD PTR $T11[rsp]
	call	?insert@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::insert
	npad	1
	lea	rcx, QWORD PTR $T36[rbp-224]
	call	??1ActorInformation@ActorMgr@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T36[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T27[rbp-112]
	call	?_Tidy@?$vector@UModelElement@UMii@@V?$allocator@UModelElement@UMii@@@std@@@std@@AEAAXXZ ; std::vector<UMii::ModelElement,std::allocator<UMii::ModelElement> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T27[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T27[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T27[rbp-208]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T27[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rdi
	lea	rdx, QWORD PTR $T33[rbp-256]
	call	??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 84   : 							SceneActor.Model = ActorMgr::ActorInfo[SceneActor.Gyml].Model;

	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rdx+48]
	mov	QWORD PTR [rdi+416], rax
$LN2@Render:

; 77   : 					for (Actor& SceneActor : ActorMgr::GetActors())

	add	rsi, 872				; 00000368H
	add	rdi, 872				; 00000368H
	cmp	rsi, r14
	jne	$LL4@Render
$LN3@Render:

; 85   : 						}
; 86   : 					}
; 87   : 					ActorMgr::UpdateModelOrder();

	call	?UpdateModelOrder@ActorMgr@@YAXXZ	; ActorMgr::UpdateModelOrder
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	rcx, r15
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN16@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rax+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], 0
	jne	SHORT $LN769@Render

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6

; 1473 :     SeparatorEx(flags, 1.0f);

	movss	xmm1, DWORD PTR __real@3f800000
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
$LN769@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4128 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 4129 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

	test	rdx, rdx
	je	SHORT $LN774@Render
	cmp	DWORD PTR [rdx+16], 3
	jne	SHORT $LN773@Render
	cmp	DWORD PTR [rdx+4], 0
	je	SHORT $LN775@Render
$LN773@Render:

; 4130 :         return;
; 4131 : 
; 4132 :     if (columns != NULL)
; 4133 :         EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
$LN774@Render:

; 4134 : 
; 4135 :     if (columns_count != 1)
; 4136 :         BeginColumns(id, columns_count, flags);

	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+3]
	lea	rcx, OFFSET FLAT:??_C@_06ICDCBJPI@Colors@
	call	?BeginColumns@ImGui@@YAXPEBDHH@Z	; ImGui::BeginColumns
$LN775@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10308:     window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR [rcx+14660]
	addss	xmm0, DWORD PTR [rax+380]
	movss	DWORD PTR [rax+380], xmm0

; 10309:     window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;

	addss	xmm0, DWORD PTR [rax+80]
	addss	xmm0, DWORD PTR [rax+384]
	movss	DWORD PTR [rax+312], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 96   : 			for (std::map<std::string, BfresFile>::iterator Iter = BfresLibrary::Models.begin(); Iter != BfresLibrary::Models.end(); )

	cmp	rbx, rax
	je	$LN1443@Render
	movss	xmm6, DWORD PTR __real@437f0000
$LL5@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 186  :         return this->_Ptr->_Myval;

	mov	r15, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 98   : 				if (!Iter->second.IsDefaultModel())

	cmp	BYTE PTR [rbx+136], 0
	jne	SHORT $LN19@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN399@Render

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	$LN826@Render
$LL397@Render:
	cmp	rbx, QWORD PTR [rax+16]
	jne	$LN826@Render

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL397@Render

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	$LN828@Render
$LN399@Render:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]
	cmp	BYTE PTR [rcx+25], 0
	jne	$LN828@Render
	npad	13
$LL403@Render:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL403@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 101  : 					continue;

	jmp	$LN828@Render
$LN19@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 186  :         return this->_Ptr->_Myval;

	lea	rsi, QWORD PTR [rbx+32]

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r14, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rdi, QWORD PTR [r14+8]

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rdi+25], 0
	jne	SHORT $LN416@Render
	npad	7
$LL415@Render:

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN417@Render

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;
; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rdi, QWORD PTR [rdi+16]

; 1620 :             } else {

	jmp	SHORT $LN418@Render
$LN417@Render:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;
; 1622 :                 _Result._Bound           = _Trynode;

	mov	r14, rdi

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rdi, QWORD PTR [rdi]
$LN418@Render:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rdi+25], 0
	je	SHORT $LL415@Render
$LN416@Render:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [r14+25], 0
	jne	$LN1442@Render
	lea	rdx, QWORD PTR [r14+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	$LN1442@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 108  : 				ModelIndex++;

	inc	r13d

; 109  : 				
; 110  : 				if (ModelIndex > 0)

	test	r13d, r13d
	jle	SHORT $LN21@Render

; 111  : 					ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
$LN21@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1437@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN1437@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 113  : 				ImGui::Text(Iter->first.c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text

; 114  : 				ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 116  : 				Data[0] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[0] / 255.0f;

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 116  : 				Data[0] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[0] / 255.0f;

	movzx	ecx, BYTE PTR [rax]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm6
	movss	DWORD PTR Data$38[rbp-256], xmm0

; 117  : 				Data[1] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[1] / 255.0f;

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 117  : 				Data[1] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[1] / 255.0f;

	movzx	eax, BYTE PTR [rcx+1]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm6
	movss	DWORD PTR Data$38[rbp-252], xmm0

; 118  : 				Data[2] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[2] / 255.0f;

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 118  : 				Data[2] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[2] / 255.0f;

	movzx	eax, BYTE PTR [rcx+2]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm6
	movss	DWORD PTR Data$38[rbp-248], xmm0

; 119  : 				Data[3] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[3] / 255.0f;

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 119  : 				Data[3] = TextureToGoLibrary::Textures[Iter->first].GetPixels()[3] / 255.0f;

	movzx	eax, BYTE PTR [rcx+3]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm6
	movss	DWORD PTR Data$38[rbp-244], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rcx, QWORD PTR [rsi+16]

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	r14, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, r14
	sub	rax, rcx
	cmp	rax, 7
	jb	$LN1351@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1438@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN1438@Render:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07KOKNCBKO@?$CD?$CDColor@
	lea	rcx, QWORD PTR $T19[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T19[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T19[rbp-232], 16
	cmovae	rcx, QWORD PTR $T19[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 120  : 				if (ImGui::ColorEdit4(("##Color" + Iter->first).c_str(), (float*)&Data, ImGuiColorEditFlags_DisplayRGB))

	mov	r8d, 1048576				; 00100000H
	lea	rdx, QWORD PTR Data$38[rbp-256]
	call	?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z	; ImGui::ColorEdit4
	movzx	edi, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T19[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN664@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T19[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN676@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN673@Render
$LN676@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN664@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 120  : 				if (ImGui::ColorEdit4(("##Color" + Iter->first).c_str(), (float*)&Data, ImGuiColorEditFlags_DisplayRGB))

	test	dil, dil
	je	$LN22@Render

; 122  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[0] = Data[0] * 255.0f;

	movss	xmm0, DWORD PTR Data$38[rbp-256]
	mulss	xmm0, xmm6
	cvttss2si edi, xmm0
	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 122  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[0] = Data[0] * 255.0f;

	mov	BYTE PTR [rax], dil

; 123  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[1] = Data[1] * 255.0f;

	movss	xmm0, DWORD PTR Data$38[rbp-252]
	mulss	xmm0, xmm6
	cvttss2si edi, xmm0
	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 123  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[1] = Data[1] * 255.0f;

	mov	BYTE PTR [rcx+1], dil

; 124  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[2] = Data[2] * 255.0f;

	movss	xmm0, DWORD PTR Data$38[rbp-248]
	mulss	xmm0, xmm6
	cvttss2si edi, xmm0
	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 124  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[2] = Data[2] * 255.0f;

	mov	BYTE PTR [rcx+2], dil

; 125  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[3] = Data[3] * 255.0f;

	movss	xmm0, DWORD PTR Data$38[rbp-244]
	mulss	xmm0, xmm6
	cvttss2si edi, xmm0
	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 125  : 					TextureToGoLibrary::Textures[Iter->first].GetPixels()[3] = Data[3] * 255.0f;

	mov	BYTE PTR [rcx+3], dil

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rdx, rsi
	call	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
	mov	r8, rax
	mov	rcx, rax
	shr	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	edx, cl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	movzx	ecx, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	rax, -3750763034362895579		; cbf29ce484222325H
	xor	rcx, rax

; 2346 :         _Val *= _FNV_prime;

	mov	r9, 1099511628211			; 00000100000001b3H
	imul	rcx, r9

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	ecx, al

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	ecx, al

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	ecx, al

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	ecx, al

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 48					; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	movzx	ecx, al

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rcx

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 126  : 					GLTextureLibrary::Textures.erase(&TextureToGoLibrary::Textures[Iter->first]);

	mov	rax, r8
	shr	rax, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	rdx, rax

; 2346 :         _Val *= _FNV_prime;

	imul	rdx, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;

	add	rdx, rdx
	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	rdi, QWORD PTR [rcx+rdx*8+8]

; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r9, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1570 :         if (_Where == _End) {

	cmp	rdi, r9
	je	SHORT $LN1350@Render

; 1571 :             return {_End, _Nodeptr{}};
; 1572 :         }
; 1573 : 
; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rax, QWORD PTR [rcx+rdx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	r8, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN900@Render
$LL899@Render:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rdi, rax
	je	SHORT $LN1350@Render

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rdi, QWORD PTR [rdi+8]

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	cmp	r8, QWORD PTR [rdi+16]
	jne	SHORT $LL899@Render
	jmp	SHORT $LN900@Render
$LN1350@Render:

; 1112 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	mov	rdi, r12
$LN900@Render:
	test	rdi, rdi

; 1113 :             if (_Target) {

	je	SHORT $LN965@Render

; 1668 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rcx+rdx*8]
	cmp	QWORD PTR [rcx+rdx*8+8], rdi
	jne	SHORT $LN911@Render

; 1669 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rdi
	jne	SHORT $LN913@Render

; 1670 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1671 : 
; 1672 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rcx+rdx*8], r9

; 1676 :             }
; 1677 :         } else if (_Bucket_lo == _Plist) {

	mov	QWORD PTR [rcx+rdx*8+8], r9
	jmp	SHORT $LN915@Render
$LN913@Render:

; 1673 :                 _Bucket_hi = _End;
; 1674 :             } else {
; 1675 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r9, QWORD PTR [rdi+8]

; 1676 :             }
; 1677 :         } else if (_Bucket_lo == _Plist) {

	mov	QWORD PTR [rcx+rdx*8+8], r9
	jmp	SHORT $LN915@Render
$LN911@Render:
	cmp	rax, rdi
	jne	SHORT $LN915@Render

; 1678 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rdx*8], rax
$LN915@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1421 :         const auto _Result = _Pnode->_Next;

	mov	rdx, QWORD PTR [rdi]

; 1422 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1423 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1424 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rax], rdx

; 1425 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rdx+8], rax

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN965@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 127  : 					Iter->second.CreateOpenGLObjects();

	lea	rcx, QWORD PTR [rbx+64]
	call	?CreateOpenGLObjects@BfresFile@@QEAAXXZ	; BfresFile::CreateOpenGLObjects
$LN22@Render:

; 128  : 				}
; 129  : 				ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [rsi+16]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rsi

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdi, r8

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1439@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rsi]
$LN1439@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 7
	jne	SHORT $LN23@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN23@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 131  : 					ImGui::BeginDisabled();

	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
	mov	rdi, QWORD PTR [rsi+16]
$LN23@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3804 :     ImGuiWindow* window = g.CurrentWindow;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [r10+16408]

; 3805 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	r9, QWORD PTR [rcx+480]

; 3806 :     if (columns == NULL)

	test	r9, r9
	jne	SHORT $LN1434@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10445:     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, rcx

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	cmp	r9, r9
	jne	SHORT $LN617@Render
	cmp	QWORD PTR [r10+19728], r9
	jne	SHORT $LN617@Render
	add	rax, 648				; 00000288H
	movss	xmm1, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, DWORD PTR [rcx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3807 :         return GetContentRegionAvail().x;

	jmp	SHORT $LN609@Render
$LN617@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	add	rax, 600				; 00000258H
	movss	xmm1, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm1, DWORD PTR [rcx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3807 :         return GetContentRegionAvail().x;

	jmp	SHORT $LN609@Render
$LN1434@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, DWORD PTR [r9+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3811 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	mov	r8, QWORD PTR [r9+104]
	lea	rax, QWORD PTR [rdx+1]
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rax, rdx, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3811 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	movss	xmm1, DWORD PTR [rcx+r8]
	subss	xmm1, DWORD PTR [rax+r8]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm0, DWORD PTR [r9+24]
	subss	xmm0, DWORD PTR [r9+20]
	mulss	xmm1, xmm0
$LN609@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 132  : 				if (ImGui::Button(("Del##" + Iter->first).c_str(), ImVec2(ImGui::GetColumnWidth() - ImGui::GetStyle().ScrollbarSize, 0)))

	subss	xmm1, DWORD PTR [r10+14668]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T8[rsp], xmm1
	mov	DWORD PTR $T8[rsp+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rax, r14
	sub	rax, rdi
	cmp	rax, 5
	jb	$LN1352@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1440@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN1440@Render:

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 5
	lea	r9, OFFSET FLAT:??_C@_05HOHECJHI@Del?$CD?$CD@
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T25[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T25[rbp-232], 16
	cmovae	rcx, QWORD PTR $T25[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T8[rsp]
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
	movzx	edi, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T25[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN573@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T25[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN585@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN582@Render
$LN585@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN573@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T25[rbp-240], r12

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T25[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T25[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 132  : 				if (ImGui::Button(("Del##" + Iter->first).c_str(), ImVec2(ImGui::GetColumnWidth() - ImGui::GetStyle().ScrollbarSize, 0)))

	test	dil, dil
	je	$LN24@Render

; 133  : 				{
; 134  : 					ImGui::NextColumn();

	call	?NextColumn@ImGui@@YAXXZ		; ImGui::NextColumn

; 135  : 					BfresFile* ModelPrt = &(Iter->second);

	lea	r12, QWORD PTR [rsi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1286 :         _Unchecked_const_iterator _Successor = _Where;

	mov	rax, r15

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rbx, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LN1011@Render

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rbx, QWORD PTR [r15+8]
	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN1012@Render
	npad	6
$LL1009@Render:
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1012@Render

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rbx

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rbx, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL1009@Render

; 58   :         } else {

	jmp	SHORT $LN1012@Render
$LN1011@Render:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rbx]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN1012@Render
	npad	2
$LL1015@Render:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL1015@Render
$LN1012@Render:

; 1288 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

	mov	rdx, r15
	lea	rcx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract
	mov	r14, rax
	lea	rcx, QWORD PTR [rax+144]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [r14+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [r14+88]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR [r14+64]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [r14+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 138  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	mov	r14, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	mov	r15, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	cmp	r14, r15
	je	$LN9@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1288 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

	lea	rsi, QWORD PTR [r14+8]
	npad	7
$LL10@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 140  : 						if (SceneActor.Model == ModelPrt)

	cmp	QWORD PTR [rsi+416], r12
	jne	$LN8@Render

; 141  : 						{
; 142  : 							ActorMgr::ActorInfo.erase(SceneActor.Gyml);

	mov	rdx, rsi
	call	?erase@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@QEAA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::erase

; 143  : 							ActorMgr::ActorInfo.insert({ SceneActor.Gyml, { BfresLibrary::GetModel(ActorMgr::GetDefaultModelKey(SceneActor)) } });

	mov	rdx, r14
	lea	rcx, QWORD PTR $T18[rsp]
	call	?GetDefaultModelKey@ActorMgr@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAUActor@@@Z ; ActorMgr::GetDefaultModelKey
	mov	rcx, rax
	call	?GetModel@BfresLibrary@@YAPEAVBfresFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BfresLibrary::GetModel
	mov	rdi, rax
	mov	QWORD PTR $T26[rbp-256], rax
	mov	WORD PTR $T26[rbp-248], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T26[rbp-240], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T26[rbp-224], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T26[rbp-216], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-240], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T26[rbp-208], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T26[rbp-192], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T26[rbp-184], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-208], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T26[rbp-176], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T26[rbp-160], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T26[rbp-152], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-176], al

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T26[rbp-144], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T26[rbp-128], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T26[rbp-120], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T26[rbp-144], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqa	XMMWORD PTR $T26[rbp-112], xmm0
	mov	QWORD PTR $T26[rbp-96], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 231  :         : first(_Val1), second(_Val2) {}

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	QWORD PTR $T35[rbp-224], rdi
	mov	WORD PTR $T35[rbp-216], 0
	lea	rdx, QWORD PTR $T26[rbp-240]
	lea	rcx, QWORD PTR $T35[rbp-208]
	call	??0UMii@@QEAA@AEBV0@@Z
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 143  : 							ActorMgr::ActorInfo.insert({ SceneActor.Gyml, { BfresLibrary::GetModel(ActorMgr::GetDefaultModelKey(SceneActor)) } });

	lea	r8, QWORD PTR $T35[rbp-256]
	lea	rdx, QWORD PTR $T34[rbp-256]
	call	?insert@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@std@@@std@@@std@@_N@2@$$QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@2@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::insert
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T35[rbp-80]
	call	?_Tidy@?$vector@UModelElement@UMii@@V?$allocator@UModelElement@UMii@@@std@@@std@@AEAAXXZ ; std::vector<UMii::ModelElement,std::allocator<UMii::ModelElement> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T35[rbp-112]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T35[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T35[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T35[rbp-208]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T26[rbp-112]
	call	?_Tidy@?$vector@UModelElement@UMii@@V?$allocator@UModelElement@UMii@@@std@@@std@@AEAAXXZ ; std::vector<UMii::ModelElement,std::allocator<UMii::ModelElement> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T26[rbp-144]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T26[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T26[rbp-208]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR $T26[rbp-240]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\unordered_map

; 438  :         return this->_Try_emplace(_Keyval).first->_Myval.second;

	mov	r8, rsi
	lea	rdx, QWORD PTR $T30[rbp-256]
	call	??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$_Hash@V?$_Umap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@V?$_Uhash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$hash@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@@2@$0A@@std@@@std@@IEAA?AU?$pair@PEAU?$_List_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Hash<std::_Umap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,ActorMgr::ActorInformation,std::_Uhash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::hash<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::equal_to<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,ActorMgr::ActorInformation> >,0> >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 144  : 							SceneActor.Model = ActorMgr::ActorInfo[SceneActor.Gyml].Model;

	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+48]
	mov	QWORD PTR [rsi+416], rax
$LN8@Render:

; 138  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	add	r14, 872				; 00000368H
	add	rsi, 872				; 00000368H
	cmp	r14, r15
	jne	$LL10@Render
$LN9@Render:

; 145  : 						}
; 146  : 					}
; 147  : 					ActorMgr::UpdateModelOrder();

	call	?UpdateModelOrder@ActorMgr@@YAXXZ	; ActorMgr::UpdateModelOrder

; 148  : 					continue;

	xor	r12d, r12d
	jmp	$LN828@Render
$LN24@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

	mov	r8, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN810@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN810@Render:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, 7
	jne	SHORT $LN26@Render

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	lea	rdx, OFFSET FLAT:??_C@_07MCAEODGB@Default@
	mov	rcx, rsi
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN26@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 151  : 					ImGui::EndDisabled();

	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled
$LN26@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN827@Render

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN826@Render
	npad	6
$LL825@Render:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN826@Render

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL825@Render
$LN826@Render:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN828@Render
$LN827@Render:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN828@Render
	npad	12
$LL831@Render:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL831@Render

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	jmp	SHORT $LN828@Render
$LN1442@Render:

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN760@Render

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN826@Render
$LL758@Render:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN826@Render

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL758@Render

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN828@Render
$LN760@Render:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN828@Render
	npad	7
$LL764@Render:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL764@Render
$LN828@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 96   : 			for (std::map<std::string, BfresFile>::iterator Iter = BfresLibrary::Models.begin(); Iter != BfresLibrary::Models.end(); )

	cmp	rbx, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	jne	$LL5@Render
$LN1443@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10316:     window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR [rax+380]
	subss	xmm0, DWORD PTR [rcx+14660]
	movss	DWORD PTR [rax+380], xmm0

; 10317:     window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;

	addss	xmm0, DWORD PTR [rax+80]
	addss	xmm0, DWORD PTR [rax+384]
	movss	DWORD PTR [rax+312], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4128 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rcx, QWORD PTR [rax+480]

; 4129 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

	test	rcx, rcx
	je	SHORT $LN159@Render
	cmp	DWORD PTR [rcx+16], 1
	jne	SHORT $LN158@Render
	cmp	DWORD PTR [rcx+4], 0
	je	SHORT $LN159@Render
$LN158@Render:

; 4130 :         return;
; 4131 : 
; 4132 :     if (columns != NULL)
; 4133 :         EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
$LN159@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
	movss	xmm6, DWORD PTR [rcx+92]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T17[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T17[rbp-232], 16
	cmovae	rcx, QWORD PTR $T17[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
	movss	xmm6, DWORD PTR [rcx+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 536  :     return _STD to_string(static_cast<double>(_Val));

	cvtps2pd xmm6, xmm6

; 529  :     const auto _Len = static_cast<size_t>(_CSTD _scprintf("%f", _Val));

	movaps	xmm1, xmm6
	movq	rdx, xmm6
	lea	rcx, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	_scprintf
	movsxd	rbx, eax

; 530  :     string _Str(_Len, '\0');

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T24[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T24[rbp-232], 16
	cmovae	rcx, QWORD PTR $T24[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\string

; 531  :     _CSTD sprintf_s(&_Str[0], _Len + 1, "%f", _Val);

	lea	rdx, QWORD PTR [rbx+1]
	movaps	xmm3, xmm6
	movq	r9, xmm6
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf@
	call	sprintf_s
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 6
	lea	r8, OFFSET FLAT:??_C@_06FMLHDGIC@Size?3?5@
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T10[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T10[rsp+16], xmm1

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T10[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T10[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 158  : 			ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	mov	QWORD PTR [rax+16], r12
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T10[rsp+16]
	mov	rdx, QWORD PTR $T10[rsp+24]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN340@Render

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T10[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T10[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T10[rsp]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 120			; 00000078H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T10[rsp]
	jmp	SHORT $LN339@Render
$LN673@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN582@Render:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN340@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01FJMABOPO@x@
	mov	edx, 1
	lea	rcx, QWORD PTR $T10[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN339@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T31[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T31[rbp-240], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 158  : 			ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	mov	QWORD PTR [rax+16], r12
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	lea	r9, QWORD PTR $T17[rsp]
	lea	r8, QWORD PTR $T31[rbp-256]
	lea	rcx, QWORD PTR $T32[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T32[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T32[rbp-232], 16
	cmovae	rcx, QWORD PTR $T32[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 158  : 			ImGui::Text(std::string("Size: " + std::to_string(ImGui::GetWindowSize().x) + "x" + std::to_string(ImGui::GetWindowSize().y)).c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T32[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN303@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T32[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN315@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN315@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN315@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN303@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T32[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T32[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T31[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN274@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T31[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN286@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN286@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN286@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN274@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T10[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN245@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T10[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN257@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN257@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN257@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN245@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T10[rsp+16], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T10[rsp], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T24[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN216@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T24[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN228@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN228@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN228@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN216@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T24[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T24[rbp-256], 0

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T17[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN186@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T17[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN198@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN198@Render
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN198@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN186@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T7[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, OFFSET FLAT:??_C@_05LGELBCGM@Close@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 160  : 			if (ImGui::Button("Close"))

	test	al, al
	je	SHORT $LN27@Render

; 161  : 			{
; 162  : 				IsOpen = false;

	mov	BYTE PTR ?IsOpen@PopupSettings@@3_NA, 0	; PopupSettings::IsOpen

; 163  : 				ActorMgr::UpdateModelOrder();

	call	?UpdateModelOrder@ActorMgr@@YAXXZ	; ActorMgr::UpdateModelOrder

; 164  : 				EditorConfig::Save();

	call	?Save@EditorConfig@@YAXXZ		; EditorConfig::Save

; 165  : 				PreferencesConfig::Save();

	call	?Save@PreferencesConfig@@YAXXZ		; PreferencesConfig::Save

; 166  : 				Editor::InitializeWithEdtc();

	call	?InitializeWithEdtc@Editor@@YAXXZ	; Editor::InitializeWithEdtc
$LN27@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3143 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3144 :     if (g.ColorStack.Size < count)

	movsxd	rax, DWORD PTR [rbx+18824]
	cmp	eax, 1
	jl	SHORT $LN148@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	lea	rdx, QWORD PTR [rax+rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	rcx, QWORD PTR [rbx+18832]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3152 :         g.Style.Colors[backup.Col] = backup.BackupValue;

	movsxd	rax, DWORD PTR [rcx+rdx*4-20]
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rdx*4-16]
	movups	XMMWORD PTR [rbx+rax*8+14776], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rbx+18824]
$LN148@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11218:     ImGuiWindow* window = g.CurrentWindow;

	mov	rcx, QWORD PTR [rbx+16408]

; 11219:     IM_ASSERT(window->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
; 11220:     IM_ASSERT(g.BeginPopupStack.Size > 0);
; 11221: 
; 11222:     // Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
; 11223:     if (g.NavWindow == window)

	cmp	QWORD PTR [rbx+19096], rcx
	jne	SHORT $LN68@Render

; 11908:     if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)

	cmp	BYTE PTR [rbx+19217], 0
	je	SHORT $LN68@Render
	cmp	DWORD PTR [rbx+19152], 0
	jne	SHORT $LN68@Render

; 11909:         g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;

	mov	eax, DWORD PTR [rbx+19220]
	and	eax, -14
	or	eax, 2
	mov	DWORD PTR [rbx+19220], eax
$LN68@Render:

; 11228:     if (window->Flags & ImGuiWindowFlags_ChildWindow)

	test	DWORD PTR [rcx+20], 16777216		; 01000000H
	je	SHORT $LN65@Render

; 11229:         g.WithinEndChild = true;

	mov	BYTE PTR [rbx+16258], 1
$LN65@Render:

; 11230:     End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 11231:     g.WithinEndChild = false;

	mov	BYTE PTR [rbx+16258], 0
$LN11@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp

; 173  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+688]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1351@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1453@Render:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1454@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1352@Render:

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1449@Render:
?Render@PopupSettings@@YAXXZ ENDP			; PopupSettings::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$3@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$3
	lea	rcx, QWORD PTR $T37[rdx]
	jmp	??1BfresFile@@QEAA@XZ
?dtor$3@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$4@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$4
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@QEAA@XZ
?dtor$4@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$7@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$7
	lea	rcx, QWORD PTR $T27[rdx]
	jmp	??1ActorInformation@ActorMgr@@QEAA@XZ
?dtor$7@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$88@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$88
	lea	rcx, QWORD PTR $T36[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$88@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$88
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$8@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$8
	lea	rcx, QWORD PTR $T36[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@QEAA@XZ
?dtor$8@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$9@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$9
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$10@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$10
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$13@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$13
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1ActorInformation@ActorMgr@@QEAA@XZ
?dtor$13@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$38@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$38
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$14@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$14
	lea	rcx, QWORD PTR $T35[rdx]
	jmp	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UActorInformation@ActorMgr@@@std@@QEAA@XZ
?dtor$14@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$15@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$15
	lea	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$16@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$16
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$17@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$17
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$18@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$18
	lea	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$18@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
text_size$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 72
$T11 = 72
$T12 = 72
$T13 = 72
$T14 = 72
$T15 = 72
$T16 = 72
$T17 = 104
$T18 = 104
$T19 = 104
$T20 = 104
$T21 = 104
$T22 = 104
$T23 = 104
$T24 = 136
$T25 = 136
$T26 = 176
$T27 = 176
$T28 = 176
backup$29 = 352
$T30 = 352
$T31 = 352
$T32 = 384
$T33 = 416
$T34 = 416
$T35 = 432
$T36 = 432
$T37 = 432
Data$38 = 640
__$ArrayPad$ = 656
?dtor$19@?0??Render@PopupSettings@@YAXXZ@4HA PROC	; `PopupSettings::Render'::`1'::dtor$19
	lea	rcx, QWORD PTR $T32[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??Render@PopupSettings@@YAXXZ@4HA ENDP	; `PopupSettings::Render'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupSettings.cpp
;	COMDAT ?Open@PopupSettings@@YAXXZ
_TEXT	SEGMENT
?Open@PopupSettings@@YAXXZ PROC				; PopupSettings::Open, COMDAT

; 177  : 	IsOpen = true;

	mov	BYTE PTR ?IsOpen@PopupSettings@@3_NA, 1	; PopupSettings::IsOpen

; 178  : }

	ret	0
?Open@PopupSettings@@YAXXZ ENDP				; PopupSettings::Open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval$ = 56
?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::erase, COMDAT

; 1138 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

$LN136:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1138 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Erase(_Keyval))) /* strengthened */ {

	mov	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+6]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+7]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	shl	rdx, 4
	add	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	r10, QWORD PTR [rdx+8]
	mov	rbx, r10

; 1570 :         if (_Where == _End) {

	cmp	r10, r8
	je	SHORT $LN111@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rax, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rax, QWORD PTR [r10+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN110@erase
	npad	7
$LL22@erase:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN111@erase

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rax, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL22@erase
	jmp	SHORT $LN110@erase
$LN111@erase:

; 1112 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	xor	ebx, ebx
$LN110@erase:
	test	rbx, rbx

; 1113 :             if (_Target) {

	je	SHORT $LN4@erase

; 1668 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]
	cmp	r10, rbx
	jne	SHORT $LN34@erase

; 1669 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN36@erase

; 1670 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1671 : 
; 1672 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], r8

; 1676 :             }
; 1677 :         } else if (_Bucket_lo == _Plist) {

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN38@erase
$LN36@erase:

; 1673 :                 _Bucket_hi = _End;
; 1674 :             } else {
; 1675 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r8, QWORD PTR [rbx+8]

; 1676 :             }
; 1677 :         } else if (_Bucket_lo == _Plist) {

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN38@erase
$LN34@erase:
	cmp	rax, rbx
	jne	SHORT $LN38@erase

; 1678 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN38@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1421 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1422 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1423 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1424 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1425 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1139 :         return _Erase(_Keyval);

	mov	eax, 1

; 1140 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@erase:

; 1139 :         return _Erase(_Keyval);

	xor	eax, eax

; 1140 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?erase@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@QEAA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
this$dead$ = 112
_Keyval$ = 120
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[], COMDAT

; 346  :     mapped_type& operator[](const key_type& _Keyval) {

$LN155:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbp, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [rbp+8]
	mov	QWORD PTR _Loc$1[rsp], rbx
	xor	r15d, r15d
	mov	DWORD PTR _Loc$1[rsp+8], r15d
	mov	rdi, rbp

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r15b
	jne	SHORT $LN9@operator
	npad	4
$LL8@operator:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$1[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN10@operator

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Loc$1[rsp+8], r15d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN11@operator
$LN10@operator:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Loc$1[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN11@operator:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r15b
	je	SHORT $LL8@operator
$LN9@operator:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r15b
	jne	SHORT $LN4@operator
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	jns	$LN3@operator
$LN4@operator:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
	je	$LN153@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r14, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	mov	QWORD PTR $T4[rsp], r14

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T4[rsp+8], r15

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T4[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rsi
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR [rdi+64], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi+72], r15
	mov	QWORD PTR [rdi+80], r15
	mov	QWORD PTR [rdi+88], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rdi+106], 256			; 00000100H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbp

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbp

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbp

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR _Loc$1[rsp]
	movaps	XMMWORD PTR $T3[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, r14
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
	mov	rdi, rax
$LN3@operator:

; 347  :         return _Try_emplace(_Keyval).first->_Myval.second;

	lea	rax, QWORD PTR [rdi+64]

; 348  :     }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN153@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN151@operator:
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
this$dead$ = 112
_Keyval$ = 120
?dtor$2@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$2@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
$T4 = 32
_Loc$1 = 48
this$dead$ = 112
_Keyval$ = 120
?dtor$1@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@QEAAAEAVTextureToGo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::operator[]'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval$ = 56
?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count, COMDAT

; 1406 :     _NODISCARD size_type count(const key_type& _Keyval) const {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rdi, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A

; 1406 :     _NODISCARD size_type count(const key_type& _Keyval) const {

	mov	rsi, rdx

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rbx, QWORD PTR [rdi+8]

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN5@count
$LL4@count:

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jns	SHORT $LN6@count

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;
; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN7@count
$LN6@count:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;
; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN7@count:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL4@count
$LN5@count:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], 0
	jne	SHORT $LN15@count
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rsi
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\compare

; 197  :         return _Val._Value < 0;

	test	al, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	js	SHORT $LN15@count

; 1407 :         if constexpr (_Multi) {
; 1408 :             const auto _Ans = _Eqrange(_Keyval);
; 1409 :             return static_cast<size_type>(_STD distance(
; 1410 :                 _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
; 1411 :         } else {
; 1412 :             return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);

	mov	eax, 1

; 1413 :         }
; 1414 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@count:
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?count@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@$0A@@std@@@std@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> >,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++, COMDAT

; 282  :     _Tree_iterator& operator++() noexcept {

$LN7:
	sub	rsp, 40					; 00000028H
	mov	r10, rcx

; 199  :         _Mybase::operator++();

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,std::_Iterator_base0>::operator++

; 283  :         _Mybase::operator++();
; 284  :         return *this;

	mov	rax, r10

; 285  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator->, COMDAT

; 186  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 32					; 00000020H

; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator==, COMDAT

; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 234  :     }

	ret	0
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::end, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	QWORD PTR [rdx], rax

; 1136 :         const auto _Scary = _Get_scary();
; 1137 :         return iterator(_Scary->_Myhead, _Scary);

	mov	rax, rdx

; 1138 :     }

	ret	0
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::begin, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR ?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A
	mov	rcx, QWORD PTR [rax]

; 1126 :         const auto _Scary = _Get_scary();
; 1127 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	rax, rdx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1128 :     }

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> *>::pointer_to, COMDAT

; 306  :         return _STD addressof(_Val);

	mov	rax, rcx

; 307  :     }

	ret	0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@SAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*, COMDAT

; 186  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 32					; 00000020H

; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++, COMDAT

; 193  :     _Tree_const_iterator& operator++() noexcept {

$LN5:
	sub	rsp, 40					; 00000028H
	mov	r10, rcx

; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,std::_Iterator_base0>::operator++

; 200  :         return *this;

	mov	rax, r10

; 201  :     }

	add	rsp, 40					; 00000028H
	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*, COMDAT

; 180  : #if _ITERATOR_DEBUG_LEVEL == 2
; 181  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 182  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 183  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 184  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 185  : 
; 186  :         return this->_Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 32					; 00000020H

; 187  :     }

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Keyval$ = 56
??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase<TextureToGo *>, COMDAT

; 1105 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

$LN133:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	r8d, BYTE PTR [rdx]

; 2346 :         _Val *= _FNV_prime;

	mov	rcx, 1099511628211			; 00000100000001b3H
	mov	rax, -3750763034362895579		; cbf29ce484222325H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1105 :     size_type _Erase(const _Keytype& _Keyval) noexcept(_Noexcept_heterogeneous_erasure<_Keytype>()) /* strengthened */ {

	mov	r9, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2345 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+1]

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+2]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+3]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+4]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+5]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+6]
	imul	r8, rcx
	xor	r8, rax
	movzx	eax, BYTE PTR [rdx+7]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	mov	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+48
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2346 :         _Val *= _FNV_prime;

	imul	r8, rcx
	xor	r8, rax
	imul	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1567 :         const size_type _Bucket = _Hashval & _Mask;

	and	rdx, r8

; 1568 :         _Nodeptr _Where         = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1569 :         const _Nodeptr _End     = _List._Mypair._Myval2._Myhead;

	mov	r8, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8
	shl	rdx, 4
	add	rdx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	mov	r10, QWORD PTR [rdx+8]
	mov	rbx, r10

; 1570 :         if (_Where == _End) {

	cmp	r10, r8
	je	SHORT $LN108@Erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	mov	rax, QWORD PTR [r9]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1574 :         const _Nodeptr _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rax, QWORD PTR [r10+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	je	SHORT $LN107@Erase
	npad	7
$LL20@Erase:

; 1578 :                 if constexpr (!_Traits::_Standard) {
; 1579 :                     if (_Traitsobj(_Traits::_Kfn(_Where->_Myval), _Keyval)) {
; 1580 :                         return {_Where->_Next, _Nodeptr{}};
; 1581 :                     }
; 1582 :                 }
; 1583 : 
; 1584 :                 return {_Where->_Next, _Where};
; 1585 :             }
; 1586 : 
; 1587 :             if (_Where == _Bucket_lo) {

	cmp	rbx, rcx
	je	SHORT $LN108@Erase

; 1588 :                 return {_Where, _Nodeptr{}};
; 1589 :             }
; 1590 : 
; 1591 :             _Where = _Where->_Prev;

	mov	rbx, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 392  :         return _Left == _Right;

	cmp	rax, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1577 :             if (!_Traitsobj(_Keyval, _Traits::_Kfn(_Where->_Myval))) {

	jne	SHORT $LL20@Erase
	jmp	SHORT $LN107@Erase
$LN108@Erase:

; 1106 :         const size_t _Hashval = _Traitsobj(_Keyval);
; 1107 :         if constexpr (_Multi) {
; 1108 :             const auto _Where = _Equal_range(_Keyval, _Hashval);
; 1109 :             _Unchecked_erase(_Where._First._Ptr, _Where._Last._Ptr);
; 1110 :             return _Where._Distance;
; 1111 :         } else {
; 1112 :             const auto _Target = _Find_last(_Keyval, _Hashval)._Duplicate;

	xor	ebx, ebx
$LN107@Erase:
	test	rbx, rbx

; 1113 :             if (_Target) {

	je	SHORT $LN2@Erase

; 1668 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rdx]
	cmp	r10, rbx
	jne	SHORT $LN32@Erase

; 1669 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rbx
	jne	SHORT $LN34@Erase

; 1670 :                 const auto _End = _List._Mypair._Myval2._Myhead;
; 1671 : 
; 1672 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rdx], r8

; 1676 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN36@Erase
$LN34@Erase:

; 1673 :                 _Bucket_hi = _End;
; 1674 :             } else {
; 1675 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	r8, QWORD PTR [rbx+8]

; 1676 :             }

	mov	QWORD PTR [rdx+8], r8
	jmp	SHORT $LN36@Erase
$LN32@Erase:

; 1677 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rbx
	jne	SHORT $LN36@Erase

; 1678 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdx], rax
$LN36@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1421 :         const auto _Result = _Pnode->_Next;

	mov	rcx, QWORD PTR [rbx]

; 1422 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1423 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+16

; 1424 :         _Pnode->_Prev->_Next = _Result;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rax], rcx

; 1425 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rcx+8], rax

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 1116 :                 return 1;

	mov	eax, 1

; 1120 :         }
; 1121 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Erase:

; 1117 :             }
; 1118 : 
; 1119 :             return 0;

	xor	eax, eax

; 1120 :         }
; 1121 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Erase@PEAVTextureToGo@@@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@AEAA_KAEBQEAVTextureToGo@@@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase<TextureToGo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$dead$ = 80
__$ReturnUdt$ = 88
_Where$ = 96
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,0>, COMDAT

; 1320 :     iterator erase(iterator _Where) noexcept /* strengthened */ {

$LN117:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rbx, QWORD PTR [r8+16]

; 1320 :     iterator erase(iterator _Where) noexcept /* strengthened */ {

	mov	r14, rdx

; 1286 :         _Unchecked_const_iterator _Successor = _Where;

	mov	rax, r8

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LN16@erase

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rbx, QWORD PTR [r8+8]
	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN21@erase
	npad	5
$LL14@erase:
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN21@erase

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rbx
	mov	rbx, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL14@erase

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {

	jmp	SHORT $LN21@erase
$LN16@erase:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN21@erase
	npad	2
$LL20@erase:
	mov	rcx, QWORD PTR [rax]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rax
	mov	rax, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL20@erase
$LN21@erase:

; 1288 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

	mov	rdx, r8
	lea	rcx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract
	mov	rbp, rax
	lea	rcx, QWORD PTR [rax+144]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [rbp+88]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR [rbp+64]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbp+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	mov	rcx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1326 :         return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);

	mov	rax, r14

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [r14], rbx

; 1327 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@1@V21@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 197  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

$LN153:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rbp, r8
	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r14, QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A
	mov	rbx, QWORD PTR [r14+8]
	mov	QWORD PTR _Loc$[rsp], rbx
	xor	r12d, r12d
	mov	DWORD PTR _Loc$[rsp+8], r12d
	mov	rdi, r14

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	jne	SHORT $LN7@Try_emplac
	npad	3
$LL6@Try_emplac:

; 1616 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$[rsp], rbx

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rdx, rbp
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	test	al, al
	jns	SHORT $LN8@Try_emplac

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR _Loc$[rsp+8], r12d

; 1619 :                 _Trynode                 = _Trynode->_Right;

	mov	rbx, QWORD PTR [rbx+16]

; 1620 :             } else {

	jmp	SHORT $LN9@Try_emplac
$LN8@Try_emplac:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR _Loc$[rsp+8], 1

; 1622 :                 _Result._Bound           = _Trynode;

	mov	rdi, rbx

; 1623 :                 _Trynode                 = _Trynode->_Left;

	mov	rbx, QWORD PTR [rbx]
$LN9@Try_emplac:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rbx+25], r12b
	je	SHORT $LL6@Try_emplac
$LN7@Try_emplac:

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdi+25], r12b
	jne	SHORT $LN2@Try_emplac
	lea	rdx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

	mov	rcx, rbp
	call	??$?__MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AUstrong_ordering@0@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<=><char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	test	al, al
	js	SHORT $LN2@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rdi
	mov	BYTE PTR [rsi+8], r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 200  :             return {_Loc._Bound, false};

	jmp	$LN149@Try_emplac
$LN2@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 164703072086692425			; 0249249249249249H
	cmp	QWORD PTR ?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A+8, rax
	je	$LN151@Try_emplac
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	r15, OFFSET FLAT:?Textures@TextureToGoLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@A ; TextureToGoLibrary::Textures
	mov	QWORD PTR $T2[rsp], r15

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 112				; 00000070H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR $T2[rsp+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, rbp
	lea	rcx, QWORD PTR [rax+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR [rdi+64], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi+72], r12
	mov	QWORD PTR [rdi+80], r12
	mov	QWORD PTR [rdi+88], r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rdi+106], 256			; 00000100H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], r14

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], r14

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], r14

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

	movups	xmm0, XMMWORD PTR _Loc$[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rax
	mov	BYTE PTR [rsi+8], 1
$LN149@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 213  :     }

	mov	rax, rsi
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN151@Try_emplac:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN148@Try_emplac:
??$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
?dtor$2@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$2@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 32
_Loc$ = 48
this$dead$ = 128
__$ReturnUdt$ = 136
_Keyval$ = 144
?dtor$1@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Try_emplace@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@@2@@std@@AEAA?AU?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,TextureToGo,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo> > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Plist$ = 16
_Bucket$ = 24
?_Erase_bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase_bucket, COMDAT

; 1665 :         // remove the node _Plist from its bucket
; 1666 :         _Nodeptr& _Bucket_lo = _Vec._Mypair._Myval2._Myfirst[_Bucket << 1]._Ptr;

	mov	rcx, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+24
	shl	r8, 4
	add	rcx, r8

; 1667 :         _Nodeptr& _Bucket_hi = _Vec._Mypair._Myval2._Myfirst[(_Bucket << 1) + 1]._Ptr;
; 1668 :         if (_Bucket_hi == _Plist) {

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rcx+8], rdx
	jne	SHORT $LN2@Erase_buck

; 1669 :             if (_Bucket_lo == _Plist) { // make bucket empty

	cmp	rax, rdx
	jne	SHORT $LN4@Erase_buck

; 1670 :                 const auto _End = _List._Mypair._Myval2._Myhead;

	mov	rax, QWORD PTR ?Textures@GLTextureLibrary@@3V?$unordered_map@PEAVTextureToGo@@VTexture@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@4@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@@std@@A+8

; 1671 : 
; 1672 :                 _Bucket_lo = _End;

	mov	QWORD PTR [rcx], rax

; 1676 :             }

	mov	QWORD PTR [rcx+8], rax

; 1679 :         }
; 1680 :     }

	ret	0
$LN4@Erase_buck:

; 1673 :                 _Bucket_hi = _End;
; 1674 :             } else {
; 1675 :                 _Bucket_hi = _Plist->_Prev; // move end back one element

	mov	rax, QWORD PTR [rdx+8]

; 1676 :             }

	mov	QWORD PTR [rcx+8], rax

; 1679 :         }
; 1680 :     }

	ret	0
$LN2@Erase_buck:

; 1677 :         } else if (_Bucket_lo == _Plist) {

	cmp	rax, rdx
	jne	SHORT $LN6@Erase_buck

; 1678 :             _Bucket_lo = _Plist->_Next; // move beginning up one element

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN6@Erase_buck:

; 1679 :         }
; 1680 :     }

	ret	0
?_Erase_bucket@?$_Hash@V?$_Umap_traits@PEAVTextureToGo@@VTexture@@V?$_Uhash_compare@PEAVTextureToGo@@U?$hash@PEAVTextureToGo@@@std@@U?$equal_to@PEAVTextureToGo@@@3@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@4@$0A@@std@@@std@@IEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<TextureToGo *,Texture,std::_Uhash_compare<TextureToGo *,std::hash<TextureToGo *>,std::equal_to<TextureToGo *> >,std::allocator<std::pair<TextureToGo * const,Texture> >,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 48
_Pnode$ = 56
?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z PROC ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_erase, COMDAT

; 1420 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

$LN68:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1421 :         const auto _Result = _Pnode->_Next;

	mov	rbx, QWORD PTR [rdx]
	mov	rdi, rdx

; 1422 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1423 :         --_Mypair._Myval2._Mysize;

	dec	QWORD PTR [rcx+8]

; 1424 :         _Pnode->_Prev->_Next = _Result;

	mov	rdx, QWORD PTR [rdx+8]

; 318  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	rcx, QWORD PTR [rdi+32]

; 1424 :         _Pnode->_Prev->_Next = _Result;

	mov	QWORD PTR [rdx], rbx

; 1425 :         _Result->_Prev       = _Pnode->_Prev;

	mov	rdx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 72					; 00000048H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list

; 1427 :         return _Result;

	mov	rax, rbx

; 1428 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Unchecked_erase@?$list@U?$pair@QEAVTextureToGo@@VTexture@@@std@@V?$allocator@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@2@@std@@AEAAPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@QEAU32@@Z ENDP ; std::list<std::pair<TextureToGo * const,Texture>,std::allocator<std::pair<TextureToGo * const,Texture> > >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Unwrapped, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

	mov	rax, rdx

; 308  :     }

	ret	0
?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Where$ = 56
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Erase_unchecked, COMDAT

; 1284 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

$LN102:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rbx, QWORD PTR [rdx+16]

; 1285 :         const auto _Scary                    = _Get_scary();
; 1286 :         _Unchecked_const_iterator _Successor = _Where;

	mov	rax, rdx

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LN8@Erase_unch

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rbx, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN13@Erase_unch
	npad	5
$LL6@Erase_unch:
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN13@Erase_unch

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rbx
	mov	rbx, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL6@Erase_unch

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {

	jmp	SHORT $LN13@Erase_unch
$LN8@Erase_unch:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN13@Erase_unch
	npad	2
$LL12@Erase_unch:
	mov	rcx, QWORD PTR [rax]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rax
	mov	rax, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL12@Erase_unch
$LN13@Erase_unch:

; 1287 :         ++_Successor; // save successor iterator for return
; 1288 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

	lea	rcx, OFFSET FLAT:?Models@BfresLibrary@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@@std@@A ; BfresLibrary::Models
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract
	mov	rbp, rax
	lea	rcx, QWORD PTR [rax+144]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbp+112]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR [rbp+88]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR [rbp+64]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbp+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 176				; 000000b0H
	mov	rcx, rbp
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1292 :     }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@2@$0A@@std@@@std@@AEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BfresFile,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\list
;	COMDAT ?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_ptr2, COMDAT

; 357  : #if _ITERATOR_DEBUG_LEVEL == 2
; 358  :         _Lockit _Lock(_LOCK_DEBUG);
; 359  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 360  :         const auto _Head          = _Myhead;
; 361  :         while (*_Pnext) {
; 362  :             _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 363  :             const auto _Pnextptr          = static_cast<_List_const_iterator<_List_val>&>(**_Pnext)._Ptr;
; 364  :             if (_Pnextptr == _Head || _Pnextptr != _Ptr) {
; 365  :                 // iterator is end() or doesn't point at the one we are orphaning, move on
; 366  :                 _Pnext = _Pnextnext;
; 367  :             } else { // orphan the iterator
; 368  :                 (*_Pnext)->_Myproxy = nullptr;
; 369  :                 *_Pnext             = *_Pnextnext;
; 370  :             }
; 371  :         }
; 372  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 373  :         (void) _Ptr;
; 374  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 375  :     }

	ret	0
?_Orphan_ptr2@?$_List_val@U?$_List_simple_types@U?$pair@QEAVTextureToGo@@VTexture@@@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@QEAVTextureToGo@@VTexture@@@std@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<TextureToGo * const,Texture> > >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Orphan_ptr, COMDAT

; 716  : #if _ITERATOR_DEBUG_LEVEL == 2
; 717  :         _Lockit _Lock(_LOCK_DEBUG);
; 718  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 719  :         while (*_Pnext) {
; 720  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 721  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 722  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 723  :             } else { // orphan the iterator
; 724  :                 (*_Pnext)->_Myproxy = nullptr;
; 725  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 726  :             }
; 727  :         }
; 728  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 729  :         (void) _Ptr;
; 730  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 731  :     }

	ret	0
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Where$ = 56
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract, COMDAT

; 504  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

$LN156:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rdx+16]
	lea	r11, QWORD PTR [rdx+16]

; 504  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

	mov	rdi, rcx

; 505  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

	mov	rsi, rdx

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN49@Extract

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	lea	r8, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN50@Extract
	npad	4
$LL47@Extract:
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN50@Extract

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rdx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL47@Extract

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {

	jmp	SHORT $LN50@Extract
$LN49@Extract:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rax]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN54@Extract
	npad	2
$LL53@Extract:
	mov	rcx, QWORD PTR [rdx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, rdx
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL53@Extract
$LN54@Extract:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	lea	r8, QWORD PTR [rsi+8]
$LN50@Extract:

; 506  :         ++_Where; // save successor iterator for return
; 507  : 
; 508  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 509  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 510  :         _Nodeptr _Pnode = _Erasednode;
; 511  : 
; 512  :         if (_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rsi]
	mov	r10, QWORD PTR [r11]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN104@Extract

; 513  :             _Fixnode = _Pnode->_Right; // stitch up right subtree
; 514  :         } else if (_Pnode->_Right->_Isnil) {

	cmp	BYTE PTR [r10+25], 0
	je	SHORT $LN7@Extract

; 515  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

	mov	r10, rcx

; 516  :         } else { // two subtrees, must lift successor node to replace erased

	jmp	SHORT $LN104@Extract
$LN7@Extract:

; 517  :             _Pnode   = _Where._Ptr; // _Pnode is successor node
; 518  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

	mov	r10, QWORD PTR [rax+16]

; 519  :         }
; 520  : 
; 521  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

	cmp	rax, rsi
	jne	$LN9@Extract
$LN104@Extract:

; 522  :             _Fixnodeparent = _Erasednode->_Parent;
; 523  :             if (!_Fixnode->_Isnil) {

	cmp	BYTE PTR [r10+25], 0
	mov	r9, QWORD PTR [r8]
	jne	SHORT $LN11@Extract

; 524  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

	mov	QWORD PTR [r10+8], r9
$LN11@Extract:

; 525  :             }
; 526  : 
; 527  :             if (_Myhead->_Parent == _Erasednode) {

	mov	rax, QWORD PTR [rdi]
	cmp	QWORD PTR [rax+8], rsi
	jne	SHORT $LN12@Extract

; 528  :                 _Myhead->_Parent = _Fixnode; // link down from root

	mov	QWORD PTR [rax+8], r10
	jmp	SHORT $LN15@Extract
$LN12@Extract:

; 529  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

	cmp	QWORD PTR [r9], rsi
	jne	SHORT $LN14@Extract

; 530  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

	mov	QWORD PTR [r9], r10

; 531  :             } else {

	jmp	SHORT $LN15@Extract
$LN14@Extract:

; 532  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

	mov	QWORD PTR [r9+16], r10
$LN15@Extract:

; 533  :             }
; 534  : 
; 535  :             if (_Myhead->_Left == _Erasednode) {

	mov	r8, QWORD PTR [rdi]
	cmp	QWORD PTR [r8], rsi
	jne	SHORT $LN16@Extract

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

	cmp	BYTE PTR [r10+25], 0
	je	SHORT $LN42@Extract
	mov	rdx, r9
	jmp	SHORT $LN58@Extract
$LN42@Extract:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r10]

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

	mov	rdx, r10

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN58@Extract
	npad	13
$LL57@Extract:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rdx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL57@Extract
$LN58@Extract:

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

	mov	QWORD PTR [r8], rdx
$LN16@Extract:

; 537  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 538  :             }
; 539  : 
; 540  :             if (_Myhead->_Right == _Erasednode) {

	mov	rdx, QWORD PTR [rdi]
	cmp	QWORD PTR [rdx+16], rsi
	jne	$LN65@Extract

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	cmp	BYTE PTR [r10+25], 0
	je	SHORT $LN44@Extract
	mov	rcx, r9
	mov	QWORD PTR [rdx+16], rcx

; 542  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 543  :             }
; 544  :         } else { // erased has two subtrees, _Pnode is successor to erased

	jmp	$LN65@Extract
$LN44@Extract:

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [r10+16]

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	mov	rcx, r10

; 445  :         while (!_Pnode->_Right->_Isnil) {

	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN62@Extract
	npad	1
$LL61@Extract:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL61@Extract
$LN62@Extract:

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	mov	QWORD PTR [rdx+16], rcx

; 542  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 543  :             }
; 544  :         } else { // erased has two subtrees, _Pnode is successor to erased

	jmp	SHORT $LN65@Extract
$LN9@Extract:

; 545  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

	mov	QWORD PTR [rcx+8], rax

; 546  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

	mov	rcx, QWORD PTR [rsi]
	mov	QWORD PTR [rax], rcx

; 547  : 
; 548  :             if (_Pnode == _Erasednode->_Right) {

	cmp	rax, QWORD PTR [r11]
	jne	SHORT $LN18@Extract

; 549  :                 _Fixnodeparent = _Pnode; // successor is next to erased

	mov	r9, rax

; 550  :             } else { // successor further down, link in place of erased

	jmp	SHORT $LN19@Extract
$LN18@Extract:

; 551  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's
; 552  :                 if (!_Fixnode->_Isnil) {

	cmp	BYTE PTR [r10+25], 0
	mov	r9, QWORD PTR [rax+8]
	jne	SHORT $LN20@Extract

; 553  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

	mov	QWORD PTR [r10+8], r9
$LN20@Extract:

; 554  :                 }
; 555  : 
; 556  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

	mov	QWORD PTR [r9], r10

; 557  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

	mov	rcx, QWORD PTR [r11]
	mov	QWORD PTR [rax+16], rcx

; 558  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

	mov	rcx, QWORD PTR [r11]
	mov	QWORD PTR [rcx+8], rax
$LN19@Extract:

; 559  :             }
; 560  : 
; 561  :             if (_Myhead->_Parent == _Erasednode) {

	mov	rcx, QWORD PTR [rdi]
	cmp	QWORD PTR [rcx+8], rsi
	jne	SHORT $LN21@Extract

; 562  :                 _Myhead->_Parent = _Pnode; // link down from root

	mov	QWORD PTR [rcx+8], rax
	jmp	SHORT $LN24@Extract
$LN21@Extract:

; 563  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

	mov	rcx, QWORD PTR [r8]
	cmp	QWORD PTR [rcx], rsi
	jne	SHORT $LN23@Extract

; 564  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

	mov	QWORD PTR [rcx], rax

; 565  :             } else {

	jmp	SHORT $LN24@Extract
$LN23@Extract:

; 566  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

	mov	QWORD PTR [rcx+16], rax
$LN24@Extract:

; 569  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

	mov	rcx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movzx	edx, BYTE PTR [rax+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 569  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

	mov	QWORD PTR [rax+8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movzx	ecx, BYTE PTR [rsi+24]
	mov	BYTE PTR [rax+24], cl

; 101  :     _Right   = _STD move(_Tmp);

	mov	BYTE PTR [rsi+24], dl
$LN65@Extract:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 573  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

	cmp	BYTE PTR [rsi+24], 1
	jne	$LN25@Extract

; 574  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

	mov	rax, QWORD PTR [rdi]
	cmp	r10, QWORD PTR [rax+8]
	je	$LN3@Extract
	mov	QWORD PTR [rsp+56], rbx
	npad	8
$LL4@Extract:
	cmp	BYTE PTR [r10+24], 1
	mov	rbx, r9
	jne	$LN152@Extract

; 575  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

	mov	rdx, QWORD PTR [r9]
	cmp	r10, rdx
	jne	$LN26@Extract

; 576  :                     _Pnode = _Fixnodeparent->_Right;

	mov	rdx, QWORD PTR [r9+16]

; 577  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

	cmp	BYTE PTR [rdx+24], 0
	jne	SHORT $LN105@Extract

; 578  :                         _Pnode->_Color         = _Black;

	mov	BYTE PTR [rdx+24], 1

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	rdx, QWORD PTR [r9+16]

; 579  :                         _Fixnodeparent->_Color = _Red;

	mov	BYTE PTR [r9+24], 0

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r9+16], rax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rdx]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN67@Extract

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], r9
$LN67@Extract:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [r9+8]
	lea	rcx, QWORD PTR [r9+8]
	mov	QWORD PTR [rdx+8], rax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rdi]
	cmp	r9, QWORD PTR [rax+8]
	jne	SHORT $LN68@Extract

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], rdx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [rdx], r9

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

	mov	rdx, QWORD PTR [r9+16]
	jmp	SHORT $LN96@Extract
$LN68@Extract:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR [rcx]
	cmp	r9, QWORD PTR [rax]
	jne	SHORT $LN70@Extract

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], rdx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [rdx], r9

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

	mov	rdx, QWORD PTR [r9+16]
	jmp	SHORT $LN96@Extract
$LN70@Extract:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], rdx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [rdx], r9

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

	mov	rdx, QWORD PTR [r9+16]
	jmp	SHORT $LN96@Extract
$LN105@Extract:
	lea	rcx, QWORD PTR [r9+8]
$LN96@Extract:

; 582  :                     }
; 583  : 
; 584  :                     if (_Pnode->_Isnil) {

	cmp	BYTE PTR [rdx+25], 0
	jne	$LN2@Extract

; 585  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 586  :                     } else if (_Pnode->_Left->_Color == _Black
; 587  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

	mov	r11, QWORD PTR [rdx]
	cmp	BYTE PTR [r11+24], 1
	jne	SHORT $LN107@Extract
	mov	rax, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rax+24], 1
	je	$LN153@Extract
$LN107@Extract:

; 588  :                         _Pnode->_Color = _Red;
; 589  :                         _Fixnode       = _Fixnodeparent;
; 590  :                     } else { // must rearrange right subtree
; 591  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

	mov	rax, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rax+24], 1
	jne	SHORT $LN33@Extract

; 592  :                             _Pnode->_Left->_Color = _Black;

	mov	BYTE PTR [r11+24], 1

; 593  :                             _Pnode->_Color        = _Red;
; 594  :                             _Rrotate(_Pnode);

	mov	rcx, rdi
	mov	BYTE PTR [rdx+24], 0
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Rrotate

; 595  :                             _Pnode = _Fixnodeparent->_Right;

	mov	rdx, QWORD PTR [r9+16]
$LN33@Extract:

; 596  :                         }
; 597  : 
; 598  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	movzx	eax, BYTE PTR [r9+24]

; 599  :                         _Fixnodeparent->_Color = _Black;
; 600  :                         _Pnode->_Right->_Color = _Black;
; 601  :                         _Lrotate(_Fixnodeparent);

	mov	rcx, rdi
	mov	BYTE PTR [rdx+24], al
	mov	BYTE PTR [r9+24], 1
	mov	rax, QWORD PTR [rdx+16]
	mov	rdx, r9
	mov	BYTE PTR [rax+24], 1
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Lrotate

; 602  :                         break; // tree now recolored/rebalanced

	jmp	$LN152@Extract
$LN26@Extract:

; 603  :                     }
; 604  :                 } else { // fixup right subtree
; 605  :                     _Pnode = _Fixnodeparent->_Left;
; 606  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

	cmp	BYTE PTR [rdx+24], 0
	jne	SHORT $LN106@Extract

; 607  :                         _Pnode->_Color         = _Black;

	mov	BYTE PTR [rdx+24], 1

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	rdx, QWORD PTR [r9]

; 608  :                         _Fixnodeparent->_Color = _Red;

	mov	BYTE PTR [r9+24], 0

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [r9], rax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN74@Extract

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], r9
$LN74@Extract:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [r9+8]
	lea	rcx, QWORD PTR [r9+8]
	mov	QWORD PTR [rdx+8], rax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rdi]
	cmp	r9, QWORD PTR [rax+8]
	jne	SHORT $LN75@Extract

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], rdx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [rdx+16], r9

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

	mov	rdx, QWORD PTR [r9]
	jmp	SHORT $LN95@Extract
$LN75@Extract:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR [rcx]
	cmp	r9, QWORD PTR [rax+16]
	jne	SHORT $LN77@Extract

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], rdx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [rdx+16], r9

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

	mov	rdx, QWORD PTR [r9]
	jmp	SHORT $LN95@Extract
$LN77@Extract:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], rdx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [rdx+16], r9

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rcx], rdx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

	mov	rdx, QWORD PTR [r9]
	jmp	SHORT $LN95@Extract
$LN106@Extract:
	lea	rcx, QWORD PTR [r9+8]
$LN95@Extract:

; 611  :                     }
; 612  : 
; 613  :                     if (_Pnode->_Isnil) {

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN2@Extract

; 614  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 615  :                     } else if (_Pnode->_Right->_Color == _Black
; 616  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

	mov	r8, QWORD PTR [rdx+16]
	cmp	BYTE PTR [r8+24], 1
	jne	SHORT $LN108@Extract
	mov	rax, QWORD PTR [rdx]
	cmp	BYTE PTR [rax+24], 1
	jne	SHORT $LN108@Extract
$LN153@Extract:

; 574  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

	mov	BYTE PTR [rdx+24], 0
$LN2@Extract:
	mov	rax, QWORD PTR [rdi]
	mov	r10, rbx
	mov	r9, QWORD PTR [rcx]
	cmp	rbx, QWORD PTR [rax+8]
	jne	$LL4@Extract
	jmp	SHORT $LN152@Extract
$LN108@Extract:

; 617  :                         _Pnode->_Color = _Red;
; 618  :                         _Fixnode       = _Fixnodeparent;
; 619  :                     } else { // must rearrange left subtree
; 620  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

	mov	rax, QWORD PTR [rdx]
	cmp	BYTE PTR [rax+24], 1
	jne	SHORT $LN39@Extract

; 621  :                             _Pnode->_Right->_Color = _Black;

	mov	BYTE PTR [r8+24], 1

; 622  :                             _Pnode->_Color         = _Red;
; 623  :                             _Lrotate(_Pnode);

	mov	rcx, rdi
	mov	BYTE PTR [rdx+24], 0
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Lrotate

; 624  :                             _Pnode = _Fixnodeparent->_Left;

	mov	rdx, QWORD PTR [r9]
$LN39@Extract:

; 625  :                         }
; 626  : 
; 627  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	movzx	eax, BYTE PTR [r9+24]

; 628  :                         _Fixnodeparent->_Color = _Black;
; 629  :                         _Pnode->_Left->_Color  = _Black;
; 630  :                         _Rrotate(_Fixnodeparent);

	mov	rcx, rdi
	mov	BYTE PTR [rdx+24], al
	mov	BYTE PTR [r9+24], 1
	mov	rax, QWORD PTR [rdx]
	mov	rdx, r9
	mov	BYTE PTR [rax+24], 1
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Rrotate
$LN152@Extract:
	mov	rbx, QWORD PTR [rsp+56]
$LN3@Extract:

; 631  :                         break; // tree now recolored/rebalanced
; 632  :                     }
; 633  :                 }
; 634  :             }
; 635  : 
; 636  :             _Fixnode->_Color = _Black; // stopping node is black

	mov	BYTE PTR [r10+24], 1
$LN25@Extract:

; 637  :         }
; 638  : 
; 639  :         if (0 < _Mysize) {

	mov	rcx, QWORD PTR [rdi+8]
	mov	rax, rsi
	test	rcx, rcx
	je	SHORT $LN40@Extract

; 640  :             --_Mysize;

	dec	rcx
	mov	QWORD PTR [rdi+8], rcx
$LN40@Extract:

; 641  :         }
; 642  : 
; 643  :         return _Erasednode;
; 644  :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Max, COMDAT

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rdx, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN9@Max
	npad	6
$LL2@Max:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rax, rdx
	mov	rdx, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL2@Max

; 450  :     }

	ret	0
$LN9@Max:

; 447  :         }
; 448  : 
; 449  :         return _Pnode;

	mov	rax, rcx

; 450  :     }

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VBfresFile@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,BfresFile> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN71:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	ebp, ebp

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rbp

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rbp+112]
	call	??2@YAPEAX_K@Z				; operator new

; 1152 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rbx, QWORD PTR [rax+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\tuple

; 366  :     tuple(tuple&&)      = default;

	mov	rdx, QWORD PTR <_Vals_1>$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [rdx]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	mov	QWORD PTR [rbx+32], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rbp
	mov	QWORD PTR [rbx+48], rbp
	mov	QWORD PTR [rbx+56], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rbx+74], 256			; 00000100H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+24], bpl
	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+25], bpl

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
?dtor$1@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >
?dtor$1@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$dead$ = 88
<_Vals_1>$ = 96
<_Vals_2>$dead$ = 104
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0AEBUpiecewise_construct_t@std@@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,bool,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [rcx+8], al

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N$0A@@?$pair@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@_N@std@@QEAA@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@1@$$QEA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool>::pair<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> *,bool><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$dead$ = 64
<_Args_1>$ = 72
<_Args_2>$dead$ = 80
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r9]
	mov	rcx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	xor	eax, eax

; 11   : 
; 12   : 	std::vector<unsigned char>& GetPixels();
; 13   : 	uint16_t& GetWidth();
; 14   : 	uint16_t& GetHeight();
; 15   : 	uint16_t& GetDepth();
; 16   : 	uint16_t& GetFormat();
; 17   : 	uint8_t& GetMipMapCount();
; 18   : 	bool& IsTransparent();
; 19   : 	bool& IsFail();
; 20   : 
; 21   : 	TextureToGo(std::string Path, std::vector<unsigned char> Bytes);
; 22   : 	TextureToGo(std::string Path);
; 23   : 	TextureToGo() {
; 24   : 		this->m_Fail = true;
; 25   : 	}
; 26   : private:
; 27   : 	struct SurfaceInfo
; 28   : 	{
; 29   : 		uint16_t MipMapLevel;
; 30   : 		uint8_t ArrayLevel;
; 31   : 		uint8_t SurfaceCount;
; 32   : 		uint32_t Size;
; 33   : 	};
; 34   : 
; 35   : 	std::vector<unsigned char> m_Pixels;
; 36   : 	uint16_t m_Width;
; 37   : 	uint16_t m_Height;
; 38   : 	uint16_t m_Depth;
; 39   : 	uint8_t m_MipMapCount;
; 40   : 	uint16_t m_Format;
; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rbx+74], 256			; 00000100H
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rax
	mov	QWORD PTR [rbx+48], rax
	mov	QWORD PTR [rbx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@1@QEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@1@AEBUpiecewise_construct_t@1@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QEAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z
_TEXT	SEGMENT
_Location$ = 48
<_Args_0>$dead$ = 56
<_Args_1>$ = 64
<_Args_2>$dead$ = 72
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z PROC ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	xor	eax, eax

; 11   : 
; 12   : 	std::vector<unsigned char>& GetPixels();
; 13   : 	uint16_t& GetWidth();
; 14   : 	uint16_t& GetHeight();
; 15   : 	uint16_t& GetDepth();
; 16   : 	uint16_t& GetFormat();
; 17   : 	uint8_t& GetMipMapCount();
; 18   : 	bool& IsTransparent();
; 19   : 	bool& IsFail();
; 20   : 
; 21   : 	TextureToGo(std::string Path, std::vector<unsigned char> Bytes);
; 22   : 	TextureToGo(std::string Path);
; 23   : 	TextureToGo() {
; 24   : 		this->m_Fail = true;
; 25   : 	}
; 26   : private:
; 27   : 	struct SurfaceInfo
; 28   : 	{
; 29   : 		uint16_t MipMapLevel;
; 30   : 		uint8_t ArrayLevel;
; 31   : 		uint8_t SurfaceCount;
; 32   : 		uint32_t Size;
; 33   : 	};
; 34   : 
; 35   : 	std::vector<unsigned char> m_Pixels;
; 36   : 	uint16_t m_Width;
; 37   : 	uint16_t m_Height;
; 38   : 	uint16_t m_Depth;
; 39   : 	uint8_t m_MipMapCount;
; 40   : 	uint16_t m_Format;
; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rbx+74], 256			; 00000100H
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rax
	mov	QWORD PTR [rbx+48], rax
	mov	QWORD PTR [rbx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rbx

; 242  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$construct_at@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@AEBUpiecewise_construct_t@2@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@$0A@@std@@YAPEAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@0@QEAU10@AEBUpiecewise_construct_t@0@$$QEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@$$QEAV?$tuple@$$V@0@@Z ENDP ; std::construct_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Val1$ = 64
_Val2$dead$ = 72
??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rdx, QWORD PTR [r8]

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rbx, rcx

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	xor	eax, eax

; 11   : 
; 12   : 	std::vector<unsigned char>& GetPixels();
; 13   : 	uint16_t& GetWidth();
; 14   : 	uint16_t& GetHeight();
; 15   : 	uint16_t& GetDepth();
; 16   : 	uint16_t& GetFormat();
; 17   : 	uint8_t& GetMipMapCount();
; 18   : 	bool& IsTransparent();
; 19   : 	bool& IsFail();
; 20   : 
; 21   : 	TextureToGo(std::string Path, std::vector<unsigned char> Bytes);
; 22   : 	TextureToGo(std::string Path);
; 23   : 	TextureToGo() {
; 24   : 		this->m_Fail = true;
; 25   : 	}
; 26   : private:
; 27   : 	struct SurfaceInfo
; 28   : 	{
; 29   : 		uint16_t MipMapLevel;
; 30   : 		uint8_t ArrayLevel;
; 31   : 		uint8_t SurfaceCount;
; 32   : 		uint32_t Size;
; 33   : 	};
; 34   : 
; 35   : 	std::vector<unsigned char> m_Pixels;
; 36   : 	uint16_t m_Width;
; 37   : 	uint16_t m_Height;
; 38   : 	uint16_t m_Depth;
; 39   : 	uint8_t m_MipMapCount;
; 40   : 	uint16_t m_Format;
; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rbx+74], 256			; 00000100H
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rax
	mov	QWORD PTR [rbx+48], rax
	mov	QWORD PTR [rbx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 305  :         : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@Upiecewise_construct_t@1@V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z
_TEXT	SEGMENT
this$ = 48
_Val1$ = 56
_Val2$dead$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>, COMDAT

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rdx]
	mov	rbx, rcx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureToGo.h

; 10   : 	void (*DecompressFunction)(unsigned int, unsigned int, std::vector<unsigned char>&, std::vector<unsigned char>&, TextureToGo* TexToGo) = nullptr;

	xor	eax, eax

; 11   : 
; 12   : 	std::vector<unsigned char>& GetPixels();
; 13   : 	uint16_t& GetWidth();
; 14   : 	uint16_t& GetHeight();
; 15   : 	uint16_t& GetDepth();
; 16   : 	uint16_t& GetFormat();
; 17   : 	uint8_t& GetMipMapCount();
; 18   : 	bool& IsTransparent();
; 19   : 	bool& IsFail();
; 20   : 
; 21   : 	TextureToGo(std::string Path, std::vector<unsigned char> Bytes);
; 22   : 	TextureToGo(std::string Path);
; 23   : 	TextureToGo() {
; 24   : 		this->m_Fail = true;
; 25   : 	}
; 26   : private:
; 27   : 	struct SurfaceInfo
; 28   : 	{
; 29   : 		uint16_t MipMapLevel;
; 30   : 		uint8_t ArrayLevel;
; 31   : 		uint8_t SurfaceCount;
; 32   : 		uint32_t Size;
; 33   : 	};
; 34   : 
; 35   : 	std::vector<unsigned char> m_Pixels;
; 36   : 	uint16_t m_Width;
; 37   : 	uint16_t m_Height;
; 38   : 	uint16_t m_Depth;
; 39   : 	uint8_t m_MipMapCount;
; 40   : 	uint16_t m_Format;
; 41   : 	bool m_Transparent = false;

	mov	WORD PTR [rbx+74], 256			; 00000100H
	mov	QWORD PTR [rbx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rbx+40], rax
	mov	QWORD PTR [rbx+48], rax
	mov	QWORD PTR [rbx+56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 301  :         : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0V?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VTextureToGo@@@std@@QEAA@AEAV?$tuple@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@AEAV?$tuple@$$V@1@U?$integer_sequence@_K$0A@@1@U?$integer_sequence@_K$S@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,TextureToGo><std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>,std::tuple<>,0>
_TEXT	ENDS
END
