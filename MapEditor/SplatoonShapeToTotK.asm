; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02LNAEAIDO@?$DL?5@			; `string'
PUBLIC	??_C@_0BA@IFILIMCB@Phive?1Shape?1Dcc@		; `string'
PUBLIC	??_C@_04ONOCDBBN@Cave@				; `string'
PUBLIC	??_C@_08BEEKCOCE@hkFloat3@			; `string'
PUBLIC	??_C@_0BE@KEMPPACH@hknpShapeType?3?3Enum@	; `string'
PUBLIC	??_C@_0P@CGKJOGGN@TemplateSize?3?5@		; `string'
PUBLIC	??_C@_0CD@IBBBDOEO@Could?5not?5find?5valid?5template?5f@ ; `string'
PUBLIC	??_C@_0BE@LPONMC@PhiveShapeGenerator@		; `string'
PUBLIC	??_C@_06LNACHKFI@FOUND?6@			; `string'
;	COMDAT ??_C@_06LNACHKFI@FOUND?6@
CONST	SEGMENT
??_C@_06LNACHKFI@FOUND?6@ DB 'FOUND', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LPONMC@PhiveShapeGenerator@
CONST	SEGMENT
??_C@_0BE@LPONMC@PhiveShapeGenerator@ DB 'PhiveShapeGenerator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IBBBDOEO@Could?5not?5find?5valid?5template?5f@
CONST	SEGMENT
??_C@_0CD@IBBBDOEO@Could?5not?5find?5valid?5template?5f@ DB 'Could not fi'
	DB	'nd valid template file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CGKJOGGN@TemplateSize?3?5@
CONST	SEGMENT
??_C@_0P@CGKJOGGN@TemplateSize?3?5@ DB 'TemplateSize: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEMPPACH@hknpShapeType?3?3Enum@
CONST	SEGMENT
??_C@_0BE@KEMPPACH@hknpShapeType?3?3Enum@ DB 'hknpShapeType::Enum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEEKCOCE@hkFloat3@
CONST	SEGMENT
??_C@_08BEEKCOCE@hkFloat3@ DB 'hkFloat3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONOCDBBN@Cave@
CONST	SEGMENT
??_C@_04ONOCDBBN@Cave@ DB 'Cave', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFILIMCB@Phive?1Shape?1Dcc@
CONST	SEGMENT
??_C@_0BA@IFILIMCB@Phive?1Shape?1Dcc@ DB 'Phive/Shape/Dcc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LNAEAIDO@?$DL?5@
CONST	SEGMENT
??_C@_02LNAEAIDO@?$DL?5@ DB '; ', 00H			; `string'
PUBLIC	??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_copy<unsigned char const *,unsigned char const *,std::allocator<unsigned char> >
PUBLIC	??$_Unwrap_sent@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z ; std::ranges::_Unwrap_sent<unsigned char const *,unsigned char const *>
PUBLIC	??$_Unwrap_iter@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z ; std::ranges::_Unwrap_iter<unsigned char const *,unsigned char const *>
PUBLIC	??$forward@PEBE@std@@YA$$QEAPEBEAEAPEBE@Z	; std::forward<unsigned char const *>
PUBLIC	??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z	; std::to_address<char const *>
PUBLIC	??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const *,unsigned char const *>
PUBLIC	??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z	; std::_To_address<char const * *>
PUBLIC	??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z ; std::_Copy_memmove<char const * const *,char const * *>
PUBLIC	??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z	; std::to_address<char const * const>
PUBLIC	?end@?$initializer_list@E@std@@QEBAPEBEXZ	; std::initializer_list<unsigned char>::end
PUBLIC	?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z ; std::allocator<char const *>::deallocate
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z	; std::allocator<char const *>::allocate
PUBLIC	??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
PUBLIC	?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
PUBLIC	?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z ; SplatoonShapeToTotK::Convert
PUBLIC	?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SplatoonShapeToTotK::ReadStringTable
PUBLIC	?BitFieldToSize@SplatoonShapeToTotK@@YAII@Z	; SplatoonShapeToTotK::BitFieldToSize
PUBLIC	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2
PUBLIC	??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z ; std::_Destroy_range<std::allocator<char const *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release
PUBLIC	??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z ; std::construct_at<char const *,char const * const &,0>
PUBLIC	??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
PUBLIC	??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z	; std::_Unfancy<char const *>
PUBLIC	??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >
PUBLIC	??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ; std::move<char const * const * &>
PUBLIC	??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z	; std::_To_address<char const * const *>
PUBLIC	??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >
PUBLIC	??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>
PUBLIC	??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>
PUBLIC	??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ; std::forward<char const * const *>
PUBLIC	?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ ; std::vector<char const *,std::allocator<char const *> >::max_size
PUBLIC	?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ ; std::vector<char const *,std::allocator<char const *> >::_Getal
PUBLIC	??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>
PUBLIC	?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ	; std::initializer_list<char const *>::end
PUBLIC	?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ; std::initializer_list<char const *>::begin
PUBLIC	?size@?$initializer_list@PEBD@std@@QEBA_KXZ	; std::initializer_list<char const *>::size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
PUBLIC	??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z ; std::forward<std::allocator<char const *> const &>
PUBLIC	??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
PUBLIC	??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
PUBLIC	??0?$allocator@PEBD@std@@QEAA@XZ		; std::allocator<char const *>::allocator<char const *>
PUBLIC	??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z	; std::initializer_list<char const *>::initializer_list<char const *>
PUBLIC	?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A ; SplatoonShapeToTotK::Materials
?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A DB 018H DUP (?) ; SplatoonShapeToTotK::Materials
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD imagerel $LN39+37
	DD	imagerel $LN39+91
	DD	imagerel $chain$0$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD imagerel $LN39+91
	DD	imagerel $LN39+98
	DD	imagerel $chain$1$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+54
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD imagerel $LN47+54
	DD	imagerel $LN47+94
	DD	imagerel $chain$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD imagerel $LN47+94
	DD	imagerel $LN47+111
	DD	imagerel $chain$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z DD imagerel $LN2692
	DD	imagerel $LN2692+12048
	DD	imagerel $unwind$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA DD imagerel ?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
	DD	imagerel ?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA+41
	DD	imagerel $unwind$?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA DD imagerel ?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
	DD	imagerel ?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA+43
	DD	imagerel $unwind$?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD imagerel $LN222
	DD	imagerel $LN222+653
	DD	imagerel $unwind$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN91
	DD	imagerel $LN91+226
	DD	imagerel $unwind$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FMaterials@SplatoonShapeToTotK@@YAXXZ DD imagerel ??__FMaterials@SplatoonShapeToTotK@@YAXXZ
	DD	imagerel ??__FMaterials@SplatoonShapeToTotK@@YAXXZ+102
	DD	imagerel $unwind$??__FMaterials@SplatoonShapeToTotK@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EMaterials@SplatoonShapeToTotK@@YAXXZ DD imagerel ??__EMaterials@SplatoonShapeToTotK@@YAXXZ
	DD	imagerel ??__EMaterials@SplatoonShapeToTotK@@YAXXZ+749
	DD	imagerel $unwind$??__EMaterials@SplatoonShapeToTotK@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+52
	DD	imagerel $unwind$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD imagerel $LN10
	DD	imagerel $LN10+68
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN41+42
	DD	imagerel $LN41+117
	DD	imagerel $chain$0$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD imagerel $LN41+117
	DD	imagerel $LN41+124
	DD	imagerel $chain$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+69
	DD	imagerel $unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD imagerel $LN49+69
	DD	imagerel $LN49+124
	DD	imagerel $chain$0$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD imagerel $LN49+124
	DD	imagerel $LN49+147
	DD	imagerel $chain$1$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+69
	DD	imagerel $unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN49
	DD	imagerel $LN49+69
	DD	imagerel $unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z DD 060d01H
	DD	0b540dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 020521H
	DD	047405H
	DD	imagerel $LN41
	DD	imagerel $LN41+42
	DD	imagerel $unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z DD 050f01H
	DD	0f00b420fH
	DD	06007e009H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EMaterials@SplatoonShapeToTotK@@YAXXZ DD 051501H
	DD	03c3415H
	DD	03a0115H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FMaterials@SplatoonShapeToTotK@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'E', 03H
	DB	00H
	DB	016H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DB 06H
	DB	085H, 05H
	DB	02H
	DB	015H, 03H
	DB	00H
	DB	0c2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	imagerel $ip2state$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0a2319H
	DD	0163414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	04beH
	DW	04e8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z DB 'L'
	DB	'=', 02H
	DB	06H
	DB	'-', 09H
	DB	08H
	DB	'M', 05H
	DB	0aH
	DB	'|'
	DB	0cH
	DB	' '
	DB	0eH
	DB	'('
	DB	012H
	DB	0dH, 04H
	DB	018H
	DB	'-', 02H
	DB	01cH
	DB	'A', 05H
	DB	01eH
	DB	0a6H
	DB	018H
	DB	'E', 02H
	DB	' '
	DB	08aH
	DB	018H
	DB	'@'
	DB	02H
	DB	018H
	DB	' '
	DB	'9', 02H
	DB	0aH
	DB	'`'
	DB	'"'
	DB	'$'
	DB	0aH
	DB	01dH, 04H
	DB	'$'
	DB	0dcH
	DB	'&'
	DB	0f0H
	DB	'('
	DB	01H, 0eH
	DB	'*'
	DB	0f1H, 05H
	DB	','
	DB	0a9H, 02H
	DB	'.'
	DB	0e2H
	DB	'0'
	DB	'`'
	DB	'2'
	DB	0cdH, 0eH
	DB	'4'
	DB	'e', 04H
	DB	'6'
	DB	0f1H, 0eH
	DB	'4'
	DB	'5', 03H
	DB	'2'
	DB	0f1H, ';'
	DB	'8'
	DB	019H, 02H
	DB	'0'
	DB	081H, 0fH
	DB	00H
	DB	'N'
	DB	'2'
	DB	01eH
	DB	018H
	DB	'.'
	DB	01cH
	DB	'4'
	DB	01eH
	DB	'4'
	DB	'4'
	DB	0cH
	DB	'2'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z DB 038H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0c1H
	DB	04H
	DB	03aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	0e1H
	DB	04H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0e1H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	041H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	0bH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	08H
	DB	03aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	0a1H
	DB	06H
	DB	03aH
	DD	imagerel ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
	DB	0c1H
	DB	0aH
	DB	0aaH
	DD	imagerel ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
	DB	0c1H
	DB	0aH
	DB	035H
	DB	02H
	DD	imagerel ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
	DB	0c1H
	DB	0aH
	DB	042H
	DD	imagerel ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
	DB	01H
	DB	0bH
	DB	03aH
	DD	imagerel ??1recursive_directory_iterator@filesystem@std@@QEAA@XZ
	DB	0c1H
	DB	0bH
	DB	03aH
	DD	imagerel ??1path@filesystem@std@@QEAA@XZ
	DB	0a0H
	DB	036H
	DD	imagerel ?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
	DB	096H
	DD	imagerel ?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA
	DB	0baH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	08H
	DB	09H
	DB	05H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	070H
	DB	075H
	DB	05H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	09H
	DB	042H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0e1H
	DB	08H
	DB	03aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	021H
	DB	07H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	0aH
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	07H
	DB	03aH
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	01H
	DB	0aH
	DB	03aH
	DD	imagerel ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ
	DB	041H
	DB	09H
	DB	03aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	061H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	061H
	DB	08H
	DB	0aaH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z
	DD	imagerel $ip2state$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z DD 0b3519H
	DD	06d3424H
	DD	0620124H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z
	DD	0302H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+54
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN47
	DD	imagerel $LN47+54
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z DD 040801H
	DD	070043208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD 020521H
	DD	057405H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z DD 040d01H
	DD	0e009520dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
?Materials$initializer$@SplatoonShapeToTotK@@3P6AXXZEA DQ FLAT:??__EMaterials@SplatoonShapeToTotK@@YAXXZ ; SplatoonShapeToTotK::Materials$initializer$
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z PROC	; std::initializer_list<char const *>::initializer_list<char const *>, COMDAT

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$initializer_list@PEBD@std@@QEAA@PEBQEBD0@Z ENDP	; std::initializer_list<char const *>::initializer_list<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@PEBD@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@PEBD@std@@QEAA@XZ PROC			; std::allocator<char const *>::allocator<char const *>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@PEBD@std@@QEAA@XZ ENDP			; std::allocator<char const *>::allocator<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
this$ = 64
_Ilist$ = 72
_Al$dead$ = 80
??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z PROC ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >, COMDAT

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN49:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	r14, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rbp, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sub	rbp, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sar	rsi, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rbp, rbp
	je	SHORT $LN36@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rsi, rax
	ja	SHORT $LN47@vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	mov	QWORD PTR [rsp+80], rbx
	call	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ; std::allocator<char const *>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rbx, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rsi*8]
	mov	QWORD PTR [rdi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rbx+rsi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi+8], rcx
$LN36@vector:

; 658  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
; 659  :     }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN47@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN45@vector:
??0?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@V?$initializer_list@PEBD@1@AEBV?$allocator@PEBD@1@@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@PEBD@std@@$$V@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@PEBD@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1><std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z PROC ; std::forward<std::allocator<char const *> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@PEBD@std@@@std@@YAAEBV?$allocator@PEBD@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char const *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEBD@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<char const *> >::_Vector_val<std::_Simple_types<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?size@?$initializer_list@PEBD@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$initializer_list@PEBD@std@@QEBA_KXZ PROC	; std::initializer_list<char const *>::size, COMDAT

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 47   :     }

	ret	0
?size@?$initializer_list@PEBD@std@@QEBA_KXZ ENDP	; std::initializer_list<char const *>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ PROC	; std::initializer_list<char const *>::begin, COMDAT

; 38   :         return _First;

	mov	rax, QWORD PTR [rcx]

; 39   :     }

	ret	0
?begin@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ENDP	; std::initializer_list<char const *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ
_TEXT	SEGMENT
this$ = 8
?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ PROC	; std::initializer_list<char const *>::end, COMDAT

; 42   :         return _Last;

	mov	rax, QWORD PTR [rcx+8]

; 43   :     }

	ret	0
?end@?$initializer_list@PEBD@std@@QEBAPEBQEBDXZ ENDP	; std::initializer_list<char const *>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN41:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN37@Construct_
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r15, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN39@Construct_
	mov	QWORD PTR [rsp+32], rdi

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ; std::allocator<char const *>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax
	mov	rdi, rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rbx*8]
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
$LN37@Construct_:
	ret	0
$LN39@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN36@Construct_:
??$_Construct_n@PEBQEBDPEBQEBD@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K$$QEAPEBQEBD1@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Construct_n<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAAEAV?$allocator@PEBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEAAAEAV?$allocator@PEBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN9@Buy_nonzer

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ; std::allocator<char const *>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rbx*8]

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);
; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Xlength
	int	3
$LN7@Buy_nonzer:
?_Buy_nonzero@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ PROC ; std::vector<char const *,std::allocator<char const *> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEBA_KXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEBAAEBV?$allocator@PEBD@2@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ PROC ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PEBD@std@@V?$_Vector_val@U?$_Simple_types@PEBD@std@@@2@$00@std@@QEBAAEBV?$allocator@PEBD@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char const *>,std::_Vector_val<std::_Simple_types<char const *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SA_KAEBV?$allocator@PEBD@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1980 :         // allocate array with _Newcapacity elements
; 1981 :         auto& _My_data    = _Mypair._Myval2;
; 1982 :         pointer& _Myfirst = _My_data._Myfirst;
; 1983 :         pointer& _Mylast  = _My_data._Mylast;
; 1984 :         pointer& _Myend   = _My_data._Myend;
; 1985 : 
; 1986 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1987 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1988 : 
; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ; std::allocator<char const *>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rbx*8]

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Buy_raw@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z PROC	; std::forward<char const * const *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ENDP	; std::forward<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z PROC ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ENDP ; std::ranges::_Unwrap_iter<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z PROC ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEBQEBDPEBQEBD@ranges@std@@YA?A_T$$QEAPEBQEBD@Z ENDP ; std::ranges::_Unwrap_sent<char const * const *,char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z PROC ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 1845 :             } else {
; 1846 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1847 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1848 :                 _Dest += _Count;
; 1849 :             }
; 1850 :             return _Dest;
; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEBQEBDPEBQEBDV?$allocator@PEBD@std@@@std@@YAPEAPEBDPEBQEBD0PEAPEBDAEAV?$allocator@PEBD@0@@Z ENDP ; std::_Uninitialized_copy<char const * const *,char const * const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z PROC	; std::_To_address<char const * const *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEBQEBD@std@@YA?A_PAEBQEBQEBD@Z ENDP	; std::_To_address<char const * const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z PROC	; std::move<char const * const * &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEBQEBD@std@@YA$$QEAPEBQEBDAEAPEBQEBD@Z ENDP	; std::move<char const * const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@PEAPEBDAEAV?$allocator@PEBD@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Uninitialized_backout_al<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1804 :     }

	ret	0
??$_Emplace_back@AEBQEBD@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAXAEBQEBD@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Emplace_back<char const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z PROC		; std::_Unfancy<char const *>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@PEBD@std@@YAPEAPEBDPEAPEBD@Z ENDP		; std::_Unfancy<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z PROC ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@PEBDAEBQEBD@?$_Default_allocator_traits@V?$allocator@PEBD@std@@@std@@SAXAEAV?$allocator@PEBD@1@QEAPEBDAEBQEBD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char const *> >::construct<char const *,char const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z PROC ; std::construct_at<char const *,char const * const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEBDAEBQEBD$0A@@std@@YAPEAPEBDQEAPEBDAEBQEBD@Z ENDP ; std::construct_at<char const *,char const * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAPEAPEBDXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::~_Uninitialized_backout_al<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z PROC ; std::_Destroy_range<std::allocator<char const *> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@PEBD@std@@@std@@YAXPEAPEBDQEAPEBDAEAV?$allocator@PEBD@0@@Z ENDP ; std::_Destroy_range<std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ ; std::vector<char const *,std::allocator<char const *> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@PEBDV?$allocator@PEBD@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >::~_Tidy_guard<std::vector<char const *,std::allocator<char const *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
;	COMDAT ??__EMaterials@SplatoonShapeToTotK@@YAXXZ
text$di	SEGMENT
$T2 = 32
??__EMaterials@SplatoonShapeToTotK@@YAXXZ PROC		; SplatoonShapeToTotK::`dynamic initializer for 'Materials'', COMDAT

; 78   : };

	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-208]
	sub	rsp, 464				; 000001d0H

; 23   : {

	lea	rax, OFFSET FLAT:??_C@_09IEDNJDJD@Undefined@
	mov	QWORD PTR $T2[rsp], rax
	lea	rax, OFFSET FLAT:??_C@_04KLGFIOKI@Soil@
	mov	QWORD PTR $T2[rsp+8], rax
	lea	rax, OFFSET FLAT:??_C@_05OENLLHN@Grass@
	mov	QWORD PTR $T2[rsp+16], rax
	lea	rax, OFFSET FLAT:??_C@_04IGCMGFBG@Sand@
	mov	QWORD PTR $T2[rsp+24], rax
	lea	rax, OFFSET FLAT:??_C@_09IHMJGAPP@HeavySand@
	mov	QWORD PTR $T2[rsp+32], rax
	lea	rax, OFFSET FLAT:??_C@_04LOGCFOOF@Snow@
	mov	QWORD PTR $T2[rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_09LPIHFLAM@HeavySnow@
	mov	QWORD PTR $T2[rsp+48], rax
	lea	rax, OFFSET FLAT:??_C@_05PBPDPMJH@Stone@
	mov	QWORD PTR $T2[rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_09PBIFHKE@StoneSlip@
	mov	QWORD PTR $T2[rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0M@CGJOPMFL@StoneNoSlip@
	mov	QWORD PTR $T2[rsp+72], rax
	lea	rax, OFFSET FLAT:??_C@_09FLEBHKMJ@SlipBoard@
	mov	QWORD PTR $T2[rsp+80], rax
	lea	rax, OFFSET FLAT:??_C@_04LJDCLKNB@Cart@
	mov	QWORD PTR $T2[rsp+88], rax
	lea	rax, OFFSET FLAT:??_C@_05MICJANKE@Metal@
	mov	QWORD PTR $T2[rbp-160], rax
	lea	rax, OFFSET FLAT:??_C@_09HNFCLMJB@MetalSlip@
	mov	QWORD PTR $T2[rbp-152], rax
	lea	rax, OFFSET FLAT:??_C@_0M@LDHHHHFH@MetalNoSlip@
	mov	QWORD PTR $T2[rbp-144], rax
	lea	rax, OFFSET FLAT:??_C@_07LCKMBNLP@WireNet@
	mov	QWORD PTR $T2[rbp-136], rax
	lea	rax, OFFSET FLAT:??_C@_04JCLBNONC@Wood@
	mov	QWORD PTR $T2[rbp-128], rax
	lea	rax, OFFSET FLAT:??_C@_03GKLMNNMP@Ice@
	mov	QWORD PTR $T2[rbp-120], rax
	lea	rax, OFFSET FLAT:??_C@_05GKKHKKE@Cloth@
	mov	QWORD PTR $T2[rbp-112], rax
	lea	rax, OFFSET FLAT:??_C@_05NBJNJCJO@Glass@
	mov	QWORD PTR $T2[rbp-104], rax
	lea	rax, OFFSET FLAT:??_C@_04CCGIJNFG@Bone@
	mov	QWORD PTR $T2[rbp-96], rax
	lea	rax, OFFSET FLAT:??_C@_04FEDAIEKO@Rope@
	mov	QWORD PTR $T2[rbp-88], rax
	lea	rax, OFFSET FLAT:??_C@_09EDIHJNKH@Character@
	mov	QWORD PTR $T2[rbp-80], rax
	lea	rax, OFFSET FLAT:??_C@_07DCJMIMKJ@Ragdoll@
	mov	QWORD PTR $T2[rbp-72], rax
	lea	rax, OFFSET FLAT:??_C@_07IBGHKGNL@Surfing@
	mov	QWORD PTR $T2[rbp-64], rax
	lea	rax, OFFSET FLAT:??_C@_0N@ICEAPMCH@GuardianFoot@
	mov	QWORD PTR $T2[rbp-56], rax
	lea	rax, OFFSET FLAT:??_C@_09EIHJAMGC@LaunchPad@
	mov	QWORD PTR $T2[rbp-48], rax
	lea	rax, OFFSET FLAT:??_C@_08OFCALKHE@Conveyer@
	mov	QWORD PTR $T2[rbp-40], rax
	lea	rax, OFFSET FLAT:??_C@_04HGNKNACL@Rail@
	mov	QWORD PTR $T2[rbp-32], rax
	lea	rax, OFFSET FLAT:??_C@_06HFLBIKBA@Grudge@
	mov	QWORD PTR $T2[rbp-24], rax
	lea	rax, OFFSET FLAT:??_C@_04JHAAIOMO@Meat@
	mov	QWORD PTR $T2[rbp-16], rax
	lea	rax, OFFSET FLAT:??_C@_09EBKCOMIJ@Vegetable@
	mov	QWORD PTR $T2[rbp-8], rax
	lea	rax, OFFSET FLAT:??_C@_04GPGPLFMI@Bomb@
	mov	QWORD PTR $T2[rbp], rax
	lea	rax, OFFSET FLAT:??_C@_09FPGFNOLO@MagicBall@
	mov	QWORD PTR $T2[rbp+8], rax
	lea	rax, OFFSET FLAT:??_C@_07MGHBHAE@Barrier@
	mov	QWORD PTR $T2[rbp+16], rax
	lea	rax, OFFSET FLAT:??_C@_07KGACNCEL@AirWall@
	mov	QWORD PTR $T2[rbp+24], rax
	lea	rax, OFFSET FLAT:??_C@_0L@OGLFIFIE@GrudgeSnow@
	mov	QWORD PTR $T2[rbp+32], rax
	lea	rax, OFFSET FLAT:??_C@_03MOMIACHF@Tar@
	mov	QWORD PTR $T2[rbp+40], rax
	lea	rax, OFFSET FLAT:??_C@_05EMKMBNJK@Water@
	mov	QWORD PTR $T2[rbp+48], rax
	lea	rax, OFFSET FLAT:??_C@_08GPMBEPKH@HotWater@
	mov	QWORD PTR $T2[rbp+56], rax
	lea	rax, OFFSET FLAT:??_C@_08OOLMNJNB@IceWater@
	mov	QWORD PTR $T2[rbp+64], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	edx, 54					; 00000036H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 23   : {

	lea	rax, OFFSET FLAT:??_C@_04LNOGDMI@Lava@
	mov	QWORD PTR $T2[rbp+72], rax
	lea	rax, OFFSET FLAT:??_C@_03IGJBMBCI@Bog@
	mov	QWORD PTR $T2[rbp+80], rax
	lea	rax, OFFSET FLAT:??_C@_0BC@HBDGHKCI@ContaminatedWater@
	mov	QWORD PTR $T2[rbp+88], rax
	lea	rax, OFFSET FLAT:??_C@_0M@IFPIJOFF@DungeonCeil@
	mov	QWORD PTR $T2[rbp+96], rax
	lea	rax, OFFSET FLAT:??_C@_03JFHPMLEF@Gas@
	mov	QWORD PTR $T2[rbp+104], rax
	lea	rax, OFFSET FLAT:??_C@_0BF@CHGLKCOF@InvalidateRestartPos@
	mov	QWORD PTR $T2[rbp+112], rax
	lea	rax, OFFSET FLAT:??_C@_0BA@CLODKHAM@HorseSpeedLimit@
	mov	QWORD PTR $T2[rbp+120], rax
	lea	rax, OFFSET FLAT:??_C@_0CJ@PMJKFGKG@ForbidDynamicCuttingAreaForHuge@
	mov	QWORD PTR $T2[rbp+128], rax
	lea	rax, OFFSET FLAT:??_C@_0CE@PMICFAFK@ForbidHorseReturnToSafePosByCli@
	mov	QWORD PTR $T2[rbp+136], rax
	lea	rax, OFFSET FLAT:??_C@_06COGLIGFC@Dragon@
	mov	QWORD PTR $T2[rbp+144], rax
	lea	rax, OFFSET FLAT:??_C@_0BB@NMPMNAPE@ReferenceSurfing@
	mov	QWORD PTR $T2[rbp+152], rax
	lea	rax, OFFSET FLAT:??_C@_09NNKBLLEE@WaterSlip@
	mov	QWORD PTR $T2[rbp+160], rax
	lea	rax, OFFSET FLAT:??_C@_0BO@MLFHCDOC@HorseDeleteImmediatelyOnDeath@
	mov	QWORD PTR $T2[rbp+168], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ; std::allocator<char const *>::allocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 432				; 000001b0H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	lea	rdx, QWORD PTR $T2[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+432]
	mov	QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 22   : std::vector<const char*> SplatoonShapeToTotK::Materials =

	lea	rcx, OFFSET FLAT:??__FMaterials@SplatoonShapeToTotK@@YAXXZ ; SplatoonShapeToTotK::`dynamic atexit destructor for 'Materials''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 22   : std::vector<const char*> SplatoonShapeToTotK::Materials =

	mov	rbx, QWORD PTR [rsp+480]
	add	rsp, 464				; 000001d0H
	pop	rbp
	jmp	atexit
??__EMaterials@SplatoonShapeToTotK@@YAXXZ ENDP		; SplatoonShapeToTotK::`dynamic initializer for 'Materials''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??__FMaterials@SplatoonShapeToTotK@@YAXXZ
text$yd	SEGMENT
??__FMaterials@SplatoonShapeToTotK@@YAXXZ PROC		; SplatoonShapeToTotK::`dynamic atexit destructor for 'Materials'', COMDAT
	sub	rsp, 40					; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A
	test	rcx, rcx
	je	SHORT $LN6@dynamic

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+16
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN24@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN21@dynamic

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN24@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A, 0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR ?Materials@SplatoonShapeToTotK@@3V?$vector@PEBDV?$allocator@PEBD@std@@@std@@A+8, xmm0
$LN6@dynamic:
	add	rsp, 40					; 00000028H
	ret	0
$LN21@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@dynamic:
??__FMaterials@SplatoonShapeToTotK@@YAXXZ ENDP		; SplatoonShapeToTotK::`dynamic atexit destructor for 'Materials''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z PROC ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAAX_K@Z ENDP ; std::vector<char const *,std::allocator<char const *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PEBD@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char const *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
;	COMDAT ?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
Section$GSCopy$ = 32
__$ArrayPad$ = 40
Reader$ = 64
Section$ = 72
?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SplatoonShapeToTotK::FindSection, COMDAT

; 81   : {

$LN91:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r11, rcx

; 80   : uint32_t SplatoonShapeToTotK::FindSection(BinaryVectorReader Reader, std::string Section)

	mov	QWORD PTR Section$GSCopy$[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	ebx, -1
	mov	DWORD PTR [rcx+8], ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 83   : 	char Data[4] = { 0 };

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	mov	r10, QWORD PTR [rdx+16]
	test	r10, r10
	je	$LN81@FindSectio

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	r9, QWORD PTR [rdx+24]
	npad	8
$LL2@FindSectio:

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rdx

; 2227 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN86@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdx]
$LN86@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 84   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	cmp	al, BYTE PTR [rcx]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 1
	jbe	$LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2227 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN85@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN85@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 84   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	mov	ecx, eax
	shr	ecx, 8
	cmp	cl, BYTE PTR [r8+1]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 2
	jbe	SHORT $LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	r8, rdx

; 2227 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN87@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r8, QWORD PTR [rdx]
$LN87@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 84   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	mov	ecx, eax
	shr	ecx, 16
	cmp	cl, BYTE PTR [r8+2]
	jne	SHORT $LN4@FindSectio
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	cmp	r10, 3
	jbe	SHORT $LN81@FindSectio

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	rcx, rdx

; 2227 :         if (_Large_string_engaged()) {

	cmp	r9, 16
	jb	SHORT $LN56@FindSectio

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rdx]
$LN56@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 84   : 	while (!(Data[0] == Section.at(0) && Data[1] == Section.at(1) && Data[2] == Section.at(2) && Data[3] == Section.at(3)))

	shr	eax, 24
	cmp	al, BYTE PTR [rcx+3]
	je	SHORT $LN3@FindSectio
$LN4@FindSectio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 146  : 	std::memcpy(Dest, this->m_Bytes.data() + this->m_Offset + 1, Size);

	mov	rax, QWORD PTR [r11]
	movsxd	rcx, ebx
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+rcx+1]

; 147  : 
; 148  : 	//std::memcopy(this->m_Bytes.begin() + this->m_Offset + 1, this->m_Bytes.begin() + this->m_Offset + 1 + Size, static_cast<char*>(Dest));
; 149  : 
; 150  : 	this->m_Offset += Size;

	add	ebx, 4
	mov	DWORD PTR [r11+8], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2267 :         if (_Mysize <= _Off) {

	jmp	SHORT $LL2@FindSectio
$LN3@FindSectio:

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 88   : 	return Reader.GetPosition();

	lea	eax, DWORD PTR [rbx+1]

; 89   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN81@FindSectio:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2268 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
	npad	1
$LN88@FindSectio:
?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SplatoonShapeToTotK::FindSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
Section$GSCopy$ = 32
__$ArrayPad$ = 40
Reader$ = 64
Section$ = 72
?dtor$0@?0??FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `SplatoonShapeToTotK::FindSection'::`1'::dtor$0
	mov	rcx, QWORD PTR Section$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `SplatoonShapeToTotK::FindSection'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
;	COMDAT ?BitFieldToSize@SplatoonShapeToTotK@@YAII@Z
_TEXT	SEGMENT
Input$ = 8
?BitFieldToSize@SplatoonShapeToTotK@@YAII@Z PROC	; SplatoonShapeToTotK::BitFieldToSize, COMDAT

; 93   : 	return Input & 0x3FFFFFFF;

	and	ecx, 1073741823				; 3fffffffH
	mov	eax, ecx

; 94   : }

	ret	0
?BitFieldToSize@SplatoonShapeToTotK@@YAII@Z ENDP	; SplatoonShapeToTotK::BitFieldToSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
;	COMDAT ?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
TargetAddress$1$ = 32
_My_data$1$ = 40
Text$ = 48
__$ArrayPad$ = 80
Reader$ = 160
Dest$ = 168
?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; SplatoonShapeToTotK::ReadStringTable, COMDAT

; 97   : {

$LN222:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r14, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	rbx, DWORD PTR [rcx+8]
	lea	r11d, DWORD PTR [rbx+4]
	mov	r15, QWORD PTR [rcx]
	mov	QWORD PTR _My_data$1$[rsp], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rbx+2]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [rbx+1]
	movsxd	r9, eax

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	esi, BYTE PTR [rbx+r8+3]
	shl	esi, 8
	movzx	eax, BYTE PTR [rdx+r8]
	or	esi, eax
	shl	esi, 8
	movzx	eax, BYTE PTR [rbx+r8+4]
	shl	eax, 24
	or	esi, eax
	movzx	eax, BYTE PTR [r9+r8]
	or	esi, eax
	bswap	esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 93   : 	return Input & 0x3FFFFFFF;

	and	esi, 1073741823				; 3fffffffH

; 98   : 	uint32_t Size = BitFieldToSize(Reader.ReadUInt32(true));
; 99   : 	uint32_t TargetAddress = Reader.GetPosition() + Size - 4; //-4 = Size(3) + Flags(1)

	add	r11d, -3				; fffffffdH
	add	esi, r11d
	mov	DWORD PTR TargetAddress$1$[rsp], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	add	ebx, 8
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Text$[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	xor	edi, edi
	mov	QWORD PTR Text$[rsp+16], rdi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebp, 15
	mov	QWORD PTR Text$[rsp+24], rbp

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR Text$[rsp], dil
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	lea	eax, DWORD PTR [rbx+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 104  : 	while (Reader.GetPosition() != TargetAddress)

	cmp	eax, esi
	je	$LN216@ReadString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 778  :         auto& _My_data   = _Mypair._Myval2;

	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	lea	r8d, QWORD PTR [rdi+22]
	lea	r10, QWORD PTR [rdi-1]
	npad	5
$LL2@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 44   : 	this->m_Offset++;

	lea	r13d, DWORD PTR [rbx+1]

; 45   : 	return this->m_Bytes[this->m_Offset];

	movsxd	rcx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 106  : 		char Character = Reader.ReadUInt8();

	movzx	r9d, BYTE PTR [rcx+rax+1]

; 107  : 		if (Character == 0x00)

	test	r9b, r9b
	jne	$LN4@ReadString
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rbx, QWORD PTR [r14+8]
	cmp	rbx, QWORD PTR [r14+16]
	je	$LN86@ReadString
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rbx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rbx+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rbx+24], 0

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r15, QWORD PTR Text$[rsp]

; 2236 :         if (_Large_string_engaged()) {

	mov	r12, QWORD PTR Text$[rsp]
	cmp	rbp, 16
	cmovae	r15, r12

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, rdx
	ja	$LN193@ReadString

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR [rbx+24], 15
	cmp	rdi, 16
	jae	SHORT $LN111@ReadString

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR [rbx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r14+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	r15, QWORD PTR _My_data$1$[rsp]
	jmp	SHORT $LN85@ReadString
$LN111@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rsi, rdi
	or	rsi, 15
	cmp	rsi, rdx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN122@ReadString

; 4716 :             return _Max;

	mov	rsi, rdx
	jmp	SHORT $LN121@ReadString
$LN122@ReadString:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rsi, 22
	cmovb	rsi, r8
$LN121@ReadString:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rsi
	add	rdx, 1
	cmovb	rdx, r10
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR [rbx], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR [rbx+16], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rsi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	esi, DWORD PTR TargetAddress$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	add	QWORD PTR [r14+8], 32			; 00000020H

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	r15, QWORD PTR _My_data$1$[rsp]
	jmp	SHORT $LN85@ReadString
$LN86@ReadString:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Text$[rsp]
	mov	rdx, rbx
	mov	rcx, r14
	call	??$_Emplace_reallocate@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QEAV21@AEBV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
	mov	rbp, QWORD PTR Text$[rsp+24]
	mov	r12, QWORD PTR Text$[rsp]
$LN85@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Text$[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rbp, 16
	cmovae	rax, r12

; 4815 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	QWORD PTR Text$[rsp+16], 0
	mov	BYTE PTR [rax], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 111  : 			continue;

	jmp	SHORT $LN219@ReadString
$LN4@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rdi, rbp

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN151@ReadString

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rdi+1]
	mov	QWORD PTR Text$[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Text$[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rbp, 16
	cmovae	rax, QWORD PTR Text$[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rdi], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rdi+1], 0

; 4053 :             return;

	jmp	SHORT $LN150@ReadString
$LN151@ReadString:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Text$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN219@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 26   : 	return this->m_Offset + 1;

	mov	r10, -1
	lea	r8d, QWORD PTR [r10+23]
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
$LN150@ReadString:
	mov	ebx, r13d
	lea	eax, DWORD PTR [r13+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 104  : 	while (Reader.GetPosition() != TargetAddress)

	mov	rbp, QWORD PTR Text$[rsp+24]
	cmp	eax, esi
	je	SHORT $LN216@ReadString
	mov	rdi, QWORD PTR Text$[rsp+16]
	jmp	$LL2@ReadString
$LN216@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN170@ReadString

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Text$[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN182@ReadString

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN182@ReadString
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN182@ReadString:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN170@ReadString:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 116  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN193@ReadString:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN218@ReadString:
?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; SplatoonShapeToTotK::ReadStringTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
TargetAddress$1$ = 32
_My_data$1$ = 40
Text$ = 48
__$ArrayPad$ = 80
Reader$ = 160
Dest$ = 168
?dtor$0@?0??ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z@4HA PROC ; `SplatoonShapeToTotK::ReadStringTable'::`1'::dtor$0
	lea	rcx, QWORD PTR Text$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z@4HA ENDP ; `SplatoonShapeToTotK::ReadStringTable'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp
;	COMDAT ?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z
_TEXT	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z PROC ; SplatoonShapeToTotK::Convert, COMDAT

; 124  : {

$LN2692:
	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-528]
	sub	rsp, 784				; 00000310H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR Bytes$GSCopy$1$[rbp-256], rdx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-256], rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR Bytes$GSCopy$[rbp-256], rdx
	xor	r13d, r13d
	mov	esi, r13d
	mov	DWORD PTR $T41[rsp], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	mov	QWORD PTR Reader$[rbp-256], rdx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rbp-240], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rbp-256], xmm1
	mov	QWORD PTR Writer$[rbp-240], r13
	mov	DWORD PTR Writer$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	mov	DWORD PTR Reader$[rbp-248], 31
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR MaterialArray$[rbp-256], xmm1
	mov	QWORD PTR MaterialArray$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 131  : 	MaterialArray.push_back(PhiveMaterial.MaterialIndex);

	mov	BYTE PTR $T25[rsp], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T25[rsp]
	xor	edx, edx
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 132  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T21[rsp], r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2279@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], r13b

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2278@Convert
$LN2279@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T21[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2278@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 133  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T22[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2272@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2271@Convert
$LN2272@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T22[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2271@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 134  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T23[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2265@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2264@Convert
$LN2265@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T23[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2264@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 135  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T24[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2258@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2257@Convert
$LN2258@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T24[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2257@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 136  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T28[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2251@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2250@Convert
$LN2251@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T28[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2250@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 137  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T26[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2244@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2243@Convert
$LN2244@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T26[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2243@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 138  : 	MaterialArray.push_back(0x00);

	mov	BYTE PTR $T27[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2237@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2236@Convert
$LN2237@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T27[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2236@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 139  : 	if (!PhiveMaterial.Climbable)

	cmp	BYTE PTR PhiveMaterial$[rbp-252], 0
	jne	SHORT $LN2292@Convert

; 140  : 	{
; 141  : 		MaterialArray.push_back(0x01);

	mov	BYTE PTR $T12[rsp], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2300@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 1

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
	inc	rdx
	mov	QWORD PTR MaterialArray$[rbp-248], rdx

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2299@Convert
$LN2300@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T12[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	rdx, QWORD PTR MaterialArray$[rbp-248]
$LN2299@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 142  : 		MaterialArray.push_back(0x80);

	mov	BYTE PTR $T11[rsp], 128			; 00000080H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN2293@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [rdx], 128			; 00000080H

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	inc	QWORD PTR MaterialArray$[rbp-248]

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2292@Convert
$LN2293@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T11[rsp]
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
$LN2292@Convert:
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 145  : 	std::vector<unsigned char> MaterialColFlagsNum = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

	mov	QWORD PTR $T18[rsp], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR MaterialColFlagsNum$[rbp-256], xmm0
	mov	QWORD PTR MaterialColFlagsNum$[rbp-240], r13

; 2010 :         _Buy_raw(_Newcapacity);

	mov	edx, 8
	lea	rcx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rcx, QWORD PTR MaterialColFlagsNum$[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rax, QWORD PTR $T18[rsp]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	r14, QWORD PTR [rcx+8]
	mov	QWORD PTR MaterialColFlagsNum$[rbp-248], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r15, QWORD PTR MaterialArray$[rbp-248]
	mov	rax, r15
	mov	rcx, QWORD PTR MaterialArray$[rbp-256]
	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 147  : 	while (MaterialArray.size() % 16 != 0)

	test	al, 15
	je	SHORT $LN2309@Convert

; 148  : 	{
; 149  : 		MaterialArray.push_back(0x00);

	mov	BYTE PTR $T9[rsp], 0
$LL2@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	r15, QWORD PTR MaterialArray$[rbp-240]
	je	SHORT $LN1614@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [r15], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	r15, QWORD PTR MaterialArray$[rbp-248]
	inc	r15
	mov	QWORD PTR MaterialArray$[rbp-248], r15

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1613@Convert
$LN1614@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T9[rsp]
	mov	rdx, r15
	lea	rcx, QWORD PTR MaterialArray$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	r15, QWORD PTR MaterialArray$[rbp-248]
$LN1613@Convert:

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, r15
	mov	rcx, QWORD PTR MaterialArray$[rbp-256]
	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 147  : 	while (MaterialArray.size() % 16 != 0)

	test	al, 15
	jne	SHORT $LL2@Convert
	mov	r14, QWORD PTR MaterialColFlagsNum$[rbp-248]
$LN2309@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, r14
	mov	rdx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	sub	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 152  : 	while (MaterialColFlagsNum.size() % 16 != 0)

	test	al, 15
	je	SHORT $LN5@Convert

; 153  : 	{
; 154  : 		MaterialColFlagsNum.push_back(0x00);

	mov	BYTE PTR $T10[rsp], 0
$LL4@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	r14, QWORD PTR MaterialColFlagsNum$[rbp-240]
	je	SHORT $LN1607@Convert

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	BYTE PTR [r14], 0

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	r14, QWORD PTR MaterialColFlagsNum$[rbp-248]
	inc	r14
	mov	QWORD PTR MaterialColFlagsNum$[rbp-248], r14

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1606@Convert
$LN1607@Convert:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T10[rsp]
	mov	rdx, r14
	lea	rcx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	call	??$_Emplace_reallocate@E@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAE$$QEAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char>
	mov	r14, QWORD PTR MaterialColFlagsNum$[rbp-248]
$LN1606@Convert:

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, r14
	mov	rdx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	sub	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 152  : 	while (MaterialColFlagsNum.size() % 16 != 0)

	test	al, 15
	jne	SHORT $LL4@Convert
	mov	r15, QWORD PTR MaterialArray$[rbp-248]
	mov	rcx, QWORD PTR MaterialArray$[rbp-256]
$LN5@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r15, rcx
	sub	r14, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 160  : 	std::cout << "Size: " << TableSize0 << "; " << TableSize1 << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_06FMLHDGIC@Size?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, r15d
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_02LNAEAIDO@?$DL?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, r14d
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Path$[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR Path$[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Path$[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR Path$[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T38[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T38[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T38[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 15
	lea	rdx, OFFSET FLAT:??_C@_0BA@IFILIMCB@Phive?1Shape?1Dcc@
	lea	rcx, QWORD PTR $T38[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 165  : 	for (const auto& DirEntry : recursive_directory_iterator(Editor::GetRomFSFile("Phive/Shape/Dcc", false)))

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T38[rsp]
	lea	rcx, QWORD PTR $T61[rbp-256]
	call	?GetRomFSFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@_N@Z ; Editor::GetRomFSFile
	npad	1
	mov	rdx, rax
	lea	rcx, QWORD PTR $T58[rbp-256]
	call	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
	npad	1
	lea	rdx, QWORD PTR $T58[rbp-256]
	lea	rcx, QWORD PTR $S8$62[rbp-256]
	call	??0recursive_directory_iterator@filesystem@std@@QEAA@AEBVpath@12@@Z ; std::filesystem::recursive_directory_iterator::recursive_directory_iterator
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T58[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T61[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	xorps	xmm0, xmm0
	movups	XMMWORD PTR <begin>$L0$63[rbp-256], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 1396 :         if (_Rep) {

	mov	rax, QWORD PTR $S8$62[rbp-248]
	test	rax, rax
	je	SHORT $LN2157@Convert

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
	mov	rax, QWORD PTR $S8$62[rbp-248]
	mov	esi, DWORD PTR $T41[rsp]
$LN2157@Convert:

; 1345 :         _Ptr = _Right._Ptr;

	movaps	xmm1, XMMWORD PTR $S8$62[rbp-256]
	movdqa	XMMWORD PTR <begin>$L0$63[rbp-256], xmm1
	movups	XMMWORD PTR <end>$L0$64[rbp-256], xmm0

; 1396 :         if (_Rep) {

	test	rax, rax
	je	SHORT $LN2118@Convert

; 1169 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
	movaps	xmm1, XMMWORD PTR $S8$62[rbp-256]
	mov	esi, DWORD PTR $T41[rsp]
$LN2118@Convert:

; 1357 :         _Ptr = _Other._Ptr;

	movdqa	XMMWORD PTR $T53[rbp-256], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 165  : 	for (const auto& DirEntry : recursive_directory_iterator(Editor::GetRomFSFile("Phive/Shape/Dcc", false)))

	lea	rdx, QWORD PTR $T53[rbp-256]
	lea	rcx, QWORD PTR <end>$L0$64[rbp-256]
	call	?end@filesystem@std@@YA?AVrecursive_directory_iterator@12@V312@@Z ; std::filesystem::end
	npad	1
	npad	3
$LL1644@Convert:
	mov	rbx, QWORD PTR <begin>$L0$63[rbp-256]
	cmp	rbx, QWORD PTR <end>$L0$64[rbp-256]
	je	$LN7@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2381 :             const auto _Result = _Get_any_status(_Status_stats_flags);

	mov	r8d, 3
	lea	rdx, QWORD PTR _Result$42[rbp-256]
	mov	rcx, rbx
	call	?_Get_any_status@directory_entry@filesystem@std@@AEBA?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status

; 2065 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

	mov	rax, QWORD PTR _Result$42[rbp-256]
	mov	edx, DWORD PTR _Result$42[rbp-248]
	test	edx, edx
	je	SHORT $LN1638@Convert
	lea	ecx, DWORD PTR [rax-1]
	test	ecx, -9					; fffffff7H
	jne	$LN2613@Convert
$LN1638@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 167  : 		if (!DirEntry.is_regular_file()) continue;

	cmp	eax, 2
	jne	$LN6@Convert

; 168  : 		if (DirEntry.path().filename().string().starts_with("Cave")) continue;

	lea	r13, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 8
	jb	SHORT $LN2616@Convert

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r13]
$LN2616@Convert:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rax, QWORD PTR [r13+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 497  :         const auto _Last     = _First + _Str.size();

	lea	r10, QWORD PTR [rcx+rax*2]

; 498  :         const auto _Filename = _Find_filename(_First, _Last);

	mov	rdx, r10
	call	?_Find_filename@filesystem@std@@YAPEB_WQEB_WPEB_W@Z ; std::filesystem::_Find_filename
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T43[rbp-256], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 499  :         return wstring_view(_Filename, static_cast<size_t>(_Last - _Filename));

	sub	r10, rax
	sar	r10, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	QWORD PTR $T43[rbp-248], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 1109 :             return _Parse_filename(_Text);

	lea	rdx, QWORD PTR $T43[rbp-256]
	lea	rcx, QWORD PTR $T37[rsp]
	call	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
	or	esi, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r12, QWORD PTR $T37[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T37[rsp+24], 8
	cmovae	r12, QWORD PTR $T37[rsp]

; 1209 :         : _Mydata(_Cts), _Mysize(_Count) {

	mov	rdi, QWORD PTR $T37[rsp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	DWORD PTR $T20[rsp], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T52[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	r9d, r9d
	mov	ecx, r9d
	mov	QWORD PTR $T52[rbp-240], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	r8d, 15
	mov	QWORD PTR $T52[rbp-232], r8

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T52[rbp-256], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	or	esi, 32					; 00000020H
	mov	DWORD PTR $T41[rsp], esi

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;
; 57   : }
; 58   : 
; 59   : template <class _Traits, class _Alloc>
; 60   : _NODISCARD basic_string<typename _Traits::char_type, _Traits, _Alloc> _Convert_wide_to_narrow(
; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 62   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);
; 63   : 
; 64   :     if (!_Input.empty()) {

	test	rdi, rdi
	je	SHORT $LN1945@Convert

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rdi, 2147483647				; 7fffffffH
	ja	$LN2356@Convert

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	DWORD PTR [rsp+32], r9d
	mov	r8d, edi
	mov	rdx, r12
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax
	mov	QWORD PTR $T16[rsp], rax
	shr	rax, 32					; 00000020H

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	test	eax, eax
	jne	$LN2357@Convert

; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	lea	rcx, QWORD PTR $T52[rbp-256]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR $T52[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T52[rbp-232], 16
	cmovae	r9, QWORD PTR $T52[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, edi
	mov	rdx, r12
	mov	ecx, DWORD PTR $T20[rsp]
	call	__std_fs_convert_wide_to_narrow
	mov	QWORD PTR $T15[rsp], rax
	shr	rax, 32					; 00000020H

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	test	eax, eax
	jne	$LN2358@Convert
	mov	r8, QWORD PTR $T52[rbp-232]
	mov	rcx, QWORD PTR $T52[rbp-240]
	xor	r9d, r9d
$LN1945@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	and	esi, -33				; ffffffffffffffdfH

; 934  :             return string<char>();

	or	esi, 28
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T52[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rdx, QWORD PTR $T52[rbp-256]

; 1420 :         if (_Mysize < _Rightsize) {

	cmp	rcx, 4
	jae	SHORT $LN1861@Convert

; 1421 :             return false;

	xor	bl, bl
	jmp	SHORT $LN1860@Convert
$LN1861@Convert:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, r9
	lea	r8, OFFSET FLAT:??_C@_04ONOCDBBN@Cave@
	npad	10
$LL2627@Convert:
	movzx	eax, BYTE PTR [rdx+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r8+rcx-1]
	jne	SHORT $LN2628@Convert
	cmp	rcx, 4
	jne	SHORT $LL2627@Convert
	mov	eax, r9d
	jmp	SHORT $LN2629@Convert
$LN2628@Convert:
	sbb	eax, eax
	or	eax, 1
$LN2629@Convert:

; 1423 :         return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;

	test	eax, eax
	sete	bl
$LN1860@Convert:

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T52[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
	lea	rcx, QWORD PTR $T37[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 168  : 		if (DirEntry.path().filename().string().starts_with("Cave")) continue;

	test	bl, bl
	jne	$LN6@Convert
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR TmpBytes$60[rbp-256], xmm0
	mov	QWORD PTR TmpBytes$60[rbp-240], rax

; 169  : 		std::vector<unsigned char> TmpBytes = ZStdFile::Decompress(DirEntry.path().string(), ZStdFile::Dictionary::Base).Data;

	lea	rax, QWORD PTR $T36[rsp]
	mov	QWORD PTR $T40[rsp], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r13

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r13+24], 8
	jb	SHORT $LN2006@Convert

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r13]
$LN2006@Convert:

; 4041 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

	mov	rdi, QWORD PTR [r13+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	DWORD PTR $T19[rsp], eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T36[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	ecx, ecx
	mov	QWORD PTR $T36[rsp+16], rcx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T36[rsp+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T36[rsp], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 80   :     return _Output;

	bts	esi, 9
	mov	DWORD PTR $T41[rsp], esi

; 54   :     }
; 55   : 
; 56   :     return _Result._Len;
; 57   : }
; 58   : 
; 59   : template <class _Traits, class _Alloc>
; 60   : _NODISCARD basic_string<typename _Traits::char_type, _Traits, _Alloc> _Convert_wide_to_narrow(
; 61   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 62   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);
; 63   : 
; 64   :     if (!_Input.empty()) {

	test	rdi, rdi
	je	SHORT $LN2049@Convert

; 65   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rdi, 2147483647				; 7fffffffH
	ja	$LN2359@Convert

; 67   :         }
; 68   : 
; 69   :         const int _Len = _Check_convert_result(

	mov	DWORD PTR [rsp+32], ecx
	xor	r9d, r9d
	mov	r8d, edi
	mov	rdx, r12
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax
	mov	QWORD PTR $T14[rsp], rax
	shr	rax, 32					; 00000020H

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	test	eax, eax
	jne	$LN2360@Convert

; 72   :         _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	lea	rcx, QWORD PTR $T36[rsp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR $T36[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T36[rsp+24], 16
	cmovae	r9, QWORD PTR $T36[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 76   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, edi
	mov	rdx, r12
	mov	ecx, DWORD PTR $T19[rsp]
	call	__std_fs_convert_wide_to_narrow
	mov	QWORD PTR $T13[rsp], rax
	shr	rax, 32					; 00000020H

; 52   :     if (_Result._Err != __std_win_error::_Success) {

	test	eax, eax
	jne	$LN2361@Convert
$LN2049@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 152  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	btr	esi, 9

; 934  :             return string<char>();

	or	esi, 448				; 000001c0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 169  : 		std::vector<unsigned char> TmpBytes = ZStdFile::Decompress(DirEntry.path().string(), ZStdFile::Dictionary::Base).Data;

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T36[rsp]
	lea	rcx, QWORD PTR $T57[rbp-256]
	call	?Decompress@ZStdFile@@YA?AUResult@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Dictionary@1@@Z ; ZStdFile::Decompress
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rax+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r8d, r8d
	mov	QWORD PTR [rax+16], r8

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rax+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+8], r8

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rbx, QWORD PTR [rax]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR TmpBytes$60[rbp-256], rbx
	mov	QWORD PTR TmpBytes$60[rbp-248], rcx
	mov	QWORD PTR TmpBytes$60[rbp-240], rdx
	lea	rcx, QWORD PTR $T57[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	edi, BYTE PTR [rbx+34]
	shl	edi, 8
	movzx	eax, BYTE PTR [rbx+33]
	or	edi, eax
	shl	edi, 8
	movzx	eax, BYTE PTR [rbx+35]
	shl	eax, 24
	or	edi, eax
	movzx	eax, BYTE PTR [rbx+32]
	or	edi, eax
	movzx	r12d, BYTE PTR [rbx+38]
	shl	r12d, 8
	movzx	eax, BYTE PTR [rbx+37]
	or	r12d, eax
	shl	r12d, 8
	movzx	eax, BYTE PTR [rbx+39]
	shl	eax, 24
	or	r12d, eax
	movzx	eax, BYTE PTR [rbx+36]
	or	r12d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 174  : 		std::cout << "TemplateSize: " << TemplateTableSize0 << "; " << TemplateTableSize1 << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0P@CGKJOGGN@TemplateSize?3?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, edi
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_02LNAEAIDO@?$DL?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, r12d
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 175  : 		if (TemplateTableSize0 == TableSize0 && TemplateTableSize1 == TableSize1)

	cmp	edi, r15d
	jne	SHORT $LN23@Convert
	cmp	r12d, r14d
	je	SHORT $LN2362@Convert
$LN23@Convert:

; 179  : 		}
; 180  : 	}

	lea	rcx, QWORD PTR TmpBytes$60[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
$LN6@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2898 :             const auto _Error = _Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl);

	lea	rcx, QWORD PTR <begin>$L0$63[rbp-256]
	call	?_Advance_and_reset_if_no_more_files@_Recursive_dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AEAV?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@3@@Z ; std::filesystem::_Recursive_dir_enum_impl::_Advance_and_reset_if_no_more_files

; 2899 :             if (_Error != __std_win_error::_Success) {

	test	eax, eax
	jne	$LN2355@Convert
	jmp	$LL1644@Convert
$LN2362@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 177  : 			Path = DirEntry.path().string();

	lea	rdx, QWORD PTR $T51[rbp-256]
	mov	rcx, r13
	call	?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
	mov	rdx, rax
	lea	rcx, QWORD PTR Path$[rbp-256]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T51[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 178  : 			break;

	lea	rcx, QWORD PTR TmpBytes$60[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1
$LN7@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2867 :         ~recursive_directory_iterator() noexcept                                   = default;

	lea	rcx, QWORD PTR <end>$L0$64[rbp-256]
	call	??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
	npad	1
	lea	rcx, QWORD PTR <begin>$L0$63[rbp-256]
	call	??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
	npad	1
	lea	rcx, QWORD PTR $S8$62[rbp-256]
	call	??1?$shared_ptr@U_Recursive_dir_enum_impl@filesystem@std@@@std@@QEAA@XZ ; std::shared_ptr<std::filesystem::_Recursive_dir_enum_impl>::~shared_ptr<std::filesystem::_Recursive_dir_enum_impl>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 182  : 	if (Path.length() == 0) //Is this case even possible? - Theoretically yes, practically probably not

	cmp	QWORD PTR Path$[rbp-240], 0
	jne	$LN24@Convert

; 184  : 		Logger::Error("PhiveShapeGenerator", "Could not find valid template file");

	lea	rax, QWORD PTR $T35[rsp]
	mov	QWORD PTR $T17[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T35[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r13d, r13d
	mov	QWORD PTR $T35[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T35[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+34]
	lea	rdx, OFFSET FLAT:??_C@_0CD@IBBBDOEO@Could?5not?5find?5valid?5template?5f@
	lea	rcx, QWORD PTR $T35[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T56[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T56[rbp-240], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T56[rbp-232], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r13+19]
	lea	rdx, OFFSET FLAT:??_C@_0BE@LPONMC@PhiveShapeGenerator@
	lea	rcx, QWORD PTR $T56[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 184  : 		Logger::Error("PhiveShapeGenerator", "Could not find valid template file");

	lea	rdx, QWORD PTR $T35[rsp]
	lea	rcx, QWORD PTR $T56[rbp-256]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	rdi, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-256]
	mov	QWORD PTR [rdi], r13
	mov	QWORD PTR [rdi+8], r13
	mov	QWORD PTR [rdi+16], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Path$[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rdx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	test	rdx, rdx
	je	SHORT $LN1834@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR MaterialColFlagsNum$[rbp-240]
	sub	r8, rdx
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR MaterialColFlagsNum$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR MaterialColFlagsNum$[rbp-240], r13
$LN1834@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rdx, QWORD PTR MaterialArray$[rbp-256]
	test	rdx, rdx
	je	SHORT $LN1829@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR MaterialArray$[rbp-240]
	sub	r8, rdx
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR MaterialArray$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR MaterialArray$[rbp-240], r13
$LN1829@Convert:
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 185  : 		return std::vector<unsigned char>();

	mov	rcx, QWORD PTR Bytes$GSCopy$1$[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	rax, rdi
	jmp	$LN1@Convert
$LN24@Convert:

; 186  : 	}
; 187  : 
; 188  : 	std::cout << "FOUND\n";

	lea	rdx, OFFSET FLAT:??_C@_06LNACHKFI@FOUND?6@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR TemplateBytes$[rbp-256], xmm0
	mov	QWORD PTR TemplateBytes$[rbp-240], rax

; 189  : 
; 190  : 	std::vector<unsigned char> TemplateBytes = ZStdFile::Decompress(Path, ZStdFile::Dictionary::Base).Data;

	lea	rdx, QWORD PTR Path$[rbp-256]
	lea	rcx, QWORD PTR $T34[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR $T55[rbp-256]
	call	?Decompress@ZStdFile@@YA?AUResult@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Dictionary@1@@Z ; ZStdFile::Decompress
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rax+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r13d, r13d
	mov	QWORD PTR [rax+16], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rax+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+8], r13

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rax]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR TemplateBytes$[rbp-256], rcx
	mov	QWORD PTR TemplateBytes$[rbp-248], rdx
	mov	QWORD PTR TemplateBytes$[rbp-240], r8
	lea	rcx, QWORD PTR $T55[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 6    : BinaryVectorReader::BinaryVectorReader(std::vector<unsigned char>& Bytes, bool BigEndian) : m_Bytes(Bytes) {}

	lea	rax, QWORD PTR TemplateBytes$[rbp-256]
	mov	QWORD PTR TemplateReader$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.h

; 39   : 	int m_Offset = -1;

	mov	r14, -1
	mov	DWORD PTR TemplateReader$[rbp-248], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r12, QWORD PTR Bytes$GSCopy$1$[rbp-256]
	mov	rcx, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	esi, BYTE PTR [rcx+90]
	shl	esi, 8
	movzx	eax, BYTE PTR [rcx+89]
	or	esi, eax
	shl	esi, 8
	movzx	eax, BYTE PTR [rcx+91]
	shl	eax, 24
	or	esi, eax
	movzx	eax, BYTE PTR [rcx+88]
	or	esi, eax
	mov	DWORD PTR HavokTagFileSize$1$[rsp], esi

; 12   : 		this->m_Offset = Offset - 1;

	lea	ebx, QWORD PTR [r13+79]
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR HavokTagFile$[rbp-256], xmm1
	mov	QWORD PTR HavokTagFile$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 197  : 	HavokTagFile.resize(HavokTagFileSize);

	mov	edi, esi
	mov	edx, esi
	lea	rcx, QWORD PTR HavokTagFile$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	test	esi, esi
	jle	SHORT $LN1755@Convert
	mov	rdx, QWORD PTR HavokTagFile$[rbp-256]
	npad	9
$LL1756@Convert:

; 37   : 		this->m_Offset++;

	movsxd	rcx, ebx
	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [rdx], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	lea	rdx, QWORD PTR [rdx+1]
	sub	rdi, 1
	jne	SHORT $LL1756@Convert
$LN1755@Convert:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR HavokTagFileWriter$[rbp-240], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR HavokTagFileWriter$[rbp-256], xmm1
	mov	QWORD PTR HavokTagFileWriter$[rbp-240], r13
	mov	DWORD PTR HavokTagFileWriter$[rbp-232], r13d

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR HavokTagFile$[rbp-248]
	mov	rdi, QWORD PTR HavokTagFile$[rbp-256]
	sub	rsi, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
	test	esi, esi
	je	SHORT $LN1741@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	mov	rdx, rbx
	lea	rcx, QWORD PTR HavokTagFileWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1741@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN2670@Convert
	npad	2
$LL1740@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	r8d, BYTE PTR [r9+rdi]
	mov	ecx, DWORD PTR HavokTagFileWriter$[rbp-232]
	add	ecx, r10d
	movsxd	rdx, ecx
	mov	rax, QWORD PTR HavokTagFileWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], r8b

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	inc	r10d
	inc	r9
	cmp	r9, rbx
	jl	SHORT $LL1740@Convert
$LN2670@Convert:

; 78   : 	this->m_Offset += Size;

	add	DWORD PTR HavokTagFileWriter$[rbp-232], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	edi, BYTE PTR [rdx+226]
	shl	edi, 8
	movzx	eax, BYTE PTR [rdx+225]
	or	edi, eax
	shl	edi, 8
	movzx	eax, BYTE PTR [rdx+227]
	shl	eax, 24
	or	edi, eax
	movzx	eax, BYTE PTR [rdx+224]
	or	edi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 205  : 	GeometrySectionOffset += Reader.GetPosition();

	add	edi, 224				; 000000e0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	ecx, BYTE PTR [rdx+230]
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+229]
	or	ecx, eax
	shl	ecx, 8
	movzx	eax, BYTE PTR [rdx+231]
	shl	eax, 24
	or	ecx, eax
	movzx	eax, BYTE PTR [rdx+228]
	or	ecx, eax

; 12   : 		this->m_Offset = Offset - 1;

	lea	eax, DWORD PTR [rdi-1]
	mov	DWORD PTR Reader$[rbp-248], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 208  : 	for (int i = 0; i < GeometrySectionCount; i++)

	jbe	$LN10@Convert
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 78   : 	this->m_Offset += Size;

	lea	ebx, DWORD PTR [rdi-84]
	lea	r14d, DWORD PTR [rdi-4]
	lea	r15d, DWORD PTR [rdi-3]
	lea	r13d, DWORD PTR [rdi-2]
	lea	esi, DWORD PTR [rdi-80]
	add	edi, -83				; ffffffffffffffadH
	mov	edx, ecx
	mov	QWORD PTR tv17315[rsp], rdx
	npad	11
$LL11@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	movsxd	rcx, eax
	mov	DWORD PTR tv17406[rsp], ecx
	add	ebx, 24
	add	edi, 24
	add	esi, 24
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	mov	r9, rcx

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rdx, r13d
	movsxd	rcx, r15d
	movsxd	rax, r14d
	movzx	edx, BYTE PTR [rdx+r8+24]
	mov	BYTE PTR tv19979[rsp], dl
	movzx	ecx, BYTE PTR [rcx+r8+24]
	mov	BYTE PTR tv19978[rsp], cl
	movzx	ecx, BYTE PTR [r9+r8+24]
	mov	BYTE PTR tv19977[rsp], cl
	movzx	eax, BYTE PTR [rax+r8+24]
	mov	BYTE PTR tv19976[rsp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR HavokTagFileWriter$[rbp-248]
	mov	rcx, rdx
	mov	r8, QWORD PTR HavokTagFileWriter$[rbp-256]
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN1327@Convert

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	movsxd	rdx, edi
	lea	rcx, QWORD PTR HavokTagFileWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR HavokTagFileWriter$[rbp-248]
	mov	r8, QWORD PTR HavokTagFileWriter$[rbp-256]
$LN1327@Convert:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR HavokTagFileWriter$[rbp-232], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rax, esi
	cmp	rax, rdx
	jbe	SHORT $LN1343@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR HavokTagFileWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN1343@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	movzx	edx, BYTE PTR tv19977[rsp]
	shl	rdx, 8
	movzx	ecx, BYTE PTR tv19979[rsp]
	or	rdx, rcx
	shl	rdx, 8
	movzx	ecx, BYTE PTR tv19978[rsp]
	or	rdx, rcx
	shl	rdx, 8
	movzx	ecx, BYTE PTR tv19976[rsp]
	or	rdx, rcx
	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rdx, QWORD PTR [rax+rax]
	mov	edx, edx
	mov	QWORD PTR [r8], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR HavokTagFileWriter$[rbp-232]
	mov	rax, QWORD PTR HavokTagFileWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR HavokTagFileWriter$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR HavokTagFileWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR HavokTagFileWriter$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR HavokTagFileWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR HavokTagFileWriter$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR HavokTagFileWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR HavokTagFileWriter$[rbp-232], 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	mov	eax, DWORD PTR tv17406[rsp]
	add	eax, 64					; 00000040H
	add	ebx, 40					; 00000028H
	add	edi, 40					; 00000028H
	add	esi, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 208  : 	for (int i = 0; i < GeometrySectionCount; i++)

	sub	QWORD PTR tv17315[rsp], 1
	mov	DWORD PTR Reader$[rbp-248], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	lea	r13d, DWORD PTR [r13+64]
	lea	r15d, DWORD PTR [r15+64]
	lea	r14d, DWORD PTR [r14+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 208  : 	for (int i = 0; i < GeometrySectionCount; i++)

	jne	$LL11@Convert
	xor	r13d, r13d
	lea	r14, QWORD PTR [r13-1]
$LN10@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR HavokTagFileWriter$[rbp-248]
	mov	rdx, QWORD PTR HavokTagFileWriter$[rbp-256]
	sub	r8, rdx
	lea	rcx, QWORD PTR HavokTagFile$[rbp-256]
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	rax, rdx
	sub	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	cmp	rax, 80					; 00000050H
	jae	SHORT $LN1367@Convert

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	mov	edx, 81					; 00000051H
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-248]
$LN1367@Convert:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], 80		; 00000050H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR HavokTagFile$[rbp-248]
	mov	rdi, QWORD PTR HavokTagFile$[rbp-256]
	sub	rsi, rdi
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
	lea	eax, DWORD PTR [rsi+80]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN2617@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN2617@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN2671@Convert
	npad	9
$LL1384@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	r8d, BYTE PTR [r9+rdi]
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, r10d
	movsxd	rdx, ecx
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], r8b

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	inc	r10d
	inc	r9
	cmp	r9, rbx
	jl	SHORT $LL1384@Convert
$LN2671@Convert:

; 78   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], esi
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T33[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T33[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T33[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04KDPJLEDB@TYPE@
	lea	rcx, QWORD PTR $T33[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 221  : 	TemplateReader.Seek(FindSection(TemplateReader, "TYPE") - 8, BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR TemplateReader$[rbp-256]
	movdqa	XMMWORD PTR $T50[rbp-256], xmm0
	lea	rdx, QWORD PTR $T33[rsp]
	lea	rcx, QWORD PTR $T50[rbp-256]
	call	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	lea	ebx, DWORD PTR [rax-9]
	mov	DWORD PTR TemplateReader$[rbp-248], ebx
	lea	edi, DWORD PTR [rbx+1]
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR PhiveData$[rbp-256], xmm0
	mov	QWORD PTR PhiveData$[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR TemplateBytes$[rbp-248]
	sub	rdx, QWORD PTR TemplateBytes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 223  : 	std::vector<unsigned char> PhiveData(TemplateReader.GetSize() - TemplateReader.GetPosition());

	sub	edx, ebx
	dec	edx
	lea	rcx, QWORD PTR PhiveData$[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@_KAEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR PhiveData$[rbp-248]
	mov	r8, QWORD PTR PhiveData$[rbp-256]
	sub	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 78   : 	this->m_Offset += Size;

	mov	rdx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	movsxd	r9, eax
	test	eax, eax
	jle	SHORT $LN1427@Convert
	npad	6
$LL1428@Convert:

; 37   : 		this->m_Offset++;

	movsxd	rcx, ebx
	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR TemplateBytes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [rdx+r8], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	inc	rdx
	cmp	rdx, r9
	jl	SHORT $LL1428@Convert

; 37   : 		this->m_Offset++;

	mov	DWORD PTR TemplateReader$[rbp-248], ebx
$LN1427@Convert:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T32[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T32[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T32[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04BCAEOPJE@INDX@
	lea	rcx, QWORD PTR $T32[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 226  : 	TemplateReader.Seek(FindSection(TemplateReader, "INDX") - 8, BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR TemplateReader$[rbp-256]
	movdqa	XMMWORD PTR $T49[rbp-256], xmm0
	lea	rdx, QWORD PTR $T32[rsp]
	lea	rcx, QWORD PTR $T49[rbp-256]
	call	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	sub	eax, 9
	mov	DWORD PTR TemplateReader$[rbp-248], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 227  : 	uint32_t PhiveSize = TemplateReader.GetPosition() - TypeOffset;

	sub	eax, edi
	lea	edx, DWORD PTR [rax+1]

; 228  : 	PhiveData.resize(PhiveSize);

	lea	rcx, QWORD PTR PhiveData$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR PhiveData$[rbp-248]
	mov	rdi, QWORD PTR PhiveData$[rbp-256]
	sub	rsi, rdi
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, esi
	cdqe
	cmp	rax, rdx
	jbe	SHORT $LN2618@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN2618@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN2672@Convert
	npad	11
$LL1467@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	r8d, BYTE PTR [r9+rdi]
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, r10d
	movsxd	rdx, ecx
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], r8b

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	inc	r10d
	inc	r9
	cmp	r9, rbx
	jl	SHORT $LL1467@Convert
$LN2672@Convert:

; 78   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], esi
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T31[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T31[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T31[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04BCAEOPJE@INDX@
	lea	rcx, QWORD PTR $T31[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 232  : 	Reader.Seek(FindSection(Reader, "INDX") - 6, BinaryVectorReader::Position::Begin);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-256]
	movdqa	XMMWORD PTR $T48[rbp-256], xmm0
	lea	rdx, QWORD PTR $T31[rsp]
	lea	rcx, QWORD PTR $T48[rbp-256]
	call	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	lea	ebx, DWORD PTR [rax-5]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 56   : 	this->m_Offset += 2;

	movsxd	r8, ebx

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rcx, ebx
	movzx	r9d, BYTE PTR [r8+rdx]
	shl	r9w, 8
	movzx	ecx, BYTE PTR [rcx+rdx-1]
	or	r9w, cx
	ror	r9w, 8
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR ItemSection$[rbp-256], xmm1
	mov	QWORD PTR ItemSection$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 235  : 	ItemSection.resize(ItemSectionSize);

	movzx	edx, r9w
	lea	rcx, QWORD PTR ItemSection$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	add	ebx, -4
	mov	DWORD PTR Reader$[rbp-248], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR ItemSection$[rbp-248]
	mov	r8, QWORD PTR ItemSection$[rbp-256]
	sub	rax, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rdx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	movsxd	r9, eax
	test	eax, eax
	jle	SHORT $LN1528@Convert
	npad	4
$LL1529@Convert:

; 37   : 		this->m_Offset++;

	movsxd	rcx, ebx
	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [rdx+r8], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	inc	rdx
	cmp	rdx, r9
	jl	SHORT $LL1529@Convert

; 37   : 		this->m_Offset++;

	mov	DWORD PTR Reader$[rbp-248], ebx
$LN1528@Convert:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T30[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T30[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T30[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04IABOEAHL@TST1@
	lea	rcx, QWORD PTR $T30[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 239  : 	Reader.Seek(FindSection(Reader, "TST1") - 8, BinaryVectorReader::Position::Begin); //-8 = Magic(4) + Size(3) + Flags(1)

	movaps	xmm0, XMMWORD PTR Reader$[rbp-256]
	movdqa	XMMWORD PTR $T47[rbp-256], xmm0
	lea	rdx, QWORD PTR $T30[rsp]
	lea	rcx, QWORD PTR $T47[rbp-256]
	call	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	sub	eax, 9
	mov	DWORD PTR Reader$[rbp-248], eax
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR TagStringTable$[rbp-256], xmm1
	mov	QWORD PTR TagStringTable$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 241  : 	ReadStringTable(Reader, &TagStringTable);

	movaps	xmm0, XMMWORD PTR Reader$[rbp-256]
	movdqa	XMMWORD PTR $T46[rbp-256], xmm0
	lea	rdx, QWORD PTR TagStringTable$[rbp-256]
	lea	rcx, QWORD PTR $T46[rbp-256]
	call	?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SplatoonShapeToTotK::ReadStringTable
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T29[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T29[rsp+16], r13

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T29[rsp+24], r13

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04IABOEAHL@TST1@
	lea	rcx, QWORD PTR $T29[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 243  : 	TemplateReader.Seek(FindSection(TemplateReader, "TST1") - 8, BinaryVectorReader::Position::Begin); //-8 = Magic(4) + Size(3) + Flags(1)

	movaps	xmm0, XMMWORD PTR TemplateReader$[rbp-256]
	movdqa	XMMWORD PTR $T45[rbp-256], xmm0
	lea	rdx, QWORD PTR $T29[rsp]
	lea	rcx, QWORD PTR $T45[rbp-256]
	call	?FindSection@SplatoonShapeToTotK@@YAIVBinaryVectorReader@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SplatoonShapeToTotK::FindSection
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	sub	eax, 9
	mov	DWORD PTR TemplateReader$[rbp-248], eax
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR TemplateTagStringTable$[rbp-256], xmm1
	mov	QWORD PTR TemplateTagStringTable$[rbp-240], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 245  : 	ReadStringTable(TemplateReader, &TemplateTagStringTable);

	movaps	xmm0, XMMWORD PTR TemplateReader$[rbp-256]
	movdqa	XMMWORD PTR $T44[rbp-256], xmm0
	lea	rdx, QWORD PTR TemplateTagStringTable$[rbp-256]
	lea	rcx, QWORD PTR $T44[rbp-256]
	call	?ReadStringTable@SplatoonShapeToTotK@@YAXVBinaryVectorReader@@PEAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; SplatoonShapeToTotK::ReadStringTable
	xorps	xmm0, xmm0
	movups	XMMWORD PTR ItemWriter$[rbp-240], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR ItemWriter$[rbp-256], xmm1
	mov	QWORD PTR ItemWriter$[rbp-240], r13
	mov	DWORD PTR ItemWriter$[rbp-232], r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 250  : 	ItemWriter.WriteRawUnsafeFixed(reinterpret_cast<const char*>(ItemSection.data()), 28);

	mov	rbx, QWORD PTR ItemSection$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	mov	edx, 28
	lea	rcx, QWORD PTR ItemWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR ItemWriter$[rbp-232]
	movzx	ecx, BYTE PTR [rbx]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+1]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+2]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 3
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+3]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 4
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+4]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 5
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+5]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 6
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+6]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 7
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+7]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 8
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+8]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 9
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+9]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 10
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+10]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 11
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+11]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 12
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+12]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 13
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+13]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 14
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+14]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 15
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+15]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 16
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+16]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 17
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+17]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 18
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+18]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 19
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+19]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 20
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+20]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 21
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+21]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 22
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+22]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 23
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+23]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 24
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+24]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 25
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+25]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 26
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [rbx+26]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [rbx+27]
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 27
	movsxd	rcx, eax
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 78   : 	this->m_Offset += Size;

	add	DWORD PTR ItemWriter$[rbp-232], 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	mov	r10d, 27
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR ItemSection$[rbp-248]
	mov	r9, QWORD PTR ItemSection$[rbp-256]
	sub	rcx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 252  : 	uint16_t ItemNodeCount = (ItemSection.size() - 28) / 12;

	add	rcx, -28
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mul	rcx
	shr	rdx, 3

; 253  : 	for (int i = 0; i < ItemNodeCount; i++)

	mov	DWORD PTR i$1$[rsp], r13d
	movzx	eax, dx
	mov	DWORD PTR $T39[rsp], eax
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	test	eax, eax
	je	$LN13@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r13d, 24
	mov	DWORD PTR tv17310[rsp], r13d
	mov	DWORD PTR tv17291[rbp-256], 25
	mov	r12d, 26
$LN2686@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	mov	r11d, 22
	movsxd	rdx, r10d
	movsxd	r8, r12d

; 56   : 	this->m_Offset += 2;

	lea	eax, DWORD PTR [r10+4]
	mov	DWORD PTR tv17249[rbp-256], eax
	lea	r10d, DWORD PTR [r12+4]
	mov	DWORD PTR tv17250[rbp-256], r10d

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movsxd	rcx, eax
	movsxd	rax, r10d
	movzx	ecx, BYTE PTR [rcx+r9]
	mov	BYTE PTR tv19895[rsp], cl
	movzx	eax, BYTE PTR [rax+r9]
	mov	BYTE PTR tv19894[rsp], al
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 257  : 		std::string Name = TagStringTable[NameIndex];

	movzx	ebx, BYTE PTR [rdx+r9+2]
	shl	rbx, 8
	movzx	eax, BYTE PTR [r8+r9+2]
	or	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rbx, 5
	add	rbx, QWORD PTR TagStringTable$[rbp-256]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Name$54[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r12d, r12d
	mov	QWORD PTR Name$54[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR Name$54[rbp-232], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN930@Convert

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN930@Convert:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r15
	ja	$LN2364@Convert

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN936@Convert

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR Name$54[rbp-240], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, 15
	mov	QWORD PTR Name$54[rbp-232], rax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR Name$54[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN952@Convert
$LN936@Convert:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	QWORD PTR Name$54[rbp-232], 15

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN947@Convert

; 4716 :             return _Max;

	mov	rdi, r15
	jmp	SHORT $LN946@Convert
$LN947@Convert:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r11
$LN946@Convert:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r14
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR Name$54[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR Name$54[rbp-240], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR Name$54[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR Name$54[rbp-232]
	mov	rsi, QWORD PTR Name$54[rbp-240]
$LN952@Convert:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Name$54[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rax, 16
	cmovae	rdx, QWORD PTR Name$54[rbp-256]

; 5187 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	r8, rsi
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 258  : 		std::cout << Name << std::endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR NewName$59[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR NewName$59[rbp-240], r12

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR NewName$59[rbp-232], r12

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR Name$54[rbp-240]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR Name$54[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rax, QWORD PTR Name$54[rbp-256]
	mov	rdx, QWORD PTR Name$54[rbp-232]
	cmp	rdx, 16
	cmovae	r14, rax

; 2620 :         if (_Count > max_size()) {

	cmp	rdi, r15
	ja	$LN2365@Convert

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rdi, 16
	jae	SHORT $LN1240@Convert

; 2629 :             _My_data._Mysize = _Count;

	mov	r15, rdi
	mov	QWORD PTR NewName$59[rbp-240], rdi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebx, 15
	mov	QWORD PTR NewName$59[rbp-232], rbx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR NewName$59[rbp-256], xmm0

; 2647 :             return;

	movq	rsi, xmm0
	jmp	SHORT $LN1256@Convert
$LN1240@Convert:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, rdi
	or	rbx, 15
	cmp	rbx, r15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1251@Convert

; 4716 :             return _Max;

	mov	rbx, r15
	jmp	SHORT $LN1250@Convert
$LN1251@Convert:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN1250@Convert:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	rsi, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR NewName$59[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	r15, rdi
	mov	QWORD PTR NewName$59[rbp-240], rdi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR NewName$59[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rdi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	rdx, QWORD PTR Name$54[rbp-232]
	mov	rdi, QWORD PTR Name$54[rbp-240]
	mov	rax, QWORD PTR Name$54[rbp-256]
$LN1256@Convert:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR Name$54[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rcx, rax

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	rdi, 8
	jne	SHORT $LN25@Convert

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??_C@_08BEEKCOCE@hkFloat3@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN25@Convert

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+11]
	lea	rdx, OFFSET FLAT:??_C@_0BE@KEMPPACH@hknpShapeType?3?3Enum@
	lea	rcx, QWORD PTR NewName$59[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rbx, QWORD PTR NewName$59[rbp-232]
	mov	r15, QWORD PTR NewName$59[rbp-240]
	mov	rsi, QWORD PTR NewName$59[rbp-256]
$LN25@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 263  : 		uint16_t NewNameIndex = 0;

	mov	WORD PTR NewNameIndex$1$[rsp], r12w

; 264  : 		for (int j = 0; j < TemplateTagStringTable.size(); j++)

	mov	edi, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r14, QWORD PTR TemplateTagStringTable$[rbp-248]
	mov	r12, QWORD PTR TemplateTagStringTable$[rbp-256]
	sub	r14, r12
	sar	r14, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 264  : 		for (int j = 0; j < TemplateTagStringTable.size(); j++)

	test	r14, r14
	je	SHORT $LN16@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	xor	ecx, ecx
	mov	eax, ecx
	cmp	rbx, 16
	setae	r13b
	npad	11
$LL17@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rax, 5
	add	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR NewName$59[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	test	r13b, r13b
	cmovne	rdx, rsi

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rax+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN259@Convert

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rax]
$LN259@Convert:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r15
	jne	SHORT $LN265@Convert

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	rcx, rax
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN2363@Convert
$LN265@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 264  : 		for (int j = 0; j < TemplateTagStringTable.size(); j++)

	inc	edi
	movsxd	rax, edi
	cmp	rax, r14
	jb	SHORT $LL17@Convert
	movzx	edi, WORD PTR NewNameIndex$1$[rsp]
$LN2363@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13d, DWORD PTR tv17310[rsp]
$LN16@Convert:
	mov	rdx, QWORD PTR ItemWriter$[rbp-248]
	sub	rdx, QWORD PTR ItemWriter$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 2
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN239@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR ItemWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN239@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	movzx	r8d, di
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR ItemWriter$[rbp-232]
	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	movzx	r8d, BYTE PTR [rax+1]
	mov	ecx, DWORD PTR ItemWriter$[rbp-232]
	inc	ecx
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, rax
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 2
	mov	DWORD PTR ItemWriter$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR ItemWriter$[rbp-248]
	sub	rdx, QWORD PTR ItemWriter$[rbp-256]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN225@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR ItemWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN225@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	movzx	r8d, BYTE PTR tv19895[rsp]
	shl	r8, 8
	movzx	ecx, BYTE PTR tv19894[rsp]
	or	r8, rcx
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR ItemWriter$[rbp-232]
	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	movzx	r8d, BYTE PTR [rax+1]
	mov	ecx, DWORD PTR ItemWriter$[rbp-232]
	inc	ecx
	movsxd	rdx, ecx
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], r8b

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r10d, DWORD PTR ItemWriter$[rbp-232]
	add	r10d, 2
	mov	DWORD PTR ItemWriter$[rbp-232], r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	mov	r15d, DWORD PTR tv17291[rbp-256]
	add	r15d, 8
	add	r13d, 8

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rdi, DWORD PTR tv17249[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR ItemSection$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r12, DWORD PTR tv17250[rbp-256]
	movsxd	rdx, r15d
	movsxd	rax, r13d
	movzx	r14d, BYTE PTR [r12+r8+4]
	movzx	ecx, BYTE PTR [rdx+r8]
	mov	BYTE PTR tv19880[rsp], cl
	movzx	ecx, BYTE PTR [rdi+r8+4]
	mov	BYTE PTR tv19879[rsp], cl
	movzx	eax, BYTE PTR [rax+r8]
	mov	BYTE PTR tv19876[rsp], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR ItemWriter$[rbp-248]
	sub	rdx, QWORD PTR ItemWriter$[rbp-256]
	lea	eax, DWORD PTR [r10+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN191@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR ItemWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN191@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	movzx	edx, BYTE PTR tv19879[rsp]
	shl	rdx, 8
	or	rdx, r14
	shl	rdx, 8
	movzx	ecx, BYTE PTR tv19880[rsp]
	or	rdx, rcx
	shl	rdx, 8
	movzx	ecx, BYTE PTR tv19876[rsp]
	or	rdx, rcx
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR ItemWriter$[rbp-232]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r14d, DWORD PTR ItemWriter$[rbp-232]
	add	r14d, 4
	mov	DWORD PTR ItemWriter$[rbp-232], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 76   : 	this->m_Offset += 4;

	lea	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR ItemReader$$sroa$10260$1$[rbp-256], eax
	add	r12d, 8
	add	r15d, 4
	mov	DWORD PTR tv17291[rbp-256], r15d
	add	r13d, 4
	mov	DWORD PTR tv17310[rsp], r13d

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR ItemSection$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rcx, r12d
	movsxd	rax, r15d
	movsxd	r8, r13d
	movzx	edi, BYTE PTR [rcx+rdx]
	shl	edi, 8
	movzx	eax, BYTE PTR [rax+rdx]
	or	edi, eax
	shl	edi, 8
	movzx	eax, BYTE PTR [r9+rdx]
	shl	eax, 24
	or	edi, eax
	movzx	eax, BYTE PTR [r8+rdx]
	or	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR Name$54[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Name$54[rbp-232], 16
	cmovae	rcx, QWORD PTR Name$54[rbp-256]

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	QWORD PTR Name$54[rbp-240], 8
	jne	SHORT $LN29@Convert

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8d, 8
	lea	rdx, OFFSET FLAT:??_C@_08BEEKCOCE@hkFloat3@
	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	jne	SHORT $LN29@Convert
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 278  : 		ItemWriter.WriteInteger(Name == "hkFloat3" ? ItemCount * 6 : ItemCount, sizeof(uint32_t));

	lea	edi, DWORD PTR [rdi+rdi*2]
	add	edi, edi
$LN29@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR ItemWriter$[rbp-248]
	sub	rdx, QWORD PTR ItemWriter$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	lea	eax, DWORD PTR [r14+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN157@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR ItemWriter$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN157@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8d, edi
	mov	QWORD PTR [rax], r8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR ItemWriter$[rbp-232]
	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR ItemWriter$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR ItemWriter$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR ItemWriter$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR ItemWriter$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR ItemWriter$[rbp-232], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rbx, 16
	jb	SHORT $LN136@Convert

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rsi

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN148@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rsi, QWORD PTR [rsi-8]
	sub	rax, rsi

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN145@Convert
$LN148@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN136@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Name$54[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN106@Convert

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Name$54[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN118@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN115@Convert
$LN118@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN106@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 253  : 	for (int i = 0; i < ItemNodeCount; i++)

	mov	r11d, DWORD PTR i$1$[rsp]
	inc	r11d
	mov	DWORD PTR i$1$[rsp], r11d
	cmp	r11d, DWORD PTR $T39[rsp]
	jge	SHORT $LN2683@Convert
	mov	r9, QWORD PTR ItemSection$[rbp-256]
	mov	r10d, DWORD PTR ItemReader$$sroa$10260$1$[rbp-256]
	mov	r15, 9223372036854775807		; 7fffffffffffffffH
	mov	r14, -1
	jmp	$LN2686@Convert
$LN145@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN115@Convert:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2683@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 253  : 	for (int i = 0; i < ItemNodeCount; i++)

	mov	r12, QWORD PTR Bytes$GSCopy$1$[rbp-256]
	xor	r13d, r13d
$LN13@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR ItemWriter$[rbp-248]
	mov	rdx, QWORD PTR ItemWriter$[rbp-256]
	sub	r8, rdx
	lea	rcx, QWORD PTR ItemSection$[rbp-256]
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR ItemSection$[rbp-248]
	mov	rdi, QWORD PTR ItemSection$[rbp-256]
	sub	rsi, rdi
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
	mov	r8d, DWORD PTR Writer$[rbp-232]
	lea	eax, DWORD PTR [r8+rsi]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN2619@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN2619@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN975@Convert
	npad	10
$LL976@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	edx, BYTE PTR [r9+rdi]
	lea	eax, DWORD PTR [r8+r10]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	lea	r10d, DWORD PTR [r10+1]
	inc	r9
	mov	r8d, DWORD PTR Writer$[rbp-232]
	cmp	r9, rbx
	jl	SHORT $LL976@Convert
$LN975@Convert:

; 78   : 	this->m_Offset += Size;

	add	r8d, esi
	mov	DWORD PTR Writer$[rbp-232], r8d
	mov	eax, r8d
	and	eax, -2147483633			; ffffffff8000000fH
	jge	SHORT $LN2625@Convert
	dec	eax
	or	eax, -16
	inc	eax
$LN2625@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 285  : 	while (Writer.GetPosition() % 16 != 0)

	test	eax, eax
	je	SHORT $LN2674@Convert
	npad	1
$LL18@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rbp-232]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], 0

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
	mov	eax, r8d
	and	eax, -2147483633			; ffffffff8000000fH
	jge	SHORT $LN2624@Convert
	dec	eax
	or	eax, -16
	inc	eax
$LN2624@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 285  : 	while (Writer.GetPosition() % 16 != 0)

	test	eax, eax
	jne	SHORT $LL18@Convert
$LN2674@Convert:

; 286  : 		Writer.WriteByte(0x0);
; 287  : 
; 288  : 	uint32_t NewTable0Offset = Writer.GetPosition();

	mov	r15d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR MaterialArray$[rbp-248]
	mov	rdi, QWORD PTR MaterialArray$[rbp-256]
	sub	rsi, rdi
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	lea	eax, DWORD PTR [rsi+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN2620@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN2620@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN909@Convert
	npad	14
$LL910@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	edx, BYTE PTR [r9+rdi]
	lea	eax, DWORD PTR [r8+r10]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	lea	r10d, DWORD PTR [r10+1]
	inc	r9
	mov	r8d, DWORD PTR Writer$[rbp-232]
	cmp	r9, rbx
	jl	SHORT $LL910@Convert
$LN909@Convert:

; 78   : 	this->m_Offset += Size;

	add	r8d, esi
	mov	DWORD PTR Writer$[rbp-232], r8d
	mov	r14d, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rsi, QWORD PTR MaterialColFlagsNum$[rbp-248]
	mov	rdi, QWORD PTR MaterialColFlagsNum$[rbp-256]
	sub	rsi, rdi
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rbx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	lea	eax, DWORD PTR [rsi+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 70   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN2621@Convert

; 72   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, rbx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN2621@Convert:

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	mov	r10d, r13d
	mov	r9, r13
	test	esi, esi
	jle	SHORT $LN895@Convert
	npad	1
$LL896@Convert:

; 75   : 	{
; 76   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movzx	edx, BYTE PTR [r9+rdi]
	lea	eax, DWORD PTR [r8+r10]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 73   : 	}
; 74   : 	for (int i = 0; i < Size; i++)

	lea	r10d, DWORD PTR [r10+1]
	inc	r9
	mov	r8d, DWORD PTR Writer$[rbp-232]
	cmp	r9, rbx
	jl	SHORT $LL896@Convert
$LN895@Convert:

; 78   : 	this->m_Offset += Size;

	lea	ebx, DWORD PTR [r8+rsi]

; 26   : 		this->m_Offset = Offset;

	mov	eax, r13d
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	cmp	rdx, 5
	jae	SHORT $LN870@Convert

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 5
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	eax, DWORD PTR Writer$[rbp-232]
$LN870@Convert:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
	lea	r8, OFFSET FLAT:??_C@_05OFCJFJKO@Phive@+1
	npad	11
$LL869@Convert:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+3]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 5
	lea	r8, QWORD PTR [r8+5]
	cmp	r9d, 5
	jb	SHORT $LL869@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 1

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 255			; 000000ffH

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 254			; 000000feH

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 4

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN814@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN814@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 48			; 00000030H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], 48			; 00000030H
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN800@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN800@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8, r15
	mov	QWORD PTR [rax], r15

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN786@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN786@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	r8, r14
	mov	QWORD PTR [rax], r14

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], r8b
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN772@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN772@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	esi, ebx
	mov	QWORD PTR [rax], rsi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], sil
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	add	r8d, 4
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR MaterialColFlagsNum$[rbp-248]
	sub	rdx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	mov	rcx, QWORD PTR MaterialArray$[rbp-248]
	sub	rcx, QWORD PTR MaterialArray$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 308  : 	Writer.WriteInteger(FileSize - 0x30 - MaterialArray.size() - MaterialColFlagsNum.size(), sizeof(uint32_t));

	lea	edi, DWORD PTR [rbx-48]
	sub	rdi, rcx
	sub	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN754@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN754@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], dil
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR MaterialArray$[rbp-248]
	sub	rdi, QWORD PTR MaterialArray$[rbp-256]
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN738@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN738@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], dil
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdi, QWORD PTR MaterialColFlagsNum$[rbp-248]
	sub	rdi, QWORD PTR MaterialColFlagsNum$[rbp-256]
	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN722@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN722@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], dil
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN708@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN708@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r13

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], 0
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 4
	mov	DWORD PTR Writer$[rbp-232], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN694@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN694@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r13

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], 0
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	edi, DWORD PTR Writer$[rbp-232]
	add	edi, 4
	mov	DWORD PTR Writer$[rbp-232], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR MaterialColFlagsNum$[rbp-248]
	sub	rcx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	mov	rax, QWORD PTR MaterialArray$[rbp-248]
	sub	rax, QWORD PTR MaterialArray$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 314  : 	Writer.WriteInteger(_byteswap_ulong(FileSize - 0x30 - MaterialArray.size() - MaterialColFlagsNum.size() - 4), 4);

	sub	ebx, ecx
	sub	ebx, eax
	sub	ebx, 52					; 00000034H
	bswap	ebx
	mov	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN676@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN676@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], bl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	rcx, rdx
	mov	r8, QWORD PTR Writer$[rbp-256]
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, edi
	cmp	rax, rcx
	jbe	SHORT $LN660@Convert

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rdi+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	r8, QWORD PTR Writer$[rbp-256]
$LN660@Convert:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-248]
	mov	rdx, r9
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN612@Convert

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+4]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-248]
$LN612@Convert:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 3
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, QWORD PTR Writer$[rbp-256]
	movsxd	rax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, r9
	jbe	SHORT $LN643@Convert

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [r9+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN643@Convert:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r10d, r13d
	lea	r9, OFFSET FLAT:??_C@_04HNHFPDAH@TAG0@+1
	npad	9
$LL642@Convert:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, r8d
	movzx	ecx, BYTE PTR [r9-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r9+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r10d, 4
	lea	r9, QWORD PTR [r9+4]
	cmp	r10d, 4
	jb	SHORT $LL642@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 16

; 14   : 	this->m_Offset++;

	mov	ebx, DWORD PTR Writer$[rbp-232]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-232], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	movsxd	rax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN592@Convert

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
$LN592@Convert:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
	lea	r8, OFFSET FLAT:??_C@_04MCDGOKGA@SDKV@+1
	npad	9
$LL591@Convert:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ebx, DWORD PTR Writer$[rbp-232]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-232], ebx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL591@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	sub	rdx, QWORD PTR Writer$[rbp-256]
	movsxd	rax, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 8
	cmp	rax, rdx
	jbe	SHORT $LN580@Convert

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 8
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	ebx, DWORD PTR Writer$[rbp-232]
$LN580@Convert:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, r13d
	lea	r8, OFFSET FLAT:??_C@_08PICJLGIE@20220100@+1
	npad	9
$LL579@Convert:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, ebx
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+3]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+4]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+5]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+6]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	ebx, DWORD PTR Writer$[rbp-232]
	inc	ebx
	mov	DWORD PTR Writer$[rbp-232], ebx

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 8
	lea	r8, QWORD PTR [r8+8]
	cmp	r9d, 8
	jb	$LL579@Convert
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 326  : 	Writer.WriteInteger(_byteswap_ulong(HavokTagFileSize + 8), 4);

	mov	edi, DWORD PTR HavokTagFileSize$1$[rsp]
	add	edi, 8
	bswap	edi
	mov	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rbp-248]
	sub	r8, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [rbx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rdx, eax
	cmp	rdx, r8
	jbe	SHORT $LN566@Convert

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN566@Convert:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r9, rax

; 89   : 
; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rbp-232]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rcx], dil
	mov	ecx, DWORD PTR Writer$[rbp-232]
	inc	ecx
	movsxd	r8, ecx
	movzx	edx, BYTE PTR [rax+1]
	mov	rcx, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [r8+rcx], dl
	mov	ecx, DWORD PTR Writer$[rbp-232]
	add	ecx, 2
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rax+2]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r9+3]
	mov	eax, DWORD PTR Writer$[rbp-232]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r9
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rbp-232], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	rcx, rdx
	mov	r8, QWORD PTR Writer$[rbp-256]
	sub	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 22   : 		if (Offset > this->m_Data.size())

	movsxd	rax, ebx
	cmp	rax, rcx
	jbe	SHORT $LN550@Convert

; 23   : 		{
; 24   : 			this->m_Data.resize(Offset + 1);

	lea	eax, DWORD PTR [rbx+1]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	rdx, QWORD PTR Writer$[rbp-248]
	mov	r8, QWORD PTR Writer$[rbp-256]
$LN550@Convert:

; 25   : 		}
; 26   : 		this->m_Offset = Offset;

	mov	DWORD PTR Writer$[rbp-232], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rbp-232]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 64			; 00000040H

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR Writer$[rbp-248]
	mov	rdx, r9
	sub	rdx, QWORD PTR Writer$[rbp-256]
	lea	eax, DWORD PTR [r8+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN532@Convert

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+4]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
	mov	r9, QWORD PTR Writer$[rbp-248]
$LN532@Convert:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 3
	mov	DWORD PTR Writer$[rbp-232], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r9, QWORD PTR Writer$[rbp-256]
	movsxd	rax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	add	rax, 4
	cmp	rax, r9
	jbe	SHORT $LN518@Convert

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [r9+4]
	lea	rcx, QWORD PTR Writer$[rbp-256]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rbp-232]
$LN518@Convert:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r10d, r13d
	lea	r9, OFFSET FLAT:??_C@_04DFNBDBBL@DATA@+1
$LL517@Convert:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, r8d
	movzx	ecx, BYTE PTR [r9-1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r9+1]
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rbp-232]
	inc	eax
	mov	DWORD PTR Writer$[rbp-232], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r9+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rbp-256]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rbp-232]
	inc	r8d
	mov	DWORD PTR Writer$[rbp-232], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r10d, 4
	lea	r9, QWORD PTR [r9+4]
	cmp	r10d, 4
	jb	SHORT $LL517@Convert
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Data$[rbp-256], xmm1
	mov	QWORD PTR Data$[rbp-240], r13

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rbx, QWORD PTR Writer$[rbp-248]
	sub	rbx, QWORD PTR Writer$[rbp-256]

; 2065 :         if (_Count != 0) {

	je	$LN2642@Convert

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbx, rax
	ja	$LN2689@Convert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN469@Convert

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN2690@Convert

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN478@Convert

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	r14, QWORD PTR [rax+39]
	and	r14, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r14-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN467@Convert
$LN478@Convert:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN469@Convert:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
$LN467@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Data$[rbp-256], r14

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR Data$[rbp-248], r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rbx]
	mov	QWORD PTR Data$[rbp-240], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rbx, QWORD PTR Writer$[rbp-256]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rdi, QWORD PTR Writer$[rbp-248]
	mov	r8, rdi
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbx
	mov	rcx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	sub	rdi, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR Data$[rbp-248], rdi

; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     template <class... _Valty>
; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {
; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	jmp	SHORT $LN509@Convert
$LN2642@Convert:
	mov	rdi, QWORD PTR Data$[rbp-248]
$LN509@Convert:

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, rdi
	mov	rcx, QWORD PTR Data$[rbp-256]
	sub	rdx, rcx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rsi, rdx
	jae	SHORT $LN426@Convert

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rdi, QWORD PTR [rsi+rcx]

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN427@Convert
$LN426@Convert:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN427@Convert

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR Data$[rbp-240]
	sub	rax, rcx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rsi, rax
	jbe	SHORT $LN428@Convert

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rsi
	lea	rcx, QWORD PTR Data$[rbp-256]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	mov	rdi, QWORD PTR Data$[rbp-248]
	jmp	SHORT $LN2687@Convert
$LN428@Convert:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rsi
	xor	edx, edx
	mov	rcx, rdi
	call	memset

; 2036 :             return _First + _Count;

	add	rdi, rsi
$LN2687@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR Data$[rbp-256]
$LN427@Convert:
	mov	rax, QWORD PTR Data$[rbp-240]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR Data$[rbp-240], r13
	mov	QWORD PTR Data$[rbp-248], r13
	mov	QWORD PTR Data$[rbp-256], r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rsi, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-256]
	mov	QWORD PTR [rsi], rcx
	mov	QWORD PTR [rsi+8], rdi
	mov	QWORD PTR [rsi+16], rax

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR ItemWriter$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN361@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR ItemWriter$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN379@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN379@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN379@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR ItemWriter$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR ItemWriter$[rbp-240], r13
$LN361@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR TemplateTagStringTable$[rbp-256]
	test	rbx, rbx
	je	SHORT $LN317@Convert

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR TemplateTagStringTable$[rbp-248]
	cmp	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	je	SHORT $LN321@Convert
	npad	2
$LL322@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL322@Convert
	mov	rbx, QWORD PTR TemplateTagStringTable$[rbp-256]
$LN321@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR TemplateTagStringTable$[rbp-240]
	sub	rdx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN350@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN350@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN350@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR TemplateTagStringTable$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR TemplateTagStringTable$[rbp-240], r13
$LN317@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR TagStringTable$[rbp-256]
	test	rbx, rbx
	je	SHORT $LN276@Convert

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR TagStringTable$[rbp-248]
	cmp	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	je	SHORT $LN280@Convert
$LL281@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL281@Convert
	mov	rbx, QWORD PTR TagStringTable$[rbp-256]
$LN280@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR TagStringTable$[rbp-240]
	sub	rdx, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN309@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN309@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN309@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR TagStringTable$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR TagStringTable$[rbp-240], r13
$LN276@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rdx, QWORD PTR ItemSection$[rbp-256]
	test	rdx, rdx
	je	SHORT $LN1204@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR ItemSection$[rbp-240]
	sub	r8, rdx
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR ItemSection$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR ItemSection$[rbp-240], r13
$LN1204@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rdx, QWORD PTR PhiveData$[rbp-256]
	test	rdx, rdx
	je	SHORT $LN1199@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR PhiveData$[rbp-240]
	sub	r8, rdx
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate
	xorps	xmm0, xmm0

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR PhiveData$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR PhiveData$[rbp-240], r13
$LN1199@Convert:
	lea	rcx, QWORD PTR HavokTagFileWriter$[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR HavokTagFile$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1170@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR HavokTagFile$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1188@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1188@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1188@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR HavokTagFile$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR HavokTagFile$[rbp-240], r13
$LN1170@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR TemplateBytes$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1144@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR TemplateBytes$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1162@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1162@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1162@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR TemplateBytes$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR TemplateBytes$[rbp-240], r13
$LN1144@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Path$[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1124@Convert

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Path$[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1136@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1136@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1136@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN1124@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR MaterialColFlagsNum$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1089@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR MaterialColFlagsNum$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1107@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1107@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1107@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR MaterialColFlagsNum$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR MaterialColFlagsNum$[rbp-240], r13
$LN1089@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR MaterialArray$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1063@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR MaterialArray$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1081@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1081@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1081@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR MaterialArray$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR MaterialArray$[rbp-240], r13
$LN1063@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Writer$[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1034@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1052@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1052@Convert
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1052@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Writer$[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Writer$[rbp-240], r13
$LN1034@Convert:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r12]
	test	rcx, rcx
	je	SHORT $LN1005@Convert

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r12+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1023@Convert

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN1020@Convert

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN1023@Convert:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r12], r13

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r12+8], r13

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r12+16], r13
$LN1005@Convert:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SplatoonShapeToTotK.cpp

; 335  : 	return Data;

	mov	rax, rsi
$LN1@Convert:

; 336  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+872]
	add	rsp, 784				; 00000310H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1020@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN2690@Convert:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2355@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\filesystem

; 2900 :                 _Throw_fs_error("recursive_directory_iterator::operator++", _Error);

	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CJ@OMKENMFB@recursive_directory_iterator?3?3o@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN2613@Convert:

; 2383 :                 _Throw_fs_error("directory_entry::status", _Result._Error, _Path);

	lea	r8, QWORD PTR [rbx+32]
	lea	rcx, OFFSET FLAT:??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	npad	1
$LN2358@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\chrono

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	mov	ecx, DWORD PTR $T15[rsp+4]
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN2357@Convert:
	mov	ecx, DWORD PTR $T16[rsp+4]
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN2356@Convert:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	npad	1
$LN2361@Convert:

; 53   :         _Throw_system_error_from_std_win_error(_Result._Err);

	mov	ecx, DWORD PTR $T13[rsp+4]
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN2360@Convert:
	mov	ecx, DWORD PTR $T14[rsp+4]
	call	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
	int	3
$LN2359@Convert:

; 66   :             _Throw_system_error(errc::invalid_argument);

	call	?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
	npad	1
$LN2365@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2364@Convert:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN2689@Convert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN2685@Convert:
?Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z ENDP ; SplatoonShapeToTotK::Convert
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$0@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$1@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$1
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$1@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$2@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$2
	lea	rcx, QWORD PTR MaterialArray$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$2@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$3@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$3
	lea	rcx, QWORD PTR MaterialColFlagsNum$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$3@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$4@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$4
	lea	rcx, QWORD PTR Path$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$6@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$6
	lea	rcx, QWORD PTR $T61[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$7@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$7
	lea	rcx, QWORD PTR $T58[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$7@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$8@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$8
	lea	rcx, QWORD PTR $S8$62[rdx]
	jmp	??1recursive_directory_iterator@filesystem@std@@QEAA@XZ ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator
?dtor$8@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$10@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$10
	lea	rcx, QWORD PTR <begin>$L0$63[rdx]
	jmp	??1recursive_directory_iterator@filesystem@std@@QEAA@XZ ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator
?dtor$10@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$12@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$12
	lea	rcx, QWORD PTR <end>$L0$64[rdx]
	jmp	??1recursive_directory_iterator@filesystem@std@@QEAA@XZ ; std::filesystem::recursive_directory_iterator::~recursive_directory_iterator
?dtor$12@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$13@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$13
	lea	rcx, QWORD PTR $T37[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$13@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$82
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T41[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN1917@dtor$82
	and	DWORD PTR $T41[rbp], -33		; ffffffffffffffdfH
	lea	rcx, QWORD PTR $T52[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1917@dtor$82:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$82@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$82
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$90
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T41[rbp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN2021@dtor$90
	and	DWORD PTR $T41[rbp], -513		; fffffffffffffdffH
	mov	rcx, QWORD PTR $T40[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2021@dtor$90:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$90@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$90
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$17@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$17
	lea	rcx, QWORD PTR TmpBytes$60[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$17@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$19@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$19
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$24@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$24
	lea	rcx, QWORD PTR TemplateBytes$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$24@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$25@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$25
	lea	rcx, QWORD PTR HavokTagFile$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$25@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$26@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$26
	lea	rcx, QWORD PTR HavokTagFileWriter$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$26@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$28@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$28
	lea	rcx, QWORD PTR PhiveData$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$28@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$31@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$31
	lea	rcx, QWORD PTR ItemSection$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$31@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$33@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$33
	lea	rcx, QWORD PTR TagStringTable$[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$33@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$35@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$35
	lea	rcx, QWORD PTR TemplateTagStringTable$[rdx]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
?dtor$35@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$36@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$36
	lea	rcx, QWORD PTR ItemWriter$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$36@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$36
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$37@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$37
	lea	rcx, QWORD PTR Name$54[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$38@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$38
	lea	rcx, QWORD PTR NewName$59[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv19979 = 48
tv19894 = 48
tv19880 = 48
$T9 = 48
tv19977 = 49
tv19895 = 49
tv19879 = 49
$T10 = 49
NewNameIndex$1$ = 50
tv19978 = 50
tv19876 = 50
$T11 = 50
tv19976 = 52
$T12 = 52
HavokTagFileSize$1$ = 56
__$ReturnUdt$GSCopy$ = 56
$T13 = 56
$T14 = 56
$T15 = 56
$T16 = 56
$T17 = 56
$T18 = 56
$T19 = 64
$T20 = 64
i$1$ = 64
tv17406 = 64
$T21 = 68
$T22 = 69
$T23 = 70
$T24 = 71
$T25 = 72
$T26 = 73
$T27 = 74
$T28 = 75
$T29 = 80
$T30 = 80
$T31 = 80
$T32 = 80
$T33 = 80
$T34 = 80
$T35 = 80
$T36 = 80
$T37 = 80
$T38 = 80
$T39 = 112
tv17315 = 112
$T40 = 112
$T41 = 120
tv17310 = 124
ItemReader$$sroa$10260$1$ = 128
tv17250 = 128
_Result$42 = 144
TemplateReader$ = 144
tv17291 = 160
Reader$ = 176
$T43 = 192
$T44 = 192
$T45 = 192
$T46 = 192
$T47 = 192
$T48 = 192
$T49 = 192
$T50 = 192
$T51 = 192
tv17249 = 224
Bytes$GSCopy$1$ = 232
$T52 = 240
__$ReturnUdt$GSCopy$1$ = 272
$T53 = 288
Bytes$GSCopy$ = 304
Writer$ = 312
ItemWriter$ = 344
MaterialArray$ = 376
MaterialColFlagsNum$ = 400
Name$54 = 424
$T55 = 424
$T56 = 424
$T57 = 424
$T58 = 424
HavokTagFileWriter$ = 456
ItemSection$ = 488
Data$ = 512
NewName$59 = 536
TmpBytes$60 = 536
$T61 = 536
HavokTagFile$ = 568
TemplateTagStringTable$ = 592
TemplateBytes$ = 616
TagStringTable$ = 640
PhiveData$ = 664
$S8$62 = 688
<begin>$L0$63 = 704
Path$ = 720
<end>$L0$64 = 752
__$ArrayPad$ = 768
__$ReturnUdt$ = 848
Bytes$ = 856
PhiveMaterial$ = 864
?dtor$39@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA PROC ; `SplatoonShapeToTotK::Convert'::`1'::dtor$39
	lea	rcx, QWORD PTR Data$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$39@?0??Convert@SplatoonShapeToTotK@@YA?AV?$vector@EV?$allocator@E@std@@@std@@V23@UMaterialSettings@1@@Z@4HA ENDP ; `SplatoonShapeToTotK::Convert'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@PEBDV?$allocator@PEBD@std@@@std@@CAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ PROC ; std::vector<char const *,std::allocator<char const *> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@PEBDV?$allocator@PEBD@std@@@std@@AEAAXXZ ENDP ; std::vector<char const *,std::allocator<char const *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ PROC ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@PEBDV?$allocator@PEBD@std@@@std@@QEAA@XZ ENDP ; std::vector<char const *,std::allocator<char const *> >::~vector<char const *,std::allocator<char const *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z PROC	; std::allocator<char const *>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@PEBD@std@@QEAAPEAPEBD_K@Z ENDP	; std::allocator<char const *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 64
_Ilist$ = 72
_Al$dead$ = 80
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN47:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rbp, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rsi, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 657  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sub	rsi, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN34@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	ja	SHORT $LN45@vector

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rdx, rsi
	mov	QWORD PTR [rsp+80], rbx
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rsi
	mov	rcx, rbx
	mov	rdx, rbp
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [rsi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi+8], rcx
$LN34@vector:

; 658  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
; 659  :     }

	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN45@vector:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN43@vector:
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$initializer_list@E@1@AEBV?$allocator@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z PROC	; std::allocator<char const *>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@PEBD@std@@QEAAXQEAPEBD_K@Z ENDP	; std::allocator<char const *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\initializer_list
;	COMDAT ?end@?$initializer_list@E@std@@QEBAPEBEXZ
_TEXT	SEGMENT
this$ = 8
?end@?$initializer_list@E@std@@QEBAPEBEXZ PROC		; std::initializer_list<unsigned char>::end, COMDAT

; 42   :         return _Last;

	mov	rax, QWORD PTR [rcx+8]

; 43   :     }

	ret	0
?end@?$initializer_list@E@std@@QEBAPEBEXZ ENDP		; std::initializer_list<unsigned char>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z PROC		; std::to_address<char const * const>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@QEBD@std@@YAPEBQEBDQEBQEBD@Z ENDP		; std::to_address<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z PROC ; std::_Copy_memmove<char const * const *,char const * *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBQEBDPEAPEBD@std@@YAPEAPEBDPEBQEBD0PEAPEBD@Z ENDP ; std::_Copy_memmove<char const * const *,char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z PROC	; std::_To_address<char const * *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAPEBD@std@@YA?A_PAEBQEAPEBD@Z ENDP	; std::_To_address<char const * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const *,unsigned char const *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN39:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN35@Construct_
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rbx, r8
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN37@Construct_
	mov	QWORD PTR [rsp+40], rdi

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
$LN35@Construct_:
	ret	0
$LN37@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN34@Construct_:
??$_Construct_n@PEBEPEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEBE1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char const *,unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z PROC		; std::to_address<char const *>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@PEBD@std@@YAPEAPEBDQEAPEBD@Z ENDP		; std::to_address<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEBE@std@@YA$$QEAPEBEAEAPEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEBE@std@@YA$$QEAPEBEAEAPEBE@Z PROC		; std::forward<unsigned char const *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEBE@std@@YA$$QEAPEBEAEAPEBE@Z ENDP		; std::forward<unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_iter@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Unwrap_iter@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z PROC ; std::ranges::_Unwrap_iter<unsigned char const *,unsigned char const *>, COMDAT

; 2488 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2489 :         if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
; 2490 :             return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 2491 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2492 :             return static_cast<_Iter&&>(_It)._Unwrapped();
; 2493 :         } else {
; 2494 :             return static_cast<_Iter&&>(_It);
; 2495 :         }
; 2496 :     }

	ret	0
??$_Unwrap_iter@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z ENDP ; std::ranges::_Unwrap_iter<unsigned char const *,unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Unwrap_sent@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z
_TEXT	SEGMENT
_Se$ = 8
??$_Unwrap_sent@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z PROC ; std::ranges::_Unwrap_sent<unsigned char const *,unsigned char const *>, COMDAT

; 2501 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
; 2502 :         if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
; 2503 :             return _Se + 0;

	mov	rax, QWORD PTR [rcx]

; 2504 :         } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
; 2505 :             return static_cast<_Sent&&>(_Se)._Unwrapped();
; 2506 :         } else {
; 2507 :             return static_cast<_Sent&&>(_Se);
; 2508 :         }
; 2509 :     }

	ret	0
??$_Unwrap_sent@PEBEPEBE@ranges@std@@YA?A_T$$QEAPEBE@Z ENDP ; std::ranges::_Unwrap_sent<unsigned char const *,unsigned char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_copy<unsigned char const *,unsigned char const *,std::allocator<unsigned char> >, COMDAT

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN23:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1819 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1850 :             return _Dest;

	sub	rsi, rbx
	lea	rax, QWORD PTR [rdi+rsi]

; 1851 :         }
; 1852 :     }
; 1853 : 
; 1854 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1855 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1856 :         _Backout._Emplace_back(*_UFirst);
; 1857 :     }
; 1858 : 
; 1859 :     return _Backout._Release();
; 1860 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Uninitialized_copy@PEBEPEBEV?$allocator@E@std@@@std@@YAPEAEPEBE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_copy<unsigned char const *,unsigned char const *,std::allocator<unsigned char> >
_TEXT	ENDS
END
