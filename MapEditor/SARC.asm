; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04FHJOMFLP@SFAT@				; `string'
PUBLIC	??_C@_0M@MPMNFAIG@SarcDecoder@			; `string'
PUBLIC	??_C@_0BL@EAELOCFG@Wrong?5magic?0?5expected?5SARC@ ; `string'
PUBLIC	??_C@_04NBKKGELJ@SARC@				; `string'
PUBLIC	??_C@_04FMMCICIC@SFNT@				; `string'
EXTRN	__imp_isprint:PROC
;	COMDAT ??_C@_04FMMCICIC@SFNT@
CONST	SEGMENT
??_C@_04FMMCICIC@SFNT@ DB 'SFNT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBKKGELJ@SARC@
CONST	SEGMENT
??_C@_04NBKKGELJ@SARC@ DB 'SARC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EAELOCFG@Wrong?5magic?0?5expected?5SARC@
CONST	SEGMENT
??_C@_0BL@EAELOCFG@Wrong?5magic?0?5expected?5SARC@ DB 'Wrong magic, expec'
	DB	'ted SARC', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MPMNFAIG@SarcDecoder@
CONST	SEGMENT
??_C@_0M@MPMNFAIG@SarcDecoder@ DB 'SarcDecoder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHJOMFLP@SFAT@
CONST	SEGMENT
??_C@_04FHJOMFLP@SFAT@ DB 'SFAT', 00H			; `string'
PUBLIC	??0Entry@SarcFile@@QEAA@$$QEAU01@@Z		; SarcFile::Entry::Entry
PUBLIC	??$construct_at@UEntry@SarcFile@@U12@$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@$$QEAU12@@Z ; std::construct_at<SarcFile::Entry,SarcFile::Entry,0>
PUBLIC	??$to_address@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z ; std::to_address<SarcFile::HashValue>
PUBLIC	??$construct_at@UEntry@SarcFile@@$$V$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@@Z ; std::construct_at<SarcFile::Entry,0>
PUBLIC	??$construct@UEntry@SarcFile@@U12@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry,SarcFile::Entry>
PUBLIC	??$forward@UEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z ; std::forward<SarcFile::Entry>
PUBLIC	??$construct_at@UNode@SarcFile@@$$V$0A@@std@@YAPEAUNode@SarcFile@@QEAU12@@Z ; std::construct_at<SarcFile::Node,0>
PUBLIC	??$construct_at@UHashValue@SarcFile@@$$V$0A@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z ; std::construct_at<SarcFile::HashValue,0>
PUBLIC	??$forward@AEAPEAUHashValue@SarcFile@@@std@@YAAEAPEAUHashValue@SarcFile@@AEAPEAU12@@Z ; std::forward<SarcFile::HashValue * &>
PUBLIC	??$forward@UHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z ; std::forward<SarcFile::HashValue>
PUBLIC	??$_To_address@PEAUHashValue@SarcFile@@@std@@YA?A_PAEBQEAUHashValue@SarcFile@@@Z ; std::_To_address<SarcFile::HashValue *>
PUBLIC	??$_Copy_backward_memmove@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z ; std::_Copy_backward_memmove<SarcFile::HashValue *,SarcFile::HashValue *>
PUBLIC	??$construct@UEntry@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry>
PUBLIC	??$_Emplace_back@UEntry@SarcFile@@@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX$$QEAUEntry@SarcFile@@@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<SarcFile::Entry>
PUBLIC	??$move@AEAUEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z ; std::move<SarcFile::Entry &>
PUBLIC	??$construct@UNode@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UNode@SarcFile@@@1@QEAUNode@SarcFile@@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::construct<SarcFile::Node>
PUBLIC	??$_Unfancy@UNode@SarcFile@@@std@@YAPEAUNode@SarcFile@@PEAU12@@Z ; std::_Unfancy<SarcFile::Node>
PUBLIC	??$construct@UHashValue@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UHashValue@SarcFile@@@1@QEAUHashValue@SarcFile@@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::construct<SarcFile::HashValue>
PUBLIC	??$?0AEAPEAUHashValue@SarcFile@@AEAPEAU01@$0A@@?$pair@PEAUHashValue@SarcFile@@PEAU12@@std@@QEAA@AEAPEAUHashValue@SarcFile@@0@Z ; std::pair<SarcFile::HashValue *,SarcFile::HashValue *>::pair<SarcFile::HashValue *,SarcFile::HashValue *><SarcFile::HashValue * &,SarcFile::HashValue * &,0>
PUBLIC	??$swap@UHashValue@SarcFile@@$0A@@std@@YAXAEAUHashValue@SarcFile@@0@Z ; std::swap<SarcFile::HashValue,0>
PUBLIC	??$_Next_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ; std::_Next_iter<SarcFile::HashValue *>
PUBLIC	??$_Prev_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ; std::_Prev_iter<SarcFile::HashValue *>
PUBLIC	??$_Move_backward_unchecked@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z ; std::_Move_backward_unchecked<SarcFile::HashValue *,SarcFile::HashValue *>
PUBLIC	??$move@AEAUHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z ; std::move<SarcFile::HashValue &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_move<SarcFile::Entry *,std::allocator<SarcFile::Entry> >
PUBLIC	??$_Get_unwrapped@AEBQEAUEntry@SarcFile@@@std@@YA?A_TAEBQEAUEntry@SarcFile@@@Z ; std::_Get_unwrapped<SarcFile::Entry * const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Emplace_back<>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Emplace_back<>
PUBLIC	?capacity@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::capacity
PUBLIC	?_Calculate_growth@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBA_K_K@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Change_array
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@AEAV?$allocator@UHashValue@SarcFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::~_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAPEAUHashValue@SarcFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@PEAUNode@SarcFile@@AEAV?$allocator@UNode@SarcFile@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Node> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAPEAUNode@SarcFile@@XZ ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::__autoclassinit2
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Node> >
PUBLIC	??$forward@AEBV?$allocator@UNode@SarcFile@@@std@@@std@@YAAEBV?$allocator@UNode@SarcFile@@@0@AEBV10@@Z ; std::forward<std::allocator<SarcFile::Node> const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@_KAEAV?$allocator@UHashValue@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::HashValue> >
PUBLIC	??$forward@AEBV?$allocator@UHashValue@SarcFile@@@std@@@std@@YAAEBV?$allocator@UHashValue@SarcFile@@@0@AEBV10@@Z ; std::forward<std::allocator<SarcFile::HashValue> const &>
PUBLIC	??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char *,unsigned char *>
PUBLIC	??$_Unfancy@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ; std::_Unfancy<SarcFile::HashValue>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z ; std::allocator<SarcFile::Node>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UNode@SarcFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::max_size
PUBLIC	?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal
PUBLIC	?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z ; std::allocator<SarcFile::HashValue>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UHashValue@SarcFile@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::max_size
PUBLIC	?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal
PUBLIC	?max_size@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEBA_KXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::max_size
PUBLIC	?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength
PUBLIC	?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ; std::vector<char,std::allocator<char> >::_Buy_raw
PUBLIC	?max_size@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEBA_KXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::max_size
PUBLIC	?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
PUBLIC	??0?$allocator@UEntry@SarcFile@@@std@@QEAA@XZ	; std::allocator<SarcFile::Entry>::allocator<SarcFile::Entry>
PUBLIC	?_Orphan_range@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAXPEAUEntry@SarcFile@@0@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Orphan_range
PUBLIC	?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<SarcFile::Node> >::_Vector_val<std::_Simple_types<SarcFile::Node> >
PUBLIC	?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ; std::vector<char,std::allocator<char> >::_Buy_nonzero
PUBLIC	?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >::_Vector_val<std::_Simple_types<SarcFile::HashValue> >
PUBLIC	??1?$_Tidy_guard@V?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >::~_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >
PUBLIC	??1?$_Tidy_guard@V?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >::~_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >
PUBLIC	??$_Destroy_range@V?$allocator@UNode@SarcFile@@@std@@@std@@YAXPEAUNode@SarcFile@@QEAU12@AEAV?$allocator@UNode@SarcFile@@@0@@Z ; std::_Destroy_range<std::allocator<SarcFile::Node> >
PUBLIC	??$_Destroy_range@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAXPEAUHashValue@SarcFile@@QEAU12@AEAV?$allocator@UHashValue@SarcFile@@@0@@Z ; std::_Destroy_range<std::allocator<SarcFile::HashValue> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1><>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UNode@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UNode@SarcFile@@@1@@Z ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1><std::allocator<SarcFile::Node> const &>
PUBLIC	??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ; std::vector<char,std::allocator<char> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Construct_n<>
PUBLIC	??$?0AEBV?$allocator@UHashValue@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UHashValue@SarcFile@@@1@@Z ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1><std::allocator<SarcFile::HashValue> const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
PUBLIC	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEBAPEAUHashValue@SarcFile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Unwrapped
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > const &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z ; std::allocator<SarcFile::Node>::deallocate
PUBLIC	?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal
PUBLIC	?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z ; std::allocator<SarcFile::HashValue>::deallocate
PUBLIC	?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal
PUBLIC	?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Tidy
PUBLIC	?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Tidy
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
PUBLIC	??0?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >
PUBLIC	?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::resize
PUBLIC	?size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::size
PUBLIC	??A?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAAEAUEntry@SarcFile@@_K@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::operator[]
PUBLIC	??0?$allocator@UNode@SarcFile@@@std@@QEAA@XZ	; std::allocator<SarcFile::Node>::allocator<SarcFile::Node>
PUBLIC	??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::vector<SarcFile::Node,std::allocator<SarcFile::Node> >
PUBLIC	??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::~vector<SarcFile::Node,std::allocator<SarcFile::Node> >
PUBLIC	??A?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAAEAUNode@SarcFile@@_K@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::operator[]
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??0?$allocator@UHashValue@SarcFile@@@std@@QEAA@XZ ; std::allocator<SarcFile::HashValue>::allocator<SarcFile::HashValue>
PUBLIC	??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >
PUBLIC	??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::~vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >
PUBLIC	?begin@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
PUBLIC	?end@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::end
PUBLIC	??A?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAAEAUHashValue@SarcFile@@_K@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::operator[]
PUBLIC	?__autoclassinit2@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::__autoclassinit2
PUBLIC	??0HashValue@SarcFile@@QEAA@XZ			; SarcFile::HashValue::HashValue
PUBLIC	?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z	; AlignWriter
PUBLIC	?AlignUp@SarcFile@@AEAAHHH@Z			; SarcFile::AlignUp
PUBLIC	?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z ; SarcFile::GetBinaryFileAlignment
PUBLIC	?LCM@SarcFile@@AEAAHHH@Z			; SarcFile::LCM
PUBLIC	?GCD@SarcFile@@AEAAHHH@Z			; SarcFile::GCD
PUBLIC	??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z		; SarcFile::Entry::operator=
PUBLIC	?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z ; std::vector<char,std::allocator<char> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::__autoclassinit2
PUBLIC	??0Entry@SarcFile@@QEAA@XZ			; SarcFile::Entry::Entry
PUBLIC	?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SarcFile::HasEntry
PUBLIC	?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; SarcFile::GetEntry
PUBLIC	??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; SarcFile::SarcFile
PUBLIC	?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ; SarcFile::ToBinary
PUBLIC	?GetEntries@SarcFile@@QEAAAEAV?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@XZ ; SarcFile::GetEntries
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+71
	DD	imagerel $unwind$??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+219
	DD	imagerel $unwind$??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD imagerel $LN99
	DD	imagerel $LN99+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD imagerel $LN99+18
	DD	imagerel $LN99+141
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD imagerel $LN99+141
	DD	imagerel $LN99+146
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+374
	DD	imagerel $unwind$??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+119
	DD	imagerel $chain$1$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+119
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+130
	DD	imagerel $chain$2$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+275
	DD	imagerel $chain$1$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+275
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+277
	DD	imagerel $chain$2$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+25
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+25
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+160
	DD	imagerel $chain$0$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+160
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+174
	DD	imagerel $chain$1$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD imagerel $LN47+39
	DD	imagerel $LN47+116
	DD	imagerel $chain$0$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD imagerel $LN47+116
	DD	imagerel $LN47+197
	DD	imagerel $chain$1$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN83
	DD	imagerel $LN83+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN83+33
	DD	imagerel $LN83+142
	DD	imagerel $chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN83+142
	DD	imagerel $LN83+271
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN83+271
	DD	imagerel $LN83+277
	DD	imagerel $chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+64
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD imagerel $LN39+37
	DD	imagerel $LN39+91
	DD	imagerel $chain$0$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD imagerel $LN39+91
	DD	imagerel $LN39+98
	DD	imagerel $chain$1$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+997
	DD	imagerel $unwind$??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+135
	DD	imagerel $unwind$?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN35
	DD	imagerel $LN35+116
	DD	imagerel $unwind$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+135
	DD	imagerel $unwind$?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+141
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN41
	DD	imagerel $LN41+137
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+141
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+50
	DD	imagerel $LN28+123
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN28+123
	DD	imagerel $LN28+191
	DD	imagerel $chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83
	DD	imagerel $LN83+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+41
	DD	imagerel $LN83+202
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+202
	DD	imagerel $LN83+203
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+203
	DD	imagerel $LN83+209
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN83+209
	DD	imagerel $LN83+215
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN76
	DD	imagerel $LN76+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN76+40
	DD	imagerel $LN76+152
	DD	imagerel $chain$0$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN76+152
	DD	imagerel $LN76+153
	DD	imagerel $chain$1$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN76+153
	DD	imagerel $LN76+159
	DD	imagerel $chain$2$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN76+159
	DD	imagerel $LN76+165
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN84
	DD	imagerel $LN84+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN84+40
	DD	imagerel $LN84+223
	DD	imagerel $chain$3$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN84+223
	DD	imagerel $LN84+224
	DD	imagerel $chain$4$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN84+224
	DD	imagerel $LN84+230
	DD	imagerel $chain$5$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD imagerel $LN84+230
	DD	imagerel $LN84+236
	DD	imagerel $chain$6$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+61
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD imagerel $LN47+61
	DD	imagerel $LN47+101
	DD	imagerel $chain$0$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD imagerel $LN47+101
	DD	imagerel $LN47+127
	DD	imagerel $chain$1$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+34
	DD	imagerel $unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+50
	DD	imagerel $LN30+123
	DD	imagerel $chain$1$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD imagerel $LN30+123
	DD	imagerel $LN30+191
	DD	imagerel $chain$2$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z DD imagerel $LN84
	DD	imagerel $LN84+208
	DD	imagerel $unwind$??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z DD imagerel $LN81
	DD	imagerel $LN81+177
	DD	imagerel $unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z DD imagerel $LN87
	DD	imagerel $LN87+232
	DD	imagerel $unwind$??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z DD imagerel $LN30
	DD	imagerel $LN30+113
	DD	imagerel $unwind$?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN29
	DD	imagerel $LN29+116
	DD	imagerel $unwind$?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN20
	DD	imagerel $LN20+82
	DD	imagerel $unwind$??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN47
	DD	imagerel $LN47+141
	DD	imagerel $unwind$?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN49
	DD	imagerel $LN49+143
	DD	imagerel $unwind$?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD imagerel $LN891
	DD	imagerel $LN891+2427
	DD	imagerel $unwind$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD imagerel $LN1275
	DD	imagerel $LN1275+5240
	DD	imagerel $unwind$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB '"'
	DB	0b6H
	DB	02H
	DB	01H, 0cH
	DB	04H
	DB	0b5H, 03H
	DB	06H
	DB	'y', 03H
	DB	08H
	DB	091H, 02H
	DB	0aH
	DB	'U', 0fH
	DB	08H
	DB	019H, 04H
	DB	06H
	DB	0f5H, 08H
	DB	0cH
	DB	0f9H, 04H
	DB	06H
	DB	0fdH, 013H
	DB	04H
	DB	0f5H, 03H
	DB	00H
	DB	'@'
	DB	06H
	DB	0cH
	DB	02H
	DB	018H
	DB	04H
	DB	0cH
	DB	08H
	DB	018H
	DB	0aH
	DB	018H
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 0cH
	DB	0aH
	DD	imagerel ??1BinaryVectorWriter@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	0aaH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DB 028H
	DD	imagerel $stateUnwindMap$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	imagerel $ip2state$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ DD 0b2a19H
	DD	02c341cH
	DD	022011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
	DD	010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 01cH
	DB	0b1H, 03H
	DB	04H
	DB	09eH
	DB	08H
	DB	011H, 09H
	DB	0aH
	DB	0d5H, 03H
	DB	0cH
	DB	0baH
	DB	0eH
	DB	0a5H, 02H
	DB	0cH
	DB	0d9H, 03H
	DB	010H
	DB	019H, 03H
	DB	0cH
	DB	019H, 06H
	DB	04H
	DB	'T'
	DB	06H
	DB	' '
	DB	04H
	DB	0a4H
	DB	00H
	DB	'N'
	DB	08H
	DB	0cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 010H
	DB	0cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	0d0H
	DB	036H
	DD	imagerel ?dtor$1@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA
	DB	02cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	060H
	DB	05aH
	DD	imagerel ??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	032H
	DD	imagerel ??1Entry@SarcFile@@QEAA@XZ
	DB	01H
	DB	03H
	DB	06aH
	DD	imagerel ??1Entry@SarcFile@@QEAA@XZ
	DB	0e1H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	imagerel $ip2state$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z DD 0b2a19H
	DD	032341cH
	DD	028011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	0132H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z DD 081201H
	DD	0b5412H
	DD	0a3412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+50
	DD	imagerel $unwind$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+61
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD 020521H
	DD	077405H
	DD	imagerel $LN47
	DD	imagerel $LN47+61
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z DD 061001H
	DD	096410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	067400H
	DD	0c5400H
	DD	imagerel $LN84
	DD	imagerel $LN84+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 081d21H
	DD	04f41dH
	DD	05e418H
	DD	06740cH
	DD	0c5405H
	DD	imagerel $LN84
	DD	imagerel $LN84+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 030f01H
	DD	0600b620fH
	DD	0300aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 020021H
	DD	087400H
	DD	imagerel $LN76
	DD	imagerel $LN76+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN76
	DD	imagerel $LN76+40
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 041301H
	DD	093413H
	DD	0600f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 080021H
	DD	04f400H
	DD	057400H
	DD	065400H
	DD	0c3400H
	DD	imagerel $LN83
	DD	imagerel $LN83+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 081b21H
	DD	04f41bH
	DD	057416H
	DD	06540dH
	DD	0c3405H
	DD	imagerel $LN83
	DD	imagerel $LN83+41
	DD	imagerel $unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 031001H
	DD	0e00c6210H
	DD	0600aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+50
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 081001H
	DD	0113410H
	DD	0f00c7210H
	DD	07008e00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD 020521H
	DD	057405H
	DD	imagerel $LN39
	DD	imagerel $LN39+37
	DD	imagerel $unwind$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z DD 040d01H
	DD	0e009520dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020021H
	DD	0be400H
	DD	imagerel $LN83
	DD	imagerel $LN83+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 043821H
	DD	0be438H
	DD	0a5405H
	DD	imagerel $LN83
	DD	imagerel $LN83+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD 020521H
	DD	097405H
	DD	imagerel $LN47
	DD	imagerel $LN47+39
	DD	imagerel $unwind$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+25
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 020521H
	DD	093405H
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+25
	DD	imagerel $unwind$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040a01H
	DD	0a640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 041b21H
	DD	05641bH
	DD	043405H
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+30
	DD	imagerel $unwind$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 021H
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040a21H
	DD	0b740aH
	DD	0a6405H
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
	DD	imagerel ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z+33
	DD	imagerel $unwind$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040a01H
	DD	0c340aH
	DD	05006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN99
	DD	imagerel $LN99+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 040701H
	DD	063407H
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?GetEntries@SarcFile@@QEAAAEAV?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@XZ
_TEXT	SEGMENT
this$ = 8
?GetEntries@SarcFile@@QEAAAEAV?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@XZ PROC ; SarcFile::GetEntries, COMDAT

; 15   :     return this->m_Entries;

	lea	rax, QWORD PTR [rcx+8]

; 16   : }

	ret	0
?GetEntries@SarcFile@@QEAAAEAV?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@XZ ENDP ; SarcFile::GetEntries
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ
_TEXT	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ PROC ; SarcFile::ToBinary, COMDAT

; 200  : {

$LN1275:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-16]
	sub	rsp, 272				; 00000110H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	edi, edi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Writer$[rsp+16], xmm0
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Writer$[rsp], xmm1
	mov	QWORD PTR Writer$[rsp+16], rdi
	mov	DWORD PTR Writer$[rsp+24], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 24   : 			this->m_Data.resize(Offset + 1);

	lea	edx, QWORD PTR [rdi+21]
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 26   : 		this->m_Offset = Offset;

	mov	eax, 20
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13, QWORD PTR [rsi+16]
	sub	r13, QWORD PTR [rsi+8]
	sar	r13, 3
	mov	rcx, 7905747460161236407		; 6db6db6db6db6db7H
	imul	r13, rcx
	mov	QWORD PTR Count$1$[rsp], r13
	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	cmp	rdx, 24
	jae	SHORT $LN914@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	eax, DWORD PTR Writer$[rsp+24]
$LN914@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, edi
	lea	r8, OFFSET FLAT:??_C@_04FHJOMFLP@SFAT@+1
	npad	12
$LL913@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL913@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN900@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN900@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 12

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], 12
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN886@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN886@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], r13

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], r13b
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN872@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN872@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 101			; 00000065H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], 101			; 00000065H
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rsp+24], 4
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Keys$[rbp-256], xmm1
	mov	QWORD PTR Keys$[rbp-240], rdi

; 2065 :         if (_Count != 0) {

	test	r13, r13
	je	$LN1228@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	r13, rax
	ja	$LN1270@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	mov	rbx, r13
	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN973@ToBinary

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN1271@ToBinary

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN180@ToBinary

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rdx, QWORD PTR [rax+rbx]
	mov	r8, rax
	jmp	SHORT $LN1266@ToBinary
$LN973@ToBinary:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN974@ToBinary

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	lea	rdx, QWORD PTR [rax+rbx]
	mov	r8, rax
	jmp	SHORT $LN1266@ToBinary
$LN974@ToBinary:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rax, rdi
	lea	rdx, QWORD PTR [rdi+rbx]
	mov	r8, rdi
$LN1266@ToBinary:
	mov	rcx, r13
	mov	QWORD PTR Keys$[rbp-256], r8
	mov	QWORD PTR Keys$[rbp-240], rdx
	npad	7
$LL998@ToBinary:
	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi

; 1803 :         ++_Last;

	add	rax, 16

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rcx, 1
	jne	SHORT $LL998@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Keys$[rbp-248], rax

; 2065 :         if (_Count != 0) {

	jmp	SHORT $LN1015@ToBinary
$LN1228@ToBinary:
	mov	rax, QWORD PTR Keys$[rbp-248]
$LN1015@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 212  :     std::vector<SarcFile::HashValue> Keys(Count);

	mov	r11d, edi

; 213  :     for (int i = 0; i < Count; i++)

	test	r13, r13
	je	SHORT $LN3@ToBinary
	mov	rax, rdi
	mov	rbx, rdi
	npad	7
$LL4@ToBinary:
	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rsi+8]
	imul	rax, rax, 56				; 00000038H
	add	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 216  :         HashValue.Node = &this->m_Entries[i];

	mov	QWORD PTR HashValue$7[rsp+8], rax

; 217  :         int j = 0;

	xor	r8d, r8d
	lea	r9, QWORD PTR [rcx+rdi]

; 220  :             char c = this->m_Entries[i].Name[j++];

	mov	r10, QWORD PTR [r9+24]
$LN1267@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

	mov	DWORD PTR HashValue$7[rsp], edx
	mov	rax, r9

; 2227 :         if (_Large_string_engaged()) {

	cmp	r10, 16
	jb	SHORT $LN420@ToBinary

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [r9]
$LN420@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 220  :             char c = this->m_Entries[i].Name[j++];

	movsx	ecx, BYTE PTR [rax+r8]
	inc	r8

; 221  :             if (!c)

	test	cl, cl
	je	SHORT $LN1055@ToBinary

; 222  :                 break;
; 223  :             HashValue.Hash = HashValue.Hash * 0x65 + c;

	imul	edx, edx, 101				; 00000065H
	add	edx, ecx

; 224  :         }

	jmp	SHORT $LN1267@ToBinary
$LN1055@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Keys$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 225  :         Keys[i] = HashValue;

	movups	xmm0, XMMWORD PTR HashValue$7[rsp]
	movups	XMMWORD PTR [rax+rbx], xmm0

; 213  :     for (int i = 0; i < Count; i++)

	inc	r11d
	add	rdi, 56					; 00000038H
	add	rbx, 16
	movsxd	rax, r11d
	cmp	rax, r13
	jb	SHORT $LL4@ToBinary
	mov	rax, QWORD PTR Keys$[rbp-248]
	xor	edi, edi
$LN3@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	r8, rax
	mov	rcx, QWORD PTR Keys$[rbp-256]
	sub	r8, rcx
	sar	r8, 4
	movzx	r9d, BYTE PTR $T6[rsp]
	mov	rdx, rax
	call	??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 229  :     uint32_t RelStringOffset = 0;

	mov	DWORD PTR RelStringOffset$1$[rsp], edi

; 230  :     uint32_t RelDataOffset = 0;

	mov	DWORD PTR RelDataOffset$1$[rsp], edi
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Alignments$[rbp-256], xmm1
	mov	QWORD PTR Alignments$[rbp-240], rdi

; 2065 :         if (_Count != 0) {

	test	r13, r13
	je	SHORT $LN841@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	r13, rax
	ja	$LN1272@ToBinary

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r13
	call	?allocate@?$allocator@I@std@@QEAAPEAI_K@Z ; std::allocator<unsigned int>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Alignments$[rbp-256], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r13*4]
	lea	rbx, QWORD PTR [rax+r8]
	mov	QWORD PTR Alignments$[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Alignments$[rbp-248], rbx
$LN841@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 234  :     for (int i = 0; i < Count; i++)

	mov	DWORD PTR i$1$[rsp], edi
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	mov	rcx, -1
	lea	r8d, QWORD PTR [rcx+23]
	test	r13, r13
	je	$LN1231@ToBinary
	mov	r14, rdi
	mov	QWORD PTR tv7185[rsp], rdi
	mov	QWORD PTR tv7184[rsp], rdi
	npad	9
$LL9@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Keys$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 236  :         std::string FileName = Keys[i].Node->Name;

	mov	rbx, QWORD PTR [rax+r14+8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR FileName$11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR FileName$11[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR FileName$11[rbp-232], rdi

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r13, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN676@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN676@ToBinary:

; 2620 :         if (_Count > max_size()) {

	cmp	r13, rdx
	ja	$LN1056@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r13, 16
	jae	SHORT $LN682@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR FileName$11[rbp-240], r13

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	r15d, 15
	mov	QWORD PTR FileName$11[rbp-232], r15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR FileName$11[rbp-256], xmm0

; 2647 :             return;

	movq	r12, xmm0
	jmp	SHORT $LN698@ToBinary
$LN682@ToBinary:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	r15, r13
	or	r15, 15
	cmp	r15, rdx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN693@ToBinary

; 4716 :             return _Max;

	mov	r15, rdx
	jmp	SHORT $LN692@ToBinary
$LN693@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	r15, 22
	cmovb	r15, r8
$LN692@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, r15
	add	rdx, 1
	cmovb	rdx, rcx
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	r12, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR FileName$11[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR FileName$11[rbp-240], r13

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR FileName$11[rbp-232], r15

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r13+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy
	mov	rax, QWORD PTR Keys$[rbp-256]
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
$LN698@ToBinary:
	xorps	xmm0, xmm0
	xor	ecx, ecx
	movups	XMMWORD PTR Buffer$8[rbp-256], xmm0
	mov	QWORD PTR Buffer$8[rbp-240], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 237  :         std::vector<unsigned char> Buffer(Keys[i].Node->Bytes.begin(), Keys[i].Node->Bytes.end());

	mov	rbx, QWORD PTR [rax+r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rdi, QWORD PTR [rbx+40]
	mov	rbx, QWORD PTR [rbx+32]

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Buffer$8[rbp-256], xmm0
	mov	QWORD PTR Buffer$8[rbp-240], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rsi, rdi
	sub	rsi, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN1229@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rsi, rdx
	ja	$LN1057@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN489@ToBinary

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN1058@ToBinary

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN572@ToBinary

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	r14, QWORD PTR [rax+39]
	and	r14, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r14-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN487@ToBinary
$LN489@ToBinary:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
$LN487@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR Buffer$8[rbp-256], r14

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR Buffer$8[rbp-248], r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+r14]
	mov	QWORD PTR Buffer$8[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, r14
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	sub	rdi, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR Buffer$8[rbp-248], rdi

; 2065 :         if (_Count != 0) {

	mov	r14, QWORD PTR tv7185[rsp]
	jmp	SHORT $LN529@ToBinary
$LN1229@ToBinary:
	mov	rdi, QWORD PTR Buffer$8[rbp-248]
$LN529@ToBinary:
	xorps	xmm0, xmm0

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T10[rbp-256], xmm0
	mov	QWORD PTR $T10[rbp-240], 0

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	sub	rdi, QWORD PTR Buffer$8[rbp-256]

; 2065 :         if (_Count != 0) {

	je	$LN1230@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdi, rax
	ja	$LN1059@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN742@ToBinary

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN1060@ToBinary

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN751@ToBinary

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN740@ToBinary
$LN742@ToBinary:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
$LN740@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR $T10[rbp-256], rsi

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR $T10[rbp-248], rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rdi]
	mov	QWORD PTR $T10[rbp-240], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rbx, QWORD PTR Buffer$8[rbp-256]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rdi, QWORD PTR Buffer$8[rbp-248]
	mov	r8, rdi
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	sub	rdi, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR $T10[rbp-248], rdi

; 2065 :         if (_Count != 0) {

	jmp	SHORT $LN782@ToBinary
$LN1230@ToBinary:
	mov	rdi, QWORD PTR $T10[rbp-248]
$LN782@ToBinary:

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR $T10[rbp-256]
	sub	rdi, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 166  :     if (Data.size() <= 0x20)

	cmp	rdi, 32					; 00000020H
	ja	SHORT $LN786@ToBinary

; 167  :     {
; 168  :         return 1;

	mov	ebx, 1
	jmp	SHORT $LN1268@ToBinary
$LN786@ToBinary:

; 169  :     }
; 170  : 
; 171  :     if (Data[0] == 'A' && Data[1] == 'I' && Data[2] == 'B') //AINB has alignment 8

	cmp	BYTE PTR [rcx], 65			; 00000041H
	jne	SHORT $LN787@ToBinary
	cmp	BYTE PTR [rcx+1], 73			; 00000049H
	jne	SHORT $LN787@ToBinary
	cmp	BYTE PTR [rcx+2], 66			; 00000042H
	jne	SHORT $LN787@ToBinary

; 172  :         return 8;

	mov	ebx, 8
	jmp	SHORT $LN1268@ToBinary
$LN787@ToBinary:

; 173  : 
; 174  :     int32_t FileSize = *reinterpret_cast<const int32_t*>(&Data[0x1C]);
; 175  :     if (FileSize != static_cast<int32_t>(Data.size()))

	mov	ebx, 1
	cmp	DWORD PTR [rcx+28], edi
	jne	SHORT $LN1268@ToBinary

; 176  :     {
; 177  :         return 1;
; 178  :     }
; 179  : 
; 180  :     return 1 << Data[0x0E];

	movzx	ecx, BYTE PTR [rcx+14]
	shl	ebx, cl
$LN1268@ToBinary:

; 161  :     return a / GCD(a, b) * b;

	lea	rcx, QWORD PTR $T10[rbp-256]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	ecx, ebx
	mov	r8d, 4
	npad	6
$LL427@ToBinary:

; 149  :     while (a != 0 && b != 0)

	test	ecx, ecx
	je	SHORT $LN1217@ToBinary

; 150  :     {
; 151  :         if (a > b)

	cmp	r8d, ecx
	jle	$LN429@ToBinary

; 152  :             a %= b;

	mov	eax, r8d
	cdq
	idiv	ecx
	mov	r8d, edx

; 149  :     while (a != 0 && b != 0)

	test	edx, edx
	jne	SHORT $LL427@ToBinary
$LN1217@ToBinary:

; 155  :     }
; 156  :     return a | b;

	or	r8d, ecx

; 161  :     return a / GCD(a, b) * b;

	mov	eax, 4
	cdq
	idiv	r8d
	mov	ecx, eax
	imul	ecx, ebx

; 185  :     return Value + (Size - Value % Size) % Size;

	mov	r8d, DWORD PTR RelDataOffset$1$[rsp]
	mov	eax, r8d
	cdq
	idiv	ecx
	mov	eax, ecx
	sub	eax, edx
	cdq
	idiv	ecx
	lea	edi, DWORD PTR [r8+rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR Buffer$8[rbp-248]
	sub	rax, QWORD PTR Buffer$8[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 242  :         uint32_t DataEnd = DataStart + Buffer.size();

	add	eax, edi
	mov	DWORD PTR RelDataOffset$1$[rsp], eax

; 243  :         Alignments[i] = Alignment;

	mov	rax, QWORD PTR Alignments$[rbp-256]
	mov	rsi, QWORD PTR tv7184[rsp]
	mov	DWORD PTR [rax+rsi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Keys$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 245  :         Writer.WriteInteger(Keys[i].Hash, sizeof(uint32_t));

	mov	ebx, DWORD PTR [rax+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN444@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN444@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rbx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], bl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN458@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN458@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 246  :         Writer.WriteInteger((0x01000000 | (RelStringOffset / 4)), sizeof(int32_t)); //Placeholder

	mov	ebx, DWORD PTR RelStringOffset$1$[rsp]
	mov	edx, ebx
	bts	rdx, 26
	shr	rdx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN653@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN653@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, edi
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN536@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN536@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, DWORD PTR RelDataOffset$1$[rsp]
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rsp+24], 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 251  :         RelStringOffset += (FileName.length() + 4) & -4;

	lea	eax, DWORD PTR [r13+4]
	and	eax, -4					; fffffffcH
	add	ebx, eax
	mov	DWORD PTR RelStringOffset$1$[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Buffer$8[rbp-256]
	test	rcx, rcx
	je	SHORT $LN1264@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Buffer$8[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN575@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN572@ToBinary
$LN575@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Buffer$8[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	xor	edi, edi
	mov	QWORD PTR Buffer$8[rbp-240], rdi

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	jmp	SHORT $LN557@ToBinary
$LN429@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 154  :             b %= a;

	mov	eax, ecx
	cdq
	idiv	r8d
	mov	ecx, edx
	jmp	$LL427@ToBinary
$LN1264@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	xor	edi, edi
$LN557@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r15, 16
	jb	SHORT $LN592@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [r15+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r12

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN604@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r12, QWORD PTR [r12-8]
	sub	rax, r12

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN601@ToBinary
$LN604@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r12
	call	??3@YAXPEAX_K@Z				; operator delete
$LN592@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 234  :     for (int i = 0; i < Count; i++)

	mov	ecx, DWORD PTR i$1$[rsp]
	inc	ecx
	mov	DWORD PTR i$1$[rsp], ecx
	add	rsi, 4
	mov	QWORD PTR tv7184[rsp], rsi
	add	r14, 16
	mov	QWORD PTR tv7185[rsp], r14
	movsxd	rax, ecx
	mov	r13, QWORD PTR Count$1$[rsp]
	cmp	rax, r13
	jae	SHORT $LN1231@ToBinary
	mov	rcx, -1
	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	lea	r8d, QWORD PTR [rcx+23]
	jmp	$LL9@ToBinary
$LN751@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN572@ToBinary:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN601@ToBinary:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1231@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	movsxd	rax, DWORD PTR Writer$[rsp+24]
	add	rax, 4
	cmp	rax, rdx
	jbe	SHORT $LN613@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN613@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, edi
	lea	r8, OFFSET FLAT:??_C@_04FMMCICIC@SFNT@+1
	npad	12
$LL612@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, DWORD PTR Writer$[rsp+24]
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL612@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN625@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN625@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 8

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], 8
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN639@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 2
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN639@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], rdi

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], 0
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	r8d, DWORD PTR Writer$[rsp+24]
	add	r8d, 2
	mov	DWORD PTR Writer$[rsp+24], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 259  :     for (int i = 0; i < Count; i++)

	mov	r12d, edi
	test	r13, r13
	je	$LN1234@ToBinary
	mov	r15, rdi
	npad	15
$LL12@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Keys$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 261  :         std::string FileName = Keys[i].Node->Name;

	mov	rbx, QWORD PTR [rax+r15+8]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR FileName$9[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR FileName$9[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR FileName$9[rbp-232], rdi

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx+24], 16
	jb	SHORT $LN311@ToBinary

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN311@ToBinary:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	ja	$LN1061@ToBinary

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN317@ToBinary

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR FileName$9[rbp-240], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	edi, 15
	mov	QWORD PTR FileName$9[rbp-232], rdi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR FileName$9[rbp-256], xmm0

; 2647 :             return;

	movq	r14, xmm0
	jmp	SHORT $LN333@ToBinary
$LN317@ToBinary:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN328@ToBinary

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN327@ToBinary
$LN328@ToBinary:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN327@ToBinary:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	r14, rax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR FileName$9[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR FileName$9[rbp-240], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR FileName$9[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN333@ToBinary:

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR FileName$9[rbp-256]

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 16
	setae	sil

; 2236 :         if (_Large_string_engaged()) {

	cmovae	rbx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	mov	r11, -1
	mov	rcx, r11
$LL1226@ToBinary:
	inc	rcx
	cmp	BYTE PTR [rbx+rcx], 0
	jne	SHORT $LL1226@ToBinary
	movsxd	rax, r8d
	add	rax, rcx
	cmp	rax, rdx
	jbe	SHORT $LN363@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	add	rdx, rcx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rsp+24]
	mov	r11, -1
$LN363@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	xor	r9d, r9d
	mov	rax, r11
	npad	7
$LL1225@ToBinary:
	inc	rax
	cmp	BYTE PTR [rbx+rax], r9b
	jne	SHORT $LL1225@ToBinary
	test	rax, rax
	je	SHORT $LN1260@ToBinary
	mov	r10, rbx
$LL362@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r10]
	movsxd	rcx, r8d
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rsp+24]
	inc	r8d
	mov	DWORD PTR Writer$[rsp+24], r8d

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	inc	r9d
	lea	r10, QWORD PTR [r10+1]
	mov	rax, r11
$LL1224@ToBinary:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL1224@ToBinary
	movsxd	rcx, r9d
	cmp	rcx, rax
	jb	SHORT $LL362@ToBinary
$LN1260@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	mov	eax, r8d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1223@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1223@ToBinary:
	test	eax, eax
	je	SHORT $LN1215@ToBinary
	npad	3
$LL341@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN350@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+2]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN350@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	inc	r8d
	mov	DWORD PTR Writer$[rsp+24], r8d
	mov	eax, r8d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN1222@ToBinary
	dec	eax
	or	eax, -4
	inc	eax
$LN1222@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	test	eax, eax
	jne	SHORT $LL341@ToBinary
	jmp	SHORT $LN407@ToBinary
$LN1215@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [r8+4]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN406@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+5]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN406@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	add	r8d, 4
	mov	DWORD PTR Writer$[rsp+24], r8d
$LN407@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	test	sil, sil
	je	SHORT $LN383@ToBinary

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	rdx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r14

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN395@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r14, QWORD PTR [r14-8]
	sub	rax, r14

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN392@ToBinary
$LN395@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r14
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN383@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 259  :     for (int i = 0; i < Count; i++)

	inc	r12d
	add	r15, 16
	movsxd	rax, r12d
	xor	edi, edi
	cmp	rax, r13
	jb	$LL12@ToBinary
$LN1234@ToBinary:

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	mov	eax, r8d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN1221@ToBinary
	dec	eax
	or	eax, -8
	inc	eax
$LN1221@ToBinary:
	test	eax, eax
	je	SHORT $LN274@ToBinary
	npad	11
$LL273@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN282@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+2]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN282@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	inc	r8d
	mov	DWORD PTR Writer$[rsp+24], r8d
	mov	eax, r8d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN1220@ToBinary
	dec	eax
	or	eax, -8
	inc	eax
$LN1220@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	test	eax, eax
	jne	SHORT $LL273@ToBinary
$LN274@ToBinary:

; 262  :         Writer.WriteBytes(FileName.c_str());
; 263  :         if (!AlignWriter(&Writer, 4))
; 264  :         {
; 265  :             Writer.Seek(4, BinaryVectorWriter::Position::Current);
; 266  :         }
; 267  :     }
; 268  : 
; 269  :     AlignWriter(&Writer, 8);
; 270  : 
; 271  :     uint32_t DataOffset = Writer.GetPosition();

	mov	r13d, r8d
	mov	r14d, edi

; 272  :     for (int i = 0; i < Count; i++)

	cmp	QWORD PTR Count$1$[rsp], 0
	jbe	$LN14@ToBinary
	mov	r15, rdi
	mov	r12, rdi
$LL15@ToBinary:

; 273  :     {
; 274  :         AlignWriter(&Writer, Alignments[i]);

	mov	rax, QWORD PTR Alignments$[rbp-256]
	mov	ebx, DWORD PTR [rax+r12]

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	mov	eax, r8d
	cdq
	idiv	ebx
	test	edx, edx
	je	SHORT $LN76@ToBinary
	npad	13
$LL75@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
	cmp	rcx, rdx
	jb	SHORT $LN84@ToBinary

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+2]
	movsxd	rdx, eax
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	r8d, DWORD PTR Writer$[rsp+24]
$LN84@ToBinary:

; 33   : 		}
; 34   : 		this->m_Offset += Offset;

	inc	r8d
	mov	DWORD PTR Writer$[rsp+24], r8d
	mov	eax, r8d
	cdq
	idiv	ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	test	edx, edx
	jne	SHORT $LL75@ToBinary
$LN76@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Keys$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 276  :         for (unsigned char Byte : Keys[i].Node->Bytes)

	mov	rcx, QWORD PTR [rax+r15+8]
	mov	rsi, QWORD PTR [rcx+40]
	mov	rdi, QWORD PTR [rcx+32]
	cmp	rdi, rsi
	je	SHORT $LN13@ToBinary
	npad	12
$LL18@ToBinary:
	movzx	ebx, BYTE PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], bl

; 14   : 	this->m_Offset++;

	mov	r8d, DWORD PTR Writer$[rsp+24]
	inc	r8d
	mov	DWORD PTR Writer$[rsp+24], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 276  :         for (unsigned char Byte : Keys[i].Node->Bytes)

	inc	rdi
	cmp	rdi, rsi
	jne	SHORT $LL18@ToBinary
$LN13@ToBinary:

; 272  :     for (int i = 0; i < Count; i++)

	inc	r14d
	add	r12, 4
	add	r15, 16
	movsxd	rax, r14d
	cmp	rax, QWORD PTR Count$1$[rsp]
	jb	$LL15@ToBinary
	xor	edi, edi
$LN14@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbx, QWORD PTR Writer$[rsp+8]
	sub	rbx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 26   : 		this->m_Offset = Offset;

	mov	eax, edi
	mov	DWORD PTR Writer$[rsp+24], eax

; 44   : 	if (this->m_Offset + strlen(Bytes) > this->m_Data.size())

	cmp	rbx, 4
	jae	SHORT $LN47@ToBinary

; 45   : 	{
; 46   : 		this->m_Data.resize(this->m_Data.size() + strlen(Bytes));

	lea	rdx, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
	mov	eax, DWORD PTR Writer$[rsp+24]
$LN47@ToBinary:

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	mov	r9d, edi
	lea	r8, OFFSET FLAT:??_C@_04NBKKGELJ@SARC@+1
	npad	7
$LL46@ToBinary:

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8-1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 49   : 	{
; 50   : 		this->m_Data[this->m_Offset] = Bytes[i];

	movzx	edx, BYTE PTR [r8+2]
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 51   : 		this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax

; 47   : 	}
; 48   : 	for (int i = 0; i < strlen(Bytes); i++)

	add	r9d, 4
	lea	r8, QWORD PTR [r8+4]
	cmp	r9d, 4
	jb	SHORT $LL46@ToBinary
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 20

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 0

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 255			; 000000ffH

; 14   : 	this->m_Offset++;

	inc	DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 12   : 	this->m_Data.resize(this->m_Data.size() + 1);

	inc	rdx
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 13   : 	this->m_Data[m_Offset] = Byte;

	movsxd	rax, DWORD PTR Writer$[rsp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rax, QWORD PTR Writer$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 13   : 	this->m_Data[m_Offset] = Byte;

	mov	BYTE PTR [rax], 254			; 000000feH

; 14   : 	this->m_Offset++;

	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN234@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN234@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	edx, ebx
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	sub	rdx, QWORD PTR Writer$[rsp]
	add	eax, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rcx, eax
	cmp	rcx, rdx
	jbe	SHORT $LN248@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	add	rdx, 4
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN248@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	rdx, r13
	mov	QWORD PTR [rax], rdx

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+1]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 2
	movsxd	rdx, eax
	movzx	ecx, BYTE PTR [r8+2]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rdx+rax], cl
	movzx	edx, BYTE PTR [r8+3]
	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 3
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	mov	eax, DWORD PTR Writer$[rsp+24]
	add	eax, 4
	mov	DWORD PTR Writer$[rsp+24], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR Writer$[rsp+8]
	sub	r8, QWORD PTR Writer$[rsp]
	add	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 83   : 	if (this->m_Offset + Size > this->m_Data.size())

	movsxd	rdx, eax
	cmp	rdx, r8
	jbe	SHORT $LN262@ToBinary

; 84   : 	{
; 85   : 		this->m_Data.resize(this->m_Data.size() + Size);

	lea	rdx, QWORD PTR [r8+2]
	lea	rcx, QWORD PTR Writer$[rsp]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN262@ToBinary:

; 86   : 	}
; 87   : 
; 88   : 	char* Bytes = new char[sizeof(int64_t)];

	mov	ecx, 8
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rax

; 90   : 	std::memcpy(Bytes, &Data, sizeof(Bytes));

	mov	QWORD PTR [rax], 256			; 00000100H

; 91   : 
; 92   : 	for (int i = 0; i < Size; i++) {
; 93   : 		this->m_Data[this->m_Offset + i] = Bytes[i];

	movsxd	rcx, DWORD PTR Writer$[rsp+24]
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], 0
	movzx	edx, BYTE PTR [r8+1]
	mov	eax, DWORD PTR Writer$[rsp+24]
	inc	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR Writer$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 	}
; 95   : 
; 96   : 	delete[] Bytes;

	mov	rcx, r8
	call	??_V@YAXPEAX@Z				; operator delete[]

; 97   : 
; 98   : 	this->m_Offset += Size;

	add	DWORD PTR Writer$[rsp+24], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	r14, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
	mov	QWORD PTR [r14], rdi
	mov	QWORD PTR [r14+8], rdi
	mov	QWORD PTR [r14+16], rdi

; 685  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR Writer$[rsp+8]
	mov	rcx, QWORD PTR Writer$[rsp]
	sub	rdx, rcx

; 2065 :         if (_Count != 0) {

	je	SHORT $LN132@ToBinary

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	$LN1273@ToBinary

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rcx, r14
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rsi, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1825 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));

	mov	rbx, QWORD PTR Writer$[rsp]

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rdi, QWORD PTR Writer$[rsp+8]
	mov	r8, rdi
	sub	r8, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbx
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1850 :             return _Dest;

	sub	rdi, rbx

; 1844 :                 _Dest += _ULast - _UFirst;

	add	rdi, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	QWORD PTR [r14+8], rdi
	mov	rcx, QWORD PTR Writer$[rsp]
	xor	edi, edi
$LN132@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	r8, QWORD PTR Alignments$[rbp-256]
	test	r8, r8
	je	SHORT $LN139@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Alignments$[rbp-240]
	sub	rax, r8
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, r8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN157@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN157@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN392@ToBinary:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN157@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Alignments$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Alignments$[rbp-240], rdi
	mov	rcx, QWORD PTR Writer$[rsp]
$LN139@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	r8, QWORD PTR Keys$[rbp-256]
	test	r8, r8
	je	SHORT $LN165@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Keys$[rbp-240]
	sub	rdx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16
	mov	rax, r8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN183@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN183@ToBinary
$LN180@ToBinary:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN183@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Keys$[rbp-256], xmm0

; 2050 :             _Mylast  = nullptr;
; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Keys$[rbp-240], rdi
	mov	rcx, QWORD PTR Writer$[rsp]
$LN165@ToBinary:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN194@ToBinary

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Writer$[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN212@ToBinary

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN212@ToBinary
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN212@ToBinary:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN194@ToBinary:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 296  :     return Writer.GetData();

	mov	rax, r14

; 297  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+352]
	add	rsp, 272				; 00000110H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN1061@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1270@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
	int	3
$LN1271@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1272@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
	npad	1
$LN1058@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN1057@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN1060@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN1059@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	npad	1
$LN1056@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1273@ToBinary:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN1265@ToBinary:
?ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ENDP ; SarcFile::ToBinary
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$0@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$0
	lea	rcx, QWORD PTR Writer$[rdx]
	jmp	??1BinaryVectorWriter@@QEAA@XZ
?dtor$0@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$1@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$1
	lea	rcx, QWORD PTR Keys$[rdx]
	jmp	??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::~vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >
?dtor$1@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$2@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$2
	lea	rcx, QWORD PTR Alignments$[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$2@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$3@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$3
	lea	rcx, QWORD PTR FileName$11[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$4@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$4
	lea	rcx, QWORD PTR Buffer$8[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$4@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
RelDataOffset$1$ = 36
RelStringOffset$1$ = 40
i$1$ = 44
tv7185 = 48
Count$1$ = 56
tv7184 = 64
__$ReturnUdt$GSCopy$ = 64
HashValue$7 = 64
__$ReturnUdt$GSCopy$1$ = 88
Writer$ = 96
Keys$ = 128
Buffer$8 = 152
FileName$9 = 176
$T10 = 176
Alignments$ = 208
FileName$11 = 232
__$ArrayPad$ = 264
this$ = 336
__$ReturnUdt$ = 344
?dtor$6@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA PROC ; `SarcFile::ToBinary'::`1'::dtor$6
	lea	rcx, QWORD PTR FileName$9[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@4HA ENDP ; `SarcFile::ToBinary'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; SarcFile::SarcFile, COMDAT

; 55   : {

$LN891:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-64]
	sub	rsp, 320				; 00000140H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r13, rdx
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx

; 54   : SarcFile::SarcFile(std::vector<unsigned char> Bytes)

	mov	QWORD PTR this$GSCopy$[rsp], rcx
	mov	QWORD PTR Bytes$GSCopy$[rsp], rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.h

; 23   : 	bool Loaded = false;

	mov	BYTE PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r14d, r14d
	mov	QWORD PTR [rcx+8], r14
	mov	QWORD PTR [rcx+16], r14
	mov	QWORD PTR [rcx+24], r14
	mov	rcx, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	cmp	BYTE PTR [rcx], 83			; 00000053H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 59   :     if (Magic[0] != 'S' || Magic[1] != 'A' || Magic[2] != 'R' || Magic[3] != 'C')

	jne	$LN15@SarcFile
	cmp	BYTE PTR [rcx+1], 65			; 00000041H
	jne	$LN15@SarcFile
	cmp	BYTE PTR [rcx+2], 82			; 00000052H
	jne	$LN15@SarcFile
	cmp	BYTE PTR [rcx+3], 67			; 00000043H
	jne	$LN15@SarcFile
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	edx, BYTE PTR [rcx+14]
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+13]
	or	edx, eax
	shl	edx, 8
	movzx	eax, BYTE PTR [rcx+15]
	shl	eax, 24
	or	edx, eax
	movzx	eax, BYTE PTR [rcx+12]
	or	edx, eax
	mov	DWORD PTR DataOffset$1$[rsp], edx

; 57   : 	return !BigEndian ? ((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)) : _byteswap_ushort(((static_cast<uint16_t>(this->m_Bytes[this->m_Offset - 1])) | (this->m_Bytes[this->m_Offset] << 8)));

	movzx	edi, BYTE PTR [rcx+27]
	shl	di, 8
	movzx	eax, BYTE PTR [rcx+26]
	or	di, ax

; 16   : 		this->m_Offset += Offset;

	mov	r14d, 31
	xorps	xmm0, xmm0
	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 76   :     std::vector<SarcFile::Node> Nodes(Count);

	movzx	r15d, di
	mov	QWORD PTR _Newsize$1$[rsp], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Nodes$[rbp-256], xmm0
	mov	QWORD PTR Nodes$[rbp-240], rax

; 2065 :         if (_Count != 0) {

	test	r15, r15
	je	SHORT $LN729@SarcFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	mov	ebx, r15d
	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN689@SarcFile

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN888@SarcFile

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN401@SarcFile

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN690@SarcFile
$LN689@SarcFile:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN690@SarcFile

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
$LN690@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	add	rbx, rax
	mov	rcx, rax
	mov	rdx, rbx
	mov	QWORD PTR Nodes$[rbp-256], rax
	mov	QWORD PTR Nodes$[rbp-240], rbx
	mov	r8, r15
	shl	r8, 4
	xor	edx, edx
	call	memset

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR Nodes$[rbp-248], rbx
$LN729@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 77   :     for (int i = 0; i < Count; i++)

	movzx	eax, di
	mov	DWORD PTR tv5542[rsp], eax
	mov	r12d, eax
	test	eax, eax
	je	$LN3@SarcFile
	xor	r15d, r15d
$LL4@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdi, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, r14d
	lea	eax, DWORD PTR [r14+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [r14+2]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r14+1]
	movsxd	r8, eax
	movzx	esi, BYTE PTR [rdx+rdi]
	shl	esi, 8
	movzx	eax, BYTE PTR [rcx+rdi]
	or	esi, eax
	shl	esi, 8
	movzx	eax, BYTE PTR [r9+rdi+4]
	shl	eax, 24
	or	esi, eax
	movzx	eax, BYTE PTR [r8+rdi]
	or	esi, eax

; 88   : 	this->m_Offset += 4;

	lea	r11d, DWORD PTR [r14+8]

; 89   : 	return !BigEndian ? (static_cast<int32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	r9, r11d
	movzx	ebx, BYTE PTR [rdi+r9]
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdi+r9-1]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdi+r9-2]
	or	ebx, eax
	shl	ebx, 8
	movzx	eax, BYTE PTR [rdi+r9-3]
	or	ebx, eax

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	lea	eax, DWORD PTR [r11+3]
	movsxd	rdx, eax
	lea	eax, DWORD PTR [r11+2]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r11+1]
	movsxd	r8, eax
	movzx	r10d, BYTE PTR [rdx+rdi]
	shl	r10d, 8
	movzx	eax, BYTE PTR [rcx+rdi]
	or	r10d, eax
	shl	r10d, 8
	movzx	eax, BYTE PTR [rdi+r9+4]
	shl	eax, 24
	or	r10d, eax
	movzx	eax, BYTE PTR [r8+rdi]
	or	r10d, eax

; 76   : 	this->m_Offset += 4;

	lea	r14d, DWORD PTR [r11+8]

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movsxd	rax, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rdi+rax]
	lea	rdx, QWORD PTR [rdi+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 77   : 	return !BigEndian ? (static_cast<uint32_t>(this->m_Bytes[this->m_Offset - 3])) |

	movzx	r8d, BYTE PTR [rdi+rax-1]
	shl	r8d, 8
	movzx	eax, BYTE PTR [rdi+rax-2]
	or	r8d, eax
	shl	r8d, 8
	movzx	eax, BYTE PTR [rcx]
	shl	eax, 24
	or	r8d, eax
	movzx	eax, BYTE PTR [rdx-3]
	or	r8d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 86   :         Node.StringOffset = (Attributes & 0xFFFF) * 4;

	movzx	ecx, bx
	shl	ecx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Nodes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 88   :         Nodes[i] = Node;

	mov	DWORD PTR [r15+rax], esi
	mov	DWORD PTR [r15+rax+4], ecx
	mov	DWORD PTR [r15+rax+8], r10d
	mov	DWORD PTR [r15+rax+12], r8d

; 77   :     for (int i = 0; i < Count; i++)

	lea	r15, QWORD PTR [r15+16]
	sub	r12, 1
	jne	$LL4@SarcFile
	mov	r15, QWORD PTR _Newsize$1$[rsp]
$LN3@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 16   : 		this->m_Offset += Offset;

	add	r14d, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 93   :     this->m_Entries.resize(Count);

	mov	r12, QWORD PTR this$GSCopy$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [r12+16]
	mov	rdx, QWORD PTR [r12+8]
	mov	rcx, rdi
	sub	rcx, rdx
	sar	rcx, 3
	mov	r8, 7905747460161236407			; 6db6db6db6db6db7H
	imul	rcx, r8

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	r15, rcx
	jae	SHORT $LN560@SarcFile

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, r15, 56				; 00000038H
	add	rsi, rdx

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN566@SarcFile
	npad	4
$LL567@SarcFile:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL567@SarcFile
$LN566@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [r12+16], rsi

; 1564 :             return;

	jmp	SHORT $LN561@SarcFile
$LN560@SarcFile:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN561@SarcFile

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r12+24]
	sub	rax, rdx
	sar	rax, 3
	imul	rax, r8

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r15, rax
	jbe	SHORT $LN562@SarcFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r15
	lea	rcx, QWORD PTR [r12+8]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN561@SarcFile
$LN562@SarcFile:

; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r15, rcx
	mov	rdx, r15
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >
	mov	QWORD PTR [r12+16], rax
$LN561@SarcFile:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR StringTableBuffer$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 95   :     std::vector<char> StringTableBuffer(DataOffset - Reader.GetPosition()); //This vector will hold the names of the Files inside SARC

	mov	r10d, DWORD PTR DataOffset$1$[rsp]
	mov	esi, r10d
	sub	esi, r14d
	dec	esi
	mov	edi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	r8d, r8d
	mov	QWORD PTR StringTableBuffer$[rbp-256], r8
	mov	QWORD PTR StringTableBuffer$[rbp-248], rax
	mov	QWORD PTR StringTableBuffer$[rbp-240], rax

; 2065 :         if (_Count != 0) {

	test	esi, esi
	je	SHORT $LN550@SarcFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN506@SarcFile

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN889@SarcFile

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN427@SarcFile

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN504@SarcFile
$LN506@SarcFile:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
$LN504@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR StringTableBuffer$[rbp-256], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rbx, QWORD PTR [rax+rsi]
	mov	QWORD PTR StringTableBuffer$[rbp-240], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR StringTableBuffer$[rbp-248], rbx
	mov	r8, QWORD PTR StringTableBuffer$[rbp-256]
	mov	r10d, DWORD PTR DataOffset$1$[rsp]
$LN550@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	movsxd	r9, esi
	test	esi, esi
	jle	SHORT $LN480@SarcFile
	xor	edx, edx
	npad	8
$LL481@SarcFile:

; 37   : 		this->m_Offset++;

	movsxd	rcx, r14d
	inc	r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [r8+rdx], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	inc	rdx
	cmp	rdx, r9
	jl	SHORT $LL481@SarcFile
	mov	r8, QWORD PTR StringTableBuffer$[rbp-256]
$LN480@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 98   :     for (int i = 0; i < Count; i++)

	xor	r14d, r14d
	mov	r15d, r14d
	mov	DWORD PTR i$1$[rsp], r14d
	mov	eax, DWORD PTR tv5542[rsp]
	test	eax, eax
	je	$LN868@SarcFile
	lea	r9d, DWORD PTR [rax-1]
	mov	DWORD PTR tv5522[rsp], r9d
	mov	r12d, r14d
	npad	14
$LL7@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR Nodes$[rbp-256]
	add	rdx, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 100  :         Reader.Seek(DataOffset + Nodes[i].DataStart, BinaryVectorReader::Position::Begin);

	mov	esi, DWORD PTR [rdx+8]
	dec	esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 12   : 		this->m_Offset = Offset - 1;

	add	esi, r10d
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Name$5[rsp], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	rbx, r14
	mov	QWORD PTR Name$5[rbp-240], rbx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	edi, 15
	mov	QWORD PTR Name$5[rbp-232], rdi

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Name$5[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 102  :         if (i == (Count - 1))

	cmp	r15d, r9d
	jne	$LN16@SarcFile

; 104  :             for (uint32_t j = Nodes[i].StringOffset; j < StringTableBuffer.size() - 1; j++)

	mov	r15d, DWORD PTR [rdx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR StringTableBuffer$[rbp-248]
	sub	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 104  :             for (uint32_t j = Nodes[i].StringOffset; j < StringTableBuffer.size() - 1; j++)

	mov	r14d, r15d
	dec	rax
	cmp	r15, rax
	jae	SHORT $LN870@SarcFile
	npad	5
$LL10@SarcFile:

; 105  :             {
; 106  :                 if (std::isprint(StringTableBuffer[j]))

	movsx	ecx, BYTE PTR [r8+r14]
	call	QWORD PTR __imp_isprint
	test	eax, eax
	je	SHORT $LN870@SarcFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	mov	rax, QWORD PTR StringTableBuffer$[rbp-256]
	movzx	r9d, BYTE PTR [rax+r14]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rbx, rdi

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN341@SarcFile

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rbx+1]
	mov	QWORD PTR Name$5[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Name$5[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdi, 16
	cmovae	rax, QWORD PTR Name$5[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rbx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rbx+1], 0

; 4053 :             return;

	jmp	SHORT $LN8@SarcFile
$LN341@SarcFile:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Name$5[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN8@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 104  :             for (uint32_t j = Nodes[i].StringOffset; j < StringTableBuffer.size() - 1; j++)

	inc	r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR StringTableBuffer$[rbp-248]
	mov	r8, QWORD PTR StringTableBuffer$[rbp-256]
	sub	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 104  :             for (uint32_t j = Nodes[i].StringOffset; j < StringTableBuffer.size() - 1; j++)

	mov	r14d, r15d
	dec	rax
	mov	rdi, QWORD PTR Name$5[rbp-232]
	mov	rbx, QWORD PTR Name$5[rbp-240]
	cmp	r14, rax
	jb	SHORT $LL10@SarcFile
$LN870@SarcFile:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR Entry$7[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	r14d, r14d
	mov	QWORD PTR Entry$7[rbp-240], r14

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$7[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$7[rbp-256], r14b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Entry$7[rbp-224], xmm0
	mov	QWORD PTR Entry$7[rbp-208], r14

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR Nodes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 117  :             Entry.Bytes.resize(Nodes[i].DataEnd - Nodes[i].DataStart);

	mov	edx, DWORD PTR [rcx+r12+12]
	sub	edx, DWORD PTR [rcx+r12+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	je	SHORT $LN275@SarcFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR Entry$7[rbp-224]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN275@SarcFile:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Nodes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 118  :             Reader.Read(reinterpret_cast<char*>(Entry.Bytes.data()), Nodes[i].DataEnd - Nodes[i].DataStart);

	mov	ecx, DWORD PTR [r12+rax+12]
	sub	ecx, DWORD PTR [r12+rax+8]
	mov	r9, QWORD PTR Entry$7[rbp-224]
	mov	rdx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	movsxd	r8, ecx
	test	ecx, ecx
	jle	SHORT $LN264@SarcFile
$LL265@SarcFile:

; 37   : 		this->m_Offset++;

	movsxd	rcx, esi
	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [r9+rdx], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	inc	rdx
	cmp	rdx, r8
	jl	SHORT $LL265@SarcFile
$LN264@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Name$5[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rdi, 16
	cmovae	rdx, QWORD PTR Name$5[rsp]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, rbx
	lea	rcx, QWORD PTR Entry$7[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 120  :             this->m_Entries[i] = Entry;

	movsxd	r15, DWORD PTR i$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rbx, r15, 56				; 00000038H
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	add	rbx, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Entry$7[rbp-256]
	cmp	rbx, rax
	je	SHORT $LN239@SarcFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Entry$7[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Entry$7[rbp-232], 16
	cmovae	rdx, QWORD PTR Entry$7[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Entry$7[rbp-240]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN239@SarcFile:
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Entry$7[rbp-224]
	cmp	rcx, rax
	je	SHORT $LN247@SarcFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Entry$7[rbp-216]
	mov	rdx, QWORD PTR Entry$7[rbp-224]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
	npad	1
$LN247@SarcFile:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Entry$7[rbp-224]
	test	rcx, rcx
	je	SHORT $LN210@SarcFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Entry$7[rbp-208]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN228@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN225@SarcFile
$LN228@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Entry$7[rbp-224], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Entry$7[rbp-208], r14
$LN210@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$7[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 121  :         }

	jmp	$LN886@SarcFile
$LN16@SarcFile:

; 124  :             for (uint32_t j = Nodes[i].StringOffset; j < Nodes[i + 1].StringOffset; j++)

	mov	r14d, DWORD PTR [rdx+4]
	cmp	r14d, DWORD PTR [rdx+20]
	jae	SHORT $LN873@SarcFile
	npad	13
$LL13@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r15d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 126  :                 if (std::isprint(StringTableBuffer[j]))

	movsx	ecx, BYTE PTR [r8+r15]
	call	QWORD PTR __imp_isprint
	test	eax, eax
	je	SHORT $LN884@SarcFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3236 :         push_back(_Ch);

	mov	rax, QWORD PTR StringTableBuffer$[rbp-256]
	movzx	r9d, BYTE PTR [rax+r15]

; 4046 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	cmp	rbx, rdi

; 4047 :         if (_Old_size < _Mypair._Myval2._Myres) {

	jae	SHORT $LN353@SarcFile

; 4048 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4049 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	lea	rax, QWORD PTR [rbx+1]
	mov	QWORD PTR Name$5[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR Name$5[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdi, 16
	cmovae	rax, QWORD PTR Name$5[rsp]

; 4051 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	BYTE PTR [rax+rbx], r9b

; 4052 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR [rax+rbx+1], 0

; 4053 :             return;

	jmp	SHORT $LN11@SarcFile
$LN353@SarcFile:

; 4054 :         }
; 4055 : 
; 4056 :         _Reallocate_grow_by(

	lea	rcx, QWORD PTR Name$5[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??push_back@01@QEAAXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
$LN11@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 124  :             for (uint32_t j = Nodes[i].StringOffset; j < Nodes[i + 1].StringOffset; j++)

	inc	r14d
	mov	rax, QWORD PTR Nodes$[rbp-256]
	mov	rdi, QWORD PTR Name$5[rbp-232]
	mov	rbx, QWORD PTR Name$5[rbp-240]
	cmp	r14d, DWORD PTR [r12+rax+20]
	jae	SHORT $LN884@SarcFile
	mov	r8, QWORD PTR StringTableBuffer$[rbp-256]
	jmp	SHORT $LL13@SarcFile
$LN884@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	r15d, DWORD PTR i$1$[rsp]
$LN873@SarcFile:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR Entry$8[rbp-256], xmm0

; 4821 :         _My_data._Mysize = 0;

	xor	r14d, r14d
	mov	QWORD PTR Entry$8[rbp-240], r14

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR Entry$8[rbp-232], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR Entry$8[rbp-256], r14b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Entry$8[rbp-224], xmm0
	mov	QWORD PTR Entry$8[rbp-208], r14

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR Nodes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 137  :             Entry.Bytes.resize(Nodes[i].DataEnd - Nodes[i].DataStart);

	mov	edx, DWORD PTR [rcx+r12+12]
	sub	edx, DWORD PTR [rcx+r12+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	je	SHORT $LN155@SarcFile

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	lea	rcx, QWORD PTR Entry$8[rbp-224]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
$LN155@SarcFile:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR Nodes$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 138  :             Reader.Read(reinterpret_cast<char*>(Entry.Bytes.data()), Nodes[i].DataEnd - Nodes[i].DataStart);

	mov	ecx, DWORD PTR [r12+rax+12]
	sub	ecx, DWORD PTR [r12+rax+8]
	mov	r9, QWORD PTR Entry$8[rbp-224]
	mov	rdx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 36   : 	for (int i = 0; i < Length; i++) {

	movsxd	r8, ecx
	test	ecx, ecx
	jle	SHORT $LN142@SarcFile
	npad	11
$LL143@SarcFile:

; 37   : 		this->m_Offset++;

	movsxd	rcx, esi
	inc	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorReader.cpp

; 38   : 		Data[i] = this->m_Bytes[this->m_Offset];

	movzx	ecx, BYTE PTR [rcx+rax+1]
	mov	BYTE PTR [r9+rdx], cl

; 36   : 	for (int i = 0; i < Length; i++) {

	inc	rdx
	cmp	rdx, r8
	jl	SHORT $LL143@SarcFile
$LN142@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Name$5[rsp]

; 2236 :         if (_Large_string_engaged()) {

	cmp	rdi, 16
	cmovae	rdx, QWORD PTR Name$5[rsp]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, rbx
	lea	rcx, QWORD PTR Entry$8[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 140  :             this->m_Entries[i] = Entry;

	movsxd	rax, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rbx, rax, 56				; 00000038H
	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	add	rbx, QWORD PTR [rax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Entry$8[rbp-256]
	cmp	rbx, rax
	je	SHORT $LN119@SarcFile

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR Entry$8[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR Entry$8[rbp-232], 16
	cmovae	rdx, QWORD PTR Entry$8[rbp-256]

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR Entry$8[rbp-240]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN119@SarcFile:
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rax, QWORD PTR Entry$8[rbp-224]
	cmp	rcx, rax
	je	SHORT $LN127@SarcFile

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR Entry$8[rbp-216]
	mov	rdx, QWORD PTR Entry$8[rbp-224]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
	npad	1
$LN127@SarcFile:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Entry$8[rbp-224]
	test	rcx, rcx
	je	SHORT $LN90@SarcFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Entry$8[rbp-208]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN108@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN105@SarcFile
$LN108@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Entry$8[rbp-224], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Entry$8[rbp-208], r14
$LN90@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR Entry$8[rbp-256]
$LN886@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 142  :     }

	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR Name$5[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN44@SarcFile

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR Name$5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN56@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN53@SarcFile
$LN56@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN44@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 98   :     for (int i = 0; i < Count; i++)

	inc	r15d
	mov	DWORD PTR i$1$[rsp], r15d
	add	r12, 16
	mov	r8, QWORD PTR StringTableBuffer$[rbp-256]
	cmp	r15d, DWORD PTR tv5542[rsp]
	jge	SHORT $LN868@SarcFile
	mov	r10d, DWORD PTR DataOffset$1$[rsp]
	mov	r9d, DWORD PTR tv5522[rsp]
	jmp	$LL7@SarcFile
$LN225@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN105@SarcFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN53@SarcFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN868@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 144  :     Loaded = true;

	mov	rbx, QWORD PTR this$GSCopy$1$[rsp]
	mov	BYTE PTR [rbx], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	test	r8, r8
	je	SHORT $LN412@SarcFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR StringTableBuffer$[rbp-240]
	sub	rdx, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, r8

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN430@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN430@SarcFile
$LN427@SarcFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN430@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR StringTableBuffer$[rbp-256], r14

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR StringTableBuffer$[rbp-248], r14

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR StringTableBuffer$[rbp-240], r14
$LN412@SarcFile:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Nodes$[rbp-256]
	test	rcx, rcx
	je	$LN386@SarcFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Nodes$[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN404@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN404@SarcFile
$LN401@SarcFile:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN404@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2051 :             _Myend   = nullptr;

	jmp	SHORT $LN386@SarcFile
$LN15@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 61   :         Logger::Error("SarcDecoder", "Wrong magic, expected SARC");

	lea	rax, QWORD PTR $T6[rsp]
	mov	QWORD PTR $T3[rsp], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T6[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T6[rbp-232], r14

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 26
	lea	rdx, OFFSET FLAT:??_C@_0BL@EAELOCFG@Wrong?5magic?0?5expected?5SARC@
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T4[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T4[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T4[rsp+24], r14

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@MPMNFAIG@SarcDecoder@
	lea	rcx, QWORD PTR $T4[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 61   :         Logger::Error("SarcDecoder", "Wrong magic, expected SARC");

	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
$LN386@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r13]
	test	rcx, rcx
	je	SHORT $LN313@SarcFile

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r13+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN331@SarcFile

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN328@SarcFile

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN331@SarcFile:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [r13], r14

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [r13+8], r14

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [r13+16], r14
$LN313@SarcFile:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 145  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+400]
	add	rsp, 320				; 00000140H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN328@SarcFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN889@SarcFile:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN888@SarcFile:
	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN885@SarcFile:
??0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; SarcFile::SarcFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$0@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$0
	mov	rcx, QWORD PTR Bytes$GSCopy$[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$0@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$1@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::~vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >
?dtor$1@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$2@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$2
	mov	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$4@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$4
	lea	rcx, QWORD PTR Nodes$[rdx]
	jmp	??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::~vector<SarcFile::Node,std::allocator<SarcFile::Node> >
?dtor$4@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$5@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$5
	lea	rcx, QWORD PTR StringTableBuffer$[rdx]
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
?dtor$5@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$6@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$6
	lea	rcx, QWORD PTR Name$5[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$7@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$7
	lea	rcx, QWORD PTR Entry$7[rdx]
	jmp	??1Entry@SarcFile@@QEAA@XZ
?dtor$7@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 32
DataOffset$1$ = 36
tv5542 = 40
this$GSCopy$1$ = 48
$T3 = 48
_Newsize$1$ = 56
tv5522 = 56
$T4 = 64
this$GSCopy$ = 96
Bytes$GSCopy$ = 104
Name$5 = 112
$T6 = 112
StringTableBuffer$ = 144
Nodes$ = 168
Entry$7 = 192
Entry$8 = 248
__$ArrayPad$ = 304
this$ = 384
Bytes$ = 392
?dtor$8@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA PROC ; `SarcFile::SarcFile'::`1'::dtor$8
	lea	rcx, QWORD PTR Entry$8[rdx]
	jmp	??1Entry@SarcFile@@QEAA@XZ
?dtor$8@?0???0SarcFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z@4HA ENDP ; `SarcFile::SarcFile'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Name$ = 72
?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SarcFile::GetEntry, COMDAT

; 19   : {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 20   :     for (SarcFile::Entry& Entry : this->GetEntries())

	mov	rbx, QWORD PTR [rcx+8]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+16]
	mov	r15, rcx
	cmp	rbx, rsi
	je	SHORT $LN3@GetEntry
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
$LL4@GetEntry:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@GetEntry

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@GetEntry:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@GetEntry

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN17@GetEntry:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@GetEntry

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN36@GetEntry
$LN23@GetEntry:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 20   :     for (SarcFile::Entry& Entry : this->GetEntries())

	add	rbx, 56					; 00000038H
	cmp	rbx, rsi
	jne	SHORT $LL4@GetEntry
$LN3@GetEntry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rbx, QWORD PTR [r15+8]
$LN36@GetEntry:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 28   : }

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rbp, QWORD PTR [rsp+80]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?GetEntry@SarcFile@@QEAAAEAUEntry@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SarcFile::GetEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
this$ = 64
Name$ = 72
?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; SarcFile::HasEntry, COMDAT

; 31   : {

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 32   :     for (SarcFile::Entry& Entry : this->GetEntries())

	mov	rbx, QWORD PTR [rcx+8]
	mov	rdi, rdx
	mov	rsi, QWORD PTR [rcx+16]
	cmp	rbx, rsi
	je	SHORT $LN3@HasEntry
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rbp, QWORD PTR [rdx+24]

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r14, QWORD PTR [rdx+16]
	npad	6
$LL4@HasEntry:

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	rbp, 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@HasEntry

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN12@HasEntry:

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, rbx

; 4584 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

	mov	r8, QWORD PTR [rbx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@HasEntry

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rbx]
$LN17@HasEntry:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	cmp	r8, r14
	jne	SHORT $LN23@HasEntry

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	call	memcmp

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

	test	eax, eax
	je	SHORT $LN34@HasEntry
$LN23@HasEntry:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 32   :     for (SarcFile::Entry& Entry : this->GetEntries())

	add	rbx, 56					; 00000038H
	cmp	rbx, rsi
	jne	SHORT $LL4@HasEntry
$LN3@HasEntry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 39   :     return false;

	xor	al, al
$LN1@HasEntry:

; 40   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN34@HasEntry:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 36   :             return true;

	mov	al, 1
	jmp	SHORT $LN1@HasEntry
?HasEntry@SarcFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; SarcFile::HasEntry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Entry@SarcFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Entry@SarcFile@@QEAA@XZ PROC				; SarcFile::Entry::Entry, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4821 :         _My_data._Mysize = 0;

	xor	eax, eax
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	rax, rcx
	ret	0
??0Entry@SarcFile@@QEAA@XZ ENDP				; SarcFile::Entry::Entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z PROC		; SarcFile::Entry::operator=, COMDAT
$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	lea	r8, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR [rdi+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN14@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	call	??$_Assign_counted_range@PEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAXPEAE_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_counted_range<unsigned char *>
$LN14@operator:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Entry@SarcFile@@QEAAAEAU01@AEBU01@@Z ENDP		; SarcFile::Entry::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?GCD@SarcFile@@AEAAHHH@Z
_TEXT	SEGMENT
this$dead$ = 8
a$ = 16
b$ = 24
?GCD@SarcFile@@AEAAHHH@Z PROC				; SarcFile::GCD, COMDAT

; 148  : {

	npad	2
$LN13@GCD:

; 149  :     while (a != 0 && b != 0)

	mov	r9d, edx
	test	edx, edx
	je	SHORT $LN10@GCD
	npad	7
$LL2@GCD:
	test	r8d, r8d
	je	SHORT $LN10@GCD

; 150  :     {
; 151  :         if (a > b)

	cmp	r9d, r8d
	jle	SHORT $LN4@GCD

; 152  :             a %= b;

	mov	eax, r9d
	cdq
	idiv	r8d
	jmp	SHORT $LN13@GCD
$LN4@GCD:

; 153  :         else
; 154  :             b %= a;

	mov	eax, r8d
	cdq
	idiv	r9d
	mov	r8d, edx
	jmp	SHORT $LL2@GCD
$LN10@GCD:

; 155  :     }
; 156  :     return a | b;

	or	r9d, r8d
	mov	eax, r9d

; 157  : }

	ret	0
?GCD@SarcFile@@AEAAHHH@Z ENDP				; SarcFile::GCD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?LCM@SarcFile@@AEAAHHH@Z
_TEXT	SEGMENT
this$dead$ = 8
a$ = 16
b$ = 24
?LCM@SarcFile@@AEAAHHH@Z PROC				; SarcFile::LCM, COMDAT

; 160  : {

	mov	r10d, edx

; 161  :     return a / GCD(a, b) * b;

	mov	ecx, r8d
$LN15@LCM:

; 149  :     while (a != 0 && b != 0)

	mov	r9d, edx
	test	edx, edx
	je	SHORT $LN12@LCM
	npad	3
$LL4@LCM:
	test	ecx, ecx
	je	SHORT $LN12@LCM

; 150  :     {
; 151  :         if (a > b)

	cmp	r9d, ecx
	jle	SHORT $LN6@LCM

; 152  :             a %= b;

	mov	eax, r9d
	cdq
	idiv	ecx
	jmp	SHORT $LN15@LCM
$LN6@LCM:

; 153  :         else
; 154  :             b %= a;

	mov	eax, ecx
	cdq
	idiv	r9d
	mov	ecx, edx
	jmp	SHORT $LL4@LCM
$LN12@LCM:

; 161  :     return a / GCD(a, b) * b;

	mov	eax, r10d

; 156  :     return a | b;

	or	r9d, ecx

; 161  :     return a / GCD(a, b) * b;

	cdq
	idiv	r9d
	imul	eax, r8d

; 162  : }

	ret	0
?LCM@SarcFile@@AEAAHHH@Z ENDP				; SarcFile::LCM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
this$dead$ = 48
Data$ = 56
?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; SarcFile::GetBinaryFileAlignment, COMDAT

; 165  : {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [rdx]
	mov	rax, r8
	sub	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 166  :     if (Data.size() <= 0x20)

	cmp	rax, 32					; 00000020H
	jbe	SHORT $LN20@GetBinaryF

; 167  :     {
; 168  :         return 1;
; 169  :     }
; 170  : 
; 171  :     if (Data[0] == 'A' && Data[1] == 'I' && Data[2] == 'B') //AINB has alignment 8

	cmp	BYTE PTR [rcx], 65			; 00000041H
	jne	SHORT $LN3@GetBinaryF
	cmp	BYTE PTR [rcx+1], 73			; 00000049H
	jne	SHORT $LN3@GetBinaryF
	cmp	BYTE PTR [rcx+2], 66			; 00000042H
	jne	SHORT $LN3@GetBinaryF

; 172  :         return 8;

	mov	rcx, rdx
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, 8

; 181  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@GetBinaryF:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	r8d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 175  :     if (FileSize != static_cast<int32_t>(Data.size()))

	cmp	DWORD PTR [rcx+28], r8d
	jne	SHORT $LN20@GetBinaryF

; 178  :     }
; 179  : 
; 180  :     return 1 << Data[0x0E];

	movzx	ecx, BYTE PTR [rcx+14]
	mov	ebx, 1
	shl	ebx, cl
	mov	rcx, rdx
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, ebx

; 181  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@GetBinaryF:

; 176  :     {
; 177  :         return 1;

	mov	rcx, rdx
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, 1

; 181  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?GetBinaryFileAlignment@SarcFile@@AEAAHV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; SarcFile::GetBinaryFileAlignment
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?AlignUp@SarcFile@@AEAAHHH@Z
_TEXT	SEGMENT
this$dead$ = 8
Value$ = 16
Size$ = 24
?AlignUp@SarcFile@@AEAAHHH@Z PROC			; SarcFile::AlignUp, COMDAT

; 184  : {

	mov	r9d, edx

; 185  :     return Value + (Size - Value % Size) % Size;

	mov	eax, edx
	cdq
	idiv	r8d
	mov	eax, r8d
	sub	eax, edx
	cdq
	idiv	r8d
	lea	eax, DWORD PTR [r9+rdx]

; 186  : }

	ret	0
?AlignUp@SarcFile@@AEAAHHH@Z ENDP			; SarcFile::AlignUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z
_TEXT	SEGMENT
Writer$ = 48
Alignment$ = 56
?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z PROC	; AlignWriter, COMDAT

; 189  : {

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	mov	r8d, DWORD PTR [rcx+24]
	mov	edi, edx
	mov	eax, r8d
	mov	rbx, rcx
	cdq
	idiv	edi
	test	edx, edx
	je	SHORT $LN24@AlignWrite
	npad	3
$LL2@AlignWrite:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	lea	eax, DWORD PTR [r8+1]
	movsxd	rcx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 30   : 		if (this->m_Offset + Offset >= this->m_Data.size())

	cmp	rcx, rax
	jb	SHORT $LN11@AlignWrite

; 31   : 		{
; 32   : 			this->m_Data.resize(Offset + this->m_Offset + 1);

	lea	eax, DWORD PTR [r8+2]
	mov	rcx, rbx
	movsxd	rdx, eax
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
$LN11@AlignWrite:

; 34   : 		this->m_Offset += Offset;

	mov	r8d, DWORD PTR [rbx+24]
	inc	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	mov	eax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BinaryVectorWriter.cpp

; 34   : 		this->m_Offset += Offset;

	mov	DWORD PTR [rbx+24], r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 191  :     while (Writer->GetPosition() % Alignment != 0)

	cdq
	idiv	edi
	test	edx, edx
	jne	SHORT $LL2@AlignWrite

; 192  :     {
; 193  :         Writer->Seek(1, BinaryVectorWriter::Position::Current);
; 194  :         Aligned = true;
; 195  :     }
; 196  :     return Aligned;

	mov	al, 1

; 197  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN24@AlignWrite:
	mov	rbx, QWORD PTR [rsp+48]
	xor	al, al
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?AlignWriter@@YA_NPEAVBinaryVectorWriter@@H@Z ENDP	; AlignWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0HashValue@SarcFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0HashValue@SarcFile@@QEAA@XZ PROC			; SarcFile::HashValue::HashValue, COMDAT
	xor	eax, eax
	mov	DWORD PTR [rcx], eax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0HashValue@SarcFile@@QEAA@XZ ENDP			; SarcFile::HashValue::HashValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
;	COMDAT ??R<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@AEBUHashValue@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
a$ = 16
b$ = 24
??R<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@AEBUHashValue@2@0@Z PROC ; `SarcFile::ToBinary'::`2'::<lambda_1>::operator(), COMDAT

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	setb	al
	ret	0
??R<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@QEBA@AEBUHashValue@2@0@Z ENDP ; `SarcFile::ToBinary'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAAEAUHashValue@SarcFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAAEAUHashValue@SarcFile@@_K@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 4
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAAEAUHashValue@SarcFile@@_K@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?end@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1805 :         auto& _My_data = _Mypair._Myval2;
; 1806 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1807 :     }

	ret	0
?end@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?begin@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1795 :         auto& _My_data = _Mypair._Myval2;
; 1796 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1797 :     }

	ret	0
?begin@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@2@XZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::~vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::~vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN87:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebp, ebp

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbp

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN66@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdx, rax
	ja	$LN84@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	mov	rdi, rdx
	shl	rdi, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN85@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN33@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rdx, rax

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN82@vector
$LN33@vector:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@vector:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN25@vector

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	mov	rdx, rax
	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN82@vector
$LN25@vector:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rax, rbp
	lea	rcx, QWORD PTR [rdi+rbp]
	mov	rdx, rbp
$LN82@vector:
	mov	QWORD PTR [rsi], rdx
	mov	r8, rsi
	mov	QWORD PTR [rsi+16], rcx
$LL49@vector:
	mov	QWORD PTR [rax], rbp
	mov	QWORD PTR [rax+8], rbp

; 1803 :         ++_Last;

	add	rax, 16

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL49@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rax
$LN66@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN85@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN84@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
	int	3
$LN81@vector:
??0?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UHashValue@SarcFile@@@1@@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UHashValue@SarcFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UHashValue@SarcFile@@@std@@QEAA@XZ PROC	; std::allocator<SarcFile::HashValue>::allocator<SarcFile::HashValue>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UHashValue@SarcFile@@@std@@QEAA@XZ ENDP	; std::allocator<SarcFile::HashValue>::allocator<SarcFile::HashValue>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Al$dead$ = 64
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN81:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN64@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN78@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN79@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN29@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@vector
$LN29@vector:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@vector:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN18@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rdi+rbx]
	mov	QWORD PTR [rsi], rdi
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	mov	rcx, rdi
	xor	edx, edx
	call	memset

; 2036 :             return _First + _Count;

	lea	rcx, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rcx
$LN64@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN79@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN78@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
	int	3
$LN76@vector:
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAAEAUNode@SarcFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAAEAUNode@SarcFile@@_K@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 4
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAAEAUNode@SarcFile@@_K@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::~vector<SarcFile::Node,std::allocator<SarcFile::Node> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::~vector<SarcFile::Node,std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Al$dead$ = 80
??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::vector<SarcFile::Node,std::allocator<SarcFile::Node> >, COMDAT

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN84:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	ebx, ebx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbp, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rbx

; 619  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rbx
	mov	QWORD PTR [rcx+16], rbx

; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN64@vector

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdx, rax
	ja	$LN81@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	mov	rdi, rdx
	shl	rdi, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN24@vector

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN82@vector

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN33@vector

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax
$LN25@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rbx+rdi]
$LN79@vector:
	mov	rdx, rsi
	shl	rbp, 4
	mov	rcx, rbx
	mov	r8, rbp
	mov	QWORD PTR [rdx], rbx
	xor	edx, edx
	mov	QWORD PTR [rsi+16], rax
	call	memset
	add	rbx, rdi

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [rsi+8], rbx
$LN64@vector:

; 620  :         _Construct_n(_Count);
; 621  :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rax, rsi
	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN33@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN24@vector:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN25@vector

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rdi
	jmp	SHORT $LN79@vector
$LN82@vector:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN81@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength
	int	3
$LN78@vector:
??0?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@_KAEBV?$allocator@UNode@SarcFile@@@1@@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::vector<SarcFile::Node,std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UNode@SarcFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UNode@SarcFile@@@std@@QEAA@XZ PROC	; std::allocator<SarcFile::Node>::allocator<SarcFile::Node>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UNode@SarcFile@@@std@@QEAA@XZ ENDP	; std::allocator<SarcFile::Node>::allocator<SarcFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAAEAUEntry@SarcFile@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAAEAUEntry@SarcFile@@_K@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	imul	rax, rdx, 56				; 00000038H
	add	rax, QWORD PTR [rcx]

; 1890 :     }

	ret	0
??A?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAAEAUEntry@SarcFile@@_K@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, 7905747460161236407		; 6db6db6db6db6db7H
	sar	rax, 3
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN30:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	r14, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	r9, 7905747460161236407			; 6db6db6db6db6db7H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 56				; 00000038H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN10@resize
	npad	5
$LL11@resize:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL11@resize
$LN10@resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >
	mov	QWORD PTR [r14+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?resize@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -16

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::HashValue>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 4
	mov	rax, rdx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAXQEAUHashValue@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::HashValue>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::Node>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 4
	mov	rax, rdx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UNode@SarcFile@@@std@@QEAAXQEAUNode@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::Node>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UHashValue@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$dead$ = 64
$T1 = 64
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8063 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	mov	BYTE PTR [rsp+24], r8b
	sub	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	movzx	r9d, BYTE PTR $T1[rsp]
	mov	r8, rdx
	sub	r8, rcx
	sar	r8, 4

; 8068 : }

	add	rsp, 40					; 00000028H

; 8064 :     _Adl_verify_range(_First, _Last);
; 8065 :     const auto _UFirst = _Get_unwrapped(_First);
; 8066 :     const auto _ULast  = _Get_unwrapped(_Last);
; 8067 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	jmp	??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@2@XZ@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;
; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEBAPEAUHashValue@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEBAPEAUHashValue@SarcFile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@QEBAPEAUHashValue@SarcFile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Pass_fn@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Func$dead$ = 16
??$_Pass_fn@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pass_fn<`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;

	mov	rax, rcx

; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }

	ret	0
??$_Pass_fn@V<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?A_PAEAV<lambda_1>@?1??ToBinary@SarcFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pass_fn<`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Al$dead$ = 72
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>, COMDAT

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	r14, r8

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax

; 630  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	r14, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2065 :         if (_Count != 0) {

	je	SHORT $LN34@allocator

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	SHORT $LN45@allocator

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	mov	rdx, r14
	mov	QWORD PTR [rsp+56], rdi
	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, r14
	mov	rcx, rdi
	mov	rdx, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rcx, QWORD PTR [r14+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rsi+8], rcx
$LN34@allocator:

; 631  :         _Adl_verify_range(_First, _Last);
; 632  :         auto _UFirst = _Get_unwrapped(_First);
; 633  :         auto _ULast  = _Get_unwrapped(_Last);
; 634  :         if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
; 635  :             const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
; 636  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 637  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 638  : #ifdef __cpp_lib_concepts
; 639  :         } else if constexpr (forward_iterator<_Iter>) {
; 640  :             const auto _Length = _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 641  :             const auto _Count  = _Convert_size<size_type>(_Length);
; 642  :             _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
; 643  : #endif // __cpp_lib_concepts
; 644  :         } else {
; 645  :             auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 646  :             _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 647  :             _Tidy_guard<vector> _Guard{this};
; 648  : 
; 649  :             _Append_uncounted_range(_STD move(_UFirst), _STD move(_ULast));
; 650  : 
; 651  :             _Guard._Target = nullptr;
; 652  :             _Proxy._Release();
; 653  :         }
; 654  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN45@allocator:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN43@allocator:
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@$0A@@?$vector@EV?$allocator@E@std@@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0AEBV?$allocator@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UHashValue@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UHashValue@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UHashValue@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UHashValue@SarcFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1><std::allocator<SarcFile::HashValue> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UHashValue@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UHashValue@SarcFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1><std::allocator<SarcFile::HashValue> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN84:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN79@Construct_
	push	rbx
	push	rsi
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN81@Construct_
	mov	QWORD PTR [rsp+96], rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	xor	ebp, ebp
	mov	QWORD PTR [rsp+48], rdi

; 75   :     return _Count * _Ty_size;

	mov	rdi, rdx
	shl	rdi, 4
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN82@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rdx, rax

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN66@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	mov	rdx, rax
	lea	rcx, QWORD PTR [rax+rdi]
	jmp	SHORT $LN66@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rax, rbp
	lea	rcx, QWORD PTR [rdi+rbp]
	mov	rdx, rbp
$LN66@Construct_:
	mov	QWORD PTR [rsi], rdx
	mov	QWORD PTR [rsi+16], rcx
	npad	5
$LL43@Construct_:
	mov	QWORD PTR [rax], rbp
	mov	QWORD PTR [rax+8], rbp

; 1803 :         ++_Last;

	add	rax, 16

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rbx, 1
	jne	SHORT $LL43@Construct_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	r14, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+8], rax

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbx
$LN79@Construct_:
	ret	0
$LN82@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN81@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
	int	3
$LN78@Construct_:
??$_Construct_n@$$V@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN76:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN71@Construct_
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rbx, rdx
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN73@Construct_
	mov	QWORD PTR [rsp+64], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN14@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN74@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Construct_
$LN23@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Construct_:

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN12@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [rsi], rdi
	mov	QWORD PTR [rsi+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	mov	rcx, rdi
	xor	edx, edx
	call	memset

; 2036 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	rdi, QWORD PTR [rsp+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2083 :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	QWORD PTR [rsi+8], rax
	add	rsp, 32					; 00000020H
	pop	rsi
$LN71@Construct_:
	ret	0
$LN74@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN73@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
	int	3
$LN70@Construct_:
??$_Construct_n@$$V@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@UNode@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UNode@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@UNode@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UNode@SarcFile@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1><std::allocator<SarcFile::Node> const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@UNode@SarcFile@@@std@@$$V@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@UNode@SarcFile@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1><std::allocator<SarcFile::Node> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Construct_n<>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN83:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	$LN76@Construct_
	push	rsi
	push	r14
	sub	rsp, 56					; 00000038H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rsi, rdx
	mov	r14, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	$LN80@Construct_
	mov	QWORD PTR [rsp+96], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	mov	rbx, rdx
	mov	QWORD PTR [rsp+48], rbp
	shl	rbx, 4
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r15

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN18@Construct_

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN81@Construct_

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN27@Construct_

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN77@Construct_
$LN27@Construct_:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@Construct_:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN19@Construct_

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	add	rax, rbx
	jmp	SHORT $LN78@Construct_
$LN19@Construct_:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN77@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	lea	rax, QWORD PTR [rdi+rbx]
$LN78@Construct_:
	mov	rcx, rdi
	shl	rsi, 4
	mov	QWORD PTR [r14], rcx
	mov	r8, rsi
	xor	edx, edx
	mov	QWORD PTR [r14+16], rax
	call	memset
	mov	rbp, QWORD PTR [rsp+48]
	add	rdi, rbx
	mov	rbx, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]

; 2066 :             _Buy_nonzero(_Count);
; 2067 :             _Tidy_guard<vector> _Guard{this};
; 2068 :             if constexpr (sizeof...(_Val) == 0) {
; 2069 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);

	mov	QWORD PTR [r14+8], rdi
	mov	rdi, QWORD PTR [rsp+40]

; 2070 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2071 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2072 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rsi
$LN76@Construct_:
	ret	0
$LN81@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN80@Construct_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength
	int	3
$LN75@Construct_:
??$_Construct_n@$$V@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Construct_n<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN28:
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	r14, rcx
	mov	r8, QWORD PTR [rcx]
	mov	r9, 7905747460161236407			; 6db6db6db6db6db7H
	mov	rcx, rdi
	sub	rcx, r8
	sar	rcx, 3
	imul	rcx, r9

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rsi

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rsi, rdx, 56				; 00000038H
	add	rsi, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rbx, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rsi, rdi
	je	SHORT $LN8@Resize
	npad	5
$LL9@Resize:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL9@Resize
$LN8@Resize:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1563 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [r14+8], rsi
	mov	rsi, QWORD PTR [rsp+56]

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r14+16]
	sub	rax, r8
	sar	rax, 3
	imul	rax, r9

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r14

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, rdi
	call	??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >
	mov	QWORD PTR [r14+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UEntry@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UEntry@SarcFile@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1>::_Compressed_pair<std::allocator<SarcFile::Entry>,std::_Vector_val<std::_Simple_types<SarcFile::Entry> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAXPEAUHashValue@SarcFile@@QEAU12@AEAV?$allocator@UHashValue@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAXPEAUHashValue@SarcFile@@QEAU12@AEAV?$allocator@UHashValue@SarcFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SarcFile::HashValue> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAXPEAUHashValue@SarcFile@@QEAU12@AEAV?$allocator@UHashValue@SarcFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UNode@SarcFile@@@std@@@std@@YAXPEAUNode@SarcFile@@QEAU12@AEAV?$allocator@UNode@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UNode@SarcFile@@@std@@@std@@YAXPEAUNode@SarcFile@@QEAU12@AEAV?$allocator@UNode@SarcFile@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SarcFile::Node> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UNode@SarcFile@@@std@@@std@@YAXPEAUNode@SarcFile@@QEAU12@AEAV?$allocator@UNode@SarcFile@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >::~_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >::~_Tidy_guard<std::vector<SarcFile::Node,std::allocator<SarcFile::Node> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >::~_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >, COMDAT

; 44   :         if (_Target) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	?_Tidy@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Tidy

; 45   :             _Target->_Tidy();
; 46   :         }
; 47   :     }

	ret	0
??1?$_Tidy_guard@V?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >::~_Tidy_guard<std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >::_Vector_val<std::_Simple_types<SarcFile::HashValue> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >::_Vector_val<std::_Simple_types<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN42@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN43@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN42@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
	int	3
$LN43@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN40@Buy_nonzer:
?_Buy_nonzero@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN41:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN39@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN40@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN19@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN8@Buy_nonzer
$LN19@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN11@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN8@Buy_nonzer
$LN11@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN8@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN39@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
	int	3
$LN40@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN37@Buy_nonzer:
?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<SarcFile::Node> >::_Vector_val<std::_Simple_types<SarcFile::Node> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<SarcFile::Node> >::_Vector_val<std::_Simple_types<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_nonzero, COMDAT

; 1995 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN44:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1996 :         // allocate array with _Newcapacity elements
; 1997 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1998 :         auto& _My_data    = _Mypair._Myval2;
; 1999 :         pointer& _Myfirst = _My_data._Myfirst;
; 2000 :         pointer& _Mylast  = _My_data._Mylast;
; 2001 :         pointer& _Myend   = _My_data._Myend;
; 2002 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2003 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2004 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2005 : 
; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN42@Buy_nonzer
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 75   :     return _Count * _Ty_size;

	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN14@Buy_nonzer

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN43@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN23@Buy_nonzer

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN23@Buy_nonzer:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Buy_nonzer:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN15@Buy_nonzer

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN12@Buy_nonzer
$LN15@Buy_nonzer:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN12@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 2011 :     }

	mov	rbx, QWORD PTR [rsp+48]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 2011 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN42@Buy_nonzer:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength
	int	3
$LN43@Buy_nonzer:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN40@Buy_nonzer:
?_Buy_nonzero@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAXPEAUEntry@SarcFile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAXPEAUEntry@SarcFile@@0@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBAXPEAUEntry@SarcFile@@0@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UEntry@SarcFile@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UEntry@SarcFile@@@std@@QEAA@XZ PROC	; std::allocator<SarcFile::Entry>::allocator<SarcFile::Entry>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UEntry@SarcFile@@@std@@QEAA@XZ ENDP	; std::allocator<SarcFile::Entry>::allocator<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@CAXXZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN7@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN34@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN16@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN8@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN5@Buy_raw
$LN8@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN5@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN34@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN32@Buy_raw:
?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@CAXXZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_raw, COMDAT

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1979 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rbx, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN31@Buy_raw

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rbx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN11@Buy_raw

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN31@Buy_raw

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN20@Buy_raw

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN20@Buy_raw:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Buy_raw:

; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN12@Buy_raw

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN12@Buy_raw:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1993 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy_raw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN38@Buy_raw:
?_Buy_raw@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UHashValue@SarcFile@@V?$allocator@UHashValue@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::HashValue,std::allocator<SarcFile::HashValue> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UHashValue@SarcFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UHashValue@SarcFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UHashValue@SarcFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::HashValue>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rdx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN10@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UHashValue@SarcFile@@@std@@QEAAPEAUHashValue@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::HashValue>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ PROC ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UNode@SarcFile@@V?$allocator@UNode@SarcFile@@@std@@@std@@AEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ ENDP ; std::vector<SarcFile::Node,std::allocator<SarcFile::Node> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UNode@SarcFile@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UNode@SarcFile@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SA_KAEBV?$allocator@UNode@SarcFile@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z PROC ; std::allocator<SarcFile::Node>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rdx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN10@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UNode@SarcFile@@@std@@QEAAPEAUNode@SarcFile@@_K@Z ENDP ; std::allocator<SarcFile::Node>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UHashValue@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UHashValue@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::HashValue>,std::_Vector_val<std::_Simple_types<SarcFile::HashValue> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@SarcFile@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@SarcFile@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@SarcFile@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SarcFile::Node>,std::_Vector_val<std::_Simple_types<SarcFile::Node> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > >, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UHashValue@SarcFile@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SarcFile::HashValue> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z PROC ; std::_Unfancy<SarcFile::HashValue>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ENDP ; std::_Unfancy<SarcFile::HashValue>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_Val$2$ = 48
_Val$2 = 48
_First$ = 112
_Last$ = 120
_Ideal$ = 128
_Pred$ = 136
??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 8033 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, rdx
	movzx	ebx, r9b
	sub	rax, rcx
	mov	r15, r8
	and	rax, -16
	mov	r14, rdx
	mov	rbp, rcx
	cmp	rax, 512				; 00000200H
	jle	$LN145@Sort_unche
	npad	13
$LL2@Sort_unche:

; 8037 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 8038 :             return;
; 8039 :         }
; 8040 : 
; 8041 :         if (_Ideal <= 0) { // heap sort if too many divisions

	mov	r9, r14
	sub	r9, rbp
	test	r15, r15
	jle	$LN146@Sort_unche

; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	sar	r9, 5

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	r8, QWORD PTR [r14-16]
	add	r9, r9
	mov	rcx, rbp
	lea	rdi, QWORD PTR [r9*8]
	movzx	r9d, bl
	add	rdi, rbp
	mov	rdx, rdi
	call	??$_Guess_median_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Guess_median_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 7966 :     _RanIt _Pfirst = _Mid;
; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	rsi, QWORD PTR [rdi+16]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	rbp, rdi
	jae	SHORT $LN194@Sort_unche
	mov	ecx, DWORD PTR [rdi]
	npad	1
$LL63@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdi-16]
	lea	rdx, QWORD PTR [rdi-16]
	cmp	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	jb	SHORT $LN194@Sort_unche
	ja	SHORT $LN194@Sort_unche

; 7971 :         --_Pfirst;

	mov	rdi, rdx
	mov	ecx, eax
	cmp	rbp, rdx
	jb	SHORT $LL63@Sort_unche
$LN194@Sort_unche:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	rsi, r14
	jae	SHORT $LN195@Sort_unche
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	ecx, DWORD PTR [rdi]
	npad	2
$LL65@Sort_unche:
	cmp	DWORD PTR [rsi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	jb	SHORT $LN195@Sort_unche
	ja	SHORT $LN195@Sort_unche

; 7975 :         ++_Plast;

	add	rsi, 16
	cmp	rsi, r14
	jb	SHORT $LL65@Sort_unche
$LN195@Sort_unche:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	rax, rsi

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	rdx, rdi
$LL67@Sort_unche:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	rax, r14
	jae	SHORT $LN196@Sort_unche
	npad	6
$LL72@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	ecx, DWORD PTR [rax]
	cmp	DWORD PTR [rdi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	jb	SHORT $LN70@Sort_unche

; 7984 :                 continue;
; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	ja	SHORT $LN196@Sort_unche

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	rsi, rax
	je	SHORT $LN80@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rax]
	movups	xmm1, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rsi], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rax], xmm1
$LN80@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	rsi, 16
$LN70@Sort_unche:
	add	rax, 16
	cmp	rax, r14
	jb	SHORT $LL72@Sort_unche
$LN196@Sort_unche:

; 7995 :         for (; _First < _Glast; --_Glast) {

	cmp	rdx, rbp
	jbe	SHORT $LN240@Sort_unche
	lea	rcx, QWORD PTR [rdx-16]
	npad	1
$LL75@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r8d, DWORD PTR [rcx]
	cmp	r8d, DWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	jb	SHORT $LN73@Sort_unche

; 7998 :                 continue;
; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	ja	SHORT $LN197@Sort_unche

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdi, 16
	cmp	rdi, rcx
	je	SHORT $LN73@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rdi], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN73@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	sub	rdx, 16
	sub	rcx, 16
	cmp	rbp, rdx
	jb	SHORT $LL75@Sort_unche
$LN197@Sort_unche:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	rdx, rbp
$LN240@Sort_unche:
	jne	SHORT $LN88@Sort_unche
	cmp	rax, r14
	je	SHORT $LN144@Sort_unche

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	rsi, rax
	je	SHORT $LN104@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	xmm1, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rdi], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rsi], xmm1
$LN104@Sort_unche:

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	rsi, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	movups	XMMWORD PTR [rdi], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdi, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rax], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8018 :             ++_Gfirst;

	add	rax, 16
	jmp	$LL67@Sort_unche
$LN88@Sort_unche:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	rdx, -16
	cmp	rax, r14
	jne	SHORT $LN91@Sort_unche

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdi, 16
	cmp	rdx, rdi
	je	SHORT $LN114@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdi], xmm1
$LN114@Sort_unche:

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rsi-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	rsi, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rdi]

; 100  :     _Left    = _STD move(_Right);

	movups	XMMWORD PTR [rdi], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rsi], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL67@Sort_unche
$LN91@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rax]

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	rax, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8029 :     }

	jmp	$LL67@Sort_unche
$LN144@Sort_unche:

; 8044 :             return;
; 8045 :         }
; 8046 : 
; 8047 :         // divide and conquer by quicksort
; 8048 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
; 8049 : 
; 8050 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

	mov	rcx, r15

; 8051 : 
; 8052 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	rdx, r14
	sar	rcx, 2
	sub	rdx, rsi
	sar	r15, 1
	mov	rax, rdi
	sub	rax, rbp
	add	r15, rcx
	and	rdx, -16
	and	rax, -16
	movzx	r9d, bl
	mov	r8, r15
	cmp	rax, rdx
	jge	SHORT $LN7@Sort_unche

; 8053 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	rdx, rdi
	mov	rcx, rbp
	call	??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 8054 :             _First = _Mid.second;

	mov	rbp, rsi

; 8055 :         } else { // loop on first half

	jmp	SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 8056 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	rdx, r14
	mov	rcx, rsi
	call	??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 8057 :             _Last = _Mid.first;

	mov	r14, rdi
$LN8@Sort_unche:

; 8034 :     // order [_First, _Last)
; 8035 :     for (;;) {
; 8036 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	rax, r14
	sub	rax, rbp
	and	rax, -16
	cmp	rax, 512				; 00000200H
	jg	$LL2@Sort_unche
$LN145@Sort_unche:

; 7907 :     if (_First != _Last) {

	cmp	rbp, r14
	je	$LN54@Sort_unche

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	rbx, QWORD PTR [rbp+16]
	cmp	rbx, r14
	je	$LN54@Sort_unche
	npad	12
$LL11@Sort_unche:

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movups	xmm1, XMMWORD PTR [rbx]
	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	movd	edx, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movups	XMMWORD PTR _Val$2$[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	edx, DWORD PTR [rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	jae	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbx

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, rbp
	add	rbx, 16
	sub	r8, rbp
	mov	rcx, rbx
	sub	rcx, r8
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7914 :                 *_First = _STD move(_Val);

	movups	xmm0, XMMWORD PTR _Val$2$[rsp]
	movups	XMMWORD PTR [rbp], xmm0

; 7915 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN146@Sort_unche:

; 6596 :     _Diff _Bottom = _Last - _First;

	sar	r9, 4

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r10, r9
	sar	r10, 1
	test	r10, r10
	jle	$LN34@Sort_unche
	lea	r11, QWORD PTR [r9-1]

; 6477 :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6478 :     }
; 6479 : }
; 6480 : 
; 6481 : _EXPORT_STD template <class _RanIt, class _Pr>
; 6482 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6483 :     // pop *_First to *(_Last - 1) and reheap
; 6484 :     _Adl_verify_range(_First, _Last);
; 6485 :     _STD _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
; 6486 : }
; 6487 : 
; 6488 : _EXPORT_STD template <class _RanIt>
; 6489 : _CONSTEXPR20 void pop_heap(_RanIt _First, _RanIt _Last) {
; 6490 :     // pop *_First to *(_Last - 1) and reheap
; 6491 :     _STD pop_heap(_First, _Last, less<>{});
; 6492 : }
; 6493 : 
; 6494 : #ifdef __cpp_lib_concepts
; 6495 : namespace ranges {
; 6496 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6497 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6498 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6499 :     constexpr void _Pop_heap_hole_by_index(_It _First, iter_difference_t<_It> _Hole,
; 6500 :         const iter_difference_t<_It> _Bottom, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6501 :         // percolate _Hole to _Bottom, then push _Val
; 6502 :         _STL_INTERNAL_CHECK(_Hole >= 0);
; 6503 :         _STL_INTERNAL_CHECK(_Bottom > 0);
; 6504 : 
; 6505 :         using _Diff      = iter_difference_t<_It>;
; 6506 :         const _Diff _Top = _Hole;
; 6507 :         _Diff _Idx       = _Hole;
; 6508 : 
; 6509 :         // Check whether _Idx can have a child before calculating that child's index, since
; 6510 :         // calculating the child's index can trigger integer overflows
; 6511 :         const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6512 :         while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child
; 6513 :             _Idx      = 2 * _Idx + 2;
; 6514 :             auto _Mid = _First + _Idx;
; 6515 :             if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid), _STD invoke(_Proj1, *_RANGES prev(_Mid)))) {
; 6516 :                 --_Idx;
; 6517 :                 --_Mid;
; 6518 :             }
; 6519 :             *(_First + _Hole) = _RANGES iter_move(_Mid);
; 6520 :             _Hole             = _Idx;
; 6521 :         }
; 6522 : 
; 6523 :         if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it
; 6524 :             *(_First + _Hole) = _RANGES iter_move(_First + (_Bottom - 1));
; 6525 :             _Hole             = _Bottom - 1;
; 6526 :         }
; 6527 : 
; 6528 :         _RANGES _Push_heap_by_index(_STD move(_First), _Hole, _Top, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6529 :     }
; 6530 : 
; 6531 :     template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
; 6532 :         requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
; 6533 :               && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
; 6534 :     constexpr void _Pop_heap_hole_unchecked(
; 6535 :         _It _First, const _It _Last, const _It _Dest, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 6536 :         // pop *_First to *_Dest and reheap
; 6537 :         _STL_INTERNAL_CHECK(_First != _Last);
; 6538 :         _STL_INTERNAL_CHECK(_First != _Dest);
; 6539 : 
; 6540 :         *_Dest            = _RANGES iter_move(_First);
; 6541 :         const auto _Count = _Last - _First;
; 6542 :         _RANGES _Pop_heap_hole_by_index(_STD move(_First), 0, _Count, _STD forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
; 6543 :     }
; 6544 : 
; 6545 :     template <random_access_iterator _It, class _Pr, class _Pj>
; 6546 :         requires sortable<_It, _Pr, _Pj>
; 6547 :     constexpr void _Pop_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
; 6548 :         // pop *_First to *(_Last - 1) and reheap
; 6549 :         if (_Last - _First < 2) {
; 6550 :             return;
; 6551 :         }
; 6552 : 
; 6553 :         --_Last;
; 6554 :         iter_value_t<_It> _Val = _RANGES iter_move(_Last);
; 6555 :         // NB: if _Proj is a _Ref_fn, this aliases the _Proj1 and _Proj2 parameters of _Pop_heap_hole_unchecked
; 6556 :         _RANGES _Pop_heap_hole_unchecked(_STD move(_First), _Last, _Last, _STD move(_Val), _Pred, _Proj, _Proj);
; 6557 :     }
; 6558 : 
; 6559 :     class _Pop_heap_fn : private _Not_quite_object {
; 6560 :     public:
; 6561 :         using _Not_quite_object::_Not_quite_object;
; 6562 : 
; 6563 :         template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
; 6564 :             requires sortable<_It, _Pr, _Pj>
; 6565 :         constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6566 :             _Adl_verify_range(_First, _Last);
; 6567 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 6568 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 6569 :             _Seek_wrapped(_First, _ULast);
; 6570 :             _RANGES _Pop_heap_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6571 :             return _First;
; 6572 :         }
; 6573 : 
; 6574 :         template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
; 6575 :             requires sortable<iterator_t<_Rng>, _Pr, _Pj>
; 6576 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 6577 :             if constexpr (common_range<_Rng>) {
; 6578 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6579 :                 return _RANGES end(_Range);
; 6580 :             } else {
; 6581 :                 auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 6582 :                 _RANGES _Pop_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 6583 :                 return _Rewrap_iterator(_Range, _STD move(_ULast));
; 6584 :             }
; 6585 :         }
; 6586 :     };
; 6587 : 
; 6588 :     _EXPORT_STD inline constexpr _Pop_heap_fn pop_heap{_Not_quite_object::_Construct_tag{}};
; 6589 : } // namespace ranges
; 6590 : #endif // __cpp_lib_concepts
; 6591 : 
; 6592 : template <class _RanIt, class _Pr>
; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	mov	rdi, r10
	sar	r11, 1
	shl	rdi, 4
	add	rdi, rbp
$LL33@Sort_unche:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;
; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	movups	xmm1, XMMWORD PTR [rdi-16]
	dec	r10
	lea	rdi, QWORD PTR [rdi-16]

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	r8, r10

; 6438 :     _Diff _Idx       = _Hole;

	mov	rcx, r10

; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	r10, r11
	jge	SHORT $LN39@Sort_unche
	npad	8
$LL38@Sort_unche:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	rdx, QWORD PTR [rcx+rcx]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rcx, QWORD PTR [rdx+2]
	add	rcx, rcx

; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [rbp+rcx*8-16]
	cmp	DWORD PTR [rbp+rcx*8], eax
	sbb	rcx, rcx
	add	r8, r8
	add	rcx, 2
	add	rcx, rdx
	mov	rax, rcx
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rbp+rax*8]
	movups	XMMWORD PTR [rbp+r8*8], xmm0

; 6449 :         _Hole             = _Idx;

	mov	r8, rcx
	cmp	rcx, r11
	jl	SHORT $LL38@Sort_unche
$LN39@Sort_unche:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	rcx, r11
	jne	SHORT $LN41@Sort_unche
	test	r9b, 1
	jne	SHORT $LN41@Sort_unche

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rax, r9
	add	rax, rax
	add	r8, r8
	movups	xmm0, XMMWORD PTR [rbp+rax*8-16]
	movups	XMMWORD PTR [rbp+r8*8], xmm0

; 6454 :         _Hole             = _Bottom - 1;

	lea	r8, QWORD PTR [r9-1]
$LN41@Sort_unche:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r10, r8
	jge	SHORT $LN198@Sort_unche
	movd	edx, xmm1
	npad	11
$LL48@Sort_unche:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rcx, QWORD PTR [r8-1]
	sar	rcx, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rax, rcx
	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	DWORD PTR [rbp+rax*8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN198@Sort_unche

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	movups	xmm0, XMMWORD PTR [rbp+rax*8]
	add	r8, r8
	movups	XMMWORD PTR [rbp+r8*8], xmm0

; 6332 :         _Hole             = _Idx;

	mov	r8, rcx
	cmp	r10, rcx
	jl	SHORT $LL48@Sort_unche
$LN198@Sort_unche:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	add	r8, r8
	movups	XMMWORD PTR [rbp+r8*8], xmm1

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r10, r10
	jg	$LL33@Sort_unche
$LN34@Sort_unche:

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	cmp	r9, 2
	jl	$LN54@Sort_unche

; 8042 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 8043 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	add	r14, -16
	npad	7
$LL55@Sort_unche:

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	xmm0, XMMWORD PTR [r14]

; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	rdi, r14
	mov	BYTE PTR [rsp+32], bl
	sub	rdi, rbp
	lea	r9, QWORD PTR _Val$2[rsp]

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	XMMWORD PTR _Val$2[rsp], xmm0

; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	r8, rdi
	xor	edx, edx
	movups	xmm0, XMMWORD PTR [rbp]
	sar	r8, 4
	mov	rcx, rbp
	movups	XMMWORD PTR [r14], xmm0
	call	??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	r14, 16
	and	rdi, -16
	cmp	rdi, 32					; 00000020H
	jge	SHORT $LL55@Sort_unche
	jmp	SHORT $LN54@Sort_unche
$LN18@Sort_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	edx, DWORD PTR [rbx-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	rax, QWORD PTR [rbx-16]
	jae	SHORT $LN15@Sort_unche
	npad	6
$LL16@Sort_unche:

; 7917 :                     *_Hole = _STD move(*_Prev); // move hole down

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx], xmm0
	mov	rcx, rax
	sub	rax, 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	edx, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	jb	SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 7918 :                 }
; 7919 : 
; 7920 :                 *_Hole = _STD move(_Val); // insert element in hole

	movups	XMMWORD PTR [rcx], xmm1
	add	rbx, 16
$LN19@Sort_unche:

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	cmp	rbx, r14
	jne	$LL11@Sort_unche
$LN54@Sort_unche:

; 8058 :         }
; 8059 :     }
; 8060 : }

	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$_Sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0_JV<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char *,unsigned char *>, COMDAT

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN39:

; 2057 :         // Dispatches between the three sized constructions.
; 2058 :         // 1-arg -> value-construction, e.g. vector(5)
; 2059 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2060 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2061 :         auto& _Al       = _Getal();
; 2062 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2063 :         auto& _My_data  = _Mypair._Myval2;
; 2064 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2065 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN35@Construct_
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 2006 :         if (_Newcapacity > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 2056 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rbx, r8
	mov	rsi, rcx

; 2006 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN37@Construct_
	mov	QWORD PTR [rsp+40], rdi

; 2008 :         }
; 2009 : 
; 2010 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy_raw

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1826 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));

	mov	rbx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1844 :                 _Dest += _ULast - _UFirst;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2074 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rsi+8], rax

; 2075 :             } else {
; 2076 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2077 :             }
; 2078 :             _ASAN_VECTOR_CREATE;
; 2079 :             _Guard._Target = nullptr;
; 2080 :         }
; 2081 : 
; 2082 :         _Proxy._Release();
; 2083 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
$LN35@Construct_:
	ret	0
$LN37@Construct_:

; 2007 :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
	int	3
$LN34@Construct_:
??$_Construct_n@PEAEPEAE@?$vector@EV?$allocator@E@std@@@std@@AEAAX_K$$QEAPEAE1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Construct_n<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UHashValue@SarcFile@@@std@@@std@@YAAEBV?$allocator@UHashValue@SarcFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UHashValue@SarcFile@@@std@@@std@@YAAEBV?$allocator@UHashValue@SarcFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<SarcFile::HashValue> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UHashValue@SarcFile@@@std@@@std@@YAAEBV?$allocator@UHashValue@SarcFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<SarcFile::HashValue> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@_KAEAV?$allocator@UHashValue@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@_KAEAV?$allocator@UHashValue@SarcFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::HashValue> >, COMDAT

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN24@Uninitiali
	xor	eax, eax
	npad	9
$LL4@Uninitiali:
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 1803 :         ++_Last;

	add	rcx, 16

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN24@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UHashValue@SarcFile@@@std@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@_KAEAV?$allocator@UHashValue@SarcFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@UNode@SarcFile@@@std@@@std@@YAAEBV?$allocator@UNode@SarcFile@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@UNode@SarcFile@@@std@@@std@@YAAEBV?$allocator@UNode@SarcFile@@@0@AEBV10@@Z PROC ; std::forward<std::allocator<SarcFile::Node> const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBV?$allocator@UNode@SarcFile@@@std@@@std@@YAAEBV?$allocator@UNode@SarcFile@@@0@AEBV10@@Z ENDP ; std::forward<std::allocator<SarcFile::Node> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Node> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	shl	rbx, 4
	xor	edx, edx
	mov	r8, rbx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UNode@SarcFile@@@std@@@std@@YAPEAUNode@SarcFile@@PEAU12@_KAEAV?$allocator@UNode@SarcFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN83:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1512 :         if (_Newsize > max_size()) {

	mov	rbx, 329406144173384850			; 0492492492492492H
	mov	rdi, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN81@Resize_rea

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	QWORD PTR [rsp+80], rbp
	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	rbp, QWORD PTR [rcx+8]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [rsi]
	sar	rcx, 3
	imul	rcx, rdx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 3
	imul	rbp, rdx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+88], r14
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN11@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rdi
	cmovb	rbx, rdi
$LN11@Resize_rea:

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@UEntry@SarcFile@@@std@@QEAAPEAUEntry@SarcFile@@_K@Z ; std::allocator<SarcFile::Entry>::allocate

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	imul	rdx, rbp, 56				; 00000038H

; 1526 :         pointer _Appended_last        = _Appended_first;
; 1527 : 
; 1528 :         _TRY_BEGIN
; 1529 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1530 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1531 :         } else {
; 1532 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r11, rdi
	mov	r14, rax
	add	rdx, rax
	sub	r11, rbp
	mov	rbp, QWORD PTR [rsp+80]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN17@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1524 :         const pointer _Newvec         = _Al.allocate(_Newcapacity);

	lea	r10, QWORD PTR [rdx+48]
	xor	eax, eax
	npad	12
$LL18@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+16], rax
	xorps	xmm0, xmm0
	mov	QWORD PTR [rdx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	r10, QWORD PTR [r10+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r10-88], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rdx, QWORD PTR [rdx+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r10-80], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx-56], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [r10-72], rax
	mov	QWORD PTR [r10-64], rax
	mov	QWORD PTR [r10-56], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	r11, 1
	jne	SHORT $LL18@Resize_rea
$LN17@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1537 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	r8, r14
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z ; std::_Uninitialized_move<SarcFile::Entry *,std::allocator<SarcFile::Entry> >

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, r14
	mov	rcx, rsi
	mov	r14, QWORD PTR [rsp+88]

; 1548 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx

; 1538 :         } else {
; 1539 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1540 :         }
; 1541 :         _CATCH_ALL
; 1542 :         _Destroy_range(_Appended_first, _Appended_last, _Al);
; 1543 :         _Al.deallocate(_Newvec, _Newcapacity);
; 1544 :         _RERAISE;
; 1545 :         _CATCH_END
; 1546 : 
; 1547 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	jmp	?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Change_array
$LN81@Resize_rea:

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@CAXXZ ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Xlength
	int	3
$LN79@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Al$dead$ = 24
??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >, COMDAT

; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN62@Uninitiali
	lea	rax, QWORD PTR [rcx+48]
	xor	r8d, r8d
	npad	4
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	lea	rax, QWORD PTR [rax+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rcx+24], r8
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx+32], r8
	mov	QWORD PTR [rcx+40], r8
	mov	QWORD PTR [rcx+48], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax-88], r8

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax-80], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rcx, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax-72], r8
	mov	QWORD PTR [rax-64], r8
	mov	QWORD PTR [rax-56], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	sub	rdx, 1
	jne	SHORT $LL4@Uninitiali
$LN62@Uninitiali:

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rax, rcx
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@PEAU12@_KAEAV?$allocator@UEntry@SarcFile@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAPEAUNode@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAPEAUNode@SarcFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAPEAUNode@SarcFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Node> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::~_Uninitialized_backout_al<std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@PEAUNode@SarcFile@@AEAV?$allocator@UNode@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@PEAUNode@SarcFile@@AEAV?$allocator@UNode@SarcFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAA@PEAUNode@SarcFile@@AEAV?$allocator@UNode@SarcFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAPEAUHashValue@SarcFile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAPEAUHashValue@SarcFile@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAPEAUHashValue@SarcFile@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::~_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::~_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@AEAV?$allocator@UHashValue@SarcFile@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@AEAV?$allocator@UHashValue@SarcFile@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAA@PEAUHashValue@SarcFile@@AEAV?$allocator@UHashValue@SarcFile@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN47:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rbx, QWORD PTR [rcx]
	mov	r14, r9
	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN20@Change_arr
	mov	QWORD PTR [rsp+72], rdi

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN6@Change_arr
$LL7@Change_arr:
	mov	rcx, rbx
	call	??1Entry@SarcFile@@QEAA@XZ
	add	rbx, 56					; 00000038H
	cmp	rbx, rdi
	jne	SHORT $LL7@Change_arr
$LN6@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	rax, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 56				; 00000038H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN20@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2033 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi], rbp
	imul	rax, r15, 56				; 00000038H
	add	rax, rbp
	mov	QWORD PTR [rsi+8], rax
	imul	rax, r14, 56				; 00000038H
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+88]
	mov	QWORD PTR [rsi+16], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN29@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN44@Change_arr:
?_Change_array@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEAAXQEAUEntry@SarcFile@@_K1@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, 7905747460161236407		; 6db6db6db6db6db7H
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 329406144173384850			; 0492492492492492H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ PROC ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, 7905747460161236407		; 6db6db6db6db6db7H
	sar	rax, 3
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@UEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<SarcFile::Entry,std::allocator<SarcFile::Entry> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_Val$2$ = 32
_First$ = 64
_Last$ = 72
_Pred$dead$ = 80
??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Insertion_sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7905 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx
	mov	rsi, rcx

; 7906 :     // insertion sort [_First, _Last)
; 7907 :     if (_First != _Last) {

	cmp	rcx, rdx
	je	$LN35@Insertion_
	mov	QWORD PTR [rsp+72], rbx

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	rbx, QWORD PTR [rcx+16]
	cmp	rbx, rdx
	je	SHORT $LN36@Insertion_
	npad	9
$LL2@Insertion_:

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movups	xmm1, XMMWORD PTR [rbx]
	mov	rdx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	movd	ecx, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7910 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	movups	XMMWORD PTR _Val$2$[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	ecx, DWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7912 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	jae	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbx

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, rsi
	add	rbx, 16
	sub	r8, rsi
	mov	rcx, rbx
	sub	rcx, r8
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7914 :                 *_First = _STD move(_Val);

	movups	xmm0, XMMWORD PTR _Val$2$[rsp]
	movups	XMMWORD PTR [rsi], xmm0

; 7915 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	ecx, DWORD PTR [rbx-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	lea	rax, QWORD PTR [rbx-16]
	jae	SHORT $LN6@Insertion_
	npad	2
$LL7@Insertion_:

; 7917 :                     *_Hole = _STD move(*_Prev); // move hole down

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rdx], xmm0
	mov	rdx, rax
	sub	rax, 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	ecx, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7916 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	jb	SHORT $LL7@Insertion_
$LN6@Insertion_:

; 7918 :                 }
; 7919 : 
; 7920 :                 *_Hole = _STD move(_Val); // insert element in hole

	movups	XMMWORD PTR [rdx], xmm1
	add	rbx, 16
$LN10@Insertion_:

; 7908 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	cmp	rbx, rdi
	jne	SHORT $LL2@Insertion_
$LN36@Insertion_:
	mov	rbx, QWORD PTR [rsp+72]

; 7921 :             }
; 7922 :         }
; 7923 :     }
; 7924 : 
; 7925 :     return _Last;

	mov	rax, rdi

; 7926 : }

	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN35@Insertion_:
	mov	rsi, QWORD PTR [rsp+80]
	mov	rax, rdi
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$_Insertion_sort_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAPEAUHashValue@SarcFile@@QEAU12@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Insertion_sort_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Pred$ = 32
??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Make_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6593 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	rdi
	mov	rdi, rdx
	mov	r9, rcx

; 6594 :     // make [_First, _Last) into a heap
; 6595 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6596 :     _Diff _Bottom = _Last - _First;

	sub	rdi, rcx
	sar	rdi, 4

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	r10, rdi
	sar	r10, 1
	test	r10, r10
	jle	$LN3@Make_heap_
	mov	QWORD PTR [rsp+32], rbx
	lea	r11, QWORD PTR [rdi-1]
	mov	rbx, r10
	sar	r11, 1
	shl	rbx, 4
	add	rbx, rcx
	mov	QWORD PTR [rsp+40], rsi
	npad	7
$LL2@Make_heap_:

; 6598 :         // reheap top half, bottom to top
; 6599 :         --_Hole;
; 6600 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	movups	xmm1, XMMWORD PTR [rbx-16]
	dec	r10
	lea	rbx, QWORD PTR [rbx-16]

; 6601 :         _STD _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	rax, r10

; 6438 :     _Diff _Idx       = _Hole;

	mov	rdx, r10

; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	r10, r11
	jge	SHORT $LN8@Make_heap_
	npad	10
$LL7@Make_heap_:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	r8, QWORD PTR [rdx+rdx]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rdx, QWORD PTR [r8+2]
	add	rdx, rdx

; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	ecx, DWORD PTR [r9+rdx*8-16]
	cmp	DWORD PTR [r9+rdx*8], ecx
	sbb	rdx, rdx
	add	rax, rax
	add	rdx, 2
	add	rdx, r8
	mov	rcx, rdx
	add	rcx, rcx
	movups	xmm0, XMMWORD PTR [r9+rcx*8]
	movups	XMMWORD PTR [r9+rax*8], xmm0

; 6449 :         _Hole             = _Idx;

	mov	rax, rdx
	cmp	rdx, r11
	jl	SHORT $LL7@Make_heap_
$LN8@Make_heap_:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	rdx, r11
	jne	SHORT $LN10@Make_heap_
	test	dil, 1
	jne	SHORT $LN10@Make_heap_

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	rcx, rdi
	add	rcx, rcx
	add	rax, rax
	movups	xmm0, XMMWORD PTR [r9+rcx*8-16]
	movups	XMMWORD PTR [r9+rax*8], xmm0

; 6454 :         _Hole             = _Bottom - 1;

	lea	rax, QWORD PTR [rdi-1]
$LN10@Make_heap_:

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r10, rax
	jge	SHORT $LN33@Make_heap_
	movd	r8d, xmm1
	npad	10
$LL17@Make_heap_:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rdx, QWORD PTR [rax-1]
	sar	rdx, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rcx, rdx
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	DWORD PTR [r9+rcx*8], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN33@Make_heap_

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	movups	xmm0, XMMWORD PTR [r9+rcx*8]
	add	rax, rax
	movups	XMMWORD PTR [r9+rax*8], xmm0

; 6332 :         _Hole             = _Idx;

	mov	rax, rdx
	cmp	r10, rdx
	jl	SHORT $LL17@Make_heap_
$LN33@Make_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	add	rax, rax
	movups	XMMWORD PTR [r9+rax*8], xmm1

; 6597 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	r10, r10
	jg	$LL2@Make_heap_
	mov	rsi, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]
$LN3@Make_heap_:

; 6602 :     }
; 6603 : }

	pop	rdi
	ret	0
??$_Make_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Make_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_Val$1 = 48
_First$ = 80
_Last$ = 88
_Pred$ = 96
??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Sort_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6816 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 64					; 00000040H

; 6817 :     // order heap by repeatedly popping
; 6818 :     for (; _Last - _First >= 2; --_Last) {

	mov	rax, rdx
	movzx	ebx, r8b
	sub	rax, rcx
	mov	rbp, rcx
	and	rax, -16
	cmp	rax, 32					; 00000020H
	jl	SHORT $LN3@Sort_heap_
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	lea	rdi, QWORD PTR [rdx-16]
	npad	1
$LL4@Sort_heap_:

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	xmm0, XMMWORD PTR [rdi]

; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	rsi, rdi
	mov	BYTE PTR [rsp+32], bl
	sub	rsi, rbp
	lea	r9, QWORD PTR _Val$1[rsp]

; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	XMMWORD PTR _Val$1[rsp], xmm0

; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	r8, rsi
	xor	edx, edx
	movups	xmm0, XMMWORD PTR [rbp]
	sar	r8, 4
	mov	rcx, rbp
	movups	XMMWORD PTR [rdi], xmm0
	call	??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 6817 :     // order heap by repeatedly popping
; 6818 :     for (; _Last - _First >= 2; --_Last) {

	sub	rdi, 16
	and	rsi, -16
	cmp	rsi, 32					; 00000020H
	jge	SHORT $LL4@Sort_heap_
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
$LN3@Sort_heap_:

; 6819 :         _STD _Pop_heap_unchecked(_First, _Last, _Pred);
; 6820 :     }
; 6821 : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
??$_Sort_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Sort_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Pred$ = 88
??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Partition_by_median_guess_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7962 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, r8

; 7963 :     // partition [_First, _Last)
; 7964 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	rdx, r8
	mov	rsi, rcx
	sub	rdx, rdi

; 7965 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	add	r8, -16
	sar	rdx, 5
	mov	rcx, rdi
	shl	rdx, 4
	add	rdx, rdi
	call	??$_Guess_median_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Guess_median_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >

; 7966 :     _RanIt _Pfirst = _Mid;
; 7967 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	rcx, QWORD PTR [rdx+16]

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	rdi, rdx
	jae	SHORT $LN92@Partition_
	mov	r8d, DWORD PTR [rdx]
	npad	6
$LL2@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdx-16]
	lea	r9, QWORD PTR [rdx-16]
	cmp	eax, r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7970 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	jb	SHORT $LN92@Partition_
	ja	SHORT $LN92@Partition_

; 7971 :         --_Pfirst;

	mov	rdx, r9
	mov	r8d, eax
	cmp	rdi, r9
	jb	SHORT $LL2@Partition_
$LN92@Partition_:

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	rcx, rbx
	jae	SHORT $LN93@Partition_
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r8d, DWORD PTR [rdx]
$LL4@Partition_:
	cmp	DWORD PTR [rcx], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7974 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	jb	SHORT $LN93@Partition_
	ja	SHORT $LN93@Partition_

; 7975 :         ++_Plast;

	add	rcx, 16
	cmp	rcx, rbx
	jb	SHORT $LL4@Partition_
$LN93@Partition_:

; 7976 :     }
; 7977 : 
; 7978 :     _RanIt _Gfirst = _Plast;

	mov	rax, rcx

; 7979 :     _RanIt _Glast  = _Pfirst;

	mov	r9, rdx
$LL6@Partition_:

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	cmp	rax, rbx
	jae	SHORT $LN94@Partition_
	npad	4
$LL11@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r8d, DWORD PTR [rdx]
	cmp	r8d, DWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7983 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	jb	SHORT $LN9@Partition_

; 7984 :                 continue;
; 7985 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	ja	SHORT $LN94@Partition_

; 7986 :                 break;
; 7987 :             } else if (_Plast != _Gfirst) {

	cmp	rcx, rax
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rax]
	movups	xmm1, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rax], xmm1
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7982 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	rcx, 16
$LN9@Partition_:
	add	rax, 16
	cmp	rax, rbx
	jb	SHORT $LL11@Partition_
$LN94@Partition_:

; 7995 :         for (; _First < _Glast; --_Glast) {

	cmp	r9, rdi
	jbe	SHORT $LN116@Partition_
	lea	r8, QWORD PTR [r9-16]
$LL14@Partition_:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r10d, DWORD PTR [r8]
	cmp	r10d, DWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7997 :             if (_DEBUG_LT_PRED(_Pred, *_Glast_prev, *_Pfirst)) {

	jb	SHORT $LN12@Partition_

; 7998 :                 continue;
; 7999 :             } else if (_Pred(*_Pfirst, *_Glast_prev)) {

	ja	SHORT $LN95@Partition_

; 8000 :                 break;
; 8001 :             } else if (--_Pfirst != _Glast_prev) {

	sub	rdx, 16
	cmp	rdx, r8
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r8]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r8], xmm1
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7995 :         for (; _First < _Glast; --_Glast) {

	sub	r9, 16
	sub	r8, 16
	cmp	rdi, r9
	jb	SHORT $LL14@Partition_
$LN95@Partition_:

; 8002 :                 swap(*_Pfirst, *_Glast_prev); // intentional ADL
; 8003 :             }
; 8004 :         }
; 8005 : 
; 8006 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	r9, rdi
$LN116@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	rax, rbx
	je	SHORT $LN74@Partition_

; 8008 :         }
; 8009 : 
; 8010 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 8011 :             if (_Plast != _Gfirst) {

	cmp	rcx, rax
	je	SHORT $LN43@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN43@Partition_:

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8015 :             ++_Plast;

	add	rcx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	movups	XMMWORD PTR [rdx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8017 :             ++_Pfirst;

	add	rdx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rax], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8018 :             ++_Gfirst;

	add	rax, 16
	jmp	$LL6@Partition_
$LN27@Partition_:

; 8019 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	r9, -16
	cmp	rax, rbx
	jne	SHORT $LN30@Partition_

; 8020 :             if (--_Glast != --_Pfirst) {

	sub	rdx, 16
	cmp	r9, rdx
	je	SHORT $LN53@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r9], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
$LN53@Partition_:

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx-16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8024 :             swap(*_Pfirst, *--_Plast); // intentional ADL

	sub	rcx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8025 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movups	xmm1, XMMWORD PTR [rax]

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rax], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8027 :             ++_Gfirst;

	add	rax, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r9], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8029 :     }

	jmp	$LL6@Partition_
$LN74@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8007 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	mov	rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rsi+8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 8030 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Partition_by_median_guess_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YA?AU?$pair@PEAUHashValue@SarcFile@@PEAU12@@0@PEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@3@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Partition_by_median_guess_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 16

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UHashValue@SarcFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::HashValue> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rax], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 16

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@SarcFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Node> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUEntry@SarcFile@@@std@@YA?A_TAEBQEAUEntry@SarcFile@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUEntry@SarcFile@@@std@@YA?A_TAEBQEAUEntry@SarcFile@@@Z PROC ; std::_Get_unwrapped<SarcFile::Entry * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUEntry@SarcFile@@@std@@YA?A_TAEBQEAUEntry@SarcFile@@@Z ENDP ; std::_Get_unwrapped<SarcFile::Entry * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z PROC ; std::_Uninitialized_move<SarcFile::Entry *,std::allocator<SarcFile::Entry> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN99:
	sub	rsp, 8
	mov	rax, r8
	mov	r11, rdx

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN94@Uninitiali
	mov	r10, rax
	mov	QWORD PTR [rsp], rbx
	sub	r10, rcx
	lea	r8, QWORD PTR [rcx+40]
	xor	ebx, ebx
	npad	1
$LL4@Uninitiali:
	xorps	xmm0, xmm0

; 1803 :         ++_Last;

	lea	r8, QWORD PTR [r8+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r10+r8-80], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r10+r8-72], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8-96]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [r8-80]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-80], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rax, 56					; 00000038H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8-72], 15
	mov	BYTE PTR [r8-96], bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-64]
	mov	r9, QWORD PTR [r8-48]
	mov	rdx, QWORD PTR [r8-56]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8-48], rbx
	mov	QWORD PTR [r8-56], rbx
	mov	QWORD PTR [r8-64], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+r8-64], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+r10-56], rdx
	mov	QWORD PTR [r10+r8-48], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, r11
	jne	SHORT $LL4@Uninitiali
	mov	rbx, QWORD PTR [rsp]
$LN94@Uninitiali:

; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	add	rsp, 8
	ret	0
??$_Uninitialized_move@PEAUEntry@SarcFile@@V?$allocator@UEntry@SarcFile@@@std@@@std@@YAPEAUEntry@SarcFile@@QEAU12@0PEAU12@AEAV?$allocator@UEntry@SarcFile@@@0@@Z ENDP ; std::_Uninitialized_move<SarcFile::Entry *,std::allocator<SarcFile::Entry> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rax], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rdx

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rax+32], rdx
	mov	QWORD PTR [rax+40], rdx
	mov	QWORD PTR [rax+48], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 56			; 00000038H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z PROC ; std::move<SarcFile::HashValue &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z ENDP ; std::move<SarcFile::HashValue &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move_backward_unchecked@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z PROC ; std::_Move_backward_unchecked<SarcFile::HashValue *,SarcFile::HashValue *>, COMDAT

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx

; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Move_backward_unchecked@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z ENDP ; std::_Move_backward_unchecked<SarcFile::HashValue *,SarcFile::HashValue *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 24
_Hole$ = 32
_Bottom$ = 40
_Val$ = 48
_Pred$ = 56
??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6432 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi

; 6433 :     // percolate _Hole to _Bottom, then push _Val
; 6434 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6435 : 
; 6436 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6437 :     const _Diff _Top = _Hole;
; 6438 :     _Diff _Idx       = _Hole;
; 6439 : 
; 6440 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6441 :     // calculating the child's index can trigger integer overflows
; 6442 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	lea	rsi, QWORD PTR [r8-1]
	mov	r10, rcx
	mov	rbx, rsi
	mov	r11, r8
	sar	rbx, 1
	mov	rdi, rdx
	mov	rcx, rdx

; 6443 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	rdx, rbx
	jge	SHORT $LN3@Pop_heap_h
	npad	14
$LL2@Pop_heap_h:

; 6444 :         _Idx = 2 * _Idx + 2;

	lea	r8, QWORD PTR [rcx+rcx]

; 6445 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	rcx, QWORD PTR [r8+2]
	add	rcx, rcx

; 6446 :             --_Idx;
; 6447 :         }
; 6448 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [r10+rcx*8-16]
	cmp	DWORD PTR [r10+rcx*8], eax
	sbb	rcx, rcx
	add	rdx, rdx
	add	rcx, 2
	add	rcx, r8
	mov	rax, rcx
	add	rax, rax
	movups	xmm0, XMMWORD PTR [r10+rax*8]
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6449 :         _Hole             = _Idx;

	mov	rdx, rcx
	cmp	rcx, rbx
	jl	SHORT $LL2@Pop_heap_h
$LN3@Pop_heap_h:

; 6450 :     }
; 6451 : 
; 6452 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	rcx, rbx
	jne	SHORT $LN5@Pop_heap_h
	test	r11b, 1
	jne	SHORT $LN5@Pop_heap_h

; 6453 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	add	r11, r11
	add	rdx, rdx
	movups	xmm0, XMMWORD PTR [r10+r11*8-16]
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6454 :         _Hole             = _Bottom - 1;

	mov	rdx, rsi
$LN5@Pop_heap_h:

; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rcx, QWORD PTR [rdx-1]
	sar	rcx, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	rdi, rdx
	jge	SHORT $LN24@Pop_heap_h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r8d, DWORD PTR [r9]
	npad	9
$LL12@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rax, rcx
	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	DWORD PTR [r10+rax*8], r8d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN24@Pop_heap_h

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	movups	xmm0, XMMWORD PTR [r10+rax*8]
	add	rdx, rdx
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6332 :         _Hole             = _Idx;

	mov	rdx, rcx
	dec	rcx
	sar	rcx, 1
	cmp	rdi, rdx
	jl	SHORT $LL12@Pop_heap_h
$LN24@Pop_heap_h:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	movups	xmm0, XMMWORD PTR [r9]

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6458 : }

	mov	rbx, QWORD PTR [rsp+48]

; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	add	rdx, rdx
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6455 :     }
; 6456 : 
; 6457 :     _STD _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6458 : }

	pop	rdi
	pop	rsi
	ret	0
??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_Val$1 = 48
_First$ = 80
_Last$ = 88
_Pred$ = 96
??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6472 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	rsp, 72					; 00000048H

; 6473 :     // pop *_First to *(_Last - 1) and reheap
; 6474 :     if (2 <= _Last - _First) {

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -16
	cmp	rax, 32					; 00000020H
	jl	SHORT $LN2@Pop_heap_u

; 6475 :         --_Last;
; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	xmm0, XMMWORD PTR [rdx-16]
	sub	rdx, 16

; 6467 :     _STD _Pop_heap_hole_by_index(

	mov	BYTE PTR [rsp+32], r8b
	lea	r9, QWORD PTR _Val$1[rsp]

; 6475 :         --_Last;
; 6476 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	movups	XMMWORD PTR _Val$1[rsp], xmm0

; 6465 :     *_Dest      = _STD move(*_First);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	sub	rdx, rcx
	sar	rdx, 4
	mov	r8, rdx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >
$LN2@Pop_heap_u:

; 6477 :         _STD _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6478 :     }
; 6479 : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Pop_heap_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@0V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Prev_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Prev_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z PROC ; std::_Prev_iter<SarcFile::HashValue *>, COMDAT

; 1451 :     return --_First;

	lea	rax, QWORD PTR [rcx-16]

; 1452 : }

	ret	0
??$_Prev_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ENDP ; std::_Prev_iter<SarcFile::HashValue *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Mid$ = 16
_Last$ = 24
_Pred$ = 32
??$_Guess_median_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Guess_median_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 7946 :     // sort median element to middle
; 7947 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7948 :     const _Diff _Count = _Last - _First;

	mov	rax, r8
	mov	r10, r8
	sub	rax, rcx
	sar	rax, 4

; 7949 :     if (40 < _Count) { // Tukey's ninther

	cmp	rax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	lea	r9, QWORD PTR [rax+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7950 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	sar	r9, 3

; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	r11, r9
	shl	r9, 4
	shl	r11, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	DWORD PTR [r9+rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7952 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	r8, QWORD PTR [r9+rcx]

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN13@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r8], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN13@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [r11+rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN21@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r8]
	movups	xmm1, XMMWORD PTR [r11+rcx]
	movups	XMMWORD PTR [r11+rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN21@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN21@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7953 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	rcx, rdx
	sub	rcx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN30@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN30@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r9+rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN38@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [r9+rdx]
	movups	XMMWORD PTR [r9+rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN38@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN38@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7954 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	rcx, r10
	sub	rcx, r9
	mov	r9, r10
	sub	r9, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r9]
	cmp	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN47@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r9]
	movups	xmm1, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r9], xmm1
$LN47@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [r10], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN55@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [r10]
	movups	XMMWORD PTR [r10], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r9]
	cmp	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN55@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r9], xmm1
$LN55@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN64@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r8]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r8], xmm1
$LN64@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [r8], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7959 : }

	ret	0
$LN2@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN81@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN81@Guess_medi:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r8], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN89@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN89@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7959 : }

	ret	0
??$_Guess_median_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Guess_median_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Next_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
??$_Next_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z PROC ; std::_Next_iter<SarcFile::HashValue *>, COMDAT

; 1438 :     return ++_First;

	lea	rax, QWORD PTR [rcx+16]

; 1439 : }

	ret	0
??$_Next_iter@PEAUHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@PEAU12@@Z ENDP ; std::_Next_iter<SarcFile::HashValue *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@UHashValue@SarcFile@@$0A@@std@@YAXAEAUHashValue@SarcFile@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@UHashValue@SarcFile@@$0A@@std@@YAXAEAUHashValue@SarcFile@@0@Z PROC ; std::swap<SarcFile::HashValue,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rcx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1

; 102  : }

	ret	0
??$swap@UHashValue@SarcFile@@$0A@@std@@YAXAEAUHashValue@SarcFile@@0@Z ENDP ; std::swap<SarcFile::HashValue,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEAUHashValue@SarcFile@@AEAPEAU01@$0A@@?$pair@PEAUHashValue@SarcFile@@PEAU12@@std@@QEAA@AEAPEAUHashValue@SarcFile@@0@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAUHashValue@SarcFile@@AEAPEAU01@$0A@@?$pair@PEAUHashValue@SarcFile@@PEAU12@@std@@QEAA@AEAPEAUHashValue@SarcFile@@0@Z PROC ; std::pair<SarcFile::HashValue *,SarcFile::HashValue *>::pair<SarcFile::HashValue *,SarcFile::HashValue *><SarcFile::HashValue * &,SarcFile::HashValue * &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAUHashValue@SarcFile@@AEAPEAU01@$0A@@?$pair@PEAUHashValue@SarcFile@@PEAU12@@std@@QEAA@AEAPEAUHashValue@SarcFile@@0@Z ENDP ; std::pair<SarcFile::HashValue *,SarcFile::HashValue *>::pair<SarcFile::HashValue *,SarcFile::HashValue *><SarcFile::HashValue * &,SarcFile::HashValue * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UHashValue@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UHashValue@SarcFile@@@1@QEAUHashValue@SarcFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UHashValue@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UHashValue@SarcFile@@@1@QEAUHashValue@SarcFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::construct<SarcFile::HashValue>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UHashValue@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UHashValue@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UHashValue@SarcFile@@@1@QEAUHashValue@SarcFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::HashValue> >::construct<SarcFile::HashValue>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UNode@SarcFile@@@std@@YAPEAUNode@SarcFile@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UNode@SarcFile@@@std@@YAPEAUNode@SarcFile@@PEAU12@@Z PROC ; std::_Unfancy<SarcFile::Node>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UNode@SarcFile@@@std@@YAPEAUNode@SarcFile@@PEAU12@@Z ENDP ; std::_Unfancy<SarcFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNode@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UNode@SarcFile@@@1@QEAUNode@SarcFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UNode@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UNode@SarcFile@@@1@QEAUNode@SarcFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::construct<SarcFile::Node>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rdx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UNode@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UNode@SarcFile@@@1@QEAUNode@SarcFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Node> >::construct<SarcFile::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z PROC ; std::move<SarcFile::Entry &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z ENDP ; std::move<SarcFile::Entry &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UEntry@SarcFile@@@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX$$QEAUEntry@SarcFile@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UEntry@SarcFile@@@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX$$QEAUEntry@SarcFile@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<SarcFile::Entry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r11d, r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1801 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	mov	r9, rdx
	xorps	xmm0, xmm0
	mov	r10, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [r8], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [r8+16], r11

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [r8+24], r11

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [r8+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r11b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rdx+48]
	mov	rcx, QWORD PTR [r9+40]
	mov	rax, QWORD PTR [r9+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+48], r11
	mov	QWORD PTR [r9+40], r11
	mov	QWORD PTR [r9+32], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+32], rax
	mov	QWORD PTR [r8+40], rcx
	mov	QWORD PTR [r8+48], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [r10+8], 56			; 00000038H

; 1804 :     }

	ret	0
??$_Emplace_back@UEntry@SarcFile@@@?$_Uninitialized_backout_al@V?$allocator@UEntry@SarcFile@@@std@@@std@@QEAAX$$QEAUEntry@SarcFile@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SarcFile::Entry> >::_Emplace_back<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UEntry@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UEntry@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR [rdx+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UEntry@SarcFile@@$$V@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_backward_memmove@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z PROC ; std::_Copy_backward_memmove<SarcFile::HashValue *,SarcFile::HashValue *>, COMDAT

; 4834 :     // implement copy_backward-like function as memmove
; 4835 :     auto _FirstPtr              = _To_address(_First);
; 4836 :     auto _LastPtr               = _To_address(_Last);
; 4837 :     auto _DestPtr               = _To_address(_Dest);
; 4838 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4839 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4840 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx
	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Copy_backward_memmove@PEAUHashValue@SarcFile@@PEAU12@@std@@YAPEAUHashValue@SarcFile@@PEAU12@00@Z ENDP ; std::_Copy_backward_memmove<SarcFile::HashValue *,SarcFile::HashValue *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAUHashValue@SarcFile@@@std@@YA?A_PAEBQEAUHashValue@SarcFile@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUHashValue@SarcFile@@@std@@YA?A_PAEBQEAUHashValue@SarcFile@@@Z PROC ; std::_To_address<SarcFile::HashValue *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAUHashValue@SarcFile@@@std@@YA?A_PAEBQEAUHashValue@SarcFile@@@Z ENDP ; std::_To_address<SarcFile::HashValue *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z PROC ; std::forward<SarcFile::HashValue>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UHashValue@SarcFile@@@std@@YA$$QEAUHashValue@SarcFile@@AEAU12@@Z ENDP ; std::forward<SarcFile::HashValue>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Hole$ = 16
_Top$ = 24
_Val$ = 32
_Pred$dead$ = 40
??$_Push_heap_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Push_heap_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6325 :     // percolate _Hole to _Top or where _Val belongs
; 6326 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6327 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	rax, QWORD PTR [rdx-1]
	mov	r10, rcx
	sar	rax, 1

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	r8, rdx
	jge	SHORT $LN3@Push_heap_
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	r11d, DWORD PTR [r9]
$LL4@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	rcx, rax
	add	rcx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	cmp	DWORD PTR [r10+rcx*8], r11d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6328 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	jae	SHORT $LN3@Push_heap_

; 6329 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6330 :         // move _Hole up to parent
; 6331 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	movups	xmm0, XMMWORD PTR [r10+rcx*8]
	add	rdx, rdx
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6332 :         _Hole             = _Idx;

	mov	rdx, rax
	dec	rax
	sar	rax, 1
	cmp	r8, rdx
	jl	SHORT $LL4@Push_heap_
$LN3@Push_heap_:

; 6333 :     }
; 6334 : 
; 6335 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	movups	xmm0, XMMWORD PTR [r9]
	add	rdx, rdx
	movups	XMMWORD PTR [r10+rdx*8], xmm0

; 6336 : }

	ret	0
??$_Push_heap_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Push_heap_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Val$ = 32
_Pred$ = 40
??$_Pop_heap_hole_unchecked@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Pop_heap_hole_unchecked<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT

; 6462 :     // pop *_First to *_Dest and reheap
; 6463 :     // precondition: _First != _Last
; 6464 :     // precondition: _First != _Dest
; 6465 :     *_Dest      = _STD move(*_First);

	movups	xmm0, XMMWORD PTR [rcx]

; 6466 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6467 :     _STD _Pop_heap_hole_by_index(

	movzx	eax, BYTE PTR _Pred$[rsp]
	sub	rdx, rcx
	sar	rdx, 4
	movups	XMMWORD PTR [r8], xmm0
	mov	r8, rdx
	mov	BYTE PTR _Pred$[rsp], al
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@_J1$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ; std::_Pop_heap_hole_by_index<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >
??$_Pop_heap_hole_unchecked@PEAUHashValue@SarcFile@@U12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00$$QEAU12@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Pop_heap_hole_unchecked<SarcFile::HashValue *,SarcFile::HashValue,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Med3_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z
_TEXT	SEGMENT
_First$ = 8
_Mid$ = 16
_Last$ = 24
_Pred$dead$ = 32
??$_Med3_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z PROC ; std::_Med3_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7931 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN9@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	xmm1, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN9@Med3_unche:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [r8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7935 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	jae	SHORT $LN17@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm1, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r8], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\SARC.cpp

; 227  :     std::sort(Keys.begin(), Keys.end(), [](const SarcFile::HashValue& a, const SarcFile::HashValue& b) { return a.Hash < b.Hash; });

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR [rdx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7938 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	jae	SHORT $LN17@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rcx], xmm1
$LN17@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 7942 : }

	ret	0
??$_Med3_unchecked@PEAUHashValue@SarcFile@@V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ@@std@@YAXPEAUHashValue@SarcFile@@00V<lambda_1>@?1??ToBinary@2@QEAA?AV?$vector@EV?$allocator@E@std@@@0@XZ@@Z ENDP ; std::_Med3_unchecked<SarcFile::HashValue *,`SarcFile::ToBinary'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAUHashValue@SarcFile@@@std@@YAAEAPEAUHashValue@SarcFile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUHashValue@SarcFile@@@std@@YAAEAPEAUHashValue@SarcFile@@AEAPEAU12@@Z PROC ; std::forward<SarcFile::HashValue * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAUHashValue@SarcFile@@@std@@YAAEAPEAUHashValue@SarcFile@@AEAPEAU12@@Z ENDP ; std::forward<SarcFile::HashValue * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UHashValue@SarcFile@@$$V$0A@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UHashValue@SarcFile@@$$V$0A@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z PROC ; std::construct_at<SarcFile::HashValue,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UHashValue@SarcFile@@$$V$0A@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z ENDP ; std::construct_at<SarcFile::HashValue,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNode@SarcFile@@$$V$0A@@std@@YAPEAUNode@SarcFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UNode@SarcFile@@$$V$0A@@std@@YAPEAUNode@SarcFile@@QEAU12@@Z PROC ; std::construct_at<SarcFile::Node,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0

; 242  : }

	ret	0
??$construct_at@UNode@SarcFile@@$$V$0A@@std@@YAPEAUNode@SarcFile@@QEAU12@@Z ENDP ; std::construct_at<SarcFile::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z PROC ; std::forward<SarcFile::Entry>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UEntry@SarcFile@@@std@@YA$$QEAUEntry@SarcFile@@AEAU12@@Z ENDP ; std::forward<SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UEntry@SarcFile@@U12@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UEntry@SarcFile@@U12@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry,SarcFile::Entry>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	r9, rdx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rdx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rdx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rdx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+24], 15
	mov	BYTE PTR [r8], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [r8+48]
	mov	rcx, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [r8+32]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
	mov	QWORD PTR [r8+32], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+32], rax
	mov	QWORD PTR [r9+40], rcx
	mov	QWORD PTR [r9+48], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UEntry@SarcFile@@U12@@?$_Default_allocator_traits@V?$allocator@UEntry@SarcFile@@@std@@@std@@SAXAEAV?$allocator@UEntry@SarcFile@@@1@QEAUEntry@SarcFile@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SarcFile::Entry> >::construct<SarcFile::Entry,SarcFile::Entry>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UEntry@SarcFile@@$$V$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UEntry@SarcFile@@$$V$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@@Z PROC ; std::construct_at<SarcFile::Entry,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@UEntry@SarcFile@@$$V$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@@Z ENDP ; std::construct_at<SarcFile::Entry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z PROC ; std::to_address<SarcFile::HashValue>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@UHashValue@SarcFile@@@std@@YAPEAUHashValue@SarcFile@@QEAU12@@Z ENDP ; std::to_address<SarcFile::HashValue>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UEntry@SarcFile@@U12@$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UEntry@SarcFile@@U12@$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<SarcFile::Entry,SarcFile::Entry,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+32]
	mov	rdx, QWORD PTR [rdx+48]
	mov	rcx, QWORD PTR [r8+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
	mov	QWORD PTR [r8+32], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+40], rcx
	mov	QWORD PTR [r9+48], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UEntry@SarcFile@@U12@$0A@@std@@YAPEAUEntry@SarcFile@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<SarcFile::Entry,SarcFile::Entry,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0Entry@SarcFile@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Entry@SarcFile@@QEAA@$$QEAU01@@Z PROC		; SarcFile::Entry::Entry, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	r8, rdx
	mov	r9, rcx
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR [rcx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR [rcx+16], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR [rcx+24], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 697  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], 15
	mov	BYTE PTR [rdx], r10b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8+32]
	mov	rdx, QWORD PTR [rdx+48]
	mov	rcx, QWORD PTR [r8+40]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+48], r10
	mov	QWORD PTR [r8+40], r10
	mov	QWORD PTR [r8+32], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r9+32], rax
	mov	rax, r9
	mov	QWORD PTR [r9+40], rcx
	mov	QWORD PTR [r9+48], rdx
	ret	0
??0Entry@SarcFile@@QEAA@$$QEAU01@@Z ENDP		; SarcFile::Entry::Entry
_TEXT	ENDS
END
