; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@LODKKDJJ@?$CD?$CDInstances@		; `string'
PUBLIC	??_C@_0O@BMOANCPA@?$CD?$CDContextMenu@		; `string'
PUBLIC	??_C@_01DNKMNLPK@?$HM@				; `string'
PUBLIC	??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd@		; `string'
PUBLIC	??_C@_09MGFHLAFE@?$DMUnknown?$DO@		; `string'
PUBLIC	??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn@		; `string'
PUBLIC	??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf@		; `string'
PUBLIC	??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn@		; `string'
PUBLIC	??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn@	; `string'
PUBLIC	??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn@	; `string'
PUBLIC	??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn@		; `string'
PUBLIC	??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn@	; `string'
PUBLIC	??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn@		; `string'
PUBLIC	??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6@		; `string'
PUBLIC	??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6@ ; `string'
PUBLIC	??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X@		; `string'
PUBLIC	??_C@_0M@JLNIJDCE@Column?5?$CF?92d@		; `string'
PUBLIC	??_C@_09PBOBBCAP@?5Width?$DN?$CFd@		; `string'
PUBLIC	??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f@		; `string'
PUBLIC	??_C@_09CFPCIBAG@?5Order?$DN?$CFd@		; `string'
PUBLIC	??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd@		; `string'
PUBLIC	??_C@_08CCPMLANI@FixedFit@			; `string'
PUBLIC	??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc@		; `string'
PUBLIC	??_C@_0M@IGAOBHEB@StretchProp@			; `string'
PUBLIC	??_C@_09OOODJBFG@FixedSame@			; `string'
PUBLIC	??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CF@ ; `string'
PUBLIC	??_C@_0M@LHDDKHJK@StretchSame@			; `string'
PUBLIC	??_C@_0P@MDFKNKGM@Clear?5settings@		; `string'
PUBLIC	??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5@ ; `string'
PUBLIC	??_C@_07IOPDKCEG@?5?$CIauto?$CJ@		; `string'
PUBLIC	??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Siz@ ; `string'
PUBLIC	??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacing@ ; `string'
PUBLIC	??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Column@ ; `string'
PUBLIC	??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColum@ ; `string'
PUBLIC	??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredC@ ; `string'
PUBLIC	??_C@_09BHNPHONE@NoResize?5@			; `string'
PUBLIC	??_C@_0DD@FILHJAIB@Instance?5?$CFd?3?5HoveredRow?3?5?$CFd?0?5La@ ; `string'
PUBLIC	??_C@_0O@PEPBBILL@WidthStretch?5@		; `string'
PUBLIC	??_C@_0M@IGDNFKMD@WidthFixed?5@			; `string'
PUBLIC	??_C@_06PFKLCOBM@?5?$CIDes?$CJ@			; `string'
PUBLIC	??_C@_06FEBPAKFP@?5?$CIAsc?$CJ@			; `string'
PUBLIC	??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset@ ; `string'
PUBLIC	??_C@_09LODDIFJL@?5?$CIFrozen?$CJ@		; `string'
PUBLIC	??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X@	; `string'
PUBLIC	??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ@ ; `string'
PUBLIC	??_C@_06ODJMJFLN@Weight@			; `string'
PUBLIC	??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_03OFHEPBNG@Asc@				; `string'
PUBLIC	??_C@_06PALFPBFG@Width?5@			; `string'
PUBLIC	??_C@_03JMFMNIFM@?9?9?9@			; `string'
PUBLIC	??_C@_03IAMDMMHH@Des@				; `string'
PUBLIC	??_C@_07HIFEPIJN@columns@			; `string'
PUBLIC	??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd@ ; `string'
;	COMDAT ??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd@
CONST	SEGMENT
??_C@_0EB@CNABLLAJ@Column?5?$CFd?5Order?5?$CFd?5SortOrder?5?$CFd@ DB 'Col'
	DB	'umn %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IAMDMMHH@Des@
CONST	SEGMENT
??_C@_03IAMDMMHH@Des@ DB 'Des', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JMFMNIFM@?9?9?9@
CONST	SEGMENT
??_C@_03JMFMNIFM@?9?9?9@ DB '---', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PALFPBFG@Width?5@
CONST	SEGMENT
??_C@_06PALFPBFG@Width?5@ DB 'Width ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFHEPBNG@Asc@
CONST	SEGMENT
??_C@_03OFHEPBNG@Asc@ DB 'Asc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BK@OLKPLDMA@ColumnsCount?3?5?$CFd?5?$CImax?5?$CFd?$CJ@ DB 'Columns'
	DB	'Count: %d (max %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODJMJFLN@Weight@
CONST	SEGMENT
??_C@_06ODJMJFLN@Weight@ DB 'Weight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ@
CONST	SEGMENT
??_C@_0BN@LNKMILO@Settings?50x?$CF08X?5?$CI?$CFd?5columns?$CJ@ DB 'Settin'
	DB	'gs 0x%08X (%d columns)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X@
CONST	SEGMENT
??_C@_0BC@LJHOAHJA@SaveFlags?3?50x?$CF08X@ DB 'SaveFlags: 0x%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LODDIFJL@?5?$CIFrozen?$CJ@
CONST	SEGMENT
??_C@_09LODDIFJL@?5?$CIFrozen?$CJ@ DB ' (Frozen)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset@
CONST	SEGMENT
??_C@_0BHH@CNHMONCM@Column?5?$CFd?5order?5?$CFd?5?8?$CFs?8?3?5offset@ DB 'C'
	DB	'olumn %d order %d ''%s'': offset %+.2f to %+.2f%s', 0aH, 'Ena'
	DB	'bled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d'
	DB	', DrawChannels: %d,%d', 0aH, 'WidthGiven: %.1f, Request/Auto:'
	DB	' %.1f/%.1f, StretchWeight: %.3f (%.1f%%)', 0aH, 'MinX: %.1f, '
	DB	'MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)', 0aH, 'Co'
	DB	'ntentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f', 0aH, 'So'
	DB	'rt: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEBPAKFP@?5?$CIAsc?$CJ@
CONST	SEGMENT
??_C@_06FEBPAKFP@?5?$CIAsc?$CJ@ DB ' (Asc)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PFKLCOBM@?5?$CIDes?$CJ@
CONST	SEGMENT
??_C@_06PFKLCOBM@?5?$CIDes?$CJ@ DB ' (Des)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGDNFKMD@WidthFixed?5@
CONST	SEGMENT
??_C@_0M@IGDNFKMD@WidthFixed?5@ DB 'WidthFixed ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEPBBILL@WidthStretch?5@
CONST	SEGMENT
??_C@_0O@PEPBBILL@WidthStretch?5@ DB 'WidthStretch ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FILHJAIB@Instance?5?$CFd?3?5HoveredRow?3?5?$CFd?0?5La@
CONST	SEGMENT
??_C@_0DD@FILHJAIB@Instance?5?$CFd?3?5HoveredRow?3?5?$CFd?0?5La@ DB 'Inst'
	DB	'ance %d: HoveredRow: %d, LastOuterHeight: %.2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BHNPHONE@NoResize?5@
CONST	SEGMENT
??_C@_09BHNPHONE@NoResize?5@ DB 'NoResize ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredC@
CONST	SEGMENT
??_C@_0CP@NOMNLPPG@HoveredColumnBody?3?5?$CFd?0?5HoveredC@ DB 'HoveredCol'
	DB	'umnBody: %d, HoveredColumnBorder: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColum@
CONST	SEGMENT
??_C@_0DL@PBPICJCB@ResizedColumn?3?5?$CFd?0?5ReorderColum@ DB 'ResizedCol'
	DB	'umn: %d, ReorderColumn: %d, HeldHeaderColumn: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Column@
CONST	SEGMENT
??_C@_0EH@GODPECNO@ColumnsGivenWidth?3?5?$CF?41f?0?5Column@ DB 'ColumnsGi'
	DB	'venWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacing@
CONST	SEGMENT
??_C@_0EB@FOKPBOFF@CellPaddingX?3?5?$CF?41f?0?5CellSpacing@ DB 'CellPaddi'
	DB	'ngX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Siz@
CONST	SEGMENT
??_C@_0DL@BMMMGOOI@OuterRect?3?5Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?5Siz@ DB 'O'
	DB	'uterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOPDKCEG@?5?$CIauto?$CJ@
CONST	SEGMENT
??_C@_07IOPDKCEG@?5?$CIauto?$CJ@ DB ' (auto)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5@
CONST	SEGMENT
??_C@_0EM@JLKLPOOK@?$CK?$CK?5?$CFd?5instances?5of?5same?5table?$CB?5@ DB '*'
	DB	'* %d instances of same table! Some data below will refer to l'
	DB	'ast instance.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDFKNKGM@Clear?5settings@
CONST	SEGMENT
??_C@_0P@MDFKNKGM@Clear?5settings@ DB 'Clear settings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHDDKHJK@StretchSame@
CONST	SEGMENT
??_C@_0M@LHDDKHJK@StretchSame@ DB 'StretchSame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CF@
CONST	SEGMENT
??_C@_0CF@DAHKPIHJ@Table?50x?$CF08X?5?$CI?$CFd?5columns?0?5in?5?8?$CF@ DB 'T'
	DB	'able 0x%08X (%d columns, in ''%s'')%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOODJBFG@FixedSame@
CONST	SEGMENT
??_C@_09OOODJBFG@FixedSame@ DB 'FixedSame', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGAOBHEB@StretchProp@
CONST	SEGMENT
??_C@_0M@IGAOBHEB@StretchProp@ DB 'StretchProp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc@
CONST	SEGMENT
??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc@ DB ' Sort=%d%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCPMLANI@FixedFit@
CONST	SEGMENT
??_C@_08CCPMLANI@FixedFit@ DB 'FixedFit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd@
CONST	SEGMENT
??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd@ DB ' Visible=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFPCIBAG@?5Order?$DN?$CFd@
CONST	SEGMENT
??_C@_09CFPCIBAG@?5Order?$DN?$CFd@ DB ' Order=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f@
CONST	SEGMENT
??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f@ DB ' Weight=%.4f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBOBBCAP@?5Width?$DN?$CFd@
CONST	SEGMENT
??_C@_09PBOBBCAP@?5Width?$DN?$CFd@ DB ' Width=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JLNIJDCE@Column?5?$CF?92d@
CONST	SEGMENT
??_C@_0M@JLNIJDCE@Column?5?$CF?92d@ DB 'Column %-2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X@
CONST	SEGMENT
??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X@ DB ' UserID=%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6@
CONST	SEGMENT
??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6@ DB '[%s][0x%08'
	DB	'X,%d]', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6@
CONST	SEGMENT
??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6@ DB 'RefScale=%g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn@
CONST	SEGMENT
??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn@ DB 'Order=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn@
CONST	SEGMENT
??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn@ DB 'Sort=%d%c%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn@
CONST	SEGMENT
??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn@ DB 'Weight=%f%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn@
CONST	SEGMENT
??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn@ DB 'Visible=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn@
CONST	SEGMENT
??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn@ DB 'UserID=0x%08X%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn@
CONST	SEGMENT
??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn@ DB 'Width=%d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf@
CONST	SEGMENT
??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf@ DB 'RefScale=%f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn@
CONST	SEGMENT
??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn@ DB 'Column %d%n', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MGFHLAFE@?$DMUnknown?$DO@
CONST	SEGMENT
??_C@_09MGFHLAFE@?$DMUnknown?$DO@ DB '<Unknown>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd@
CONST	SEGMENT
??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd@ DB '0x%08X,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM@ DB '|', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BMOANCPA@?$CD?$CDContextMenu@
CONST	SEGMENT
??_C@_0O@BMOANCPA@?$CD?$CDContextMenu@ DB '##ContextMenu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LODKKDJJ@?$CD?$CDInstances@
CONST	SEGMENT
??_C@_0M@LODKKDJJ@?$CD?$CDInstances@ DB '##Instances', 00H ; `string'
PUBLIC	?swap@?$ImVector@D@@QEAAXAEAU1@@Z		; ImVector<char>::swap
PUBLIC	?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ; ImVector<ImGuiOldColumnData>::_grow_capacity
PUBLIC	?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z ; ImVector<ImGuiOldColumns>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z ; ImVector<ImGuiOldColumns>::reserve
PUBLIC	??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>
PUBLIC	?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z ; ImVector<ImGuiOldColumnData>::push_back
PUBLIC	?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ; ImPool<ImGuiTable>::GetIndex
PUBLIC	?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ ; ImChunkStream<ImGuiTableSettings>::clear
PUBLIC	?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
PUBLIC	?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z ; ImChunkStream<ImGuiTableSettings>::swap
PUBLIC	?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ ; ImVector<ImGuiOldColumns>::back
PUBLIC	?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z ; ImVector<ImGuiOldColumns>::push_back
PUBLIC	??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ; ImSpan<ImGuiTableColumn>::operator[]
PUBLIC	??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ; ImSpan<ImGuiTableCellData>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ ; ImVector<ImGuiTableColumnSortSpecs>::clear
PUBLIC	?BeginColumns@ImGui@@YAXPEBDHH@Z		; ImGui::BeginColumns
PUBLIC	?GetColumnsID@ImGui@@YAIPEBDH@Z			; ImGui::GetColumnsID
PUBLIC	?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns
PUBLIC	?PopColumnsBackground@ImGui@@YAXXZ		; ImGui::PopColumnsBackground
PUBLIC	?PushColumnsBackground@ImGui@@YAXXZ		; ImGui::PushColumnsBackground
PUBLIC	?PushColumnClipRect@ImGui@@YAXH@Z		; ImGui::PushColumnClipRect
PUBLIC	?SetColumnWidth@ImGui@@YAXHM@Z			; ImGui::SetColumnWidth
PUBLIC	?SetColumnOffset@ImGui@@YAXHM@Z			; ImGui::SetColumnOffset
PUBLIC	?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnNormFromOffset
PUBLIC	?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ; ImGui::SetWindowClipRectBeforeSetChannel
PUBLIC	?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ; ImGui::TableSettingsFindByID
PUBLIC	?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ; ImGui::TableSettingsCreate
PUBLIC	?TablePopBackgroundChannel@ImGui@@YAXXZ		; ImGui::TablePopBackgroundChannel
PUBLIC	?TablePushBackgroundChannel@ImGui@@YAXXZ	; ImGui::TablePushBackgroundChannel
PUBLIC	?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableEndCell
PUBLIC	?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ; ImGui::TableGetCellBgRect
PUBLIC	?ItemSize@ImGui@@YAXAEBUImRect@@M@Z		; ImGui::ItemSize
PUBLIC	?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ; ImGuiTableSettings::GetColumnSettings
PUBLIC	??0ImGuiTableSettings@@QEAA@XZ			; ImGuiTableSettings::ImGuiTableSettings
PUBLIC	??0ImGuiTableColumnSettings@@QEAA@XZ		; ImGuiTableColumnSettings::ImGuiTableColumnSettings
PUBLIC	??0ImGuiOldColumns@@QEAA@XZ			; ImGuiOldColumns::ImGuiOldColumns
PUBLIC	??0ImGuiOldColumnData@@QEAA@XZ			; ImGuiOldColumnData::ImGuiOldColumnData
PUBLIC	?GetColumnWidth@ImGui@@YAMH@Z			; ImGui::GetColumnWidth
PUBLIC	?GetColumnOffset@ImGui@@YAMH@Z			; ImGui::GetColumnOffset
PUBLIC	?NextColumn@ImGui@@YAXXZ			; ImGui::NextColumn
PUBLIC	?Columns@ImGui@@YAXHPEBD_N@Z			; ImGui::Columns
PUBLIC	?EndColumns@ImGui@@YAXXZ			; ImGui::EndColumns
PUBLIC	?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ; ImGui::GetColumnOffsetFromNorm
PUBLIC	?TableGcCompactSettings@ImGui@@YAXXZ		; ImGui::TableGcCompactSettings
PUBLIC	?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableGcCompactTransientBuffers
PUBLIC	?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z ; ImGui::TableGcCompactTransientBuffers
PUBLIC	?TableSettingsAddSettingsHandler@ImGui@@YAXXZ	; ImGui::TableSettingsAddSettingsHandler
PUBLIC	?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z	; ImGui::TableEndRow
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+132
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD imagerel $LN26+132
	DD	imagerel $LN26+143
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN26+28
	DD	imagerel $LN26+126
	DD	imagerel $chain$0$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD imagerel $LN26+126
	DD	imagerel $LN26+137
	DD	imagerel $chain$1$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z DD imagerel $LN11
	DD	imagerel $LN11+114
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+63
	DD	imagerel $unwind$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+119
	DD	imagerel $unwind$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD imagerel $LN35+72
	DD	imagerel $LN35+179
	DD	imagerel $chain$0$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD imagerel $LN35+179
	DD	imagerel $LN35+298
	DD	imagerel $chain$1$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BeginColumns@ImGui@@YAXPEBDHH@Z DD imagerel $LN184
	DD	imagerel $LN184+1569
	DD	imagerel $unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetColumnsID@ImGui@@YAIPEBDH@Z DD imagerel $LN18
	DD	imagerel $LN18+174
	DD	imagerel $unwind$?GetColumnsID@ImGui@@YAIPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD imagerel $LN104
	DD	imagerel $LN104+552
	DD	imagerel $unwind$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PopColumnsBackground@ImGui@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$?PopColumnsBackground@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PushColumnsBackground@ImGui@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+205
	DD	imagerel $unwind$?PushColumnsBackground@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetColumnOffset@ImGui@@YAXHM@Z DD imagerel $LN58
	DD	imagerel $LN58+301
	DD	imagerel $unwind$?SetColumnOffset@ImGui@@YAXHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD imagerel $LN8
	DD	imagerel $LN8+127
	DD	imagerel $unwind$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel $unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+59
	DD	imagerel $chain$0$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+59
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+920
	DD	imagerel $chain$6$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+920
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+925
	DD	imagerel $chain$7$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+925
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+932
	DD	imagerel $chain$8$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+144
	DD	imagerel $unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+144
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+588
	DD	imagerel $chain$0$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+588
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+643
	DD	imagerel $chain$1$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z DD imagerel ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z+247
	DD	imagerel $unwind$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD imagerel ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
	DD	imagerel ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z+151
	DD	imagerel $unwind$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
	DD	imagerel ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z+353
	DD	imagerel $unwind$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TablePopBackgroundChannel@ImGui@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+204
	DD	imagerel $unwind$?TablePopBackgroundChannel@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TablePushBackgroundChannel@ImGui@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+210
	DD	imagerel $unwind$?TablePushBackgroundChannel@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75
	DD	imagerel $LN75+51
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+51
	DD	imagerel $LN75+136
	DD	imagerel $chain$0$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+136
	DD	imagerel $LN75+139
	DD	imagerel $chain$2$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+139
	DD	imagerel $LN75+633
	DD	imagerel $chain$5$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+633
	DD	imagerel $LN75+765
	DD	imagerel $chain$6$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+765
	DD	imagerel $LN75+770
	DD	imagerel $chain$7$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?NextColumn@ImGui@@YAXXZ DD imagerel $LN75+770
	DD	imagerel $LN75+781
	DD	imagerel $chain$8$?NextColumn@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Columns@ImGui@@YAXHPEBD_N@Z DD imagerel $LN12
	DD	imagerel $LN12+100
	DD	imagerel $unwind$?Columns@ImGui@@YAXHPEBD_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146
	DD	imagerel $LN146+32
	DD	imagerel $unwind$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+32
	DD	imagerel $LN146+241
	DD	imagerel $chain$3$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+241
	DD	imagerel $LN146+300
	DD	imagerel $chain$6$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+300
	DD	imagerel $LN146+868
	DD	imagerel $chain$13$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+868
	DD	imagerel $LN146+1156
	DD	imagerel $chain$14$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+1156
	DD	imagerel $LN146+1181
	DD	imagerel $chain$15$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+1181
	DD	imagerel $LN146+1324
	DD	imagerel $chain$16$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$?EndColumns@ImGui@@YAXXZ DD imagerel $LN146+1324
	DD	imagerel $LN146+1390
	DD	imagerel $chain$17$?EndColumns@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactSettings@ImGui@@YAXXZ DD imagerel $LN116
	DD	imagerel $LN116+591
	DD	imagerel $unwind$?TableGcCompactSettings@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN46
	DD	imagerel $LN46+249
	DD	imagerel $unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ DD imagerel $LN28
	DD	imagerel $LN28+207
	DD	imagerel $unwind$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299
	DD	imagerel $LN299+37
	DD	imagerel $unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+37
	DD	imagerel $LN299+49
	DD	imagerel $chain$2$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+49
	DD	imagerel $LN299+642
	DD	imagerel $chain$8$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+642
	DD	imagerel $LN299+1000
	DD	imagerel $chain$9$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+1000
	DD	imagerel $LN299+1191
	DD	imagerel $chain$11$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+1191
	DD	imagerel $LN299+1427
	DD	imagerel $chain$12$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+1427
	DD	imagerel $LN299+1685
	DD	imagerel $chain$13$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+1685
	DD	imagerel $LN299+1734
	DD	imagerel $chain$14$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+1734
	DD	imagerel $LN299+2181
	DD	imagerel $chain$15$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD imagerel $LN299+2181
	DD	imagerel $LN299+2209
	DD	imagerel $chain$16$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 021H
	DD	imagerel $LN299
	DD	imagerel $LN299+37
	DD	imagerel $unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 060021H
	DD	06b800H
	DD	01ad400H
	DD	021c400H
	DD	imagerel $LN299
	DD	imagerel $LN299+37
	DD	imagerel $unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 020021H
	DD	06b800H
	DD	imagerel $LN299+37
	DD	imagerel $LN299+49
	DD	imagerel $chain$2$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 021H
	DD	imagerel $LN299+49
	DD	imagerel $LN299+642
	DD	imagerel $chain$8$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 021H
	DD	imagerel $LN299+642
	DD	imagerel $LN299+1000
	DD	imagerel $chain$9$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 041421H
	DD	0a7814H
	DD	0b6808H
	DD	imagerel $LN299+642
	DD	imagerel $LN299+1000
	DD	imagerel $chain$9$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 020621H
	DD	07a806H
	DD	imagerel $LN299+49
	DD	imagerel $LN299+642
	DD	imagerel $chain$8$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 0c4021H
	DD	019e440H
	DD	01f6438H
	DD	06b81bH
	DD	089815H
	DD	098810H
	DD	018f404H
	DD	imagerel $LN299+37
	DD	imagerel $LN299+49
	DD	imagerel $chain$2$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 060c21H
	DD	01ad40cH
	DD	021c408H
	DD	0207404H
	DD	imagerel $LN299
	DD	imagerel $LN299+37
	DD	imagerel $unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z DD 041e19H
	DD	01b0110H
	DD	050043005H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsAddSettingsHandler@ImGui@@YAXXZ DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?TableGcCompactSettings@ImGui@@YAXXZ DB 06H
	DB	0e9H, 02H
	DB	02H
	DB	'M', 05H
	DB	04H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?TableGcCompactSettings@ImGui@@YAXXZ DB 04H
	DB	0aH
	DD	imagerel ??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
	DB	070H
	DB	03eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?TableGcCompactSettings@ImGui@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?TableGcCompactSettings@ImGui@@YAXXZ
	DD	imagerel $ip2state$?TableGcCompactSettings@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableGcCompactSettings@ImGui@@YAXXZ DD 0c2b19H
	DD	012641cH
	DD	011541cH
	DD	010341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?TableGcCompactSettings@ImGui@@YAXXZ
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$?EndColumns@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN146
	DD	imagerel $LN146+32
	DD	imagerel $unwind$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$?EndColumns@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN146+32
	DD	imagerel $LN146+241
	DD	imagerel $chain$3$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$?EndColumns@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN146+241
	DD	imagerel $LN146+300
	DD	imagerel $chain$6$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?EndColumns@ImGui@@YAXXZ DD 020021H
	DD	09a800H
	DD	imagerel $LN146+241
	DD	imagerel $LN146+300
	DD	imagerel $chain$6$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?EndColumns@ImGui@@YAXXZ DD 0e4721H
	DD	08b847H
	DD	09a835H
	DD	0d682cH
	DD	01cf420H
	DD	01de418H
	DD	01ed410H
	DD	01fc408H
	DD	imagerel $LN146+241
	DD	imagerel $LN146+300
	DD	imagerel $chain$6$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?EndColumns@ImGui@@YAXXZ DD 062321H
	DD	0a9823H
	DD	0207415H
	DD	0235408H
	DD	imagerel $LN146+32
	DD	imagerel $LN146+241
	DD	imagerel $chain$3$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EndColumns@ImGui@@YAXXZ DD 081e21H
	DD	0b881eH
	DD	0c7819H
	DD	0246408H
	DD	0223404H
	DD	imagerel $LN146
	DD	imagerel $LN146+32
	DD	imagerel $unwind$?EndColumns@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EndColumns@ImGui@@YAXXZ DD 021919H
	DD	021010aH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Columns@ImGui@@YAXHPEBD_N@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?NextColumn@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN75
	DD	imagerel $LN75+51
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?NextColumn@ImGui@@YAXXZ DD 021H
	DD	imagerel $LN75+136
	DD	imagerel $LN75+139
	DD	imagerel $chain$2$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?NextColumn@ImGui@@YAXXZ DD 040021H
	DD	037800H
	DD	046800H
	DD	imagerel $LN75+136
	DD	imagerel $LN75+139
	DD	imagerel $chain$2$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?NextColumn@ImGui@@YAXXZ DD 061321H
	DD	037813H
	DD	04680eH
	DD	0c5405H
	DD	imagerel $LN75+136
	DD	imagerel $LN75+139
	DD	imagerel $chain$2$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?NextColumn@ImGui@@YAXXZ DD 020021H
	DD	0d7400H
	DD	imagerel $LN75
	DD	imagerel $LN75+51
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?NextColumn@ImGui@@YAXXZ DD 020521H
	DD	0d7405H
	DD	imagerel $LN75
	DD	imagerel $LN75+51
	DD	imagerel $unwind$?NextColumn@ImGui@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NextColumn@ImGui@@YAXXZ DD 040a01H
	DD	0e340aH
	DD	06006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ItemSize@ImGui@@YAXAEBUImRect@@M@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TablePushBackgroundChannel@ImGui@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TablePopBackgroundChannel@ImGui@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z DD 036119H
	DD	063461H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD 021H
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+144
	DD	imagerel $unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD 020521H
	DD	0e3405H
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
	DD	imagerel ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z+144
	DD	imagerel $unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z DD 041919H
	DD	07004920bH
	DD	050026003H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 021H
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel $unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 021H
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+59
	DD	imagerel $chain$0$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 0c1c21H
	DD	04681cH
	DD	0af417H
	DD	0be410H
	DD	0cd40cH
	DD	0e6408H
	DD	0145404H
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+59
	DD	imagerel $chain$0$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 020421H
	DD	0dc404H
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
	DD	imagerel ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z+42
	DD	imagerel $unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z DD 031101H
	DD	0700de211H
	DD	0300cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetColumnOffset@ImGui@@YAXHM@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PushColumnsBackground@ImGui@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PopColumnsBackground@ImGui@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DB 04H
	DB	089H, 03H
	DB	02H
	DB	0edH, 02H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DB 06H
	DB	0aH
	DD	imagerel ??1ImGuiOldColumns@@QEAA@XZ
	DB	040H
	DB	03eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DB 028H
	DD	imagerel $stateUnwindMap$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
	DD	imagerel $ip2state$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z DD 091711H
	DD	01a6417H
	DD	0195417H
	DD	0183417H
	DD	0160117H
	DD	07010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetColumnsID@ImGui@@YAIPEBDH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BeginColumns@ImGui@@YAXPEBDHH@Z DD 0154019H
	DD	05a831H
	DD	06982bH
	DD	078826H
	DD	087821H
	DD	09681dH
	DD	01e3419H
	DD	0140119H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN35
	DD	imagerel $LN35+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
tv2341 = 48
tv2340 = 52
$T5 = 56
$T6 = 56
tv2370 = 64
window$1$ = 64
suffix$1$ = 72
c$7 = 72
clip_rect_vec4$8 = 72
$T9 = 72
$T10 = 72
cell_bg_rect$11 = 72
row_rect$12 = 72
$T13 = 72
__$ArrayPad$ = 88
table$ = 240
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z PROC		; ImGui::TableEndRow, COMDAT

; 1797 : {

$LN299:
	mov	r11, rsp
	push	rbp
	push	rbx
	lea	rbp, QWORD PTR [r11-95]
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-137], rax

; 1798 :     ImGuiContext& g = *GImGui;
; 1799 :     ImGuiWindow* window = g.CurrentWindow;
; 1800 :     IM_ASSERT(window == table->InnerWindow);
; 1801 :     IM_ASSERT(table->IsInsideRow);
; 1802 : 
; 1803 :     if (table->CurrentColumn != -1)

	cmp	DWORD PTR [rcx+116], -1
	mov	rbx, rcx
	mov	QWORD PTR [r11+24], rdi
	mov	QWORD PTR [r11+32], r12
	mov	QWORD PTR [r11-24], r13
	mov	QWORD PTR [r11-40], r15
	mov	r15, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	XMMWORD PTR [r11-88], xmm8
	movaps	XMMWORD PTR [r11-104], xmm9
	movaps	XMMWORD PTR [rsp+96], xmm11
	mov	r12, QWORD PTR [r15+16408]
	mov	QWORD PTR window$1$[rbp-137], r12
	je	SHORT $LN11@TableEndRo

; 1804 :         TableEndCell(table);

	call	?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ; ImGui::TableEndCell
$LN11@TableEndRo:

; 1805 : 
; 1806 :     // Logging
; 1807 :     if (g.LogEnabled)

	xor	r13d, r13d
	mov	QWORD PTR [rsp+248], rsi
	mov	QWORD PTR [rsp+200], r14
	cmp	BYTE PTR [r15+24256], r13b
	je	$LN235@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13376:     const char* suffix = g.LogNextSuffix;

	mov	rax, QWORD PTR [r15+24296]

; 3327 :     const char* text_display_end = text;

	lea	r14, OFFSET FLAT:??_C@_01DNKMNLPK@?$HM@

; 13375:     const char* prefix = g.LogNextPrefix;

	mov	rdx, QWORD PTR [r15+24288]

; 3327 :     const char* text_display_end = text;

	mov	rdi, r14

; 13373:     ImGuiWindow* window = g.CurrentWindow;

	mov	rsi, QWORD PTR [r15+16408]

; 13376:     const char* suffix = g.LogNextSuffix;

	mov	QWORD PTR suffix$1$[rbp-137], rax

; 13377:     g.LogNextPrefix = g.LogNextSuffix = NULL;

	mov	QWORD PTR [r15+24296], r13
	mov	QWORD PTR [r15+24288], r13

; 3331 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	r14, -1
	jae	SHORT $LN236@TableEndRo
$LL134@TableEndRo:
	movzx	ecx, BYTE PTR [rdi]
	test	cl, cl
	je	SHORT $LN236@TableEndRo
	lea	rax, QWORD PTR [rdi+1]
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN228@TableEndRo
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN236@TableEndRo
$LN228@TableEndRo:

; 3332 :         text_display_end++;

	mov	rdi, rax
	cmp	rax, -1
	jb	SHORT $LL134@TableEndRo
$LN236@TableEndRo:

; 13391:     if (prefix)

	mov	r12, -1
	test	rdx, rdx
	je	SHORT $LN121@TableEndRo

; 13392:         LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.

	mov	r8, r12
$LL233@TableEndRo:
	inc	r8
	cmp	BYTE PTR [rdx+r8], r13b
	jne	SHORT $LL233@TableEndRo
	add	r8, rdx
	xor	ecx, ecx
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN121@TableEndRo:

; 13393: 
; 13394:     // Re-adjust padding if we have popped out of our starting depth
; 13395:     if (g.LogDepthRef > window->DC.TreeDepth)

	mov	eax, DWORD PTR [rsi+448]
	mov	ecx, DWORD PTR [r15+24312]
	cmp	ecx, eax
	jle	SHORT $LN122@TableEndRo

; 13396:         g.LogDepthRef = window->DC.TreeDepth;

	mov	DWORD PTR [r15+24312], eax
	mov	ecx, eax
$LN122@TableEndRo:

; 13397:     const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

	mov	r13d, DWORD PTR [rsi+448]
	sub	r13d, ecx
	npad	8
$LL115@TableEndRo:

; 1854 :     const char* p = (const char*)memchr(str, '\n', str_end - str);

	mov	r8, rdi
	mov	edx, 10
	sub	r8, r14
	mov	rcx, r14
	call	memchr

; 1855 :     return p ? p : str_end;

	test	rax, rax
	mov	rsi, rdi
	cmovne	rsi, rax

; 13407:         if (line_start != line_end || !is_last_line)

	cmp	r14, rsi
	jne	SHORT $LN124@TableEndRo
	cmp	rsi, rdi
	je	SHORT $LN198@TableEndRo
$LN124@TableEndRo:

; 13408:         {
; 13409:             const int line_length = (int)(line_end - line_start);

	mov	r9d, esi

; 13410:             const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;

	lea	edx, DWORD PTR [r13*4]
	sub	r9d, r14d
	cmp	BYTE PTR [r15+24308], 0
	jne	SHORT $LN132@TableEndRo
	mov	edx, 1
$LN132@TableEndRo:

; 13411:             LogText("%*s%.*s", indentation, "", line_length, line_start);

	lea	r8, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR [rsp+32], r14
	lea	rcx, OFFSET FLAT:??_C@_07LFDEMEGD@?$CF?$CKs?$CF?4?$CKs@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText

; 13412:             g.LogLineFirstItem = false;

	mov	BYTE PTR [r15+24308], 0

; 13413:             if (*line_end == '\n')

	cmp	BYTE PTR [rsi], 10
	jne	SHORT $LN125@TableEndRo

; 13414:             {
; 13415:                 LogText(IM_NEWLINE);

	lea	rcx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6@
	call	?LogText@ImGui@@YAXPEBDZZ		; ImGui::LogText

; 13416:                 g.LogLineFirstItem = true;

	mov	BYTE PTR [r15+24308], 1
$LN125@TableEndRo:

; 13417:             }
; 13418:         }
; 13419:         if (is_last_line)

	cmp	rsi, rdi
	je	SHORT $LN198@TableEndRo

; 13420:             break;
; 13421:         text_remaining = line_end + 1;

	lea	r14, QWORD PTR [rsi+1]

; 13422:     }

	jmp	$LL115@TableEndRo
$LN198@TableEndRo:

; 13423: 
; 13424:     if (suffix)

	mov	rax, QWORD PTR suffix$1$[rbp-137]
	mov	r13d, 0
	test	rax, rax
	je	SHORT $LN237@TableEndRo
	npad	6
$LL232@TableEndRo:

; 13425:         LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));

	cmp	BYTE PTR [rax+r12+1], r13b
	lea	r12, QWORD PTR [r12+1]
	jne	SHORT $LL232@TableEndRo
	lea	r8, QWORD PTR [rax+r12]
	mov	rdx, rax
	xor	ecx, ecx
	call	?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z ; ImGui::LogRenderedText
$LN237@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1812 :     window->DC.CursorPos.y = table->RowPosY2;

	mov	r12, QWORD PTR window$1$[rbp-137]
$LN235@TableEndRo:
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [r12+316], eax

; 1813 : 
; 1814 :     // Row background fill
; 1815 :     const float bg_y1 = table->RowPosY1;
; 1816 :     const float bg_y2 = table->RowPosY2;
; 1817 :     const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);

	mov	eax, DWORD PTR [rbx+112]
	movsx	r9d, WORD PTR [rbx+540]
	movss	xmm9, DWORD PTR [rbx+124]
	movss	xmm8, DWORD PTR [rbx+128]
	mov	DWORD PTR tv2340[rbp-137], r9d
	lea	ecx, DWORD PTR [rax+1]
	mov	DWORD PTR tv2341[rbp-137], ecx

; 1818 :     const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);

	movsx	ecx, WORD PTR [rbx+538]
	mov	DWORD PTR tv2370[rbp-137], ecx

; 1819 :     if (table->CurrentRow == 0)

	test	eax, eax
	jne	SHORT $LN13@TableEndRo

; 1820 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFirstRowHeight = bg_y2 - bg_y1;

	movsx	eax, WORD PTR [rbx+120]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3394 :     inline ImGuiTableInstanceData*  TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }

	test	eax, eax
	jne	SHORT $LN142@TableEndRo
	lea	rax, QWORD PTR [rbx+416]
	jmp	SHORT $LN141@TableEndRo
$LN142@TableEndRo:
	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+448]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax+rdx*8]
$LN141@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1820 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFirstRowHeight = bg_y2 - bg_y1;

	movaps	xmm0, xmm8
	subss	xmm0, xmm9
	movss	DWORD PTR [rax+8], xmm0
$LN13@TableEndRo:

; 1821 : 
; 1822 :     const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);

	comiss	xmm8, DWORD PTR [rbx+284]
	movss	xmm11, DWORD PTR __real@3f800000
	jb	$LN239@TableEndRo
	movss	xmm0, DWORD PTR [rbx+292]
	comiss	xmm0, xmm9
	jb	$LN239@TableEndRo

; 1823 :     if (is_visible)
; 1824 :     {
; 1825 :         // Update data for TableGetHoveredRow()
; 1826 :         if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2)

	cmp	WORD PTR [rbx+512], -1
	movaps	XMMWORD PTR [rsp+112], xmm10
	je	SHORT $LN15@TableEndRo
	movss	xmm0, DWORD PTR [r15+3596]
	comiss	xmm0, xmm9
	jb	SHORT $LN15@TableEndRo
	comiss	xmm8, xmm0
	jbe	SHORT $LN15@TableEndRo

; 1827 :             TableGetInstanceData(table, table->InstanceCurrent)->HoveredRowNext = table->CurrentRow;

	movsx	eax, WORD PTR [rbx+120]
	mov	r8d, DWORD PTR [rbx+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3394 :     inline ImGuiTableInstanceData*  TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }

	test	eax, eax
	jne	SHORT $LN189@TableEndRo
	lea	rax, QWORD PTR [rbx+416]
	jmp	SHORT $LN188@TableEndRo
$LN189@TableEndRo:
	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+448]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax+rdx*8]
$LN188@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1827 :             TableGetInstanceData(table, table->InstanceCurrent)->HoveredRowNext = table->CurrentRow;

	mov	DWORD PTR [rax+20], r8d
$LN15@TableEndRo:

; 1828 : 
; 1829 :         // Decide of background color for the row
; 1830 :         ImU32 bg_col0 = 0;
; 1831 :         ImU32 bg_col1 = 0;
; 1832 :         if (table->RowBgColor[0] != IM_COL32_DISABLE)

	mov	eax, DWORD PTR [rbx+152]
	lea	r8, QWORD PTR [rbx+4]
	mov	r14d, r13d
	cmp	eax, 16777216				; 01000000H
	jne	SHORT $LN297@TableEndRo

; 1833 :             bg_col0 = table->RowBgColor[0];
; 1834 :         else if (table->Flags & ImGuiTableFlags_RowBg)

	test	BYTE PTR [r8], 64			; 00000040H
	je	SHORT $LN18@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1835 :             bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);

	mov	eax, DWORD PTR [rbx+148]
	and	eax, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 61					; 0000003dH
	add	rax, rax
	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
	movups	XMMWORD PTR c$7[rbp-137], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rbp-137]
	movss	DWORD PTR c$7[rbp-125], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
$LN297@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1836 :         if (table->RowBgColor[1] != IM_COL32_DISABLE)

	mov	r14d, eax
$LN18@TableEndRo:
	mov	edi, DWORD PTR [rbx+156]

; 1837 :             bg_col1 = table->RowBgColor[1];
; 1838 : 
; 1839 :         // Decide of top border color
; 1840 :         ImU32 border_col = 0;

	mov	r15d, r13d
	cmp	edi, 16777216				; 01000000H
	cmove	edi, r13d

; 1841 :         const float border_size = TABLE_BORDER_SIZE;
; 1842 :         if (table->CurrentRow > 0 || table->InnerWindow == table->OuterWindow)

	cmp	DWORD PTR [rbx+112], 0
	jg	SHORT $LN21@TableEndRo
	mov	rax, QWORD PTR [rbx+376]
	cmp	QWORD PTR [rbx+384], rax
	jne	SHORT $LN40@TableEndRo
$LN21@TableEndRo:

; 1843 :             if (table->Flags & ImGuiTableFlags_BordersInnerH)

	test	BYTE PTR [r8], 128			; 00000080H
	je	SHORT $LN40@TableEndRo

; 1844 :                 border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

	test	DWORD PTR [rbx+144], 65536		; 00010000H
	je	SHORT $LN39@TableEndRo
	mov	r15d, DWORD PTR [rbx+160]
	jmp	SHORT $LN40@TableEndRo
$LN39@TableEndRo:
	mov	r15d, DWORD PTR [rbx+164]
$LN40@TableEndRo:

; 1845 : 
; 1846 :         const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;

	movzx	esi, WORD PTR [rbx+546]

; 1847 :         const bool draw_strong_bottom_border = unfreeze_rows_actual;
; 1848 :         if ((bg_col0 | bg_col1 | border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)

	mov	eax, edi
	shr	si, 15
	or	eax, r15d
	xor	sil, 1
	or	eax, r14d
	jne	SHORT $LN24@TableEndRo
	cmp	DWORD PTR tv2341[rbp-137], r9d
	je	SHORT $LN24@TableEndRo
	test	sil, sil
	je	SHORT $LN23@TableEndRo
$LN24@TableEndRo:

; 1849 :         {
; 1850 :             // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
; 1851 :             // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
; 1852 :             if ((table->Flags & ImGuiTableFlags_NoClip) == 0)

	test	DWORD PTR [r8], 1048576			; 00100000H
	jne	SHORT $LN229@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movups	xmm0, XMMWORD PTR [rbx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1853 :                 window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();

	mov	rax, QWORD PTR [r12+728]
	movups	XMMWORD PTR $T13[rbp-137], xmm0
	movups	XMMWORD PTR [rax+136], xmm0
$LN229@TableEndRo:

; 1854 :             table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);

	mov	rdx, QWORD PTR [r12+728]
	xor	r8d, r8d
	mov	rcx, QWORD PTR [rbx+408]
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN23@TableEndRo:

; 1855 :         }
; 1856 : 
; 1857 :         // Draw row background
; 1858 :         // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
; 1859 :         if (bg_col0 || bg_col1)

	xorps	xmm10, xmm10
	test	r14d, r14d
	jne	SHORT $LN27@TableEndRo
	test	edi, edi
	je	$LN29@TableEndRo
$LN27@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rbx+264]
	movaps	XMMWORD PTR [rsp+176], xmm6
	movaps	xmm6, xmm9
	movaps	XMMWORD PTR [rsp+160], xmm7

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movaps	xmm7, xmm8

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm0, DWORD PTR [rbx+296]
	maxss	xmm6, DWORD PTR [rbx+300]

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm7, DWORD PTR [rbx+308]

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR row_rect$12[rbp-137], xmm0

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rbx+272]

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR row_rect$12[rbp-133], xmm6
	movss	DWORD PTR row_rect$12[rbp-125], xmm7

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm0, DWORD PTR [rbx+304]

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR row_rect$12[rbp-129], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1863 :             if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)

	test	r14d, r14d
	je	SHORT $LN28@TableEndRo
	comiss	xmm7, xmm6
	jbe	SHORT $LN28@TableEndRo

; 1864 :                 window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);

	mov	rcx, QWORD PTR [r12+728]
	lea	r8, QWORD PTR row_rect$12[rbp-129]
	mov	DWORD PTR [rsp+40], r13d
	lea	rdx, QWORD PTR row_rect$12[rbp-137]
	mov	r9d, r14d
	movss	DWORD PTR [rsp+32], xmm10
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN28@TableEndRo:

; 1865 :             if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)

	test	edi, edi
	je	SHORT $LN296@TableEndRo
	comiss	xmm7, xmm6
	jbe	SHORT $LN296@TableEndRo

; 1866 :                 window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);

	mov	rcx, QWORD PTR [r12+728]
	lea	r8, QWORD PTR row_rect$12[rbp-129]
	mov	DWORD PTR [rsp+40], r13d
	lea	rdx, QWORD PTR row_rect$12[rbp-137]
	mov	r9d, edi
	movss	DWORD PTR [rsp+32], xmm10
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN296@TableEndRo:
	movaps	xmm6, XMMWORD PTR [rsp+176]
	movaps	xmm7, XMMWORD PTR [rsp+160]
$LN29@TableEndRo:

; 1867 :         }
; 1868 : 
; 1869 :         // Draw cell background color
; 1870 :         if (draw_cell_bg_color)

	test	sil, sil
	je	$LN3@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	mov	rdi, QWORD PTR [rbx+56]
	movsx	rax, WORD PTR [rbx+546]
	lea	rsi, QWORD PTR [rdi+rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1873 :             for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)

	cmp	rdi, rsi
	ja	$LN3@TableEndRo
	npad	7
$LL4@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsx	rax, WORD PTR [rdi+4]

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rbx+124]
	maxss	xmm0, DWORD PTR [rbx+300]

; 623  :     inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	imul	rcx, rax, 112				; 00000070H

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR cell_bg_rect$11[rbp-133], xmm0

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	movss	xmm0, DWORD PTR [rbx+128]
	minss	xmm0, DWORD PTR [rbx+308]

; 623  :     inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	mov	rax, QWORD PTR [rbx+24]

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR cell_bg_rect$11[rbp-125], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1633 :     float x2 = column->MaxX;

	movss	xmm2, DWORD PTR [rcx+rax+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR [rcx+rax+8]

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	movaps	xmm3, xmm2

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, DWORD PTR [rbx+264]

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm3, DWORD PTR [rbx+272]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1880 :                 cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling

	movss	xmm4, DWORD PTR [rcx+rax+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	maxss	xmm1, DWORD PTR [rbx+296]

; 462  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }

	minss	xmm3, DWORD PTR [rbx+304]

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm4

; 546  :     void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.

	movss	DWORD PTR cell_bg_rect$11[rbp-129], xmm3
	movss	DWORD PTR cell_bg_rect$11[rbp-137], xmm1

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	jae	SHORT $LN89@TableEndRo
	movss	DWORD PTR cell_bg_rect$11[rbp-137], xmm4
$LN89@TableEndRo:

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm2, xmm3
	ja	SHORT $LN93@TableEndRo
	movss	DWORD PTR cell_bg_rect$11[rbp-129], xmm2
$LN93@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1882 :                 window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);

	mov	r9d, DWORD PTR [rdi]
	lea	r8, QWORD PTR cell_bg_rect$11[rbp-129]
	mov	rcx, QWORD PTR [r12+728]
	lea	rdx, QWORD PTR cell_bg_rect$11[rbp-137]
	mov	DWORD PTR [rsp+40], r13d
	movss	DWORD PTR [rsp+32], xmm10
	call	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	add	rdi, 8
	cmp	rdi, rsi
	jbe	$LL4@TableEndRo
$LN3@TableEndRo:
	movaps	xmm10, XMMWORD PTR [rsp+112]

; 1883 :             }
; 1884 :         }
; 1885 : 
; 1886 :         // Draw top border
; 1887 :         if (border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)

	test	r15d, r15d
	je	SHORT $LN31@TableEndRo
	comiss	xmm9, DWORD PTR [rbx+300]
	jb	SHORT $LN31@TableEndRo
	movss	xmm0, DWORD PTR [rbx+308]
	comiss	xmm0, xmm9
	jbe	SHORT $LN31@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+172]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1888 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

	lea	r8, QWORD PTR $T6[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+168]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1888 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

	lea	rdx, QWORD PTR $T10[rbp-137]
	mov	rcx, QWORD PTR [r12+728]
	mov	r9d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rbp-137], xmm0
	movss	DWORD PTR $T10[rbp-137], xmm1
	movss	DWORD PTR $T6[rbp-133], xmm9
	movss	DWORD PTR $T10[rbp-133], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1888 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

	movss	DWORD PTR [rsp+32], xmm11
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN31@TableEndRo:

; 1889 : 
; 1890 :         // Draw bottom border at the row unfreezing mark (always strong)
; 1891 :         if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)

	mov	edi, DWORD PTR tv2341[rbp-137]
	mov	r9d, DWORD PTR tv2340[rbp-137]
	cmp	edi, r9d
	jne	SHORT $LN32@TableEndRo
	comiss	xmm8, DWORD PTR [rbx+300]
	jb	SHORT $LN32@TableEndRo
	movss	xmm0, DWORD PTR [rbx+308]
	comiss	xmm0, xmm8
	jbe	SHORT $LN32@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm0, DWORD PTR [rbx+172]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1892 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);

	lea	r8, QWORD PTR $T9[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	xmm1, DWORD PTR [rbx+168]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1892 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);

	lea	rdx, QWORD PTR $T5[rbp-137]
	mov	r9d, DWORD PTR [rbx+160]
	mov	rcx, QWORD PTR [r12+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rbp-137], xmm0
	movss	DWORD PTR $T5[rbp-137], xmm1
	movss	DWORD PTR $T9[rbp-133], xmm8
	movss	DWORD PTR $T5[rbp-133], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1892 :             window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);

	movss	DWORD PTR [rsp+32], xmm11
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
	mov	r9d, DWORD PTR tv2340[rbp-137]
	jmp	SHORT $LN32@TableEndRo
$LN239@TableEndRo:

; 1893 :     }
; 1894 : 
; 1895 :     // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
; 1896 :     // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
; 1897 :     // get the new cursor position.
; 1898 :     if (unfreeze_rows_request)

	mov	edi, DWORD PTR tv2341[rbp-137]
$LN32@TableEndRo:
	movaps	xmm9, XMMWORD PTR [rsp+128]
	movaps	xmm8, XMMWORD PTR [rsp+144]
	mov	r15, QWORD PTR [rsp+192]
	mov	r14, QWORD PTR [rsp+200]
	mov	rsi, QWORD PTR [rsp+248]
	cmp	edi, DWORD PTR tv2370[rbp-137]
	jne	SHORT $LN6@TableEndRo

; 1899 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

	cmp	DWORD PTR [rbx+108], 0
	mov	edx, r13d
	jle	SHORT $LN6@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13388:         g.LogLineFirstItem = true;

	mov	rcx, r13
$LL7@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1900 :             table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;

	mov	rax, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR [rcx+112]
	inc	edx
	mov	BYTE PTR [rcx+rax-6], 0
	cmp	edx, DWORD PTR [rbx+108]
	jl	SHORT $LL7@TableEndRo
$LN6@TableEndRo:

; 1901 :     if (unfreeze_rows_actual)

	cmp	edi, r9d
	mov	rdi, QWORD PTR [rsp+256]
	jne	$LN34@TableEndRo

; 1902 :     {
; 1903 :         IM_ASSERT(table->IsUnfrozenRows == false);
; 1904 :         const float y0 = ImMax(table->RowPosY2 + 1, window->InnerClipRect.Min.y);

	movss	xmm0, DWORD PTR [rbx+128]

; 1906 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFrozenHeight = y0 - table->OuterRect.Min.y;

	movsx	eax, WORD PTR [rbx+120]
	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, DWORD PTR [r12+580]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1905 :         table->IsUnfrozenRows = true;

	mov	BYTE PTR [rbx+565], 1

; 1906 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFrozenHeight = y0 - table->OuterRect.Min.y;

	movaps	xmm1, xmm0
	subss	xmm1, DWORD PTR [rbx+236]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3394 :     inline ImGuiTableInstanceData*  TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }

	test	eax, eax
	jne	SHORT $LN60@TableEndRo
	lea	rax, QWORD PTR [rbx+416]
	jmp	SHORT $LN59@TableEndRo
$LN60@TableEndRo:
	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+448]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	lea	rax, QWORD PTR [rax+rdx*8]
$LN59@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1906 :         TableGetInstanceData(table, table->InstanceCurrent)->LastFrozenHeight = y0 - table->OuterRect.Min.y;

	movss	DWORD PTR [rax+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, DWORD PTR [r12+588]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1914 :         float row_height = table->RowPosY2 - table->RowPosY1;

	movss	xmm1, DWORD PTR [rbx+128]
	movzx	eax, WORD PTR [rbx+552]
	movss	DWORD PTR [rbx+332], xmm0
	movss	DWORD PTR [rbx+300], xmm0
	movss	xmm0, DWORD PTR [r12+588]
	movss	DWORD PTR [rbx+340], xmm0
	movss	DWORD PTR [rbx+308], xmm0
	movaps	xmm0, xmm1

; 1915 :         table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;

	addss	xmm1, DWORD PTR [rbx+268]
	subss	xmm0, DWORD PTR [rbx+124]
	mov	WORD PTR [rbx+550], ax
	subss	xmm1, DWORD PTR [rbx+236]
	movss	DWORD PTR [r12+316], xmm1

; 1917 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

	cmp	DWORD PTR [rbx+108], 0
	movss	DWORD PTR [rbx+128], xmm1
	subss	xmm1, xmm0
	movss	DWORD PTR [rbx+124], xmm1
	jle	SHORT $LN231@TableEndRo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13388:         g.LogLineFirstItem = true;

	mov	rdx, r13
	npad	1
$LL10@TableEndRo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	mov	rcx, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1917 :         for (int column_n = 0; column_n < table->ColumnsCount; column_n++)

	lea	rdx, QWORD PTR [rdx+112]
	inc	r13d

; 1918 :         {
; 1919 :             ImGuiTableColumn* column = &table->Columns[column_n];
; 1920 :             column->DrawChannelCurrent = column->DrawChannelUnfrozen;

	movzx	eax, WORD PTR [rdx+rcx-16]
	mov	WORD PTR [rdx+rcx-20], ax

; 1921 :             column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;

	mov	eax, DWORD PTR [rbx+332]
	mov	DWORD PTR [rdx+rcx-76], eax
	cmp	r13d, DWORD PTR [rbx+108]
	jl	SHORT $LL10@TableEndRo
$LN231@TableEndRo:

; 1922 :         }
; 1923 : 
; 1924 :         // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
; 1925 :         SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);

	mov	rax, QWORD PTR [rbx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rax+32]
	movss	xmm3, DWORD PTR [rax+36]
	movss	xmm2, DWORD PTR [rax+40]
	movss	xmm1, DWORD PTR [rax+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [rax+32]

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r12+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$8[rbp-137], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r12+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$8[rbp-133], xmm3
	movss	DWORD PTR clip_rect_vec4$8[rbp-129], xmm2
	movss	DWORD PTR clip_rect_vec4$8[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r12+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$8[rbp-137]
	movsxd	rdx, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR [rax+96]
	add	rdx, rdx
	movups	XMMWORD PTR [rcx+rdx*8-16], xmm0

; 1926 :         table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);

	mov	rax, QWORD PTR [rbx+24]
	mov	rdx, QWORD PTR [r12+728]
	mov	rcx, QWORD PTR [rbx+408]
	movzx	r8d, WORD PTR [rax+92]
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN34@TableEndRo:

; 1927 :     }
; 1928 : 
; 1929 :     if (!(table->RowFlags & ImGuiTableRowFlags_Headers))

	test	BYTE PTR [rbx+144], 1
	movaps	xmm11, XMMWORD PTR [rsp+96]
	mov	r13, QWORD PTR [rsp+208]
	mov	r12, QWORD PTR [rsp+264]
	mov	BYTE PTR [rbx+555], 0
	jne	SHORT $LN35@TableEndRo

; 1930 :         table->RowBgColorCounter++;

	inc	DWORD PTR [rbx+148]
$LN35@TableEndRo:

; 1931 :     table->IsInsideRow = false;
; 1932 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-137]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	pop	rbx
	pop	rbp
	ret	0
?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z ENDP		; ImGui::TableEndRow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsAddSettingsHandler@ImGui@@YAXXZ
_TEXT	SEGMENT
ini_handler$ = 32
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ PROC	; ImGui::TableSettingsAddSettingsHandler, COMDAT

; 3512 : {

$LN28:
	sub	rsp, 120				; 00000078H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1846 :     ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	lea	r8, OFFSET FLAT:??_C@_05LFBINIGO@Table@+1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1846 :     ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }

	mov	DWORD PTR ini_handler$[rsp+12], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	lea	r11, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1846 :     ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR ini_handler$[rsp+24], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2050 :     ImU32 crc = seed;

	mov	r10d, -1				; ffffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1846 :     ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR ini_handler$[rsp+64], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2065 :         while (unsigned char c = *data++)

	mov	r9b, 84					; 00000054H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3514 :     ini_handler.TypeName = "Table";

	lea	rax, OFFSET FLAT:??_C@_05LFBINIGO@Table@
	mov	QWORD PTR ini_handler$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2050 :     ImU32 crc = seed;

	mov	eax, r10d
	npad	6
$LL8@TableSetti:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r9b, 35					; 00000023H
	jne	SHORT $LN13@TableSetti
	cmp	BYTE PTR [r8], r9b
	jne	SHORT $LN13@TableSetti
	cmp	BYTE PTR [r8+1], r9b
	cmove	eax, r10d
$LN13@TableSetti:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	edx, al
	movzx	ecx, r9b
	movzx	r9d, BYTE PTR [r8]
	xor	rdx, rcx
	shr	eax, 8
	inc	r8
	xor	eax, DWORD PTR [r11+rdx*4]
	test	r9b, r9b
	jne	SHORT $LL8@TableSetti

; 13637:     g.SettingsHandlers.push_back(*handler);

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	lea	rdx, QWORD PTR ini_handler$[rsp]

; 2072 :     return ~crc;

	not	eax

; 13637:     g.SettingsHandlers.push_back(*handler);

	add	rcx, 24112				; 00005e30H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3515 :     ini_handler.TypeHash = ImHashStr("Table");

	mov	DWORD PTR ini_handler$[rsp+8], eax

; 3516 :     ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;

	lea	rax, OFFSET FLAT:?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ; TableSettingsHandler_ClearAll
	mov	QWORD PTR ini_handler$[rsp+16], rax

; 3517 :     ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;

	lea	rax, OFFSET FLAT:?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z ; TableSettingsHandler_ReadOpen
	mov	QWORD PTR ini_handler$[rsp+32], rax

; 3518 :     ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;

	lea	rax, OFFSET FLAT:?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z ; TableSettingsHandler_ReadLine
	mov	QWORD PTR ini_handler$[rsp+40], rax

; 3519 :     ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;

	lea	rax, OFFSET FLAT:?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ; TableSettingsHandler_ApplyAll
	mov	QWORD PTR ini_handler$[rsp+48], rax

; 3520 :     ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;

	lea	rax, OFFSET FLAT:?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z ; TableSettingsHandler_WriteAll
	mov	QWORD PTR ini_handler$[rsp+56], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 13637:     g.SettingsHandlers.push_back(*handler);

	call	?push_back@?$ImVector@UImGuiSettingsHandler@@@@QEAAXAEBUImGuiSettingsHandler@@@Z ; ImVector<ImGuiSettingsHandler>::push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3522 : }

	add	rsp, 120				; 00000078H
	ret	0
?TableSettingsAddSettingsHandler@ImGui@@YAXXZ ENDP	; ImGui::TableSettingsAddSettingsHandler
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z
_TEXT	SEGMENT
temp_data$ = 48
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z PROC ; ImGui::TableGcCompactTransientBuffers, COMDAT

; 3561 : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3562 :     temp_data->DrawSplitter.ClearFreeMemory();

	add	rcx, 16
	call	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory

; 3563 :     temp_data->LastTimeActive = -1.0f;

	mov	DWORD PTR [rbx+4], -1082130432		; bf800000H

; 3564 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z ENDP ; ImGui::TableGcCompactTransientBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
table$ = 48
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z PROC ; ImGui::TableGcCompactTransientBuffers, COMDAT

; 3546 : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 3548 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3549 :     IM_ASSERT(table->MemoryCompacted == false);
; 3550 :     table->SortSpecs.Specs = NULL;

	xor	edi, edi
	mov	QWORD PTR [rcx+488], rdi
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+480]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3548 :     ImGuiContext& g = *GImGui;

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	test	rcx, rcx
	je	SHORT $LN7@TableGcCom
	mov	QWORD PTR [rbx+472], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN11@TableGcCom

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN11@TableGcCom:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rbx+480], rdi
$LN7@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3552 :     table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.

	mov	BYTE PTR [rbx+557], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+400]
	test	rcx, rcx
	je	SHORT $LN20@TableGcCom
	mov	QWORD PTR [rbx+392], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN24@TableGcCom

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN24@TableGcCom:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+400], rdi
$LN20@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3554 :     table->MemoryCompacted = true;

	mov	BYTE PTR [rbx+569], 1

; 3555 :     for (int n = 0; n < table->ColumnsCount; n++)

	cmp	DWORD PTR [rbx+108], edi
	jle	SHORT $LN3@TableGcCom
	mov	rcx, rdi
	npad	8
$LL4@TableGcCom:

; 3556 :         table->Columns[n].NameOffset = -1;

	mov	rax, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR [rcx+112]
	inc	edi
	mov	WORD PTR [rax+rcx-32], -1
	cmp	edi, DWORD PTR [rbx+108]
	jl	SHORT $LL4@TableGcCom
$LN3@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sub	rbx, QWORD PTR [rsi+19768]
	mov	rax, 1024819115206086201		; 0e38e38e38e38e39H
	imul	rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3558 : }

	mov	rbx, QWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sar	rdx, 5
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3557 :     g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;

	mov	rax, QWORD PTR [rsi+19808]

; 3558 : }

	mov	rsi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3557 :     g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;

	mov	DWORD PTR [rax+rcx*4], -1082130432	; bf800000H

; 3558 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z ENDP ; ImGui::TableGcCompactTransientBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableGcCompactSettings@ImGui@@YAXXZ
_TEXT	SEGMENT
sz$1$ = 40
$T1 = 48
new_chunk_stream$ = 56
__$ArrayPad$ = 72
?TableGcCompactSettings@ImGui@@YAXXZ PROC		; ImGui::TableGcCompactSettings, COMDAT

; 3568 : {

$LN116:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3569 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3570 :     int required_memory = 0;

	xor	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	lea	r14, QWORD PTR [rbx+24152]
	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN111@TableGcCom
	lea	rdx, QWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3571 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	test	rdx, rdx
	je	SHORT $LN111@TableGcCom
	movsxd	r8, DWORD PTR [rbx+24144]
	add	r8, 4
	add	r8, rcx
	npad	6
$LL16@TableGcCom:

; 3572 :         if (settings->ID != 0)

	cmp	DWORD PTR [rdx], 0
	je	SHORT $LN2@TableGcCom

; 3238 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

	movsx	eax, WORD PTR [rdx+12]
	shl	eax, 4

; 3573 :             required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);

	add	esi, 20
	add	esi, eax
$LN2@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	movsxd	rcx, DWORD PTR [rdx-4]
	add	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3571 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	xor	edx, edx
	cmp	rcx, r8
	cmovne	rdx, rcx
	test	rdx, rdx
	jne	SHORT $LL16@TableGcCom
$LN111@TableGcCom:

; 3574 :     if (required_memory == g.SettingsTables.Buf.Size)

	lea	r13, QWORD PTR [rbx+24144]
	cmp	esi, DWORD PTR [r13]
	je	$LN95@TableGcCom
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	edi, edi
	mov	QWORD PTR new_chunk_stream$[rsp], rdi
	xor	r15d, r15d
	xor	ebp, ebp
	mov	QWORD PTR new_chunk_stream$[rsp+8], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3576 :     ImChunkStream<ImGuiTableSettings> new_chunk_stream;

	test	esi, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	jle	SHORT $LN27@TableGcCom
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN32@TableGcCom

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rbx+244]
$LN32@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
	mov	QWORD PTR new_chunk_stream$[rsp+8], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	edi, esi
	mov	DWORD PTR new_chunk_stream$[rsp+4], esi
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN27@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	mov	rsi, QWORD PTR [r14]
	test	rsi, rsi
	je	$LN6@TableGcCom
	add	rsi, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3578 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	je	$LN6@TableGcCom
	mov	edx, -4					; fffffffcH
$LL49@TableGcCom:

; 3579 :         if (settings->ID != 0)

	cmp	DWORD PTR [rsi], 0
	je	$LN5@TableGcCom

; 3238 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

	movsx	rax, WORD PTR [rsi+12]
	shl	rax, 4
	lea	rcx, QWORD PTR [rax+20]
	mov	QWORD PTR $T1[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 705  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

	add	rax, 27
	and	rax, rdx
	mov	QWORD PTR sz$1$[rsp], rax
	mov	ecx, r15d
	lea	r12d, DWORD PTR [rax+r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	r12d, edi
	jle	$LN67@TableGcCom

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	edi, edi
	je	SHORT $LN65@TableGcCom
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, edi
	jmp	SHORT $LN66@TableGcCom
$LN65@TableGcCom:
	mov	eax, 8
$LN66@TableGcCom:
	mov	r14d, r12d
	cmp	eax, r12d
	cmovg	r14d, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	r14d, edi
	jle	SHORT $LN67@TableGcCom
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN72@TableGcCom

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rbx+244]
$LN72@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rcx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rbp, rbp
	je	SHORT $LN82@TableGcCom
	movsxd	r8, r15d
	mov	rdx, rbp
	mov	rcx, rax
	call	memcpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rcx, rcx
	je	SHORT $LN80@TableGcCom

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rcx+244]
$LN80@TableGcCom:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN82@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rbp, rbx
	mov	QWORD PTR new_chunk_stream$[rsp+8], rbx
	mov	edi, r14d
	mov	DWORD PTR new_chunk_stream$[rsp+4], r14d
	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	ecx, r15d
$LN67@TableGcCom:

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	r15d, r12d
	mov	DWORD PTR new_chunk_stream$[rsp], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 705  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

	movsxd	rax, ecx
	mov	rcx, QWORD PTR sz$1$[rsp]
	mov	DWORD PTR [rax+rbp], ecx
	lea	rcx, QWORD PTR [rax+4]
	add	rcx, rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3580 :             memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));

	mov	r8, QWORD PTR $T1[rsp]
	mov	rdx, rsi
	call	memcpy
$LN5@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	movsxd	r8, DWORD PTR [rsi-4]
	add	r8, rsi

; 709  :     T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }

	movsxd	rcx, DWORD PTR [r13]

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	mov	rdx, QWORD PTR [r13+8]
	add	rdx, 4
	add	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3578 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	xor	esi, esi
	cmp	r8, rdx
	cmovne	rsi, r8
	test	rsi, rsi
	mov	edx, -4					; fffffffcH
	jne	$LL49@TableGcCom
$LN6@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1928 :     inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	DWORD PTR [r13], r15d
	mov	DWORD PTR [r13+4], edi
	mov	rcx, QWORD PTR [r13+8]
	mov	QWORD PTR [r13+8], rbp

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	test	rcx, rcx
	je	SHORT $LN101@TableGcCom
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rbx, rbx
	je	SHORT $LN99@TableGcCom

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rbx+244]
$LN99@TableGcCom:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN101@TableGcCom:
$LN95@TableGcCom:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3582 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?TableGcCompactSettings@ImGui@@YAXXZ ENDP		; ImGui::TableGcCompactSettings
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
sz$1$ = 40
$T1 = 48
new_chunk_stream$ = 56
__$ArrayPad$ = 72
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA PROC ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
	lea	rcx, QWORD PTR new_chunk_stream$[rdx]
	jmp	??1?$ImChunkStream@UImGuiTableSettings@@@@QEAA@XZ
?dtor$0@?0??TableGcCompactSettings@ImGui@@YAXXZ@4HA ENDP ; `ImGui::TableGcCompactSettings'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
_TEXT	SEGMENT
columns$ = 8
offset_norm$ = 16
?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z PROC ; ImGui::GetColumnOffsetFromNorm, COMDAT

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm0, DWORD PTR [rcx+24]
	subss	xmm0, DWORD PTR [rcx+20]
	mulss	xmm0, xmm1

; 3746 : }

	ret	0
?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ENDP ; ImGui::GetColumnOffsetFromNorm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?EndColumns@ImGui@@YAXXZ
_TEXT	SEGMENT
is_being_resized$1$ = 48
hovered$3 = 48
held$4 = 49
flags$1$ = 52
$T5 = 56
$T6 = 64
g$1$ = 72
c$7 = 80
column_hit_rect$8 = 96
__$ArrayPad$ = 112
?EndColumns@ImGui@@YAXXZ PROC				; ImGui::EndColumns, COMDAT

; 4046 : {

$LN146:
	mov	r11, rsp
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 4047 :     ImGuiContext& g = *GImGui;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR g$1$[rsp], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4046 : {

	movaps	XMMWORD PTR [r11-72], xmm7
	movaps	XMMWORD PTR [r11-88], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4049 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rbx, QWORD PTR [rsi+480]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rsi+237], 1
	mov	r8, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4053 :     if (columns->Count > 1)

	cmp	DWORD PTR [rbx+16], 1
	jle	SHORT $LN8@EndColumns

; 4054 :     {
; 4055 :         PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 4056 :         columns->Splitter.Merge(window->DrawList);

	mov	rdx, QWORD PTR [rsi+728]
	lea	rcx, QWORD PTR [rbx+112]
	call	?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge
$LN8@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm7, DWORD PTR [rbx+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4059 :     const ImGuiOldColumnFlags flags = columns->Flags;

	mov	ecx, DWORD PTR [rbx+4]
	mov	DWORD PTR flags$1$[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm7, DWORD PTR [rsi+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4060 :     columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);

	movss	DWORD PTR [rbx+32], xmm7

; 4061 :     window->DC.CursorPos.y = columns->LineMaxY;

	movss	DWORD PTR [rsi+316], xmm7

; 4062 :     if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))

	test	cl, 16
	jne	SHORT $LN9@EndColumns

; 4063 :         window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

	mov	eax, DWORD PTR [rbx+40]
	mov	DWORD PTR [rsi+336], eax
$LN9@EndColumns:

; 4064 : 
; 4065 :     // Draw columns borders and handle resize
; 4066 :     // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
; 4067 :     bool is_being_resized = false;

	xor	al, al
	xorps	xmm8, xmm8

; 4068 :     if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)

	test	cl, 1
	jne	$LN111@EndColumns
	cmp	BYTE PTR [rsi+240], al
	jne	$LN111@EndColumns
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm7, DWORD PTR [rsi+636]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4068 :     if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)

	mov	QWORD PTR [rsp+280], rbp

; 4069 :     {
; 4070 :         // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
; 4071 :         const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
; 4072 :         const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
; 4073 :         int dragging_column = -1;

	mov	ebp, -1
	mov	QWORD PTR [rsp+256], rdi

; 4074 :         for (int n = 1; n < columns->Count; n++)

	mov	edi, 1
	movaps	XMMWORD PTR [rsp+160], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm9, DWORD PTR [rbx+36]
	maxss	xmm9, DWORD PTR [rsi+628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4074 :         for (int n = 1; n < columns->Count; n++)

	cmp	DWORD PTR [rbx+16], edi
	jle	$LN143@EndColumns
	mov	QWORD PTR [rsp+248], r12
	mov	QWORD PTR [rsp+240], r13
	mov	QWORD PTR [rsp+232], r14
	mov	QWORD PTR [rsp+224], r15
	lea	r15d, QWORD PTR [rbp+29]
	movaps	XMMWORD PTR [rsp+208], xmm6
	movaps	XMMWORD PTR [rsp+144], xmm10
	movss	xmm10, DWORD PTR __real@40800000
	movaps	XMMWORD PTR [rsp+128], xmm11
	movss	xmm11, DWORD PTR __real@3f800000
	npad	4
$LL4@EndColumns:

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r13d, ebp
	mov	r12, QWORD PTR [rbx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4077 :             float x = window->Pos.x + GetColumnOffset(n);

	mov	r8d, edi

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rcx, QWORD PTR [rax+16408]
	mov	rdx, QWORD PTR [rcx+480]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN59@EndColumns

; 3777 :         return 0.0f;

	movaps	xmm6, xmm8
	jmp	SHORT $LN58@EndColumns
$LN59@EndColumns:

; 3778 : 
; 3779 :     if (column_index < 0)

	test	edi, edi
	jns	SHORT $LN60@EndColumns

; 3780 :         column_index = columns->Current;

	mov	r8d, DWORD PTR [rdx+12]
$LN60@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm6, DWORD PTR [rdx+24]
	subss	xmm6, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r8d
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm6, DWORD PTR [rcx+rax]
	addss	xmm6, DWORD PTR [rdx+20]
$LN58@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4077 :             float x = window->Pos.x + GetColumnOffset(n);

	addss	xmm6, DWORD PTR [rsi+80]

; 4078 :             const ImGuiID column_id = columns->ID + ImGuiID(n);

	mov	r14d, DWORD PTR [rbx]

; 4081 :             if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))

	lea	rcx, QWORD PTR column_hit_rect$8[rsp]
	add	r14d, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR column_hit_rect$8[rsp+4], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4081 :             if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))

	mov	r9d, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR column_hit_rect$8[rsp+12], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4081 :             if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))

	xor	r8d, r8d
	mov	edx, r14d
	movaps	xmm1, xmm6
	movaps	xmm0, xmm6
	addss	xmm1, xmm10
	subss	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 523  :     constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}

	movss	DWORD PTR column_hit_rect$8[rsp+8], xmm1
	movss	DWORD PTR column_hit_rect$8[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4081 :             if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))

	call	?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z ; ImGui::ItemAdd
	test	al, al
	je	$LN2@EndColumns

; 4082 :                 continue;
; 4083 : 
; 4084 :             bool hovered = false, held = false;

	xor	cl, cl

; 4085 :             if (!(flags & ImGuiOldColumnFlags_NoResize))

	test	BYTE PTR flags$1$[rsp], 2
	mov	BYTE PTR hovered$3[rsp], cl
	mov	BYTE PTR held$4[rsp], cl
	jne	SHORT $LN19@EndColumns

; 4086 :             {
; 4087 :                 ButtonBehavior(column_hit_rect, column_id, &hovered, &held);

	lea	r9, QWORD PTR held$4[rsp]
	mov	DWORD PTR [rsp+32], 0
	lea	r8, QWORD PTR hovered$3[rsp]
	mov	edx, r14d
	lea	rcx, QWORD PTR column_hit_rect$8[rsp]
	call	?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z ; ImGui::ButtonBehavior

; 4088 :                 if (hovered || held)

	movzx	ecx, BYTE PTR hovered$3[rsp]
	movzx	eax, BYTE PTR held$4[rsp]
	test	cl, cl
	jne	SHORT $LN14@EndColumns
	test	al, al
	je	SHORT $LN19@EndColumns
$LN14@EndColumns:

; 4089 :                     g.MouseCursor = ImGuiMouseCursor_ResizeEW;

	mov	rdx, QWORD PTR g$1$[rsp]
	mov	DWORD PTR [rdx+19936], 4

; 4090 :                 if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))

	test	al, al
	je	SHORT $LN19@EndColumns
	test	BYTE PTR [r15+r12+8], 2

; 4091 :                     dragging_column = n;
; 4092 :             }
; 4093 : 
; 4094 :             // Draw column
; 4095 :             const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);

	mov	ebp, edi
	mov	eax, 29
	cmovne	ebp, r13d
	jmp	SHORT $LN20@EndColumns
$LN19@EndColumns:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	rax, 27
$LN20@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3090 :     ImGuiStyle& style = GImGui->Style;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3091 :     ImVec4 c = style.Colors[idx];

	add	rax, 14
	add	rax, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp+4], xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	xmm0, XMMWORD PTR [rcx+rax*8+14552]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4096 :             const float xi = IM_FLOOR(x);

	cvttss2si eax, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3091 :     ImVec4 c = style.Colors[idx];

	movups	XMMWORD PTR c$7[rsp], xmm0

; 3092 :     c.w *= style.Alpha * alpha_mul;

	shufps	xmm0, xmm0, 255				; 000000ffH
	mulss	xmm0, DWORD PTR [rcx+14552]

; 3093 :     return ColorConvertFloat4ToU32(c);

	lea	rcx, QWORD PTR c$7[rsp]
	movss	DWORD PTR c$7[rsp+12], xmm0
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4096 :             const float xi = IM_FLOOR(x);

	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T5[rsp], xmm0
	movss	DWORD PTR $T6[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4097 :             window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);

	movaps	xmm0, xmm9
	addss	xmm0, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T6[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4097 :             window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);

	mov	rcx, QWORD PTR [rsi+728]
	lea	rdx, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3093 :     return ColorConvertFloat4ToU32(c);

	mov	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4097 :             window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);

	movss	DWORD PTR [rsp+32], xmm11
	lea	r8, QWORD PTR $T5[rsp]
	call	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN2@EndColumns:

; 4074 :         for (int n = 1; n < columns->Count; n++)

	mov	eax, DWORD PTR [rbx+16]
	inc	edi
	add	r15, 28
	cmp	edi, eax
	jl	$LL4@EndColumns
	movaps	xmm11, XMMWORD PTR [rsp+128]
	movaps	xmm6, XMMWORD PTR [rsp+208]
	mov	r15, QWORD PTR [rsp+224]
	mov	r14, QWORD PTR [rsp+232]
	mov	r13, QWORD PTR [rsp+240]
	mov	r12, QWORD PTR [rsp+248]

; 4098 :         }
; 4099 : 
; 4100 :         // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
; 4101 :         if (dragging_column != -1)

	cmp	ebp, -1
	je	$LN116@EndColumns

; 4102 :         {
; 4103 :             if (!columns->IsBeingResized)

	cmp	BYTE PTR [rbx+9], 0
	jne	SHORT $LN6@EndColumns

; 4104 :                 for (int n = 0; n < columns->Count + 1; n++)

	xor	r8d, r8d
	inc	eax
	test	eax, eax
	jle	SHORT $LN6@EndColumns
	xor	edx, edx
	npad	11
$LL7@EndColumns:

; 4105 :                     columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;

	mov	rcx, QWORD PTR [rbx+104]
	lea	rdx, QWORD PTR [rdx+28]
	inc	r8d
	mov	eax, DWORD PTR [rcx+rdx-28]
	mov	DWORD PTR [rcx+rdx-24], eax
	mov	eax, DWORD PTR [rbx+16]
	inc	eax
	cmp	r8d, eax
	jl	SHORT $LL7@EndColumns
$LN6@EndColumns:

; 3759 :     ImGuiContext& g = *GImGui;

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3765 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

	lea	ecx, DWORD PTR [rbp-1]

; 4106 :             columns->IsBeingResized = is_being_resized = true;

	mov	BYTE PTR [rbx+9], 1
	mov	BYTE PTR is_being_resized$1$[rsp], 1

; 3764 :     float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;

	mov	rax, QWORD PTR [r8+16408]
	movss	xmm2, DWORD PTR [r8+3592]
	subss	xmm2, DWORD PTR [r8+16524]

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 3764 :     float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;

	addss	xmm2, xmm10
	subss	xmm2, DWORD PTR [rax+80]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN29@EndColumns

; 3777 :         return 0.0f;

	movaps	xmm1, xmm8
	jmp	SHORT $LN28@EndColumns
$LN29@EndColumns:

; 3778 : 
; 3779 :     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN109@EndColumns

; 3780 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [rdx+12]
$LN109@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
	subss	xmm1, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, ecx
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [rdx+20]
$LN28@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3765 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

	movss	xmm3, DWORD PTR [r8+14664]
	movaps	xmm0, xmm3
	addss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm2, xmm0
	jae	SHORT $LN39@EndColumns
	movaps	xmm2, xmm0
$LN39@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3766 :     if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))

	test	BYTE PTR [rbx+4], 4
	je	SHORT $LN51@EndColumns

; 3767 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	lea	eax, DWORD PTR [rbp+1]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN41@EndColumns

; 3777 :         return 0.0f;

	movaps	xmm1, xmm8
	jmp	SHORT $LN40@EndColumns
$LN41@EndColumns:

; 3778 : 
; 3779 :     if (column_index < 0)

	test	eax, eax
	jns	SHORT $LN42@EndColumns

; 3780 :         column_index = columns->Current;

	mov	eax, DWORD PTR [rdx+12]
$LN42@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
	subss	xmm1, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [rdx+20]
$LN40@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3767 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	subss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm1, xmm2
	ja	SHORT $LN51@EndColumns
	movaps	xmm2, xmm1
$LN51@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4108 :             SetColumnOffset(dragging_column, x);

	movaps	xmm1, xmm2
	mov	ecx, ebp
	call	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
	movzx	eax, BYTE PTR is_being_resized$1$[rsp]
	jmp	SHORT $LN144@EndColumns
$LN116@EndColumns:

; 4098 :         }
; 4099 : 
; 4100 :         // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
; 4101 :         if (dragging_column != -1)

	xor	al, al
$LN144@EndColumns:
	movaps	xmm10, XMMWORD PTR [rsp+144]
$LN143@EndColumns:
	mov	rdi, QWORD PTR [rsp+256]
	mov	rbp, QWORD PTR [rsp+280]
	movaps	xmm9, XMMWORD PTR [rsp+160]
$LN111@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11692:     ImGuiWindow* window = g.CurrentWindow;

	movaps	xmm7, XMMWORD PTR [rsp+192]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4111 :     columns->IsBeingResized = is_being_resized;

	mov	BYTE PTR [rbx+9], al

; 4112 : 
; 4113 :     window->WorkRect = window->ParentWorkRect;

	movups	xmm0, XMMWORD PTR [rsi+608]
	movups	XMMWORD PTR [rsi+592], xmm0

; 4114 :     window->ParentWorkRect = columns->HostBackupParentWorkRect;

	movups	xmm0, XMMWORD PTR [rbx+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11692:     ImGuiWindow* window = g.CurrentWindow;

	mov	rbx, QWORD PTR [rsp+272]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4115 :     window->DC.CurrentColumns = NULL;

	mov	QWORD PTR [rsi+480], 0
	movups	XMMWORD PTR [rsi+608], xmm0

; 4116 :     window->DC.ColumnsOffset.x = 0.0f;

	mov	DWORD PTR [rsi+384], 0

; 4117 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	movss	xmm0, DWORD PTR [rsi+380]
	addss	xmm0, DWORD PTR [rsi+80]
	addss	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11692:     ImGuiWindow* window = g.CurrentWindow;

	movaps	xmm8, XMMWORD PTR [rsp+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4117 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	cvttss2si eax, xmm0
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11691:     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4117 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rsi+312], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11693:     window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);

	cmp	QWORD PTR [rax+19728], 0
	mov	rcx, QWORD PTR [rax+16408]
	mov	rsi, QWORD PTR [rsp+288]
	jne	SHORT $LN23@EndColumns
	cmp	QWORD PTR [rcx+480], 0
	jne	SHORT $LN23@EndColumns
	mov	BYTE PTR [rcx+408], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4119 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	ret	0
$LN23@EndColumns:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 11693:     window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);

	mov	BYTE PTR [rcx+408], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4119 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	ret	0
?EndColumns@ImGui@@YAXXZ ENDP				; ImGui::EndColumns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?Columns@ImGui@@YAXHPEBD_N@Z
_TEXT	SEGMENT
columns_count$ = 48
id$ = 56
border$dead$ = 64
?Columns@ImGui@@YAXHPEBD_N@Z PROC			; ImGui::Columns, COMDAT

; 4122 : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4122 : {

	mov	ebx, ecx
	mov	rdi, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r8+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4128 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [r8+16408]
	mov	rcx, QWORD PTR [rax+480]

; 4129 :     if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)

	test	rcx, rcx
	je	SHORT $LN3@Columns
	cmp	DWORD PTR [rcx+16], ebx
	jne	SHORT $LN2@Columns
	cmp	DWORD PTR [rcx+4], 0
	je	SHORT $LN4@Columns
$LN2@Columns:

; 4130 :         return;
; 4131 : 
; 4132 :     if (columns != NULL)
; 4133 :         EndColumns();

	call	?EndColumns@ImGui@@YAXXZ		; ImGui::EndColumns
$LN3@Columns:

; 4134 : 
; 4135 :     if (columns_count != 1)

	cmp	ebx, 1
	je	SHORT $LN4@Columns

; 4136 :         BeginColumns(id, columns_count, flags);

	xor	r8d, r8d
	mov	edx, ebx
	mov	rcx, rdi
	call	?BeginColumns@ImGui@@YAXPEBDHH@Z	; ImGui::BeginColumns
$LN4@Columns:

; 4137 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Columns@ImGui@@YAXHPEBD_N@Z ENDP			; ImGui::Columns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?NextColumn@ImGui@@YAXXZ
_TEXT	SEGMENT
clip_rect_vec4$2 = 32
?NextColumn@ImGui@@YAXXZ PROC				; ImGui::NextColumn, COMDAT

; 3990 : {

$LN75:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 80					; 00000050H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rbx, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3992 :     if (window->SkipItems || window->DC.CurrentColumns == NULL)

	cmp	BYTE PTR [rbx+240], 0
	jne	$LN3@NextColumn
	mov	QWORD PTR [rsp+104], rdi
	mov	rdi, QWORD PTR [rbx+480]
	test	rdi, rdi
	je	$LN73@NextColumn

; 3993 :         return;
; 3994 : 
; 3995 :     ImGuiContext& g = *GImGui;
; 3996 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;
; 3997 : 
; 3998 :     if (columns->Count == 1)

	mov	ecx, DWORD PTR [rdi+16]
	cmp	ecx, 1
	jne	SHORT $LN4@NextColumn

; 3999 :     {
; 4000 :         window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	movss	xmm0, DWORD PTR [rbx+380]
	addss	xmm0, DWORD PTR [rbx+80]
	mov	rdi, QWORD PTR [rsp+104]
	addss	xmm0, DWORD PTR [rbx+384]
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rbx+312], xmm0

; 4043 : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
$LN4@NextColumn:

; 4001 :         IM_ASSERT(columns->Current == 0);
; 4002 :         return;
; 4003 :     }
; 4004 : 
; 4005 :     // Next column
; 4006 :     if (++columns->Current == columns->Count)

	mov	eax, DWORD PTR [rdi+12]
	mov	QWORD PTR [rsp+96], rbp
	inc	eax
	xor	ebp, ebp
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	mov	DWORD PTR [rdi+12], eax
	cmp	eax, ecx
	jne	SHORT $LN5@NextColumn

; 4007 :         columns->Current = 0;

	mov	DWORD PTR [rdi+12], ebp
$LN5@NextColumn:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rsi+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r8, QWORD PTR [rsi+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rdx, DWORD PTR [r8+512]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	rax, QWORD PTR [r8+520]
	mov	ecx, DWORD PTR [rax+rdx*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	lea	eax, DWORD PTR [rdx-1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10356:     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	DWORD PTR [r8+500], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	mov	DWORD PTR [r8+512], eax

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, DWORD PTR [rdi+12]
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4014 :     SetWindowClipRectBeforeSetChannel(window, column->ClipRect);

	mov	rax, QWORD PTR [rdi+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rcx+rax+12]
	movss	xmm3, DWORD PTR [rcx+rax+16]
	movss	xmm2, DWORD PTR [rcx+rax+20]
	movss	xmm1, DWORD PTR [rcx+rax+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [rcx+rax+12]

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [rbx+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$2[rsp], xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [rbx+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$2[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$2[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$2[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [rbx+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$2[rsp]
	movsxd	rdx, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR [rax+96]
	add	rdx, rdx
	movups	XMMWORD PTR [rcx+rdx*8-16], xmm0

; 4015 :     columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

	mov	r8d, DWORD PTR [rdi+12]
	lea	rcx, QWORD PTR [rdi+112]
	mov	rdx, QWORD PTR [rbx+728]
	inc	r8d
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rdi+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4019 :     if (columns->Current > 0)

	xorps	xmm6, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, DWORD PTR [rbx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4019 :     if (columns->Current > 0)

	movsxd	rcx, DWORD PTR [rdi+12]
	movss	xmm7, DWORD PTR [rsi+14628]
	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	DWORD PTR [rdi+32], xmm0
	test	ecx, ecx
	jle	SHORT $LN6@NextColumn

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [r9+16408]
	mov	rdx, QWORD PTR [rax+480]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN33@NextColumn
	xorps	xmm1, xmm1

; 3777 :         return 0.0f;

	jmp	SHORT $LN31@NextColumn
$LN33@NextColumn:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
	subss	xmm1, DWORD PTR [rdx+20]
	mov	rax, QWORD PTR [rdx+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rcx, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [rdx+20]
$LN31@NextColumn:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4023 :         window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;

	subss	xmm1, DWORD PTR [rbx+380]
	addss	xmm1, xmm7
	movss	DWORD PTR [rbx+384], xmm1

; 4024 :     }

	jmp	SHORT $LN7@NextColumn
$LN6@NextColumn:

; 4029 :         window->DC.IsSameLine = false;

	mov	BYTE PTR [rbx+376], bpl
	movaps	xmm0, xmm7
	subss	xmm0, DWORD PTR [rbx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4028 :         window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);

	movss	DWORD PTR [rbx+384], xmm0

; 4030 :         columns->LineMinY = columns->LineMaxY;

	mov	eax, DWORD PTR [rdi+32]
	mov	DWORD PTR [rdi+28], eax
$LN7@NextColumn:

; 4031 :     }
; 4032 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	movss	xmm0, DWORD PTR [rbx+80]
	addss	xmm0, DWORD PTR [rbx+380]
	addss	xmm0, DWORD PTR [rbx+384]
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rbx+312], xmm0

; 4033 :     window->DC.CursorPos.y = columns->LineMinY;

	mov	eax, DWORD PTR [rdi+28]

; 4034 :     window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

	mov	QWORD PTR [rbx+352], rbp

; 4035 :     window->DC.CurrLineTextBaseOffset = 0.0f;

	mov	DWORD PTR [rbx+368], ebp

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rbp, QWORD PTR [rsp+96]

; 4033 :     window->DC.CursorPos.y = columns->LineMinY;

	mov	DWORD PTR [rbx+316], eax

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [r9+16408]

; 4036 : 
; 4037 :     // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
; 4038 :     float offset_0 = GetColumnOffset(columns->Current);

	mov	r8d, DWORD PTR [rdi+12]
	mov	ecx, r8d

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN46@NextColumn
	xorps	xmm1, xmm1

; 3777 :         return 0.0f;

	jmp	SHORT $LN53@NextColumn
$LN46@NextColumn:

; 3779 :     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN62@NextColumn

; 3780 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [rdx+12]
$LN62@NextColumn:

; 3781 :     IM_ASSERT(column_index < columns->Columns.Size);
; 3782 : 
; 3783 :     const float t = columns->Columns[column_index].OffsetNorm;
; 3784 :     const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);

	movss	xmm0, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	lea	eax, DWORD PTR [r8+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3779 :     if (column_index < 0)

	test	eax, eax
	jns	SHORT $LN55@NextColumn

; 3780 :         column_index = columns->Current;

	mov	eax, DWORD PTR [rdx+12]
$LN55@NextColumn:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm6, DWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm6, DWORD PTR [rcx+rax]
	addss	xmm6, xmm0
$LN53@NextColumn:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 4040 :     float width = offset_1 - offset_0;

	movaps	xmm0, xmm6
	subss	xmm0, xmm1

; 4041 :     PushItemWidth(width * 0.65f);

	mulss	xmm0, DWORD PTR __real@3f266666
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 4042 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

	addss	xmm6, DWORD PTR [rbx+80]
	subss	xmm6, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movss	DWORD PTR [rbx+600], xmm6
	movaps	xmm6, XMMWORD PTR [rsp+64]
$LN73@NextColumn:
	mov	rdi, QWORD PTR [rsp+104]
$LN3@NextColumn:

; 4043 : }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
?NextColumn@ImGui@@YAXXZ ENDP				; ImGui::NextColumn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnOffset@ImGui@@YAMH@Z
_TEXT	SEGMENT
column_index$ = 8
?GetColumnOffset@ImGui@@YAMH@Z PROC			; ImGui::GetColumnOffset, COMDAT

; 3774 :     ImGuiWindow* window = GetCurrentWindowRead();
; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rax+16408]
	mov	r8, QWORD PTR [rdx+480]

; 3776 :     if (columns == NULL)

	test	r8, r8
	jne	SHORT $LN2@GetColumnO
	xorps	xmm0, xmm0

; 3786 : }

	ret	0
$LN2@GetColumnO:

; 3777 :         return 0.0f;
; 3778 : 
; 3779 :     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN3@GetColumnO

; 3780 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [r8+12]
$LN3@GetColumnO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm0, DWORD PTR [r8+24]
	subss	xmm0, DWORD PTR [r8+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, ecx
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [r8+104]
	mulss	xmm0, DWORD PTR [rcx+rax]
	addss	xmm0, DWORD PTR [r8+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3786 : }

	ret	0
?GetColumnOffset@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnWidth@ImGui@@YAMH@Z
_TEXT	SEGMENT
column_index$ = 8
?GetColumnWidth@ImGui@@YAMH@Z PROC			; ImGui::GetColumnWidth, COMDAT

; 3803 :     ImGuiContext& g = *GImGui;
; 3804 :     ImGuiWindow* window = g.CurrentWindow;
; 3805 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rax+16408]
	mov	r9, QWORD PTR [rdx+480]

; 3806 :     if (columns == NULL)

	test	r9, r9
	jne	SHORT $LN2@GetColumnW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10446:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	cmp	r9, r9
	jne	SHORT $LN9@GetColumnW
	cmp	QWORD PTR [rax+19728], r9
	mov	eax, 648				; 00000288H
	je	SHORT $LN10@GetColumnW
$LN9@GetColumnW:
	mov	eax, 600				; 00000258H
$LN10@GetColumnW:
	movss	xmm0, DWORD PTR [rax+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm0, DWORD PTR [rdx+312]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3812 : }

	ret	0
$LN2@GetColumnW:

; 3807 :         return GetContentRegionAvail().x;
; 3808 : 
; 3809 :     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN3@GetColumnW

; 3810 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [r9+12]
$LN3@GetColumnW:

; 3811 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	mov	r8, QWORD PTR [r9+104]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm1, DWORD PTR [r9+24]
	subss	xmm1, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rdx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3811 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	lea	rax, QWORD PTR [rdx+1]
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rax, rdx, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3811 :     return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);

	movss	xmm0, DWORD PTR [rcx+r8]
	subss	xmm0, DWORD PTR [rax+r8]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	mulss	xmm0, xmm1

; 3812 : }

	ret	0
?GetColumnWidth@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ImFloor@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor, COMDAT

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiOldColumnData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiOldColumnData@@QEAA@XZ PROC			; ImGuiOldColumnData::ImGuiOldColumnData, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	xor	eax, eax
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1587 :     ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }

	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+24], eax
	mov	rax, rcx
	ret	0
??0ImGuiOldColumnData@@QEAA@XZ ENDP			; ImGuiOldColumnData::ImGuiOldColumnData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiOldColumns@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiOldColumns@@QEAA@XZ PROC			; ImGuiOldColumns::ImGuiOldColumns, COMDAT

; 1608 :     ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }

	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1608 :     ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	XMMWORD PTR [rcx+112], xmm0
	mov	QWORD PTR [rcx+128], rax
	mov	rax, rcx
	ret	0
??0ImGuiOldColumns@@QEAA@XZ ENDP			; ImGuiOldColumns::ImGuiOldColumns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableColumnSettings@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTableColumnSettings@@QEAA@XZ PROC		; ImGuiTableColumnSettings::ImGuiTableColumnSettings, COMDAT

; 2985 :     {
; 2986 :         WidthOrWeight = 0.0f;

	xor	eax, eax

; 2987 :         UserID = 0;
; 2988 :         Index = -1;

	mov	DWORD PTR [rcx+8], -1			; ffffffffH
	mov	QWORD PTR [rcx], rax
	mov	eax, -1

; 2989 :         DisplayOrder = SortOrder = -1;

	mov	WORD PTR [rcx+12], ax

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx+14]
	and	al, 244					; 000000f4H

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	BYTE PTR [rcx+14], al

; 2993 :     }

	mov	rax, rcx
	ret	0
??0ImGuiTableColumnSettings@@QEAA@XZ ENDP		; ImGuiTableColumnSettings::ImGuiTableColumnSettings
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTableSettings@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImGuiTableSettings@@QEAA@XZ PROC			; ImGuiTableSettings::ImGuiTableSettings, COMDAT

; 3006 :     ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }

	xor	eax, eax
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+16], eax
	mov	rax, rcx
	ret	0
??0ImGuiTableSettings@@QEAA@XZ ENDP			; ImGuiTableSettings::ImGuiTableSettings
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ
_TEXT	SEGMENT
this$ = 8
?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ PROC ; ImGuiTableSettings::GetColumnSettings, COMDAT

; 3007 :     ImGuiTableColumnSettings*   GetColumnSettings()     { return (ImGuiTableColumnSettings*)(this + 1); }

	lea	rax, QWORD PTR [rcx+20]
	ret	0
?GetColumnSettings@ImGuiTableSettings@@QEAAPEAUImGuiTableColumnSettings@@XZ ENDP ; ImGuiTableSettings::GetColumnSettings
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?ItemSize@ImGui@@YAXAEBUImRect@@M@Z
_TEXT	SEGMENT
$T1 = 48
bb$ = 48
text_baseline_y$ = 56
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z PROC		; ImGui::ItemSize, COMDAT

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

$LN8:
	sub	rsp, 40					; 00000028H

; 528  :     ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }

	movss	xmm0, DWORD PTR [rcx+8]
	movss	xmm2, DWORD PTR [rcx+12]
	subss	xmm0, DWORD PTR [rcx]
	subss	xmm2, DWORD PTR [rcx+4]

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	lea	rcx, QWORD PTR $T1[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T1[rsp], xmm0
	movss	DWORD PTR $T1[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3133 :     inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.

	call	?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z	; ImGui::ItemSize
	add	rsp, 40					; 00000028H
	ret	0
?ItemSize@ImGui@@YAXAEBUImRect@@M@Z ENDP		; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
table$ = 16
column_n$ = 24
?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z PROC ; ImGui::TableGetCellBgRect, COMDAT

; 1634 :     //if (column->PrevEnabledColumn == -1)
; 1635 :     //    x1 -= table->OuterPaddingX;
; 1636 :     //if (column->NextEnabledColumn == -1)
; 1637 :     //    x2 += table->OuterPaddingX;
; 1638 :     x1 = ImMax(x1, table->WorkRect.Min.x);

	movss	xmm0, DWORD PTR [rdx+264]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 623  :     inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, r8d
	imul	r8, rax, 112				; 00000070H
	add	r8, QWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1632 :     float x1 = column->MinX;

	movss	xmm3, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1633 :     float x2 = column->MaxX;

	movss	xmm2, DWORD PTR [r8+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	jae	SHORT $LN8@TableGetCe
	movaps	xmm3, xmm0
$LN8@TableGetCe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1639 :     x2 = ImMin(x2, table->WorkRect.Max.x);

	movss	xmm0, DWORD PTR [rdx+272]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, xmm2
	ja	SHORT $LN12@TableGetCe
	movaps	xmm2, xmm0
$LN12@TableGetCe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1640 :     return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);

	movss	xmm1, DWORD PTR [rdx+128]
	mov	rax, rcx
	movss	xmm0, DWORD PTR [rdx+124]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR [rcx+4], xmm0
	movss	DWORD PTR [rcx+12], xmm1
	movss	DWORD PTR [rcx], xmm3
	movss	DWORD PTR [rcx+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 1641 : }

	ret	0
?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z ENDP ; ImGui::TableGetCellBgRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z
_TEXT	SEGMENT
table$ = 8
?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z PROC		; ImGui::TableEndCell, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, DWORD PTR [rcx+116]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2060 :     ImGuiWindow* window = table->InnerWindow;

	mov	r9, QWORD PTR [rcx+384]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	imul	r8, rax, 112				; 00000070H
	add	r8, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2062 :     if (window->DC.IsSetPos)

	cmp	BYTE PTR [r9+377], 0
	je	SHORT $LN2@TableEndCe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9781 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rax+16408]

; 9782 :     IM_ASSERT(window->DC.IsSetPos);
; 9783 :     window->DC.IsSetPos = false;

	mov	BYTE PTR [rdx+377], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 463  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }

	movss	xmm1, DWORD PTR [rdx+336]
	movss	xmm0, DWORD PTR [rdx+340]
	maxss	xmm1, DWORD PTR [rdx+312]
	maxss	xmm0, DWORD PTR [rdx+316]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 9791 :     window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	movss	DWORD PTR [rdx+336], xmm1
	movss	DWORD PTR [rdx+340], xmm0
$LN2@TableEndCe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2067 :     if (table->RowFlags & ImGuiTableRowFlags_Headers)

	test	BYTE PTR [rcx+144], 1
	je	SHORT $LN3@TableEndCe

; 2068 :         p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call

	mov	eax, 72					; 00000048H
	jmp	SHORT $LN4@TableEndCe
$LN3@TableEndCe:
	cmp	BYTE PTR [rcx+565], 0
	mov	eax, 68					; 00000044H
	mov	edx, 64					; 00000040H
	cmove	eax, edx
$LN4@TableEndCe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [r8+rax]
	maxss	xmm0, DWORD PTR [r9+336]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2071 :     *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);

	movss	DWORD PTR [r8+rax], xmm0

; 2072 :     if (column->IsEnabled)

	cmp	BYTE PTR [r8+98], 0
	je	SHORT $LN5@TableEndCe

; 2073 :         table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);

	movss	xmm1, DWORD PTR [r9+340]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rcx+128]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2073 :         table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);

	addss	xmm1, DWORD PTR [rcx+192]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2073 :         table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);

	movss	DWORD PTR [rcx+128], xmm0
$LN5@TableEndCe:

; 2074 :     column->ItemWidth = window->DC.ItemWidth;

	mov	eax, DWORD PTR [r9+500]
	mov	DWORD PTR [r8+60], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rcx+136]
	maxss	xmm0, DWORD PTR [r9+372]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 2078 :     table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);

	movss	DWORD PTR [rcx+136], xmm0

; 2079 : }

	ret	0
?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z ENDP		; ImGui::TableEndCell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TablePushBackgroundChannel@ImGui@@YAXXZ
_TEXT	SEGMENT
clip_rect_vec4$1 = 32
?TablePushBackgroundChannel@ImGui@@YAXXZ PROC		; ImGui::TablePushBackgroundChannel, COMDAT

; 2289 : {

$LN10:
	sub	rsp, 56					; 00000038H

; 2290 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2291 :     ImGuiWindow* window = g.CurrentWindow;
; 2292 :     ImGuiTable* table = g.CurrentTable;

	mov	rcx, QWORD PTR [rax+19728]
	mov	r9, QWORD PTR [rax+16408]

; 2293 : 
; 2294 :     // Optimization: avoid SetCurrentChannel() + PushClipRect()
; 2295 :     table->HostBackupInnerClipRect = window->ClipRect;

	movups	xmm0, XMMWORD PTR [r9+624]
	movups	XMMWORD PTR [rcx+360], xmm0

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR [rcx+328]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rcx+328]
	movss	xmm3, DWORD PTR [rcx+332]
	movss	xmm2, DWORD PTR [rcx+336]
	movss	xmm1, DWORD PTR [rcx+340]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r9+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$1[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$1[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$1[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$1[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$1[rsp]
	movsxd	r8, DWORD PTR [rax+88]
	mov	rdx, QWORD PTR [rax+96]
	add	r8, r8
	movups	XMMWORD PTR [rdx+r8*8-16], xmm0

; 2296 :     SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
; 2297 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);

	movzx	r8d, WORD PTR [rcx+550]
	mov	rcx, QWORD PTR [rcx+408]
	mov	rdx, QWORD PTR [r9+728]

; 2298 : }

	add	rsp, 56					; 00000038H

; 2296 :     SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
; 2297 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);

	jmp	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
?TablePushBackgroundChannel@ImGui@@YAXXZ ENDP		; ImGui::TablePushBackgroundChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TablePopBackgroundChannel@ImGui@@YAXXZ
_TEXT	SEGMENT
clip_rect_vec4$1 = 32
?TablePopBackgroundChannel@ImGui@@YAXXZ PROC		; ImGui::TablePopBackgroundChannel, COMDAT

; 2301 : {

$LN12:
	sub	rsp, 56					; 00000038H

; 2302 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 2303 :     ImGuiWindow* window = g.CurrentWindow;
; 2304 :     ImGuiTable* table = g.CurrentTable;

	mov	rcx, QWORD PTR [rax+19728]
	mov	r10, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, DWORD PTR [rcx+116]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [rcx+360]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rcx+360]
	movss	xmm3, DWORD PTR [rcx+364]
	movss	xmm2, DWORD PTR [rcx+368]
	movss	xmm1, DWORD PTR [rcx+372]
	movss	DWORD PTR clip_rect_vec4$1[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$1[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$1[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$1[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	imul	r9, rax, 112				; 00000070H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r10+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	add	r9, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r10+624], xmm0

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r10+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$1[rsp]
	movsxd	r8, DWORD PTR [rax+88]
	mov	rdx, QWORD PTR [rax+96]
	add	r8, r8
	movups	XMMWORD PTR [rdx+r8*8-16], xmm0

; 2305 :     ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
; 2306 : 
; 2307 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 2308 :     SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
; 2309 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);

	movzx	r8d, WORD PTR [r9+92]
	mov	rdx, QWORD PTR [r10+728]
	mov	rcx, QWORD PTR [rcx+408]

; 2310 : }

	add	rsp, 56					; 00000038H

; 2305 :     ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
; 2306 : 
; 2307 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 2308 :     SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
; 2309 :     table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);

	jmp	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
?TablePopBackgroundChannel@ImGui@@YAXXZ ENDP		; ImGui::TablePopBackgroundChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ PROC ; `ImGui::TableMergeDrawChannels'::`2'::MergeGroup::MergeGroup, COMDAT

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	DWORD PTR [rcx+16], eax
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0MergeGroup@?1??TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z@QEAA@XZ ENDP ; `ImGui::TableMergeDrawChannels'::`2'::MergeGroup::MergeGroup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z
_TEXT	SEGMENT
settings$ = 8
id$ = 16
columns_count$ = 24
columns_count_max$ = 32
?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z PROC ; TableSettingsInit, COMDAT

; 3225 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	ebx, r8d
	mov	edi, edx
	mov	r10, rcx

; 3226 :     IM_PLACEMENT_NEW(settings) ImGuiTableSettings();

	test	rcx, rcx
	je	SHORT $LN6@TableSetti
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3006 :     ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+16], eax
$LN6@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3227 :     ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();

	xor	ebp, ebp
	lea	r8, QWORD PTR [rcx+20]
	mov	r11d, ebp

; 3228 :     for (int n = 0; n < columns_count_max; n++, settings_column++)

	lea	esi, QWORD PTR [rbp-1]
	cmp	r9d, 4
	jl	$LC18@TableSetti

; 3227 :     ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();

	lea	eax, DWORD PTR [r9-4]
	shr	eax, 2
	lea	rcx, QWORD PTR [r8+24]
	inc	eax
	mov	edx, eax
	lea	r11d, DWORD PTR [rax*4]
	npad	7

; 3228 :     for (int n = 0; n < columns_count_max; n++, settings_column++)

$LL23@TableSetti:

; 3229 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

	test	r8, r8
	je	SHORT $LN19@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2986 :         WidthOrWeight = 0.0f;

	mov	DWORD PTR [r8], ebp

; 2987 :         UserID = 0;

	mov	DWORD PTR [rcx-20], ebp

; 2988 :         Index = -1;

	mov	DWORD PTR [rcx-16], -1			; ffffffffH

; 2989 :         DisplayOrder = SortOrder = -1;

	mov	WORD PTR [rcx-12], si

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx-10]
	and	al, 244					; 000000f4H

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	BYTE PTR [rcx-10], al
$LN19@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3229 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

	lea	rax, QWORD PTR [rcx-8]
	test	rax, rax
	je	SHORT $LN20@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2986 :         WidthOrWeight = 0.0f;

	mov	DWORD PTR [rax], ebp

; 2987 :         UserID = 0;

	mov	DWORD PTR [rcx-4], ebp

; 2988 :         Index = -1;

	mov	DWORD PTR [rcx], -1			; ffffffffH

; 2989 :         DisplayOrder = SortOrder = -1;

	mov	WORD PTR [rcx+4], si

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx+6]
	and	al, 244					; 000000f4H

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	BYTE PTR [rcx+6], al
$LN20@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3229 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

	lea	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN21@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2986 :         WidthOrWeight = 0.0f;

	mov	DWORD PTR [rax], ebp

; 2987 :         UserID = 0;

	mov	DWORD PTR [rcx+12], ebp

; 2988 :         Index = -1;

	mov	DWORD PTR [rcx+16], -1			; ffffffffH

; 2989 :         DisplayOrder = SortOrder = -1;

	mov	WORD PTR [rcx+20], si

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx+22]
	and	al, 244					; 000000f4H

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	BYTE PTR [rcx+22], al
$LN21@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3229 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

	lea	rax, QWORD PTR [rcx+24]
	test	rax, rax
	je	SHORT $LN22@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2986 :         WidthOrWeight = 0.0f;

	mov	DWORD PTR [rax], ebp

; 2987 :         UserID = 0;

	mov	DWORD PTR [rcx+28], ebp

; 2988 :         Index = -1;

	mov	DWORD PTR [rcx+32], -1			; ffffffffH

; 2989 :         DisplayOrder = SortOrder = -1;

	mov	WORD PTR [rcx+36], si

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx+38]
	and	al, 244					; 000000f4H

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	BYTE PTR [rcx+38], al
$LN22@TableSetti:
	add	r8, 64					; 00000040H
	add	rcx, 64					; 00000040H
	sub	rdx, 1
	jne	$LL23@TableSetti
$LC18@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3228 :     for (int n = 0; n < columns_count_max; n++, settings_column++)

	cmp	r11d, r9d
	jge	SHORT $LN17@TableSetti
	mov	edx, r9d
	lea	rcx, QWORD PTR [r8+8]
	sub	edx, r11d
$LC4@TableSetti:

; 3229 :         IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();

	lea	rax, QWORD PTR [rcx-8]
	test	rax, rax
	je	SHORT $LN8@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 2986 :         WidthOrWeight = 0.0f;

	mov	DWORD PTR [rax], ebp

; 2990 :         SortDirection = ImGuiSortDirection_None;

	movzx	eax, BYTE PTR [rcx+6]
	and	al, 244					; 000000f4H
	mov	DWORD PTR [rcx-4], ebp

; 2991 :         IsEnabled = 1;
; 2992 :         IsStretch = 0;

	or	al, 4
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	BYTE PTR [rcx+6], al
	mov	WORD PTR [rcx+4], si
$LN8@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3228 :     for (int n = 0; n < columns_count_max; n++, settings_column++)

	add	rcx, 16
	sub	rdx, 1
	jne	SHORT $LC4@TableSetti
$LN17@TableSetti:

; 3230 :     settings->ID = id;
; 3231 :     settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
; 3232 :     settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
; 3233 :     settings->WantApply = true;
; 3234 : }

	mov	rbp, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	mov	DWORD PTR [r10], edi
	mov	rdi, QWORD PTR [rsp+32]
	mov	WORD PTR [r10+12], bx
	mov	rbx, QWORD PTR [rsp+8]
	mov	WORD PTR [r10+14], r9w
	mov	BYTE PTR [r10+16], 1
	ret	0
?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ENDP ; TableSettingsInit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsCalcChunkSize@@YA_KH@Z
_TEXT	SEGMENT
columns_count$ = 8
?TableSettingsCalcChunkSize@@YA_KH@Z PROC		; TableSettingsCalcChunkSize, COMDAT

; 3238 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

	movsxd	rax, ecx
	shl	rax, 4
	add	rax, 20

; 3239 : }

	ret	0
?TableSettingsCalcChunkSize@@YA_KH@Z ENDP		; TableSettingsCalcChunkSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z
_TEXT	SEGMENT
id$ = 48
columns_count$ = 56
?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z PROC ; ImGui::TableSettingsCreate, COMDAT

; 3242 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	esi, ecx

; 3243 :     ImGuiContext& g = *GImGui;
; 3244 :     ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3238 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

	mov	rdx, rdi
	shl	rdx, 4

; 3243 :     ImGuiContext& g = *GImGui;
; 3244 :     ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));

	add	rcx, 24144				; 00005e50H

; 3238 :     return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);

	add	rdx, 20

; 3243 :     ImGuiContext& g = *GImGui;
; 3244 :     ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));

	call	?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ; ImChunkStream<ImGuiTableSettings>::alloc_chunk

; 3245 :     TableSettingsInit(settings, id, columns_count, columns_count);

	mov	r9d, edi
	mov	r8d, edi
	mov	edx, esi
	mov	rcx, rax
	mov	rbx, rax
	call	?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ; TableSettingsInit

; 3246 :     return settings;
; 3247 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ENDP ; ImGui::TableSettingsCreate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z
_TEXT	SEGMENT
id$ = 8
?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z PROC ; ImGui::TableSettingsFindByID, COMDAT

; 3252 :     // FIXME-OPT: Might want to store a lookup map for this?
; 3253 :     ImGuiContext& g = *GImGui;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r8d, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	mov	r9, QWORD PTR [r10+24152]
	test	r9, r9
	je	SHORT $LN3@TableSetti
	lea	rax, QWORD PTR [r9+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	test	rax, rax
	je	SHORT $LN3@TableSetti
	npad	1
$LL10@TableSetti:

; 3255 :         if (settings->ID == id)

	cmp	DWORD PTR [rax], r8d
	je	SHORT $LN1@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	movsxd	rdx, DWORD PTR [rax-4]

; 709  :     T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }

	movsxd	rcx, DWORD PTR [r10+24144]

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	add	rdx, rax
	add	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	add	rcx, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	cmp	rdx, rcx
	cmovne	rax, rdx
	test	rax, rax
	jne	SHORT $LL10@TableSetti
$LN3@TableSetti:

; 3256 :             return settings;
; 3257 :     return NULL;

	xor	eax, eax
$LN1@TableSetti:

; 3258 : }

	ret	0
?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z ENDP ; ImGui::TableSettingsFindByID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
_TEXT	SEGMENT
ctx$ = 48
__formal$ = 56
?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z PROC ; TableSettingsHandler_ClearAll, COMDAT

; 3405 : {

	push	rbx
	sub	rsp, 32					; 00000020H

; 3406 :     ImGuiContext& g = *ctx;
; 3407 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

	xor	edx, edx
	mov	rbx, rcx
	cmp	DWORD PTR [rcx+19776], edx
	je	SHORT $LN3@TableSetti
	xor	r8d, r8d
	npad	10
$LL4@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 686  :     T*          TryGetMapData(ImPoolIdx n)          { int idx = Map.Data[n].val_i; if (idx == -1) return NULL; return GetByIndex(idx); }

	mov	rax, QWORD PTR [rbx+19784]
	movsxd	rcx, DWORD PTR [rax+r8+8]
	cmp	ecx, -1
	je	SHORT $LN2@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rcx, QWORD PTR [rcx+rcx*8]
	shl	rcx, 6
	add	rcx, QWORD PTR [rbx+19768]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3408 :         if (ImGuiTable* table = g.Tables.TryGetMapData(i))

	je	SHORT $LN2@TableSetti

; 3409 :             table->SettingsOffset = -1;

	mov	DWORD PTR [rcx+100], -1
$LN2@TableSetti:

; 3406 :     ImGuiContext& g = *ctx;
; 3407 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

	inc	edx
	add	r8, 16
	cmp	edx, DWORD PTR [rbx+19776]
	jne	SHORT $LL4@TableSetti
$LN3@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rbx+24152]
	test	rcx, rcx
	je	SHORT $LN19@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+24144], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN23@TableSetti

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN23@TableSetti:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+24152], 0
$LN19@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3411 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?TableSettingsHandler_ClearAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ENDP ; TableSettingsHandler_ClearAll
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z
_TEXT	SEGMENT
ctx$ = 8
__formal$ = 16
?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z PROC ; TableSettingsHandler_ApplyAll, COMDAT

; 3416 :     ImGuiContext& g = *ctx;
; 3417 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

	xor	edx, edx
	cmp	DWORD PTR [rcx+19776], edx
	je	SHORT $LN3@TableSetti
	mov	r8d, edx
	npad	3
$LL4@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 686  :     T*          TryGetMapData(ImPoolIdx n)          { int idx = Map.Data[n].val_i; if (idx == -1) return NULL; return GetByIndex(idx); }

	mov	rax, QWORD PTR [rcx+19784]
	movsxd	r9, DWORD PTR [r8+rax+8]
	cmp	r9d, -1
	je	SHORT $LN2@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	lea	rax, QWORD PTR [r9+r9*8]
	shl	rax, 6
	add	rax, QWORD PTR [rcx+19768]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3418 :         if (ImGuiTable* table = g.Tables.TryGetMapData(i))

	je	SHORT $LN2@TableSetti

; 3419 :         {
; 3420 :             table->IsSettingsRequestLoad = true;

	mov	BYTE PTR [rax+560], 1

; 3421 :             table->SettingsOffset = -1;

	mov	DWORD PTR [rax+100], -1
$LN2@TableSetti:

; 3416 :     ImGuiContext& g = *ctx;
; 3417 :     for (int i = 0; i != g.Tables.GetMapSize(); i++)

	inc	edx
	add	r8, 16
	cmp	edx, DWORD PTR [rcx+19776]
	jne	SHORT $LL4@TableSetti
$LN3@TableSetti:

; 3422 :         }
; 3423 : }

	ret	0
?TableSettingsHandler_ApplyAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@@Z ENDP ; TableSettingsHandler_ApplyAll
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z
_TEXT	SEGMENT
id$ = 32
columns_count$ = 36
__$ArrayPad$ = 40
__formal$ = 64
__formal$ = 72
name$ = 80
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z PROC ; TableSettingsHandler_ReadOpen, COMDAT

; 3426 : {

	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rcx, r8

; 3427 :     ImGuiID id = 0;

	mov	DWORD PTR id$[rsp], 0

; 3428 :     int columns_count = 0;
; 3429 :     if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)

	lea	r8, QWORD PTR id$[rsp]
	mov	DWORD PTR columns_count$[rsp], 0
	lea	r9, QWORD PTR columns_count$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_09BDLBIGPI@0x?$CF08X?0?$CFd@
	call	sscanf
	cmp	eax, 2
	jge	SHORT $LN2@TableSetti

; 3430 :         return NULL;

	xor	eax, eax

; 3442 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
$LN2@TableSetti:

; 3253 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	QWORD PTR [rsp+48], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	mov	r8, QWORD PTR [r9+24152]
	test	r8, r8
	je	SHORT $LN25@TableSetti
	lea	rbx, QWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	test	rbx, rbx
	je	SHORT $LN25@TableSetti
	mov	r10d, DWORD PTR id$[rsp]
	npad	5
$LL15@TableSetti:

; 3255 :         if (settings->ID == id)

	cmp	DWORD PTR [rbx], r10d
	je	SHORT $LN6@TableSetti
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	movsxd	rdx, DWORD PTR [rbx-4]

; 709  :     T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }

	movsxd	rcx, DWORD PTR [r9+24144]

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	add	rdx, rbx
	add	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	xor	ebx, ebx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	add	rcx, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3254 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	cmp	rdx, rcx
	cmovne	rbx, rdx
	test	rbx, rbx
	jne	SHORT $LL15@TableSetti

; 3255 :         if (settings->ID == id)

	jmp	SHORT $LN3@TableSetti
$LN6@TableSetti:

; 3431 : 
; 3432 :     if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))
; 3433 :     {
; 3434 :         if (settings->ColumnsCountMax >= columns_count)

	movsx	r9d, WORD PTR [rbx+14]
	mov	r8d, DWORD PTR columns_count$[rsp]
	cmp	r9d, r8d
	jl	SHORT $LN4@TableSetti

; 3435 :         {
; 3436 :             TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle

	mov	edx, r10d
	mov	rcx, rbx
	call	?TableSettingsInit@@YAXPEAUImGuiTableSettings@@IHH@Z ; TableSettingsInit

; 3437 :             return settings;

	mov	rax, rbx
	jmp	SHORT $LN31@TableSetti
$LN4@TableSetti:

; 3438 :         }
; 3439 :         settings->ID = 0; // Invalidate storage, we won't fit because of a count change

	mov	DWORD PTR [rbx], 0
$LN25@TableSetti:

; 3440 :     }
; 3441 :     return ImGui::TableSettingsCreate(id, columns_count);

	mov	r10d, DWORD PTR id$[rsp]
$LN3@TableSetti:
	mov	edx, DWORD PTR columns_count$[rsp]
	mov	ecx, r10d
	call	?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z ; ImGui::TableSettingsCreate
$LN31@TableSetti:
	mov	rbx, QWORD PTR [rsp+48]

; 3442 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?TableSettingsHandler_ReadOpen@@YAPEAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEBD@Z ENDP ; TableSettingsHandler_ReadOpen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z
_TEXT	SEGMENT
r$ = 48
column_n$ = 52
c$1 = 56
n$ = 60
f$ = 64
__$ArrayPad$ = 72
__formal$ = 112
__formal$ = 120
entry$ = 128
line$ = 136
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z PROC ; TableSettingsHandler_ReadLine, COMDAT

; 3445 : {

	push	rbp
	push	rsi
	push	rdi
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-80], rax

; 3446 :     // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
; 3447 :     ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;
; 3448 :     float f = 0.0f;
; 3449 :     int column_n = 0, r = 0, n = 0;

	xor	eax, eax
	mov	DWORD PTR f$[rbp-80], 0
	mov	rdi, r8
	mov	DWORD PTR column_n$[rbp-80], eax

; 3450 : 
; 3451 :     if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }

	lea	r8, QWORD PTR f$[rbp-80]
	mov	DWORD PTR r$[rbp-80], eax
	lea	rdx, OFFSET FLAT:??_C@_0M@LAOOHBLO@RefScale?$DN?$CFf@
	mov	DWORD PTR n$[rbp-80], eax
	mov	rcx, r9
	mov	rsi, r9
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN2@TableSetti
	movss	xmm0, DWORD PTR f$[rbp-80]
	movss	DWORD PTR [rdi+8], xmm0
	jmp	$LN5@TableSetti
$LN2@TableSetti:

; 3452 : 
; 3453 :     if (sscanf(line, "Column %d%n", &column_n, &r) == 1)

	lea	r9, QWORD PTR r$[rbp-80]
	mov	rcx, rsi
	lea	r8, QWORD PTR column_n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0M@JOECNJOM@Column?5?$CFd?$CFn@
	call	sscanf
	cmp	eax, 1
	jne	$LN5@TableSetti

; 3454 :     {
; 3455 :         if (column_n < 0 || column_n >= settings->ColumnsCount)

	movsxd	rcx, DWORD PTR column_n$[rbp-80]
	test	ecx, ecx
	js	$LN5@TableSetti
	movsx	eax, WORD PTR [rdi+12]
	cmp	ecx, eax
	jge	$LN5@TableSetti
	mov	QWORD PTR [rsp+112], rbx

; 3456 :             return;
; 3457 :         line = ImStrSkipBlank(line + r);

	movsxd	rbx, DWORD PTR r$[rbp-80]
	add	rbx, rsi
	npad	4
$LL14@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@TableSetti
	cmp	al, 9
	jne	SHORT $LN15@TableSetti
$LN16@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL14@TableSetti
$LN15@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3459 :         ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;

	mov	rsi, rcx
	mov	BYTE PTR c$1[rbp-80], 0
	add	rsi, rsi

; 3461 :         if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }

	lea	r9, QWORD PTR r$[rbp-80]
	lea	r8, QWORD PTR n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0BA@KAIOJKEL@UserID?$DN0x?$CF08X?$CFn@
	mov	WORD PTR [rdi+rsi*8+28], cx
	mov	rcx, rbx
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN6@TableSetti
	movsxd	rax, DWORD PTR r$[rbp-80]
	add	rbx, rax
$LL19@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN21@TableSetti
	cmp	al, 9
	jne	SHORT $LN20@TableSetti
$LN21@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL19@TableSetti
$LN20@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3461 :         if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }

	mov	eax, DWORD PTR n$[rbp-80]
	mov	DWORD PTR [rdi+rsi*8+24], eax
$LN6@TableSetti:

; 3462 :         if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

	lea	r9, QWORD PTR r$[rbp-80]
	mov	rcx, rbx
	lea	r8, QWORD PTR n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0L@LJLKPCDP@Width?$DN?$CFd?$CFn@
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN73@TableSetti
	movsxd	rax, DWORD PTR r$[rbp-80]
	add	rbx, rax
	npad	4
$LL24@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN26@TableSetti
	cmp	al, 9
	jne	SHORT $LN25@TableSetti
$LN26@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL24@TableSetti
$LN25@TableSetti:
	movd	xmm0, DWORD PTR n$[rbp-80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3462 :         if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

	and	BYTE PTR [rdi+rsi*8+34], 247		; 000000f7H
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rdi+rsi*8+20], xmm0
	or	DWORD PTR [rdi+4], 1
$LN73@TableSetti:

; 3463 :         if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

	lea	r9, QWORD PTR r$[rbp-80]
	mov	rcx, rbx
	lea	r8, QWORD PTR f$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0M@IJODOCHC@Weight?$DN?$CFf?$CFn@
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN74@TableSetti
	movsxd	rax, DWORD PTR r$[rbp-80]
	add	rbx, rax
	npad	6
$LL29@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN31@TableSetti
	cmp	al, 9
	jne	SHORT $LN30@TableSetti
$LN31@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL29@TableSetti
$LN30@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3463 :         if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }

	movss	xmm0, DWORD PTR f$[rbp-80]
	or	BYTE PTR [rdi+rsi*8+34], 8
	movss	DWORD PTR [rdi+rsi*8+20], xmm0
	or	DWORD PTR [rdi+4], 1
$LN74@TableSetti:

; 3464 :         if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }

	lea	r9, QWORD PTR r$[rbp-80]
	mov	rcx, rbx
	lea	r8, QWORD PTR n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0N@EKALHFOF@Visible?$DN?$CFd?$CFn@
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN75@TableSetti
	movsxd	rax, DWORD PTR r$[rbp-80]
	add	rbx, rax
$LL34@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN36@TableSetti
	cmp	al, 9
	jne	SHORT $LN35@TableSetti
$LN36@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL34@TableSetti
$LN35@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3464 :         if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }

	movzx	eax, BYTE PTR [rdi+rsi*8+34]
	movzx	ecx, BYTE PTR n$[rbp-80]
	and	al, 251					; 000000fbH
	and	cl, 1
	shl	cl, 2
	or	cl, al
	mov	BYTE PTR [rdi+rsi*8+34], cl
	or	DWORD PTR [rdi+4], 4
$LN75@TableSetti:

; 3465 :         if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }

	lea	r9, QWORD PTR r$[rbp-80]
	mov	rcx, rbx
	lea	r8, QWORD PTR n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHOFPJL@Order?$DN?$CFd?$CFn@
	call	sscanf
	cmp	eax, 1
	jne	SHORT $LN76@TableSetti
	movsxd	rax, DWORD PTR r$[rbp-80]
	add	rbx, rax
$LL39@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1905 :     while (str[0] == ' ' || str[0] == '\t')

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN41@TableSetti
	cmp	al, 9
	jne	SHORT $LN40@TableSetti
$LN41@TableSetti:

; 1906 :         str++;

	inc	rbx
	jmp	SHORT $LL39@TableSetti
$LN40@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3465 :         if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }

	movzx	eax, WORD PTR n$[rbp-80]
	mov	WORD PTR [rdi+rsi*8+30], ax
	or	DWORD PTR [rdi+4], 2
$LN76@TableSetti:

; 3466 :         if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }

	lea	rax, QWORD PTR r$[rbp-80]
	mov	rcx, rbx
	lea	r9, QWORD PTR c$1[rbp-80]
	mov	QWORD PTR [rsp+32], rax
	lea	r8, QWORD PTR n$[rbp-80]
	lea	rdx, OFFSET FLAT:??_C@_0M@KGHCDDIO@Sort?$DN?$CFd?$CFc?$CFn@
	call	sscanf
	mov	rbx, QWORD PTR [rsp+112]
	cmp	eax, 2
	jne	SHORT $LN5@TableSetti
	movzx	eax, WORD PTR n$[rbp-80]
	mov	WORD PTR [rdi+rsi*8+32], ax
	cmp	BYTE PTR c$1[rbp-80], 94		; 0000005eH
	movzx	eax, BYTE PTR [rdi+rsi*8+34]
	sete	cl
	and	al, 252					; 000000fcH
	inc	cl
	or	cl, al
	mov	BYTE PTR [rdi+rsi*8+34], cl
	or	DWORD PTR [rdi+4], 8
$LN5@TableSetti:

; 3467 :     }
; 3468 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-80]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?TableSettingsHandler_ReadLine@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAXPEBD@Z ENDP ; TableSettingsHandler_ReadLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z
_TEXT	SEGMENT
tv1158 = 48
ctx$ = 144
handler$ = 152
buf$ = 160
save_size$1$ = 168
?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z PROC ; TableSettingsHandler_WriteAll, COMDAT

; 3471 : {

	mov	r11, rsp
	mov	QWORD PTR [r11+16], rdx
	mov	QWORD PTR [r11+8], rcx
	push	rbx
	push	rdi
	sub	rsp, 120				; 00000078H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	mov	rax, QWORD PTR [rcx+24152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3471 : {

	mov	rdi, rdx
	mov	rbx, r8
	mov	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 706  :     T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }

	test	rax, rax
	je	$LN3@TableSetti
	mov	QWORD PTR [r11-32], r12
	lea	r12, QWORD PTR [rax+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3473 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	test	r12, r12
	je	$LN112@TableSetti
	mov	QWORD PTR [r11+24], rbp
	mov	QWORD PTR [r11-24], rsi
	mov	QWORD PTR [r11-40], r13
	mov	QWORD PTR [r11-48], r14
	xor	r14d, r14d
	mov	QWORD PTR [r11-56], r15
	movaps	XMMWORD PTR [rsp+64], xmm6
	xorps	xmm6, xmm6
	npad	6
$LL25@TableSetti:

; 3474 :     {
; 3475 :         if (settings->ID == 0) // Skip ditched settings

	cmp	DWORD PTR [r12], 0
	je	$LN2@TableSetti

; 3476 :             continue;
; 3477 : 
; 3478 :         // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
; 3479 :         // (e.g. Order was unchanged)
; 3480 :         const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
; 3481 :         const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;

	mov	r15d, DWORD PTR [r12+4]
	mov	r13d, r15d
	movzx	ebp, BYTE PTR [r12+4]

; 3482 :         const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;

	mov	esi, r15d
	shr	esi, 1
	and	bpl, 1
	shr	r13d, 2
	and	sil, 1

; 3483 :         const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;

	shr	r15d, 3
	and	r13b, 1
	and	r15b, 1
	mov	BYTE PTR save_size$1$[rsp], bpl
	mov	DWORD PTR tv1158[rsp], esi

; 3484 :         if (!save_size && !save_visible && !save_order && !save_sort)

	test	bpl, bpl
	jne	SHORT $LN9@TableSetti
	test	r13b, r13b
	jne	SHORT $LN9@TableSetti
	test	sil, sil
	jne	SHORT $LN9@TableSetti
	test	r15b, r15b
	je	$LN2@TableSetti
$LN9@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2420 :     int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }

	mov	r8d, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3487 :         buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve

	movsx	eax, WORD PTR [r12+12]
	imul	ecx, eax, 50				; 00000032H
	lea	edx, DWORD PTR [r8-1]
	add	edx, ecx
	test	r8d, r8d
	cmove	edx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2423 :     void                reserve(int capacity)   { Buf.reserve(capacity); }

	mov	rcx, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3487 :         buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve

	add	edx, 30
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2423 :     void                reserve(int capacity)   { Buf.reserve(capacity); }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3488 :         buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);

	movsx	eax, WORD PTR [r12+12]
	lea	rdx, OFFSET FLAT:??_C@_0BB@PGHPBJD@?$FL?$CFs?$FN?$FL0x?$CF08X?0?$CFd?$FN?6@
	mov	r9d, DWORD PTR [r12]
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi]
	mov	DWORD PTR [rsp+32], eax
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf

; 3489 :         if (settings->RefScale != 0.0f)

	movss	xmm0, DWORD PTR [r12+8]
	ucomiss	xmm0, xmm6
	jp	SHORT $LN84@TableSetti
	je	SHORT $LN10@TableSetti
$LN84@TableSetti:

; 3490 :             buf->appendf("RefScale=%g\n", settings->RefScale);

	cvtps2pd xmm2, xmm0
	lea	rdx, OFFSET FLAT:??_C@_0N@NHEEPCEH@RefScale?$DN?$CFg?6@
	mov	rcx, rbx
	movq	r8, xmm2
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN10@TableSetti:

; 3492 :         for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)

	xor	eax, eax
	lea	rdi, QWORD PTR [r12+20]
	cmp	ax, WORD PTR [r12+12]
	jge	$LN83@TableSetti
$LL7@TableSetti:

; 3493 :         {
; 3494 :             // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
; 3495 :             bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);

	cmp	DWORD PTR [rdi+4], 0
	jne	SHORT $LN19@TableSetti
	test	bpl, bpl
	jne	SHORT $LN19@TableSetti
	test	r13b, r13b
	jne	SHORT $LN19@TableSetti
	test	sil, sil
	jne	SHORT $LN19@TableSetti
	test	r15b, r15b
	je	$LN5@TableSetti
	cmp	WORD PTR [rdi+12], -1
	je	$LN5@TableSetti
$LN19@TableSetti:

; 3496 :             if (!save_column)
; 3497 :                 continue;
; 3498 :             buf->appendf("Column %-2d", column_n);

	mov	r8d, r14d
	lea	rdx, OFFSET FLAT:??_C@_0M@JLNIJDCE@Column?5?$CF?92d@
	mov	rcx, rbx
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf

; 3499 :             if (column->UserID != 0)                    { buf->appendf(" UserID=%08X", column->UserID); }

	mov	r8d, DWORD PTR [rdi+4]
	test	r8d, r8d
	je	SHORT $LN12@TableSetti
	lea	rdx, OFFSET FLAT:??_C@_0N@PGBEGIHP@?5UserID?$DN?$CF08X@
	mov	rcx, rbx
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN12@TableSetti:

; 3500 :             if (save_size && column->IsStretch)         { buf->appendf(" Weight=%.4f", column->WidthOrWeight); }

	test	bpl, bpl
	je	SHORT $LN14@TableSetti
	test	BYTE PTR [rdi+14], 8
	je	SHORT $LN114@TableSetti
	movss	xmm2, DWORD PTR [rdi]
	lea	rdx, OFFSET FLAT:??_C@_0N@MFKBBKPH@?5Weight?$DN?$CF?44f@
	cvtps2pd xmm2, xmm2
	mov	rcx, rbx
	movq	r8, xmm2
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf

; 3501 :             if (save_size && !column->IsStretch)        { buf->appendf(" Width=%d", (int)column->WidthOrWeight); }

	test	BYTE PTR [rdi+14], 8
	jne	SHORT $LN14@TableSetti
$LN114@TableSetti:
	cvttss2si r8d, DWORD PTR [rdi]
	lea	rdx, OFFSET FLAT:??_C@_09PBOBBCAP@?5Width?$DN?$CFd@
	mov	rcx, rbx
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN14@TableSetti:

; 3502 :             if (save_visible)                           { buf->appendf(" Visible=%d", column->IsEnabled); }

	test	r13b, r13b
	je	SHORT $LN82@TableSetti
	movzx	r8d, BYTE PTR [rdi+14]
	lea	rdx, OFFSET FLAT:??_C@_0M@CIPDPODB@?5Visible?$DN?$CFd@
	shr	r8d, 2
	mov	rcx, rbx
	and	r8d, 1
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN82@TableSetti:

; 3503 :             if (save_order)                             { buf->appendf(" Order=%d", column->DisplayOrder); }

	test	sil, sil
	je	SHORT $LN16@TableSetti
	movsx	r8d, WORD PTR [rdi+10]
	lea	rdx, OFFSET FLAT:??_C@_09CFPCIBAG@?5Order?$DN?$CFd@
	mov	rcx, rbx
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN16@TableSetti:

; 3504 :             if (save_sort && column->SortOrder != -1)   { buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^'); }

	test	r15b, r15b
	je	SHORT $LN17@TableSetti
	movsx	ecx, WORD PTR [rdi+12]
	cmp	cx, -1
	je	SHORT $LN17@TableSetti
	movzx	eax, BYTE PTR [rdi+14]
	lea	rdx, OFFSET FLAT:??_C@_0L@EAJILIBD@?5Sort?$DN?$CFd?$CFc@
	and	al, 3
	mov	r9d, 94					; 0000005eH
	cmp	al, 1
	mov	r8d, ecx
	mov	eax, 118				; 00000076H
	mov	rcx, rbx
	cmove	r9d, eax
	call	?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ	; ImGuiTextBuffer::appendf
$LN17@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2680 :     const int write_off = (Buf.Size != 0) ? Buf.Size : 1;

	mov	eax, DWORD PTR [rbx]
	mov	ebp, 1

; 2681 :     const int needed_sz = write_off + len;
; 2682 :     if (write_off + len >= Buf.Capacity)

	mov	edx, DWORD PTR [rbx+4]
	test	eax, eax
	cmovne	ebp, eax
	lea	esi, DWORD PTR [rbp+1]
	cmp	esi, edx
	jl	SHORT $LN37@TableSetti

; 2683 :     {
; 2684 :         int new_capacity = Buf.Capacity * 2;

	add	edx, edx

; 2685 :         Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);

	mov	rcx, rbx
	cmp	esi, edx
	cmovg	edx, esi
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN37@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+4]
	cmp	esi, ecx
	jle	SHORT $LN44@TableSetti

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN48@TableSetti
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN49@TableSetti
$LN48@TableSetti:
	mov	eax, 8
$LN49@TableSetti:
	cmp	eax, esi
	mov	edx, esi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN44@TableSetti:
	mov	DWORD PTR [rbx], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2689 :     memcpy(&Buf[write_off - 1], str, (size_t)len);

	mov	rax, QWORD PTR [rbx+8]
	mov	esi, DWORD PTR tv1158[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2689 :     memcpy(&Buf[write_off - 1], str, (size_t)len);

	mov	BYTE PTR [rcx+rax-1], 10

; 2690 :     Buf[write_off - 1 + len] = 0;

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, ebp
	movzx	ebp, BYTE PTR save_size$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2690 :     Buf[write_off - 1 + len] = 0;

	mov	BYTE PTR [rcx+rax], 0
$LN5@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3492 :         for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)

	movsx	eax, WORD PTR [r12+12]
	inc	r14d
	add	rdi, 16
	cmp	r14d, eax
	jl	$LL7@TableSetti
$LN83@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2680 :     const int write_off = (Buf.Size != 0) ? Buf.Size : 1;

	mov	eax, DWORD PTR [rbx]
	mov	esi, 1

; 2681 :     const int needed_sz = write_off + len;
; 2682 :     if (write_off + len >= Buf.Capacity)

	mov	edx, DWORD PTR [rbx+4]
	test	eax, eax
	cmovne	esi, eax
	lea	edi, DWORD PTR [rsi+1]
	cmp	edi, edx
	jl	SHORT $LN55@TableSetti

; 2683 :     {
; 2684 :         int new_capacity = Buf.Capacity * 2;

	add	edx, edx

; 2685 :         Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);

	mov	rcx, rbx
	cmp	edi, edx
	cmovg	edx, edi
	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN55@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rbx+4]
	cmp	edi, ecx
	jle	SHORT $LN62@TableSetti

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN66@TableSetti
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN67@TableSetti
$LN66@TableSetti:
	mov	eax, 8
$LN67@TableSetti:
	cmp	eax, edi
	mov	edx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN62@TableSetti:
	mov	rdx, QWORD PTR ctx$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2690 :     Buf[write_off - 1 + len] = 0;

	xor	r14d, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [rbx], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2689 :     memcpy(&Buf[write_off - 1], str, (size_t)len);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR handler$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2689 :     memcpy(&Buf[write_off - 1], str, (size_t)len);

	mov	BYTE PTR [rcx+rax-1], 10

; 2690 :     Buf[write_off - 1 + len] = 0;

	mov	rax, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rcx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2690 :     Buf[write_off - 1 + len] = 0;

	mov	BYTE PTR [rcx+rax], 0
$LN2@TableSetti:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 709  :     T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }

	movsxd	rcx, DWORD PTR [rdx+24144]

; 707  :     T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }

	mov	rdx, QWORD PTR [rdx+24152]
	movsxd	r8, DWORD PTR [r12-4]
	add	rdx, 4
	add	r8, r12
	add	rdx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3473 :     for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))

	cmp	r8, rdx
	mov	r12, r14
	mov	rdx, QWORD PTR ctx$[rsp]
	cmovne	r12, r8
	test	r12, r12
	jne	$LL25@TableSetti
	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	mov	r13, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+160]
$LN112@TableSetti:
	mov	r12, QWORD PTR [rsp+104]
$LN3@TableSetti:

; 3505 :             buf->append("\n");
; 3506 :         }
; 3507 :         buf->append("\n");
; 3508 :     }
; 3509 : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rbx
	ret	0
?TableSettingsHandler_WriteAll@@YAXPEAUImGuiContext@@PEAUImGuiSettingsHandler@@PEAUImGuiTextBuffer@@@Z ENDP ; TableSettingsHandler_WriteAll
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z
_TEXT	SEGMENT
clip_rect_vec4$ = 0
window$ = 32
clip_rect$ = 40
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z PROC ; ImGui::SetWindowClipRectBeforeSetChannel, COMDAT

; 3724 : {

$LN8:
	sub	rsp, 24

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [rdx]

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [rcx+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [rcx+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [rcx+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$[rsp]
	movsxd	rdx, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR [rax+96]
	add	rdx, rdx
	movups	XMMWORD PTR [rcx+rdx*8-16], xmm0

; 3729 : }

	add	rsp, 24
	ret	0
?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z ENDP ; ImGui::SetWindowClipRectBeforeSetChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z
_TEXT	SEGMENT
columns$ = 8
offset$ = 16
?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z PROC ; ImGui::GetColumnNormFromOffset, COMDAT

; 3750 :     return offset / (columns->OffMaxX - columns->OffMinX);

	movss	xmm0, DWORD PTR [rcx+24]
	subss	xmm0, DWORD PTR [rcx+20]
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 3751 : }

	ret	0
?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z ENDP ; ImGui::GetColumnNormFromOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z
_TEXT	SEGMENT
columns$ = 8
column_index$ = 16
?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z PROC ; GetDraggedColumnOffset, COMDAT

; 3757 :     // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
; 3758 :     // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
; 3759 :     ImGuiContext& g = *GImGui;

	mov	r9, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3765 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

	lea	r8d, DWORD PTR [rdx-1]
	mov	r10d, edx
	mov	r11, rcx
	xorps	xmm1, xmm1
	mov	rax, QWORD PTR [r9+16408]
	movss	xmm2, DWORD PTR [r9+3592]
	subss	xmm2, DWORD PTR [r9+16524]

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 3760 :     ImGuiWindow* window = g.CurrentWindow;
; 3761 :     IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
; 3762 :     IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));
; 3763 : 
; 3764 :     float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;

	addss	xmm2, DWORD PTR __real@40800000
	subss	xmm2, DWORD PTR [rax+80]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN5@GetDragged
	xorps	xmm3, xmm3

; 3777 :         return 0.0f;

	jmp	SHORT $LN4@GetDragged
$LN5@GetDragged:

; 3778 : 
; 3779 :     if (column_index < 0)

	test	r8d, r8d
	jns	SHORT $LN29@GetDragged

; 3780 :         column_index = columns->Current;

	mov	r8d, DWORD PTR [rdx+12]
$LN29@GetDragged:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm3, DWORD PTR [rdx+24]
	subss	xmm3, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r8d
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm3, DWORD PTR [rcx+rax]
	addss	xmm3, DWORD PTR [rdx+20]
$LN4@GetDragged:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3765 :     x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);

	movss	xmm4, DWORD PTR [r9+14664]
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm2, xmm0
	jae	SHORT $LN15@GetDragged
	movaps	xmm2, xmm0
$LN15@GetDragged:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3766 :     if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))

	test	BYTE PTR [r11+4], 4
	je	SHORT $LN31@GetDragged

; 3767 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	lea	eax, DWORD PTR [r10+1]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	je	SHORT $LN16@GetDragged

; 3778 : 
; 3779 :     if (column_index < 0)

	test	eax, eax
	jns	SHORT $LN18@GetDragged

; 3780 :         column_index = columns->Current;

	mov	eax, DWORD PTR [rdx+12]
$LN18@GetDragged:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
	subss	xmm1, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [rdx+20]
$LN16@GetDragged:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3767 :         x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	subss	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm1, xmm2
	ja	SHORT $LN31@GetDragged
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3769 :     return x;

	movaps	xmm0, xmm1

; 3770 : }

	ret	0
$LN31@GetDragged:
	movaps	xmm0, xmm2
	ret	0
?GetDraggedColumnOffset@@YAMPEAUImGuiOldColumns@@H@Z ENDP ; GetDraggedColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z
_TEXT	SEGMENT
columns$ = 8
column_index$ = 16
before_resize$ = 24
?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z PROC	; GetColumnWidthEx, COMDAT

; 3790 :     if (column_index < 0)

	test	edx, edx
	jns	SHORT $LN2@GetColumnW

; 3791 :         column_index = columns->Current;

	mov	edx, DWORD PTR [rcx+12]
$LN2@GetColumnW:

; 3792 : 
; 3793 :     float offset_norm;
; 3794 :     if (before_resize)

	mov	r9, QWORD PTR [rcx+104]
	movsxd	rdx, edx
	lea	rax, QWORD PTR [rdx+1]
	imul	r10, rax, 28
	imul	rax, rdx, 28
	test	r8b, r8b
	je	SHORT $LN3@GetColumnW

; 3795 :         offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

	movss	xmm1, DWORD PTR [r10+r9+4]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm0, DWORD PTR [rcx+24]

; 3795 :         offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

	subss	xmm1, DWORD PTR [rax+r9+4]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	subss	xmm0, DWORD PTR [rcx+20]
	mulss	xmm0, xmm1

; 3798 :     return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
; 3799 : }

	ret	0
$LN3@GetColumnW:

; 3796 :     else
; 3797 :         offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

	movss	xmm1, DWORD PTR [r10+r9]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm0, DWORD PTR [rcx+24]

; 3796 :     else
; 3797 :         offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

	subss	xmm1, DWORD PTR [rax+r9]

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	subss	xmm0, DWORD PTR [rcx+20]
	mulss	xmm0, xmm1

; 3798 :     return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
; 3799 : }

	ret	0
?GetColumnWidthEx@@YAMPEAUImGuiOldColumns@@H_N@Z ENDP	; GetColumnWidthEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?SetColumnOffset@ImGui@@YAXHM@Z
_TEXT	SEGMENT
column_index$ = 8
offset$ = 16
?SetColumnOffset@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnOffset, COMDAT

; 3815 : {

$LN58:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 3816 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movaps	xmm2, xmm1
	mov	r8d, ecx
	npad	4
$LL37@SetColumnO:

; 3817 :     ImGuiWindow* window = g.CurrentWindow;
; 3818 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [rbx+16408]
	mov	r9, QWORD PTR [rax+480]

; 3819 :     IM_ASSERT(columns != NULL);
; 3820 : 
; 3821 :     if (column_index < 0)

	test	r8d, r8d
	jns	SHORT $LN47@SetColumnO

; 3822 :         column_index = columns->Current;

	mov	r8d, DWORD PTR [r9+12]
$LN47@SetColumnO:

; 3823 :     IM_ASSERT(column_index < columns->Columns.Size);
; 3824 : 
; 3825 :     const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);

	mov	edi, DWORD PTR [r9+4]
	lea	r10, QWORD PTR [r9+16]
	test	dil, 4
	jne	SHORT $LN40@SetColumnO
	mov	eax, DWORD PTR [r10]
	dec	eax
	cmp	r8d, eax
	jge	SHORT $LN40@SetColumnO
	mov	sil, 1

; 3826 :     const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

	mov	eax, r8d

; 3790 :     if (column_index < 0)

	test	r8d, r8d
	jns	SHORT $LN46@SetColumnO

; 3791 :         column_index = columns->Current;

	mov	eax, DWORD PTR [r9+12]
$LN46@SetColumnO:

; 3792 : 
; 3793 :     float offset_norm;
; 3794 :     if (before_resize)

	mov	rcx, QWORD PTR [r9+104]
	movsxd	rdx, eax
	lea	rax, QWORD PTR [rdx+1]
	imul	r11, rax, 28
	imul	rax, rdx, 28
	cmp	BYTE PTR [r9+9], 0
	je	SHORT $LN12@SetColumnO

; 3795 :         offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;

	movss	xmm0, DWORD PTR [r11+rcx+4]
	subss	xmm0, DWORD PTR [rax+rcx+4]
	jmp	SHORT $LN13@SetColumnO
$LN12@SetColumnO:

; 3796 :     else
; 3797 :         offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;

	movss	xmm0, DWORD PTR [r11+rcx]
	subss	xmm0, DWORD PTR [rax+rcx]
$LN13@SetColumnO:

; 3745 :     return offset_norm * (columns->OffMaxX - columns->OffMinX);

	movss	xmm3, DWORD PTR [r9+24]
	movaps	xmm4, xmm3
	subss	xmm4, DWORD PTR [r9+20]
	mulss	xmm4, xmm0

; 3826 :     const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

	jmp	SHORT $LN9@SetColumnO
$LN40@SetColumnO:
	movss	xmm3, DWORD PTR [r9+24]
	xor	sil, sil
	xorps	xmm4, xmm4
$LN9@SetColumnO:

; 3827 : 
; 3828 :     if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))

	test	dil, 8
	jne	SHORT $LN28@SetColumnO

; 3829 :         offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));

	mov	eax, DWORD PTR [r10]
	movaps	xmm1, xmm3
	sub	eax, r8d
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [rbx+14664]
	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	comiss	xmm1, xmm2
	ja	SHORT $LN28@SetColumnO
	movaps	xmm2, xmm1
$LN28@SetColumnO:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3750 :     return offset / (columns->OffMaxX - columns->OffMinX);

	subss	xmm3, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3830 :     columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3750 :     return offset / (columns->OffMaxX - columns->OffMinX);

	divss	xmm1, xmm3

; 3830 :     columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

	mov	rax, QWORD PTR [r9+104]
	movss	DWORD PTR [rcx+rax], xmm1

; 3831 : 
; 3832 :     if (preserve_width)

	test	sil, sil
	je	SHORT $LN4@SetColumnO
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR [rbx+14664]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3833 :         SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));

	inc	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3833 :         SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));

	addss	xmm2, xmm0
	jmp	$LL37@SetColumnO
$LN4@SetColumnO:

; 3834 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
?SetColumnOffset@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?SetColumnWidth@ImGui@@YAXHM@Z
_TEXT	SEGMENT
column_index$ = 8
width$ = 16
?SetColumnWidth@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnWidth, COMDAT

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3837 : {

	movaps	xmm2, xmm1
	movsxd	r9, ecx

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+16408]
	mov	r8, QWORD PTR [rdx+480]

; 3776 :     if (columns == NULL)

	test	r8, r8
	jne	SHORT $LN5@SetColumnW

; 3844 :     SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

	xorps	xmm1, xmm1
	lea	ecx, DWORD PTR [r9+1]
	addss	xmm1, xmm2
	jmp	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
$LN5@SetColumnW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [r8+24]
	subss	xmm1, DWORD PTR [r8+20]
	mov	rax, QWORD PTR [r8+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, r9, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mulss	xmm1, DWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3844 :     SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

	lea	ecx, DWORD PTR [r9+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	addss	xmm1, DWORD PTR [r8+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3844 :     SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);

	addss	xmm1, xmm2
	jmp	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
?SetColumnWidth@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?PushColumnClipRect@ImGui@@YAXH@Z
_TEXT	SEGMENT
column_index$dead$ = 8
?PushColumnClipRect@ImGui@@YAXH@Z PROC			; ImGui::PushColumnClipRect, COMDAT

; 3849 :     ImGuiWindow* window = GetCurrentWindowRead();
; 3850 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3851 :     if (column_index < 0)
; 3852 :         column_index = columns->Current;
; 3853 : 
; 3854 :     ImGuiOldColumnData* column = &columns->Columns[column_index];
; 3855 :     PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);

	xor	r8d, r8d
	mov	rcx, QWORD PTR [rax+16408]
	mov	rax, QWORD PTR [rcx+480]
	mov	rcx, QWORD PTR [rax+104]
	lea	rdx, QWORD PTR [rcx+20]
	add	rcx, 12
	jmp	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
?PushColumnClipRect@ImGui@@YAXH@Z ENDP			; ImGui::PushColumnClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?PushColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
clip_rect_vec4$1 = 32
?PushColumnsBackground@ImGui@@YAXXZ PROC		; ImGui::PushColumnsBackground, COMDAT

; 3860 : {

$LN11:
	sub	rsp, 56					; 00000038H

; 3861 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r9, QWORD PTR [rax+16408]

; 3862 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	r8, QWORD PTR [r9+480]

; 3863 :     if (columns->Count == 1)

	cmp	DWORD PTR [r8+16], 1
	je	$LN1@PushColumn

; 3864 :         return;
; 3865 : 
; 3866 :     // Optimization: avoid SetCurrentChannel() + PushClipRect()
; 3867 :     columns->HostBackupClipRect = window->ClipRect;

	movups	xmm0, XMMWORD PTR [r9+624]
	movups	XMMWORD PTR [r8+60], xmm0

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR [r8+44]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [r8+44]
	movss	xmm3, DWORD PTR [r8+48]
	movss	xmm2, DWORD PTR [r8+52]
	movss	xmm1, DWORD PTR [r8+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r9+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$1[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$1[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$1[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$1[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r9+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$1[rsp]
	movsxd	rdx, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR [rax+96]
	add	rdx, rdx
	movups	XMMWORD PTR [rcx+rdx*8-16], xmm0

; 3868 :     SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
; 3869 :     columns->Splitter.SetCurrentChannel(window->DrawList, 0);

	mov	rdx, QWORD PTR [r9+728]
	lea	rcx, QWORD PTR [r8+112]
	xor	r8d, r8d

; 3870 : }

	add	rsp, 56					; 00000038H

; 3868 :     SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
; 3869 :     columns->Splitter.SetCurrentChannel(window->DrawList, 0);

	jmp	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN1@PushColumn:

; 3870 : }

	add	rsp, 56					; 00000038H
	ret	0
?PushColumnsBackground@ImGui@@YAXXZ ENDP		; ImGui::PushColumnsBackground
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?PopColumnsBackground@ImGui@@YAXXZ
_TEXT	SEGMENT
clip_rect_vec4$1 = 32
?PopColumnsBackground@ImGui@@YAXXZ PROC			; ImGui::PopColumnsBackground, COMDAT

; 3873 : {

$LN11:
	sub	rsp, 56					; 00000038H

; 3874 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	r10, QWORD PTR [rax+16408]

; 3875 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	r9, QWORD PTR [r10+480]

; 3876 :     if (columns->Count == 1)

	cmp	DWORD PTR [r9+16], 1
	je	$LN1@PopColumns

; 3726 :     window->ClipRect = clip_rect;

	movups	xmm0, XMMWORD PTR [r9+60]

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	mov	rax, QWORD PTR [r10+728]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	xmm4, DWORD PTR [r9+60]
	movss	xmm3, DWORD PTR [r9+64]
	movss	xmm2, DWORD PTR [r9+68]
	movss	xmm1, DWORD PTR [r9+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3726 :     window->ClipRect = clip_rect;

	movups	XMMWORD PTR [r10+624], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movss	DWORD PTR clip_rect_vec4$1[rsp], xmm4
	movss	DWORD PTR clip_rect_vec4$1[rsp+4], xmm3
	movss	DWORD PTR clip_rect_vec4$1[rsp+8], xmm2
	movss	DWORD PTR clip_rect_vec4$1[rsp+12], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3727 :     window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;

	movss	DWORD PTR [rax+136], xmm4
	movss	DWORD PTR [rax+140], xmm3
	movss	DWORD PTR [rax+144], xmm2
	movss	DWORD PTR [rax+148], xmm1

; 3728 :     window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;

	mov	rax, QWORD PTR [r10+728]
	movups	xmm0, XMMWORD PTR clip_rect_vec4$1[rsp]
	movsxd	rdx, DWORD PTR [rax+88]
	mov	rcx, QWORD PTR [rax+96]
	add	rdx, rdx
	movups	XMMWORD PTR [rcx+rdx*8-16], xmm0

; 3877 :         return;
; 3878 : 
; 3879 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 3880 :     SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
; 3881 :     columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

	mov	r8d, DWORD PTR [r9+12]
	lea	rcx, QWORD PTR [r9+112]
	mov	rdx, QWORD PTR [r10+728]
	inc	r8d

; 3882 : }

	add	rsp, 56					; 00000038H

; 3877 :         return;
; 3878 : 
; 3879 :     // Optimization: avoid PopClipRect() + SetCurrentChannel()
; 3880 :     SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
; 3881 :     columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

	jmp	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
$LN1@PopColumns:

; 3882 : }

	add	rsp, 56					; 00000038H
	ret	0
?PopColumnsBackground@ImGui@@YAXXZ ENDP			; ImGui::PopColumnsBackground
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z
_TEXT	SEGMENT
$T1 = 32
window$ = 192
id$ = 200
?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z PROC ; ImGui::FindOrCreateColumns, COMDAT

; 3885 : {

$LN104:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	edi, edx
	mov	rbx, rcx

; 3886 :     // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
; 3887 :     for (int n = 0; n < window->ColumnsStorage.Size; n++)

	xor	r9d, r9d
	movsxd	rsi, DWORD PTR [rcx+696]
	test	esi, esi
	jle	SHORT $LN100@FindOrCrea
	mov	r8d, r9d
	mov	rdx, QWORD PTR [rcx+704]
	mov	rax, rdx
$LL4@FindOrCrea:

; 3888 :         if (window->ColumnsStorage[n].ID == id)

	cmp	DWORD PTR [rax], edi
	je	SHORT $LN97@FindOrCrea

; 3886 :     // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
; 3887 :     for (int n = 0; n < window->ColumnsStorage.Size; n++)

	inc	r9d
	inc	r8
	add	rax, 136				; 00000088H
	cmp	r8, rsi
	jl	SHORT $LL4@FindOrCrea
$LN100@FindOrCrea:
	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1608 :     ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }

	xor	eax, eax
	movups	XMMWORD PTR $T1[rsp], xmm0
	movups	XMMWORD PTR $T1[rsp+16], xmm0
	movups	XMMWORD PTR $T1[rsp+32], xmm0
	movups	XMMWORD PTR $T1[rsp+48], xmm0
	movups	XMMWORD PTR $T1[rsp+64], xmm0
	movups	XMMWORD PTR $T1[rsp+80], xmm0
	movups	XMMWORD PTR $T1[rsp+96], xmm0
	movups	XMMWORD PTR $T1[rsp+112], xmm0
	mov	QWORD PTR $T1[rsp+128], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	ecx, DWORD PTR [rcx+700]
	cmp	esi, ecx
	jne	$LN45@FindOrCrea
	inc	esi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN43@FindOrCrea
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN44@FindOrCrea
$LN97@FindOrCrea:

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, r9d
	imul	rax, rax, 136				; 00000088H
	add	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3889 :             return &window->ColumnsStorage[n];

	jmp	$LN1@FindOrCrea
$LN43@FindOrCrea:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, 8
$LN44@FindOrCrea:
	cmp	eax, esi
	cmovg	esi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	esi, ecx
	jle	SHORT $LN45@FindOrCrea
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN50@FindOrCrea

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN50@FindOrCrea:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, esi
	imul	rcx, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+704]
	test	rdx, rdx
	je	SHORT $LN60@FindOrCrea
	movsxd	rcx, DWORD PTR [rbx+696]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+704]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN58@FindOrCrea

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN58@FindOrCrea

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN58@FindOrCrea:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN60@FindOrCrea:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+704], rbp
	mov	DWORD PTR [rbx+700], esi
	xorps	xmm0, xmm0
$LN45@FindOrCrea:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rax, DWORD PTR [rbx+696]
	imul	rcx, rax, 136				; 00000088H
	mov	rax, QWORD PTR [rbx+704]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	XMMWORD PTR [rcx+rax+16], xmm0
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movups	XMMWORD PTR [rcx+rax+48], xmm0
	movups	XMMWORD PTR [rcx+rax+64], xmm0
	movups	XMMWORD PTR [rcx+rax+80], xmm0
	movups	XMMWORD PTR [rcx+rax+96], xmm0
	movups	XMMWORD PTR [rcx+rax+112], xmm0
	movsd	xmm0, QWORD PTR $T1[rsp+128]
	movsd	QWORD PTR [rcx+rax+128], xmm0
	inc	DWORD PTR [rbx+696]

; 2687 :     inline ~ImDrawListSplitter() { ClearFreeMemory(); }

	lea	rcx, QWORD PTR $T1[rsp+112]
	call	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory
	npad	1

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR $T1[rsp+128]
	test	rcx, rcx
	je	SHORT $LN78@FindOrCrea
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN76@FindOrCrea

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN76@FindOrCrea:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN78@FindOrCrea:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1906 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

	mov	rcx, QWORD PTR $T1[rsp+104]
	test	rcx, rcx
	je	SHORT $LN90@FindOrCrea
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN88@FindOrCrea

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN88@FindOrCrea:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
	npad	1
$LN90@FindOrCrea:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rbx+696]
	imul	rcx, rax, 136				; 00000088H
	mov	rax, QWORD PTR [rbx+704]
	add	rax, -136				; ffffffffffffff78H
	add	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3893 :     columns->ID = id;

	mov	DWORD PTR [rax], edi
$LN1@FindOrCrea:

; 3894 :     return columns;
; 3895 : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ENDP ; ImGui::FindOrCreateColumns
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
window$ = 192
id$ = 200
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA PROC ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1ImGuiOldColumns@@QEAA@XZ
?dtor$0@?0??FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z@4HA ENDP ; `ImGui::FindOrCreateColumns'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?GetColumnsID@ImGui@@YAIPEBDH@Z
_TEXT	SEGMENT
str_id$ = 48
columns_count$ = 56
?GetColumnsID@ImGui@@YAIPEBDH@Z PROC			; ImGui::GetColumnsID, COMDAT

; 3898 : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	r8, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3898 : {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r8+16408]
	mov	BYTE PTR [rax+237], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rdi, QWORD PTR [r8+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	test	rcx, rcx
	cmovne	edx, eax
	lea	ecx, DWORD PTR [rdx+287454023]
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rdi+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3904 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

	lea	rsi, OFFSET FLAT:??_C@_07HIFEPIJN@columns@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	r8, QWORD PTR [rdi+304]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3904 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

	test	rbx, rbx
	cmovne	rsi, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	xor	edx, edx
	mov	rcx, rsi
	mov	r8d, DWORD PTR [r8+rax*4-4]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr

; 3854 :     ImGuiContext& g = *Ctx;
; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rcx, QWORD PTR [rdi]
	mov	ebx, eax
	cmp	DWORD PTR [rcx+16480], eax
	jne	SHORT $LN6@GetColumns

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	mov	r8, rsi
	mov	edx, 11
	mov	ecx, eax
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN6@GetColumns:

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3907 :     return id;

	mov	eax, ebx

; 3908 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8417 :     window->IDStack.pop_back();

	mov	rdx, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rdx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3908 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?GetColumnsID@ImGui@@YAIPEBDH@Z ENDP			; ImGui::GetColumnsID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp
;	COMDAT ?BeginColumns@ImGui@@YAXPEBDHH@Z
_TEXT	SEGMENT
flags$1$ = 32
column$3 = 40
__$ArrayPad$ = 72
str_id$ = 224
columns_count$ = 232
flags$ = 240
?BeginColumns@ImGui@@YAXPEBDHH@Z PROC			; ImGui::BeginColumns, COMDAT

; 3911 : {

$LN184:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	movaps	XMMWORD PTR [rsp+80], xmm10
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3912 :     ImGuiContext& g = *GImGui;

	mov	r15, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdi, rcx

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	xor	ebp, ebp

; 3911 : {

	mov	DWORD PTR flags$1$[rsp], r8d

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	mov	ecx, edx
	test	rdi, rdi

; 3911 : {

	mov	r12d, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [r15+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	cmovne	ecx, ebp
	add	ecx, 287454023				; 11223347H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+237], 1
	mov	rsi, QWORD PTR [r15+16408]
	mov	BYTE PTR [rsi+237], 1
	mov	rbx, QWORD PTR [r15+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3903 :     PushID(0x11223347 + (str_id ? 0 : columns_count));

	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rax, DWORD PTR [rbx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3904 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

	lea	r14, OFFSET FLAT:??_C@_07HIFEPIJN@columns@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	mov	r8, QWORD PTR [rbx+304]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3904 :     ImGuiID id = window->GetID(str_id ? str_id : "columns");

	test	rdi, rdi
	cmovne	r14, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3853 :     ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);

	xor	edx, edx
	mov	rcx, r14
	mov	r8d, DWORD PTR [r8+rax*4-4]
	call	?ImHashStr@@YAIPEBD_KI@Z		; ImHashStr

; 3854 :     ImGuiContext& g = *Ctx;
; 3855 :     if (g.DebugHookIdInfo == id)

	mov	rcx, QWORD PTR [rbx]
	mov	edi, eax
	cmp	DWORD PTR [rcx+16480], eax
	jne	SHORT $LN109@BeginColum

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	mov	r8, r14
	lea	edx, QWORD PTR [rbp+11]
	mov	ecx, eax
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN109@BeginColum:

; 8417 :     window->IDStack.pop_back();

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rdx, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3920 :     ImGuiOldColumns* columns = FindOrCreateColumns(window, id);

	mov	rcx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1939 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [rdx+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3920 :     ImGuiOldColumns* columns = FindOrCreateColumns(window, id);

	mov	edx, edi
	call	?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z ; ImGui::FindOrCreateColumns

; 3921 :     IM_ASSERT(columns->ID == id);
; 3922 :     columns->Current = 0;
; 3923 :     columns->Count = columns_count;
; 3924 :     columns->Flags = flags;
; 3925 :     window->DC.CurrentColumns = columns;
; 3926 :     window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
; 3927 : 
; 3928 :     columns->HostCursorPosY = window->DC.CursorPos.y;
; 3929 :     columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
; 3930 :     columns->HostInitialClipRect = window->ClipRect;
; 3931 :     columns->HostBackupParentWorkRect = window->ParentWorkRect;
; 3932 :     window->ParentWorkRect = window->WorkRect;
; 3933 : 
; 3934 :     // Set state for first column
; 3935 :     // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
; 3936 :     const float column_padding = g.Style.ItemSpacing.x;
; 3937 :     const float half_clip_extend_x = ImFloor(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));

	movss	xmm8, DWORD PTR __real@3f000000
	mov	r13, rax

; 3941 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

	movss	xmm9, DWORD PTR __real@3f800000
	xorps	xmm7, xmm7
	mov	DWORD PTR [rax+12], ebp
	mov	DWORD PTR [rax+16], r12d
	mov	eax, DWORD PTR flags$1$[rsp]
	mov	DWORD PTR [r13+4], eax
	mov	ecx, DWORD PTR [rsi+316]
	mov	QWORD PTR [rsi+480], r13
	mov	BYTE PTR [rsi+408], bpl
	mov	DWORD PTR [r13+36], ecx
	mov	ecx, DWORD PTR [rsi+336]
	mov	DWORD PTR [r13+40], ecx
	movups	xmm0, XMMWORD PTR [rsi+624]
	movups	XMMWORD PTR [r13+44], xmm0
	movups	xmm0, XMMWORD PTR [rsi+608]
	movups	XMMWORD PTR [r13+76], xmm0
	movups	xmm0, XMMWORD PTR [rsi+592]
	movss	xmm4, DWORD PTR [rsi+128]
	movss	xmm2, DWORD PTR [rsi+600]
	movss	xmm5, DWORD PTR [rsi+140]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [rsi+380]
	movups	XMMWORD PTR [rsi+608], xmm0

; 3943 : 
; 3944 :     // Clear data if columns count changed
; 3945 :     if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)

	mov	ecx, DWORD PTR [r13+96]
	movss	xmm10, DWORD PTR [r15+14628]
	addss	xmm1, xmm10
	movaps	xmm0, xmm10
	subss	xmm0, xmm4
	mulss	xmm4, xmm8
	subss	xmm3, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm4, xmm5
	maxss	xmm0, xmm7

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvttss2si eax, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3938 :     const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);

	subss	xmm1, xmm0

; 3940 :     columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);

	addss	xmm3, xmm0
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 472  : static inline float  ImFloor(float f)                                           { return (float)(int)(f); }

	cvtdq2ps xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3940 :     columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);

	movss	DWORD PTR [r13+20], xmm3

; 3941 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

	addss	xmm3, xmm9
	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3941 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

	subss	xmm1, DWORD PTR [rsi+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3941 :     columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);

	movss	DWORD PTR [r13+24], xmm1

; 3942 :     columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

	movss	xmm0, DWORD PTR [rsi+316]
	movss	DWORD PTR [r13+32], xmm0
	movss	DWORD PTR [r13+28], xmm0

; 3943 : 
; 3944 :     // Clear data if columns count changed
; 3945 :     if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)

	test	ecx, ecx
	je	SHORT $LN182@BeginColum
	lea	eax, DWORD PTR [r12+1]
	cmp	ecx, eax
	je	SHORT $LN8@BeginColum
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [r13+100]
	test	ecx, ecx
	jns	SHORT $LN142@BeginColum

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, ebp
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	rcx, QWORD PTR [r13+96]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN142@BeginColum:
	mov	DWORD PTR [r13+96], ebp
	mov	BYTE PTR [r13+8], 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3780 :         column_index = columns->Current;

	jmp	SHORT $LN162@BeginColum
$LN8@BeginColum:

; 3946 :         columns->Columns.resize(0);
; 3947 : 
; 3948 :     // Initialize default widths
; 3949 :     columns->IsFirstFrame = (columns->Columns.Size == 0);

	test	ecx, ecx
$LN182@BeginColum:
	sete	al
	mov	BYTE PTR [r13+8], al

; 3950 :     if (columns->Columns.Size == 0)

	test	ecx, ecx
	jne	$LN3@BeginColum
$LN162@BeginColum:

; 3951 :     {
; 3952 :         columns->Columns.reserve(columns_count + 1);

	lea	r14d, DWORD PTR [r12+1]
	mov	edx, r14d
	lea	rcx, QWORD PTR [r13+96]
	call	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
	mov	edi, ebp

; 3953 :         for (int n = 0; n < columns_count + 1; n++)

	test	r14d, r14d
	jle	$LN3@BeginColum
	movd	xmm6, r12d
	cvtdq2ps xmm6, xmm6
	npad	14
$LL4@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	r8d, DWORD PTR [r13+96]
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR [r13+100]
	movd	xmm1, edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1587 :     ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }

	mov	QWORD PTR column$3[rsp+20], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3956 :             column.OffsetNorm = n / (float)columns_count;

	cvtdq2ps xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 1587 :     ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }

	movdqu	XMMWORD PTR column$3[rsp+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3956 :             column.OffsetNorm = n / (float)columns_count;

	divss	xmm1, xmm6
	movss	DWORD PTR column$3[rsp], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	cmp	r8d, ecx
	jne	SHORT $LN96@BeginColum
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN100@BeginColum
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN101@BeginColum
$LN100@BeginColum:
	mov	eax, 8
$LN101@BeginColum:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	lea	rcx, QWORD PTR [r13+96]

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN96@BeginColum:
	movsxd	rax, DWORD PTR [r13+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3953 :         for (int n = 0; n < columns_count + 1; n++)

	inc	edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, QWORD PTR [r13+104]
	movups	xmm0, XMMWORD PTR column$3[rsp]
	movsd	xmm1, QWORD PTR column$3[rsp+16]
	imul	rdx, rax, 28
	mov	eax, DWORD PTR column$3[rsp+24]
	movups	XMMWORD PTR [rdx+rcx], xmm0
	movsd	QWORD PTR [rdx+rcx+16], xmm1
	mov	DWORD PTR [rdx+rcx+24], eax
	inc	DWORD PTR [r13+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3953 :         for (int n = 0; n < columns_count + 1; n++)

	cmp	edi, r14d
	jl	$LL4@BeginColum
$LN3@BeginColum:

; 3961 :     for (int n = 0; n < columns_count; n++)

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	r12d, r12d
	jle	$LN6@BeginColum

; 3968 :         column->ClipRect.ClipWithFull(window->ClipRect);

	movss	xmm4, DWORD PTR __real@ff7fffff
	mov	rdx, rbp
	npad	7
$LL7@BeginColum:

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [r10+16408]

; 3962 :     {
; 3963 :         // Compute clipping rectangle
; 3964 :         ImGuiOldColumnData* column = &columns->Columns[n];
; 3965 :         float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));

	mov	ecx, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	mov	r8, QWORD PTR [r13+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	r9, QWORD PTR [rax+480]

; 3776 :     if (columns == NULL)

	test	r9, r9
	jne	SHORT $LN15@BeginColum

; 3777 :         return 0.0f;

	movss	xmm2, DWORD PTR [rsi+80]
	inc	ebp
	movaps	xmm0, xmm2
	movaps	xmm1, xmm7
	addss	xmm0, xmm7
	addss	xmm0, xmm8
	cvttss2si eax, xmm0
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
	jmp	SHORT $LN22@BeginColum
$LN15@BeginColum:

; 3779 :     if (column_index < 0)

	test	ebp, ebp
	jns	SHORT $LN158@BeginColum

; 3780 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [r9+12]
$LN158@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [r9+24]
	subss	xmm1, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	movss	xmm2, DWORD PTR [rsi+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [r9+104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	add	ebp, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	addss	xmm0, xmm1
	addss	xmm0, xmm8
	cvttss2si eax, xmm0
	movd	xmm3, eax
	mov	eax, ebp
	cvtdq2ps xmm3, xmm3

; 3779 :     if (column_index < 0)

	jns	SHORT $LN24@BeginColum

; 3780 :         column_index = columns->Current;

	mov	eax, DWORD PTR [r9+12]
$LN24@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [r9+24]
	subss	xmm1, DWORD PTR [r9+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [r9+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
	addss	xmm1, DWORD PTR [r9+20]
$LN22@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3966 :         float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);

	addss	xmm2, xmm1

; 3967 :         column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);

	movss	DWORD PTR [rdx+r8+12], xmm3
	mov	DWORD PTR [rdx+r8+16], -8388609		; ff7fffffH
	subss	xmm2, xmm9
	addss	xmm2, xmm8
	cvttss2si eax, xmm2
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [rdx+r8+20], xmm0
	mov	DWORD PTR [rdx+r8+24], 2139095039	; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	movss	xmm1, DWORD PTR [rsi+628]
	comiss	xmm1, xmm4
	ja	SHORT $LN43@BeginColum
	movss	xmm1, DWORD PTR [rsi+636]
	minss	xmm1, xmm4
$LN43@BeginColum:
	movss	xmm0, DWORD PTR [rsi+624]
	comiss	xmm0, xmm3
	ja	SHORT $LN47@BeginColum
	movss	xmm0, DWORD PTR [rsi+632]
	minss	xmm0, xmm3
$LN47@BeginColum:

; 547  :     void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.

	movss	DWORD PTR [rdx+r8+12], xmm0
	movss	DWORD PTR [rdx+r8+16], xmm1

; 464  : static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }

	movss	xmm0, DWORD PTR [rdx+r8+24]
	movss	xmm1, DWORD PTR [rsi+628]
	comiss	xmm1, xmm0
	ja	SHORT $LN55@BeginColum
	movss	xmm1, DWORD PTR [rsi+636]
	minss	xmm1, xmm0
$LN55@BeginColum:
	movss	xmm2, DWORD PTR [rdx+r8+20]
	movss	xmm0, DWORD PTR [rsi+624]
	comiss	xmm0, xmm2
	ja	SHORT $LN59@BeginColum
	movss	xmm0, DWORD PTR [rsi+632]
	minss	xmm0, xmm2
$LN59@BeginColum:

; 547  :     void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.

	movss	DWORD PTR [rdx+r8+20], xmm0
	movss	DWORD PTR [rdx+r8+24], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3961 :     for (int n = 0; n < columns_count; n++)

	add	rdx, 28
	cmp	ebp, r12d
	jl	$LL7@BeginColum
$LN6@BeginColum:

; 3969 :     }
; 3970 : 
; 3971 :     if (columns->Count > 1)

	mov	r8d, DWORD PTR [r13+16]
	cmp	r8d, 1
	jle	SHORT $LN10@BeginColum

; 3972 :     {
; 3973 :         columns->Splitter.Split(window->DrawList, 1 + columns->Count);

	inc	r8d
	lea	rcx, QWORD PTR [r13+112]
	call	?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::Split

; 3974 :         columns->Splitter.SetCurrentChannel(window->DrawList, 1);

	mov	rdx, QWORD PTR [rsi+728]
	lea	rcx, QWORD PTR [r13+112]
	mov	r8d, 1
	call	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 3850 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 3851 :     if (column_index < 0)
; 3852 :         column_index = columns->Current;
; 3853 : 
; 3854 :     ImGuiOldColumnData* column = &columns->Columns[column_index];
; 3855 :     PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);

	xor	r8d, r8d
	mov	rcx, QWORD PTR [rax+16408]
	mov	rax, QWORD PTR [rcx+480]
	mov	rcx, QWORD PTR [rax+104]
	lea	rdx, QWORD PTR [rcx+20]
	add	rcx, 12
	call	?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z ; ImGui::PushClipRect
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN10@BeginColum:

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rax, QWORD PTR [r10+16408]

; 3975 :         PushColumnClipRect(0);
; 3976 :     }
; 3977 : 
; 3978 :     // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
; 3979 :     float offset_0 = GetColumnOffset(columns->Current);

	mov	r8d, DWORD PTR [r13+12]
	mov	ecx, r8d

; 3775 :     ImGuiOldColumns* columns = window->DC.CurrentColumns;

	mov	rdx, QWORD PTR [rax+480]

; 3776 :     if (columns == NULL)

	test	rdx, rdx
	jne	SHORT $LN63@BeginColum

; 3777 :         return 0.0f;

	movaps	xmm1, xmm7
	movaps	xmm6, xmm7
	jmp	SHORT $LN70@BeginColum
$LN63@BeginColum:

; 3779 :     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN159@BeginColum

; 3780 :         column_index = columns->Current;

	mov	ecx, DWORD PTR [rdx+12]
$LN159@BeginColum:

; 3781 :     IM_ASSERT(column_index < columns->Columns.Size);
; 3782 : 
; 3783 :     const float t = columns->Columns[column_index].OffsetNorm;
; 3784 :     const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);

	movss	xmm0, DWORD PTR [rdx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm1, DWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	movsxd	rax, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm1, DWORD PTR [rcx+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3785 :     return x_offset;

	lea	eax, DWORD PTR [r8+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	addss	xmm1, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3779 :     if (column_index < 0)

	test	eax, eax
	jns	SHORT $LN72@BeginColum

; 3780 :         column_index = columns->Current;

	mov	eax, DWORD PTR [rdx+12]
$LN72@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	movss	xmm6, DWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	cdqe
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1917 :     inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

	imul	rcx, rax, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	mov	rax, QWORD PTR [rdx+104]
	mulss	xmm6, DWORD PTR [rcx+rax]
	addss	xmm6, xmm0
$LN70@BeginColum:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3981 :     float width = offset_1 - offset_0;

	movaps	xmm0, xmm6
	subss	xmm0, xmm1

; 3982 :     PushItemWidth(width * 0.65f);

	mulss	xmm0, DWORD PTR __real@3f266666
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 3983 :     window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
; 3984 :     window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

	movss	xmm2, DWORD PTR [rsi+80]
	movaps	xmm1, xmm10
	subss	xmm1, DWORD PTR [rsi+128]
	movaps	xmm0, xmm2

; 3985 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

	addss	xmm2, xmm6
	addss	xmm0, DWORD PTR [rsi+380]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm1, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_tables.cpp

; 3985 :     window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;

	subss	xmm2, xmm10
	addss	xmm0, xmm1
	movss	DWORD PTR [rsi+384], xmm1
	movss	DWORD PTR [rsi+600], xmm2
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 3986 :     window->WorkRect.Max.y = window->ContentRegionRect.Max.y;

	mov	eax, DWORD PTR [rsi+652]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [rsi+604], eax
	movss	DWORD PTR [rsi+312], xmm0

; 3987 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+80]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?BeginColumns@ImGui@@YAXPEBDHH@Z ENDP			; ImGui::BeginColumns
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ PROC ; ImVector<ImGuiTableColumnSortSpecs>::clear, COMDAT

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN2@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN6@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN2@clear:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImVector@UImGuiTableColumnSortSpecs@@@@QEAAXXZ ENDP ; ImVector<ImGuiTableColumnSortSpecs>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z PROC ; ImSpan<ImGuiTableCellData>::operator[], COMDAT

; 622  :     inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, edx
	lea	rax, QWORD PTR [rax+rdx*8]
	ret	0
??A?$ImSpan@UImGuiTableCellData@@@@QEAAAEAUImGuiTableCellData@@H@Z ENDP ; ImSpan<ImGuiTableCellData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z PROC ; ImSpan<ImGuiTableColumn>::operator[], COMDAT

; 623  :     inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

	movsxd	rax, edx
	imul	rax, rax, 112				; 00000070H
	add	rax, QWORD PTR [rcx]
	ret	0
??A?$ImSpan@UImGuiTableColumn@@@@QEBAAEBUImGuiTableColumn@@H@Z ENDP ; ImSpan<ImGuiTableColumn>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z PROC ; ImVector<ImGuiOldColumns>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN35:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rsi, rdx
	cmp	edi, ecx
	jne	$LN8@push_back
	inc	edi

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rbp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN13@push_back

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN13@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	movsxd	rax, edi
	imul	rcx, rax, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN23@push_back
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN21@push_back

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN21@push_back

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN21@push_back:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN23@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rbp
	mov	rbp, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rsi]
	imul	rcx, rax, 136				; 00000088H
	mov	rax, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rcx+rax], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rcx+rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rsi+32]
	movups	XMMWORD PTR [rcx+rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rsi+48]
	movups	XMMWORD PTR [rcx+rax+48], xmm1
	movups	xmm0, XMMWORD PTR [rsi+64]
	movups	XMMWORD PTR [rcx+rax+64], xmm0
	movups	xmm1, XMMWORD PTR [rsi+80]
	movups	XMMWORD PTR [rcx+rax+80], xmm1
	movups	xmm0, XMMWORD PTR [rsi+96]
	movups	XMMWORD PTR [rcx+rax+96], xmm0
	movups	xmm1, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rcx+rax+112], xmm1
	movsd	xmm0, QWORD PTR [rsi+128]
	mov	rsi, QWORD PTR [rsp+64]
	movsd	QWORD PTR [rcx+rax+128], xmm0
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImGuiOldColumns@@@@QEAAXAEBUImGuiOldColumns@@@Z ENDP ; ImVector<ImGuiOldColumns>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ PROC ; ImVector<ImGuiOldColumns>::back, COMDAT

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	mov	eax, DWORD PTR [rcx]
	dec	eax
	cdqe
	imul	rax, rax, 136				; 00000088H
	add	rax, QWORD PTR [rcx+8]
	ret	0
?back@?$ImVector@UImGuiOldColumns@@@@QEAAAEAUImGuiOldColumns@@XZ ENDP ; ImVector<ImGuiOldColumns>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z PROC ; ImChunkStream<ImGuiTableSettings>::swap, COMDAT
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1928 :     inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	r8d, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rdx], r8d
	mov	r8d, DWORD PTR [rcx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	rax, QWORD PTR [rdx+8]
	mov	DWORD PTR [rdx+4], r8d
	mov	r8, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rdx+8], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 712  :     void    swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }

	ret	0
?swap@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXAEAU1@@Z ENDP ; ImChunkStream<ImGuiTableSettings>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z
_TEXT	SEGMENT
this$ = 48
sz$ = 56
?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z PROC ; ImChunkStream<ImGuiTableSettings>::alloc_chunk, COMDAT

; 705  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rbp, DWORD PTR [rcx]
	lea	esi, DWORD PTR [rdx+7]
	and	esi, -4
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [rcx+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 705  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

	lea	edi, DWORD PTR [rsi+rbp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	edi, ecx
	jle	SHORT $LN4@alloc_chun

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN8@alloc_chun
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN9@alloc_chun
$LN8@alloc_chun:
	mov	eax, 8
$LN9@alloc_chun:
	cmp	eax, edi
	mov	edx, edi

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@D@@QEAAXH@Z		; ImVector<char>::reserve
$LN4@alloc_chun:
	mov	DWORD PTR [rbx], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 705  :     T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }

	mov	rax, QWORD PTR [rbx+8]
	mov	DWORD PTR [rbp+rax], esi
	add	rbp, 4
	mov	rax, QWORD PTR [rbx+8]
	mov	rbx, QWORD PTR [rsp+48]
	add	rax, rbp
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?alloc_chunk@?$ImChunkStream@UImGuiTableSettings@@@@QEAAPEAUImGuiTableSettings@@_K@Z ENDP ; ImChunkStream<ImGuiTableSettings>::alloc_chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ PROC ; ImChunkStream<ImGuiTableSettings>::clear, COMDAT

; 702  :     void    clear()                     { Buf.clear(); }

$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN4@clear
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4312 :         if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN8@clear

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN8@clear:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1908 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

	mov	QWORD PTR [rbx+8], 0
$LN4@clear:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 702  :     void    clear()                     { Buf.clear(); }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clear@?$ImChunkStream@UImGuiTableSettings@@@@QEAAXXZ ENDP ; ImChunkStream<ImGuiTableSettings>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z PROC ; ImPool<ImGuiTable>::GetIndex, COMDAT

; 672  :     ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }

	sub	rdx, QWORD PTR [rcx+8]
	mov	rax, 1024819115206086201		; 0e38e38e38e38e39H
	imul	rdx
	sar	rdx, 5
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
	ret	0
?GetIndex@?$ImPool@UImGuiTable@@@@QEBAHPEBUImGuiTable@@@Z ENDP ; ImPool<ImGuiTable>::GetIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z PROC ; ImVector<ImGuiOldColumnData>::push_back, COMDAT

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	r8d, DWORD PTR [rcx]
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	mov	rdi, rdx
	cmp	r8d, ecx
	jne	SHORT $LN2@push_back
	inc	r8d

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, r8d

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	cmovg	r8d, eax

; 1938 :     inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

	mov	edx, r8d
	call	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN2@push_back:
	movsxd	rax, DWORD PTR [rbx]
	movups	xmm0, XMMWORD PTR [rdi]
	imul	rdx, rax, 28
	add	rdx, QWORD PTR [rbx+8]
	movups	XMMWORD PTR [rdx], xmm0
	movsd	xmm1, QWORD PTR [rdi+16]
	movsd	QWORD PTR [rdx+16], xmm1
	mov	eax, DWORD PTR [rdi+24]
	mov	DWORD PTR [rdx+24], eax
	inc	DWORD PTR [rbx]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$ImVector@UImGuiOldColumnData@@@@QEAAXAEBUImGuiOldColumnData@@@Z ENDP ; ImVector<ImGuiOldColumnData>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z PROC ; ImVector<ImGuiOldColumnData>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 28
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 28
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ENDP ; ImVector<ImGuiOldColumnData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z PROC	; ImVector<ImGuiOldColumnData>::resize, COMDAT

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	ecx, DWORD PTR [rcx+4]
	test	ecx, ecx
	jns	SHORT $LN8@resize

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	eax, ecx
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	add	eax, ecx

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	rcx, rbx

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	test	eax, eax
	cmovg	edx, eax

; 1931 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	call	?reserve@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ; ImVector<ImGuiOldColumnData>::reserve
$LN8@resize:
	mov	DWORD PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$ImVector@UImGuiOldColumnData@@@@QEAAXH@Z ENDP	; ImVector<ImGuiOldColumnData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ PROC	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>, COMDAT

; 1903 :     inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$ImVector@UImGuiOldColumnData@@@@QEAA@XZ ENDP	; ImVector<ImGuiOldColumnData>::ImVector<ImGuiOldColumnData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z PROC	; ImVector<ImGuiOldColumns>::reserve, COMDAT

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx
	cmp	edi, DWORD PTR [rcx+4]
	jle	SHORT $LN1@reserve
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rsp+48], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4303 :     if (ImGuiContext* ctx = GImGui)

	test	rax, rax
	je	SHORT $LN6@reserve

; 4304 :         ctx->IO.MetricsActiveAllocations++;

	inc	DWORD PTR [rax+244]
$LN6@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	imul	rcx, rdi, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 1158 : static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }

	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	test	rdx, rdx
	je	SHORT $LN16@reserve
	movsxd	rcx, DWORD PTR [rbx]
	imul	r8, rcx, 136				; 00000088H
	mov	rcx, rax
	call	memcpy
	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 4311 :     if (ptr)

	test	rcx, rcx
	je	SHORT $LN14@reserve

; 4312 :         if (ImGuiContext* ctx = GImGui)

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	test	rax, rax
	je	SHORT $LN14@reserve

; 4313 :             ctx->IO.MetricsActiveAllocations--;

	dec	DWORD PTR [rax+244]
$LN14@reserve:

; 1159 : static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }

	call	QWORD PTR __imp_free
$LN16@reserve:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1934 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

	mov	QWORD PTR [rbx+8], rsi
	mov	rsi, QWORD PTR [rsp+48]
	mov	DWORD PTR [rbx+4], edi
$LN1@reserve:
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reserve@?$ImVector@UImGuiOldColumns@@@@QEAAXH@Z ENDP	; ImVector<ImGuiOldColumns>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z PROC ; ImVector<ImGuiOldColumns>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiOldColumns@@@@QEBAHH@Z ENDP ; ImVector<ImGuiOldColumns>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z PROC ; ImVector<ImGuiOldColumnData>::_grow_capacity, COMDAT

; 1930 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, edx
	test	r9d, r9d
	je	SHORT $LN3@grow_capac
	mov	eax, r9d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r9d
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
$LN3@grow_capac:
	mov	eax, 8
	cmp	eax, r8d
	cmovg	r8d, eax
	mov	eax, r8d
	ret	0
?_grow_capacity@?$ImVector@UImGuiOldColumnData@@@@QEBAHH@Z ENDP ; ImVector<ImGuiOldColumnData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ?swap@?$ImVector@D@@QEAAXAEAU1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?swap@?$ImVector@D@@QEAAXAEAU1@@Z PROC			; ImVector<char>::swap, COMDAT

; 1928 :     inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	r8d, DWORD PTR [rdx]
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rcx], r8d
	mov	r8d, DWORD PTR [rdx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	rax, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+4], r8d
	mov	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rcx+8], r8
	ret	0
?swap@?$ImVector@D@@QEAAXAEAU1@@Z ENDP			; ImVector<char>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMin@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>, COMDAT

; 454  : template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }

	minss	xmm0, xmm1
	ret	0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImMax@M@@YAMMM@Z
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>, COMDAT

; 455  : template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }

	maxss	xmm0, xmm1
	ret	0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
;	COMDAT ??$ImLerp@M@@YAMMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
t$ = 24
??$ImLerp@M@@YAMMMM@Z PROC				; ImLerp<float>, COMDAT

; 457  : template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm1
	ret	0
??$ImLerp@M@@YAMMMM@Z ENDP				; ImLerp<float>
_TEXT	ENDS
END
