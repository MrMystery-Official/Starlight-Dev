; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0GK@MDCLKLJL@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0DG@ONCLPBID@medianFilterWalkableArea?3?5Out?5o@ ; `string'
PUBLIC	??_C@_0CO@GHLBLKHM@erodeWalkableArea?3?5Out?5of?5memor@ ; `string'
PUBLIC	??_C@_0BA@GEKLAGIM@context?5?$CB?$DN?5NULL@	; `string'
;	COMDAT ??_C@_0BA@GEKLAGIM@context?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BA@GEKLAGIM@context?5?$CB?$DN?5NULL@ DB 'context != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GHLBLKHM@erodeWalkableArea?3?5Out?5of?5memor@
CONST	SEGMENT
??_C@_0CO@GHLBLKHM@erodeWalkableArea?3?5Out?5of?5memor@ DB 'erodeWalkable'
	DB	'Area: Out of memory ''dist'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ONCLPBID@medianFilterWalkableArea?3?5Out?5o@
CONST	SEGMENT
??_C@_0DG@ONCLPBID@medianFilterWalkableArea?3?5Out?5o@ DB 'medianFilterWa'
	DB	'lkableArea: Out of memory ''areas'' (%d).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@MDCLKLJL@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0GK@MDCLKLJL@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastArea.cpp', 00H	; `string'
PUBLIC	??$rcMin@H@@YAHHH@Z				; rcMin<int>
PUBLIC	?rcGetCon@@YAHAEBUrcCompactSpan@@H@Z		; rcGetCon
PUBLIC	?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z ; rcErodeWalkableArea
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z DD imagerel $LN241
	DD	imagerel $LN241+1661
	DD	imagerel $unwind$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z DB 08H
	DB	096H
	DB	00H
	DB	'b'
	DB	02H
	DB	'A', 017H
	DB	06H
	DB	','
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z DB 06H
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	0b0H
	DB	038H
	DB	046H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z
	DD	imagerel $ip2state$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z DD 0a1411H
	DD	0173414H
	DD	0f010d214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp
;	COMDAT ?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z
_TEXT	SEGMENT
zSize$1$ = 32
tv3766 = 36
xSize$1$ = 36
compactHeightfield$GSCopy$1$ = 40
erosionRadius$1$ = 48
$T1 = 56
tv3746 = 56
tv3745 = 64
tv3743 = 64
distanceToBoundary$1$ = 72
tv3754 = 80
tv3744 = 88
timer$ = 88
context$GSCopy$1$ = 104
context$ = 176
erosionRadius$ = 184
compactHeightfield$ = 192
?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z PROC ; rcErodeWalkableArea, COMDAT

; 76   : {

$LN241:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	rbx, r8
	mov	QWORD PTR compactHeightfield$GSCopy$1$[rsp], rbx
	mov	DWORD PTR erosionRadius$1$[rsp], edx
	mov	rdi, rcx
	mov	QWORD PTR context$GSCopy$1$[rsp], rcx

; 77   : 	rcAssert(context != NULL);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN37@rcErodeWal
	test	rcx, rcx
	jne	SHORT $LN37@rcErodeWal
	lea	r8d, QWORD PTR [rcx+77]
	lea	rdx, OFFSET FLAT:??_C@_0GK@MDCLKLJL@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BA@GEKLAGIM@context?5?$CB?$DN?5NULL@
	call	rax
$LN37@rcErodeWal:

; 78   : 
; 79   : 	const int xSize = compactHeightfield.width;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR xSize$1$[rsp], eax

; 80   : 	const int zSize = compactHeightfield.height;

	mov	esi, DWORD PTR [rbx+4]
	mov	DWORD PTR zSize$1$[rsp], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rsp], rdi
	mov	DWORD PTR timer$[rsp+8], 13

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [rdi+9], 0
	je	SHORT $LN171@rcErodeWal
	mov	rax, QWORD PTR [rdi]
	mov	edx, 13
	mov	rcx, rdi
	call	QWORD PTR [rax+32]
	npad	1
$LN171@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 85   : 	unsigned char* distanceToBoundary = (unsigned char*)rcAlloc(sizeof(unsigned char) * compactHeightfield.spanCount,

	movsxd	rcx, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r12, rax
	mov	QWORD PTR distanceToBoundary$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 87   : 	if (!distanceToBoundary)

	movsxd	rcx, DWORD PTR [rbx+8]
	test	rax, rax
	jne	SHORT $LN38@rcErodeWal

; 88   : 	{
; 89   : 		context->log(RC_LOG_ERROR, "erodeWalkableArea: Out of memory 'dist' (%d).", compactHeightfield.spanCount);

	mov	r9d, ecx
	lea	r8, OFFSET FLAT:??_C@_0CO@GHLBLKHM@erodeWalkableArea?3?5Out?5of?5memor@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, rdi
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	$LN62@rcErodeWal
$LN38@rcErodeWal:

; 90   : 		return false;
; 91   : 	}
; 92   : 	memset(distanceToBoundary, 0xff, sizeof(unsigned char) * compactHeightfield.spanCount);

	mov	r8, rcx
	mov	edx, 255				; 000000ffH
	mov	rcx, rax
	call	memset
	xor	r8d, r8d
	mov	r15d, r8d

; 93   : 	
; 94   : 	// Mark boundary cells.
; 95   : 	for (int z = 0; z < zSize; ++z)

	test	esi, esi
	jle	$LN227@rcErodeWal

; 90   : 		return false;
; 91   : 	}
; 92   : 	memset(distanceToBoundary, 0xff, sizeof(unsigned char) * compactHeightfield.spanCount);

	mov	eax, r8d
	mov	QWORD PTR tv3745[rsp], rax
	movsxd	rdx, DWORD PTR xSize$1$[rsp]
	mov	rcx, rdx
	shl	rcx, 2
	mov	QWORD PTR tv3744[rsp], rcx
	npad	6
$LL4@rcErodeWal:

; 96   : 	{
; 97   : 		for (int x = 0; x < xSize; ++x)

	mov	ebp, r8d
	lea	r14, QWORD PTR [rbx+64]
	test	edx, edx
	jle	$LN2@rcErodeWal
	mov	rcx, rax
	mov	QWORD PTR tv3746[rsp], rax
	npad	9
$LL7@rcErodeWal:

; 98   : 		{
; 99   : 			const rcCompactCell& cell = compactHeightfield.cells[x + z * zStride];

	mov	rax, QWORD PTR [r14]

; 100  : 			for (int spanIndex = (int)cell.index, maxSpanIndex = (int)(cell.index + cell.count); spanIndex < maxSpanIndex; ++spanIndex)

	mov	ecx, DWORD PTR [rcx+rax]
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	mov	r11d, eax
	shr	ecx, 24
	lea	r13d, DWORD PTR [rax+rcx]
	mov	QWORD PTR tv3754[rsp], r13
	cmp	r11, r13
	jae	$LN5@rcErodeWal
	npad	11
$LL10@rcErodeWal:

; 101  : 			{
; 102  : 				if (compactHeightfield.areas[spanIndex] == RC_NULL_AREA)

	mov	rdi, QWORD PTR [rbx+88]
	cmp	BYTE PTR [rdi+r11], 0
	je	$LN230@rcErodeWal

; 103  : 				{
; 104  : 					distanceToBoundary[spanIndex] = 0;
; 105  : 					continue;
; 106  : 				}
; 107  : 				const rcCompactSpan& span = compactHeightfield.spans[spanIndex];

	mov	rax, QWORD PTR [rbx+72]
	lea	rcx, QWORD PTR [rax+r11*8]

; 108  : 
; 109  : 				// Check that there is a non-null adjacent span in each of the 4 cardinal directions.
; 110  : 				int neighborCount = 0;

	mov	r10d, r8d

; 111  : 				for (int direction = 0; direction < 4; ++direction)

	mov	eax, r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rsi, QWORD PTR [r14]
	mov	ebx, DWORD PTR [rcx+4]
	and	ebx, 16777215				; 00ffffffH
	mov	r12d, DWORD PTR xSize$1$[rsp]
	lea	r13, OFFSET FLAT:__ImageBase
	npad	11
$LL13@rcErodeWal:

; 659  : 
; 660  : /// Returns the maximum of two values.
; 661  : /// @param[in]		a	Value A
; 662  : /// @param[in]		b	Value B
; 663  : /// @return The maximum of the two values.
; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
; 665  : 
; 666  : /// Returns the absolute value.
; 667  : /// @param[in]		a	The value.
; 668  : /// @return The absolute value of the specified value.
; 669  : template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }
; 670  : 
; 671  : /// Returns the square of the value.
; 672  : /// @param[in]		a	The value.
; 673  : /// @return The square of the value.
; 674  : template<class T> inline T rcSqr(T a) { return a * a; }
; 675  : 
; 676  : /// Clamps the value to the specified range.
; 677  : /// @param[in]		value			The value to clamp.
; 678  : /// @param[in]		minInclusive	The minimum permitted return value.
; 679  : /// @param[in]		maxInclusive	The maximum permitted return value.
; 680  : /// @return The value, clamped to the specified range.
; 681  : template<class T> inline T rcClamp(T value, T minInclusive, T maxInclusive)
; 682  : {
; 683  : 	return value < minInclusive ? minInclusive: (value > maxInclusive ? maxInclusive : value);
; 684  : }
; 685  : 
; 686  : /// Returns the square root of the value.
; 687  : ///  @param[in]		x	The value.
; 688  : ///  @return The square root of the vlaue.
; 689  : float rcSqrt(float x);
; 690  : 
; 691  : /// @}
; 692  : /// @name Vector helper functions.
; 693  : /// @{
; 694  : 
; 695  : /// Derives the cross product of two vectors. (@p v1 x @p v2)
; 696  : /// @param[out]		dest	The cross product. [(x, y, z)]
; 697  : /// @param[in]		v1		A Vector [(x, y, z)]
; 698  : /// @param[in]		v2		A vector [(x, y, z)]
; 699  : inline void rcVcross(float* dest, const float* v1, const float* v2)
; 700  : {
; 701  : 	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
; 702  : 	dest[1] = v1[2]*v2[0] - v1[0]*v2[2];
; 703  : 	dest[2] = v1[0]*v2[1] - v1[1]*v2[0];
; 704  : }
; 705  : 
; 706  : /// Derives the dot product of two vectors. (@p v1 . @p v2)
; 707  : /// @param[in]		v1	A Vector [(x, y, z)]
; 708  : /// @param[in]		v2	A vector [(x, y, z)]
; 709  : /// @return The dot product.
; 710  : inline float rcVdot(const float* v1, const float* v2)
; 711  : {
; 712  : 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
; 713  : }
; 714  : 
; 715  : /// Performs a scaled vector addition. (@p v1 + (@p v2 * @p s))
; 716  : /// @param[out]		dest	The result vector. [(x, y, z)]
; 717  : /// @param[in]		v1		The base vector. [(x, y, z)]
; 718  : /// @param[in]		v2		The vector to scale and add to @p v1. [(x, y, z)]
; 719  : /// @param[in]		s		The amount to scale @p v2 by before adding to @p v1.
; 720  : inline void rcVmad(float* dest, const float* v1, const float* v2, const float s)
; 721  : {
; 722  : 	dest[0] = v1[0]+v2[0]*s;
; 723  : 	dest[1] = v1[1]+v2[1]*s;
; 724  : 	dest[2] = v1[2]+v2[2]*s;
; 725  : }
; 726  : 
; 727  : /// Performs a vector addition. (@p v1 + @p v2)
; 728  : /// @param[out]		dest	The result vector. [(x, y, z)]
; 729  : /// @param[in]		v1		The base vector. [(x, y, z)]
; 730  : /// @param[in]		v2		The vector to add to @p v1. [(x, y, z)]
; 731  : inline void rcVadd(float* dest, const float* v1, const float* v2)
; 732  : {
; 733  : 	dest[0] = v1[0]+v2[0];
; 734  : 	dest[1] = v1[1]+v2[1];
; 735  : 	dest[2] = v1[2]+v2[2];
; 736  : }
; 737  : 
; 738  : /// Performs a vector subtraction. (@p v1 - @p v2)
; 739  : /// @param[out]		dest	The result vector. [(x, y, z)]
; 740  : /// @param[in]		v1		The base vector. [(x, y, z)]
; 741  : /// @param[in]		v2		The vector to subtract from @p v1. [(x, y, z)]
; 742  : inline void rcVsub(float* dest, const float* v1, const float* v2)
; 743  : {
; 744  : 	dest[0] = v1[0]-v2[0];
; 745  : 	dest[1] = v1[1]-v2[1];
; 746  : 	dest[2] = v1[2]-v2[2];
; 747  : }
; 748  : 
; 749  : /// Selects the minimum value of each element from the specified vectors.
; 750  : /// @param[in,out]	mn	A vector.  (Will be updated with the result.) [(x, y, z)]
; 751  : /// @param[in]		v	A vector. [(x, y, z)]
; 752  : inline void rcVmin(float* mn, const float* v)
; 753  : {
; 754  : 	mn[0] = rcMin(mn[0], v[0]);
; 755  : 	mn[1] = rcMin(mn[1], v[1]);
; 756  : 	mn[2] = rcMin(mn[2], v[2]);
; 757  : }
; 758  : 
; 759  : /// Selects the maximum value of each element from the specified vectors.
; 760  : /// @param[in,out]	mx	A vector.  (Will be updated with the result.) [(x, y, z)]
; 761  : /// @param[in]		v	A vector. [(x, y, z)]
; 762  : inline void rcVmax(float* mx, const float* v)
; 763  : {
; 764  : 	mx[0] = rcMax(mx[0], v[0]);
; 765  : 	mx[1] = rcMax(mx[1], v[1]);
; 766  : 	mx[2] = rcMax(mx[2], v[2]);
; 767  : }
; 768  : 
; 769  : /// Performs a vector copy.
; 770  : /// @param[out]		dest	The result. [(x, y, z)]
; 771  : /// @param[in]		v		The vector to copy. [(x, y, z)]
; 772  : inline void rcVcopy(float* dest, const float* v)
; 773  : {
; 774  : 	dest[0] = v[0];
; 775  : 	dest[1] = v[1];
; 776  : 	dest[2] = v[2];
; 777  : }
; 778  : 
; 779  : /// Returns the distance between two points.
; 780  : /// @param[in]		v1	A point. [(x, y, z)]
; 781  : /// @param[in]		v2	A point. [(x, y, z)]
; 782  : /// @return The distance between the two points.
; 783  : inline float rcVdist(const float* v1, const float* v2)
; 784  : {
; 785  : 	float dx = v2[0] - v1[0];
; 786  : 	float dy = v2[1] - v1[1];
; 787  : 	float dz = v2[2] - v1[2];
; 788  : 	return rcSqrt(dx*dx + dy*dy + dz*dz);
; 789  : }
; 790  : 
; 791  : /// Returns the square of the distance between two points.
; 792  : /// @param[in]		v1	A point. [(x, y, z)]
; 793  : /// @param[in]		v2	A point. [(x, y, z)]
; 794  : /// @return The square of the distance between the two points.
; 795  : inline float rcVdistSqr(const float* v1, const float* v2)
; 796  : {
; 797  : 	float dx = v2[0] - v1[0];
; 798  : 	float dy = v2[1] - v1[1];
; 799  : 	float dz = v2[2] - v1[2];
; 800  : 	return dx*dx + dy*dy + dz*dz;
; 801  : }
; 802  : 
; 803  : /// Normalizes the vector.
; 804  : /// @param[in,out]	v	The vector to normalize. [(x, y, z)]
; 805  : inline void rcVnormalize(float* v)
; 806  : {
; 807  : 	float d = 1.0f / rcSqrt(rcSqr(v[0]) + rcSqr(v[1]) + rcSqr(v[2]));
; 808  : 	v[0] *= d;
; 809  : 	v[1] *= d;
; 810  : 	v[2] *= d;
; 811  : }
; 812  : 
; 813  : /// @}
; 814  : /// @name Heightfield Functions
; 815  : /// @see rcHeightfield
; 816  : /// @{
; 817  : 
; 818  : /// Calculates the bounding box of an array of vertices.
; 819  : /// @ingroup recast
; 820  : /// @param[in]		verts		An array of vertices. [(x, y, z) * @p nv]
; 821  : /// @param[in]		numVerts	The number of vertices in the @p verts array.
; 822  : /// @param[out]		minBounds	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
; 823  : /// @param[out]		maxBounds	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
; 824  : void rcCalcBounds(const float* verts, int numVerts, float* minBounds, float* maxBounds);
; 825  : 
; 826  : /// Calculates the grid size based on the bounding box and grid cell size.
; 827  : /// @ingroup recast
; 828  : /// @param[in]		minBounds	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
; 829  : /// @param[in]		maxBounds	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
; 830  : /// @param[in]		cellSize	The xz-plane cell size. [Limit: > 0] [Units: wu]
; 831  : /// @param[out]		sizeX		The width along the x-axis. [Limit: >= 0] [Units: vx]
; 832  : /// @param[out]		sizeZ		The height along the z-axis. [Limit: >= 0] [Units: vx]
; 833  : void rcCalcGridSize(const float* minBounds, const float* maxBounds, float cellSize, int* sizeX, int* sizeZ);
; 834  : 
; 835  : /// Initializes a new heightfield.
; 836  : /// See the #rcConfig documentation for more information on the configuration parameters.
; 837  : /// 
; 838  : /// @see rcAllocHeightfield, rcHeightfield
; 839  : /// @ingroup recast
; 840  : /// 
; 841  : /// @param[in,out]	context		The build context to use during the operation.
; 842  : /// @param[in,out]	heightfield	The allocated heightfield to initialize.
; 843  : /// @param[in]		sizeX		The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
; 844  : /// @param[in]		sizeZ		The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
; 845  : /// @param[in]		minBounds	The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
; 846  : /// @param[in]		maxBounds	The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
; 847  : /// @param[in]		cellSize	The xz-plane cell size to use for the field. [Limit: > 0] [Units: wu]
; 848  : /// @param[in]		cellHeight	The y-axis cell size to use for field. [Limit: > 0] [Units: wu]
; 849  : /// @returns True if the operation completed successfully.
; 850  : bool rcCreateHeightfield(rcContext* context, rcHeightfield& heightfield, int sizeX, int sizeZ,
; 851  : 						 const float* minBounds, const float* maxBounds,
; 852  : 						 float cellSize, float cellHeight);
; 853  : 
; 854  : /// Sets the area id of all triangles with a slope below the specified value
; 855  : /// to #RC_WALKABLE_AREA.
; 856  : ///
; 857  : /// Only sets the area id's for the walkable triangles.  Does not alter the
; 858  : /// area id's for un-walkable triangles.
; 859  : /// 
; 860  : /// See the #rcConfig documentation for more information on the configuration parameters.
; 861  : /// 
; 862  : /// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
; 863  : /// 
; 864  : /// @ingroup recast
; 865  : /// @param[in,out]	context				The build context to use during the operation.
; 866  : /// @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
; 867  : /// 									[Limits: 0 <= value < 90] [Units: Degrees]
; 868  : /// @param[in]		verts				The vertices. [(x, y, z) * @p nv]
; 869  : /// @param[in]		numVerts			The number of vertices.
; 870  : /// @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
; 871  : /// @param[in]		numTris				The number of triangles.
; 872  : /// @param[out]		triAreaIDs			The triangle area ids. [Length: >= @p nt]
; 873  : void rcMarkWalkableTriangles(rcContext* context, float walkableSlopeAngle, const float* verts, int numVerts,
; 874  : 							 const int* tris, int numTris, unsigned char* triAreaIDs); 
; 875  : 
; 876  : /// Sets the area id of all triangles with a slope greater than or equal to the specified value to #RC_NULL_AREA.
; 877  : /// 
; 878  : /// Only sets the area id's for the un-walkable triangles.  Does not alter the
; 879  : /// area id's for walkable triangles.
; 880  : /// 
; 881  : /// See the #rcConfig documentation for more information on the configuration parameters.
; 882  : /// 
; 883  : /// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
; 884  : /// 
; 885  : /// @ingroup recast
; 886  : /// @param[in,out]	context				The build context to use during the operation.
; 887  : /// @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
; 888  : /// 									[Limits: 0 <= value < 90] [Units: Degrees]
; 889  : /// @param[in]		verts				The vertices. [(x, y, z) * @p nv]
; 890  : /// @param[in]		numVerts			The number of vertices.
; 891  : /// @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
; 892  : /// @param[in]		numTris				The number of triangles.
; 893  : /// @param[out]		triAreaIDs			The triangle area ids. [Length: >= @p nt]
; 894  : void rcClearUnwalkableTriangles(rcContext* context, float walkableSlopeAngle, const float* verts, int numVerts,
; 895  : 								const int* tris, int numTris, unsigned char* triAreaIDs); 
; 896  : 
; 897  : /// Adds a span to the specified heightfield.
; 898  : /// 
; 899  : /// The span addition can be set to favor flags. If the span is merged to
; 900  : /// another span and the new @p spanMax is within @p flagMergeThreshold units
; 901  : /// from the existing span, the span flags are merged.
; 902  : /// 
; 903  : /// @ingroup recast
; 904  : /// @param[in,out]	context				The build context to use during the operation.
; 905  : /// @param[in,out]	heightfield			An initialized heightfield.
; 906  : /// @param[in]		x					The column x index where the span is to be added.
; 907  : /// 									[Limits: 0 <= value < rcHeightfield::width]
; 908  : /// @param[in]		z					The column z index where the span is to be added.
; 909  : /// 									[Limits: 0 <= value < rcHeightfield::height]
; 910  : /// @param[in]		spanMin				The minimum height of the span. [Limit: < @p spanMax] [Units: vx]
; 911  : /// @param[in]		spanMax				The maximum height of the span. [Limit: <= #RC_SPAN_MAX_HEIGHT] [Units: vx]
; 912  : /// @param[in]		areaID				The area id of the span. [Limit: <= #RC_WALKABLE_AREA)
; 913  : /// @param[in]		flagMergeThreshold	The merge threshold. [Limit: >= 0] [Units: vx]
; 914  : /// @returns True if the operation completed successfully.
; 915  : bool rcAddSpan(rcContext* context, rcHeightfield& heightfield,
; 916  : 	           int x, int z,
; 917  :                unsigned short spanMin, unsigned short spanMax,
; 918  :                unsigned char areaID, int flagMergeThreshold);
; 919  : 
; 920  : /// Rasterizes a single triangle into the specified heightfield.
; 921  : ///
; 922  : /// Calling this for each triangle in a mesh is less efficient than calling rcRasterizeTriangles
; 923  : ///
; 924  : /// No spans will be added if the triangle does not overlap the heightfield grid.
; 925  : ///
; 926  : /// @see rcHeightfield
; 927  : /// @ingroup recast
; 928  : /// @param[in,out]	context				The build context to use during the operation.
; 929  : /// @param[in]		v0					Triangle vertex 0 [(x, y, z)]
; 930  : /// @param[in]		v1					Triangle vertex 1 [(x, y, z)]
; 931  : /// @param[in]		v2					Triangle vertex 2 [(x, y, z)]
; 932  : /// @param[in]		areaID				The area id of the triangle. [Limit: <= #RC_WALKABLE_AREA]
; 933  : /// @param[in,out]	heightfield			An initialized heightfield.
; 934  : /// @param[in]		flagMergeThreshold	The distance where the walkable flag is favored over the non-walkable flag.
; 935  : /// 									[Limit: >= 0] [Units: vx]
; 936  : /// @returns True if the operation completed successfully.
; 937  : bool rcRasterizeTriangle(rcContext* context,
; 938  :                          const float* v0, const float* v1, const float* v2,
; 939  :                          unsigned char areaID, rcHeightfield& heightfield, int flagMergeThreshold = 1);
; 940  : 
; 941  : /// Rasterizes an indexed triangle mesh into the specified heightfield.
; 942  : ///
; 943  : /// Spans will only be added for triangles that overlap the heightfield grid.
; 944  : /// 
; 945  : /// @see rcHeightfield
; 946  : /// @ingroup recast
; 947  : /// @param[in,out]	context				The build context to use during the operation.
; 948  : /// @param[in]		verts				The vertices. [(x, y, z) * @p nv]
; 949  : /// @param[in]		numVerts			The number of vertices. (unused) TODO (graham): Remove in next major release
; 950  : /// @param[in]		tris				The triangle indices. [(vertA, vertB, vertC) * @p nt]
; 951  : /// @param[in]		triAreaIDs			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
; 952  : /// @param[in]		numTris				The number of triangles.
; 953  : /// @param[in,out]	heightfield			An initialized heightfield.
; 954  : /// @param[in]		flagMergeThreshold	The distance where the walkable flag is favored over the non-walkable flag. 
; 955  : ///										[Limit: >= 0] [Units: vx]
; 956  : /// @returns True if the operation completed successfully.
; 957  : bool rcRasterizeTriangles(rcContext* context,
; 958  :                           const float* verts, int numVerts,
; 959  :                           const int* tris, const unsigned char* triAreaIDs, int numTris,
; 960  :                           rcHeightfield& heightfield, int flagMergeThreshold = 1);
; 961  : 
; 962  : /// Rasterizes an indexed triangle mesh into the specified heightfield.
; 963  : ///
; 964  : /// Spans will only be added for triangles that overlap the heightfield grid.
; 965  : /// 
; 966  : /// @see rcHeightfield
; 967  : /// @ingroup recast
; 968  : /// @param[in,out]	context				The build context to use during the operation.
; 969  : /// @param[in]		verts				The vertices. [(x, y, z) * @p nv]
; 970  : /// @param[in]		numVerts			The number of vertices. (unused) TODO (graham): Remove in next major release
; 971  : /// @param[in]		tris				The triangle indices. [(vertA, vertB, vertC) * @p nt]
; 972  : /// @param[in]		triAreaIDs			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
; 973  : /// @param[in]		numTris				The number of triangles.
; 974  : /// @param[in,out]	heightfield			An initialized heightfield.
; 975  : /// @param[in]		flagMergeThreshold	The distance where the walkable flag is favored over the non-walkable flag. 
; 976  : /// 									[Limit: >= 0] [Units: vx]
; 977  : /// @returns True if the operation completed successfully.
; 978  : bool rcRasterizeTriangles(rcContext* context,
; 979  :                           const float* verts, int numVerts,
; 980  :                           const unsigned short* tris, const unsigned char* triAreaIDs, int numTris,
; 981  :                           rcHeightfield& heightfield, int flagMergeThreshold = 1);
; 982  : 
; 983  : /// Rasterizes a triangle list into the specified heightfield.
; 984  : ///
; 985  : /// Expects each triangle to be specified as three sequential vertices of 3 floats.
; 986  : ///
; 987  : /// Spans will only be added for triangles that overlap the heightfield grid.
; 988  : /// 
; 989  : /// @see rcHeightfield
; 990  : /// @ingroup recast
; 991  : /// @param[in,out]	context				The build context to use during the operation.
; 992  : /// @param[in]		verts				The triangle vertices. [(ax, ay, az, bx, by, bz, cx, by, cx) * @p nt]
; 993  : /// @param[in]		triAreaIDs			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
; 994  : /// @param[in]		numTris				The number of triangles.
; 995  : /// @param[in,out]	heightfield			An initialized heightfield.
; 996  : /// @param[in]		flagMergeThreshold	The distance where the walkable flag is favored over the non-walkable flag. 
; 997  : /// 									[Limit: >= 0] [Units: vx]
; 998  : /// @returns True if the operation completed successfully.
; 999  : bool rcRasterizeTriangles(rcContext* context,
; 1000 :                           const float* verts, const unsigned char* triAreaIDs, int numTris,
; 1001 :                           rcHeightfield& heightfield, int flagMergeThreshold = 1);
; 1002 : 
; 1003 : /// Marks non-walkable spans as walkable if their maximum is within @p walkableClimb of the span below them.
; 1004 : ///
; 1005 : /// This removes small obstacles and rasterization artifacts that the agent would be able to walk over
; 1006 : /// such as curbs.  It also allows agents to move up terraced structures like stairs.
; 1007 : /// 
; 1008 : /// Obstacle spans are marked walkable if: <tt>obstacleSpan.smax - walkableSpan.smax < walkableClimb</tt>
; 1009 : /// 
; 1010 : /// @warning Will override the effect of #rcFilterLedgeSpans.  If both filters are used, call #rcFilterLedgeSpans only after applying this filter.
; 1011 : ///
; 1012 : /// @see rcHeightfield, rcConfig
; 1013 : /// 
; 1014 : /// @ingroup recast
; 1015 : /// @param[in,out]	context			The build context to use during the operation.
; 1016 : /// @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable. 
; 1017 : /// 								[Limit: >=0] [Units: vx]
; 1018 : /// @param[in,out]	heightfield		A fully built heightfield.  (All spans have been added.)
; 1019 : void rcFilterLowHangingWalkableObstacles(rcContext* context, int walkableClimb, rcHeightfield& heightfield);
; 1020 : 
; 1021 : /// Marks spans that are ledges as not-walkable.
; 1022 : ///
; 1023 : /// A ledge is a span with one or more neighbors whose maximum is further away than @p walkableClimb
; 1024 : /// from the current span's maximum.
; 1025 : /// This method removes the impact of the overestimation of conservative voxelization 
; 1026 : /// so the resulting mesh will not have regions hanging in the air over ledges.
; 1027 : /// 
; 1028 : /// A span is a ledge if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) > walkableClimb</tt>
; 1029 : /// 
; 1030 : /// @see rcHeightfield, rcConfig
; 1031 : /// 
; 1032 : /// @ingroup recast
; 1033 : /// @param[in,out]	context				The build context to use during the operation.
; 1034 : /// @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to 
; 1035 : /// 								be considered walkable. [Limit: >= 3] [Units: vx]
; 1036 : /// @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable. 
; 1037 : /// 								[Limit: >=0] [Units: vx]
; 1038 : /// @param[in,out]	heightfield			A fully built heightfield.  (All spans have been added.)
; 1039 : void rcFilterLedgeSpans(rcContext* context, int walkableHeight, int walkableClimb, rcHeightfield& heightfield);
; 1040 : 
; 1041 : /// Marks walkable spans as not walkable if the clearance above the span is less than the specified walkableHeight.
; 1042 : /// 
; 1043 : /// For this filter, the clearance above the span is the distance from the span's 
; 1044 : /// maximum to the minimum of the next higher span in the same column.
; 1045 : /// If there is no higher span in the column, the clearance is computed as the
; 1046 : /// distance from the top of the span to the maximum heightfield height.
; 1047 : /// 
; 1048 : /// @see rcHeightfield, rcConfig
; 1049 : /// @ingroup recast
; 1050 : /// 
; 1051 : /// @param[in,out]	context			The build context to use during the operation.
; 1052 : /// @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to 
; 1053 : /// 								be considered walkable. [Limit: >= 3] [Units: vx]
; 1054 : /// @param[in,out]	heightfield		A fully built heightfield.  (All spans have been added.)
; 1055 : void rcFilterWalkableLowHeightSpans(rcContext* context, int walkableHeight, rcHeightfield& heightfield);
; 1056 : 
; 1057 : /// Returns the number of spans contained in the specified heightfield.
; 1058 : ///  @ingroup recast
; 1059 : ///  @param[in,out]	context		The build context to use during the operation.
; 1060 : ///  @param[in]		heightfield	An initialized heightfield.
; 1061 : ///  @returns The number of spans in the heightfield.
; 1062 : int rcGetHeightFieldSpanCount(rcContext* context, const rcHeightfield& heightfield);
; 1063 : 
; 1064 : /// @}
; 1065 : /// @name Compact Heightfield Functions
; 1066 : /// @see rcCompactHeightfield
; 1067 : /// @{
; 1068 : 
; 1069 : /// Builds a compact heightfield representing open space, from a heightfield representing solid space.
; 1070 : ///
; 1071 : /// This is just the beginning of the process of fully building a compact heightfield.
; 1072 : /// Various filters may be applied, then the distance field and regions built.
; 1073 : /// E.g: #rcBuildDistanceField and #rcBuildRegions
; 1074 : ///
; 1075 : /// See the #rcConfig documentation for more information on the configuration parameters.
; 1076 : ///
; 1077 : /// @see rcAllocCompactHeightfield, rcHeightfield, rcCompactHeightfield, rcConfig
; 1078 : /// @ingroup recast
; 1079 : /// 
; 1080 : /// @param[in,out]	context				The build context to use during the operation.
; 1081 : /// @param[in]		walkableHeight		Minimum floor to 'ceiling' height that will still allow the floor area 
; 1082 : /// 									to be considered walkable. [Limit: >= 3] [Units: vx]
; 1083 : /// @param[in]		walkableClimb		Maximum ledge height that is considered to still be traversable. 
; 1084 : /// 									[Limit: >=0] [Units: vx]
; 1085 : /// @param[in]		heightfield			The heightfield to be compacted.
; 1086 : /// @param[out]		compactHeightfield	The resulting compact heightfield. (Must be pre-allocated.)
; 1087 : /// @returns True if the operation completed successfully.
; 1088 : bool rcBuildCompactHeightfield(rcContext* context, int walkableHeight, int walkableClimb,
; 1089 : 							   const rcHeightfield& heightfield, rcCompactHeightfield& compactHeightfield);
; 1090 : 
; 1091 : /// Erodes the walkable area within the heightfield by the specified radius.
; 1092 : /// 
; 1093 : /// Basically, any spans that are closer to a boundary or obstruction than the specified radius 
; 1094 : /// are marked as un-walkable.
; 1095 : ///
; 1096 : /// This method is usually called immediately after the heightfield has been built.
; 1097 : /// 
; 1098 : /// @see rcCompactHeightfield, rcBuildCompactHeightfield, rcConfig::walkableRadius
; 1099 : /// @ingroup recast
; 1100 : ///
; 1101 : /// @param[in,out]	context				The build context to use during the operation.
; 1102 : /// @param[in]		erosionRadius		The radius of erosion. [Limits: 0 < value < 255] [Units: vx]
; 1103 : /// @param[in,out]	compactHeightfield	The populated compact heightfield to erode.
; 1104 : /// @returns True if the operation completed successfully.
; 1105 : bool rcErodeWalkableArea(rcContext* context, int erosionRadius, rcCompactHeightfield& compactHeightfield);
; 1106 : 
; 1107 : /// Applies a median filter to walkable area types (based on area id), removing noise.
; 1108 : /// 
; 1109 : /// This filter is usually applied after applying area id's using functions
; 1110 : /// such as #rcMarkBoxArea, #rcMarkConvexPolyArea, and #rcMarkCylinderArea.
; 1111 : /// 
; 1112 : /// @see rcCompactHeightfield
; 1113 : /// @ingroup recast
; 1114 : /// 
; 1115 : /// @param[in,out]	context		The build context to use during the operation.
; 1116 : /// @param[in,out]	compactHeightfield		A populated compact heightfield.
; 1117 : /// @returns True if the operation completed successfully.
; 1118 : bool rcMedianFilterWalkableArea(rcContext* context, rcCompactHeightfield& compactHeightfield);
; 1119 : 
; 1120 : /// Applies an area id to all spans within the specified bounding box. (AABB) 
; 1121 : /// 
; 1122 : /// @see rcCompactHeightfield, rcMedianFilterWalkableArea
; 1123 : /// @ingroup recast
; 1124 : /// 
; 1125 : /// @param[in,out]	context				The build context to use during the operation.
; 1126 : /// @param[in]		boxMinBounds		The minimum extents of the bounding box. [(x, y, z)] [Units: wu]
; 1127 : /// @param[in]		boxMaxBounds		The maximum extents of the bounding box. [(x, y, z)] [Units: wu]
; 1128 : /// @param[in]		areaId				The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
; 1129 : /// @param[in,out]	compactHeightfield	A populated compact heightfield.
; 1130 : void rcMarkBoxArea(rcContext* context, const float* boxMinBounds, const float* boxMaxBounds, unsigned char areaId,
; 1131 : 				   rcCompactHeightfield& compactHeightfield);
; 1132 : 
; 1133 : /// Applies the area id to the all spans within the specified convex polygon. 
; 1134 : ///
; 1135 : /// The value of spacial parameters are in world units.
; 1136 : /// 
; 1137 : /// The y-values of the polygon vertices are ignored. So the polygon is effectively 
; 1138 : /// projected onto the xz-plane, translated to @p minY, and extruded to @p maxY.
; 1139 : /// 
; 1140 : /// @see rcCompactHeightfield, rcMedianFilterWalkableArea
; 1141 : /// @ingroup recast
; 1142 : /// 
; 1143 : /// @param[in,out]	context				The build context to use during the operation.
; 1144 : /// @param[in]		verts				The vertices of the polygon [For: (x, y, z) * @p numVerts]
; 1145 : /// @param[in]		numVerts			The number of vertices in the polygon.
; 1146 : /// @param[in]		minY				The height of the base of the polygon. [Units: wu]
; 1147 : /// @param[in]		maxY				The height of the top of the polygon. [Units: wu]
; 1148 : /// @param[in]		areaId				The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
; 1149 : /// @param[in,out]	compactHeightfield	A populated compact heightfield.
; 1150 : void rcMarkConvexPolyArea(rcContext* context, const float* verts, int numVerts,
; 1151 : 						  float minY, float maxY, unsigned char areaId,
; 1152 : 						  rcCompactHeightfield& compactHeightfield);
; 1153 : 
; 1154 : /// Expands a convex polygon along its vertex normals by the given offset amount.
; 1155 : /// Inserts extra vertices to bevel sharp corners.
; 1156 : ///
; 1157 : /// Helper function to offset convex polygons for rcMarkConvexPolyArea.
; 1158 : ///
; 1159 : /// @ingroup recast
; 1160 : /// 
; 1161 : /// @param[in]		verts		The vertices of the polygon [Form: (x, y, z) * @p numVerts]
; 1162 : /// @param[in]		numVerts	The number of vertices in the polygon.
; 1163 : /// @param[in]		offset		How much to offset the polygon by. [Units: wu]
; 1164 : /// @param[out]		outVerts	The offset vertices (should hold up to 2 * @p numVerts) [Form: (x, y, z) * return value]
; 1165 : /// @param[in]		maxOutVerts	The max number of vertices that can be stored to @p outVerts.
; 1166 : /// @returns Number of vertices in the offset polygon or 0 if too few vertices in @p outVerts.
; 1167 : int rcOffsetPoly(const float* verts, int numVerts, float offset, float* outVerts, int maxOutVerts);
; 1168 : 
; 1169 : /// Applies the area id to all spans within the specified y-axis-aligned cylinder.
; 1170 : /// 
; 1171 : /// @see rcCompactHeightfield, rcMedianFilterWalkableArea
; 1172 : /// 
; 1173 : /// @ingroup recast
; 1174 : /// 
; 1175 : /// @param[in,out]	context				The build context to use during the operation.
; 1176 : /// @param[in]		position			The center of the base of the cylinder. [Form: (x, y, z)] [Units: wu] 
; 1177 : /// @param[in]		radius				The radius of the cylinder. [Units: wu] [Limit: > 0]
; 1178 : /// @param[in]		height				The height of the cylinder. [Units: wu] [Limit: > 0]
; 1179 : /// @param[in]		areaId				The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
; 1180 : /// @param[in,out]	compactHeightfield	A populated compact heightfield.
; 1181 : void rcMarkCylinderArea(rcContext* context, const float* position, float radius, float height,
; 1182 : 						unsigned char areaId, rcCompactHeightfield& compactHeightfield);
; 1183 : 
; 1184 : /// Builds the distance field for the specified compact heightfield. 
; 1185 : /// @ingroup recast
; 1186 : /// @param[in,out]	ctx		The build context to use during the operation.
; 1187 : /// @param[in,out]	chf		A populated compact heightfield.
; 1188 : /// @returns True if the operation completed successfully.
; 1189 : bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf);
; 1190 : 
; 1191 : /// Builds region data for the heightfield using watershed partitioning.
; 1192 : /// @ingroup recast
; 1193 : /// @param[in,out]	ctx				The build context to use during the operation.
; 1194 : /// @param[in,out]	chf				A populated compact heightfield.
; 1195 : /// @param[in]		borderSize		The size of the non-navigable border around the heightfield.
; 1196 : /// 								[Limit: >=0] [Units: vx]
; 1197 : /// @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
; 1198 : /// 								[Limit: >=0] [Units: vx].
; 1199 : /// @param[in]		mergeRegionArea	Any regions with a span count smaller than this value will, if possible,
; 1200 : /// 								be merged with larger regions. [Limit: >=0] [Units: vx] 
; 1201 : /// @returns True if the operation completed successfully.
; 1202 : bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf, int borderSize, int minRegionArea, int mergeRegionArea);
; 1203 : 
; 1204 : /// Builds region data for the heightfield by partitioning the heightfield in non-overlapping layers.
; 1205 : /// @ingroup recast
; 1206 : /// @param[in,out]	ctx				The build context to use during the operation.
; 1207 : /// @param[in,out]	chf				A populated compact heightfield.
; 1208 : /// @param[in]		borderSize		The size of the non-navigable border around the heightfield.
; 1209 : ///  								[Limit: >=0] [Units: vx]
; 1210 : /// @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
; 1211 : ///  								[Limit: >=0] [Units: vx].
; 1212 : /// @returns True if the operation completed successfully.
; 1213 : bool rcBuildLayerRegions(rcContext* ctx, rcCompactHeightfield& chf, int borderSize, int minRegionArea);
; 1214 : 
; 1215 : /// Builds region data for the heightfield using simple monotone partitioning.
; 1216 : /// @ingroup recast 
; 1217 : /// @param[in,out]	ctx				The build context to use during the operation.
; 1218 : /// @param[in,out]	chf				A populated compact heightfield.
; 1219 : /// @param[in]		borderSize		The size of the non-navigable border around the heightfield.
; 1220 : ///  								[Limit: >=0] [Units: vx]
; 1221 : /// @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
; 1222 : ///  								[Limit: >=0] [Units: vx].
; 1223 : /// @param[in]		mergeRegionArea	Any regions with a span count smaller than this value will, if possible, 
; 1224 : ///  								be merged with larger regions. [Limit: >=0] [Units: vx] 
; 1225 : /// @returns True if the operation completed successfully.
; 1226 : bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
; 1227 : 							int borderSize, int minRegionArea, int mergeRegionArea);
; 1228 : 
; 1229 : /// Sets the neighbor connection data for the specified direction.
; 1230 : /// @param[in]		span			The span to update.
; 1231 : /// @param[in]		direction		The direction to set. [Limits: 0 <= value < 4]
; 1232 : /// @param[in]		neighborIndex	The index of the neighbor span.
; 1233 : inline void rcSetCon(rcCompactSpan& span, int direction, int neighborIndex)
; 1234 : {
; 1235 : 	const unsigned int shift = (unsigned int)direction * 6;
; 1236 : 	const unsigned int con = span.con;
; 1237 : 	span.con = (con & ~(0x3f << shift)) | (((unsigned int)neighborIndex & 0x3f) << shift);
; 1238 : }
; 1239 : 
; 1240 : /// Gets neighbor connection data for the specified direction.
; 1241 : /// @param[in]		span		The span to check.
; 1242 : /// @param[in]		direction	The direction to check. [Limits: 0 <= value < 4]
; 1243 : /// @return The neighbor connection data for the specified direction, or #RC_NOT_CONNECTED if there is no connection.
; 1244 : inline int rcGetCon(const rcCompactSpan& span, int direction)
; 1245 : {
; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [rax+rax*2]
	add	ecx, ecx

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r9d, ebx
	shr	r9d, cl
	and	r9d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 114  : 					if (neighborConnection == RC_NOT_CONNECTED)

	cmp	r9d, 63					; 0000003fH
	je	SHORT $LN190@rcErodeWal
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	mov	ecx, eax
	and	ecx, 3
	lea	rdx, QWORD PTR [rcx*4]
	mov	r8d, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rdx+r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 119  : 					const int neighborX = x + rcGetDirOffsetX(direction);

	add	r8d, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	mov	edx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rdx+r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 120  : 					const int neighborZ = z + rcGetDirOffsetY(direction);

	add	edx, r15d

; 121  : 					const int neighborSpanIndex = (int)compactHeightfield.cells[neighborX + neighborZ * zStride].index + neighborConnection;

	imul	edx, r12d
	add	edx, r8d
	movsxd	rcx, edx
	mov	edx, DWORD PTR [rsi+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r9d

; 122  : 					
; 123  : 					if (compactHeightfield.areas[neighborSpanIndex] == RC_NULL_AREA)

	cmp	BYTE PTR [rdx+rdi], 0
	je	SHORT $LN190@rcErodeWal

; 124  : 					{
; 125  : 						break;
; 126  : 					}
; 127  : 					neighborCount++;

	inc	r10d

; 111  : 				for (int direction = 0; direction < 4; ++direction)

	inc	eax
	cmp	eax, 4
	jl	SHORT $LL13@rcErodeWal
$LN190@rcErodeWal:

; 128  : 				}
; 129  : 				
; 130  : 				// At least one missing neighbour, so this is a boundary cell.
; 131  : 				if (neighborCount != 4)

	cmp	r10d, 4
	mov	r12, QWORD PTR distanceToBoundary$1$[rsp]
	mov	r13, QWORD PTR tv3754[rsp]
	je	SHORT $LN238@rcErodeWal
	xor	r8d, r8d
$LN230@rcErodeWal:

; 132  : 				{
; 133  : 					distanceToBoundary[spanIndex] = 0;

	mov	BYTE PTR [r11+r12], 0

; 128  : 				}
; 129  : 				
; 130  : 				// At least one missing neighbour, so this is a boundary cell.
; 131  : 				if (neighborCount != 4)

	jmp	SHORT $LN8@rcErodeWal
$LN238@rcErodeWal:
	xor	r8d, r8d
$LN8@rcErodeWal:

; 100  : 			for (int spanIndex = (int)cell.index, maxSpanIndex = (int)(cell.index + cell.count); spanIndex < maxSpanIndex; ++spanIndex)

	inc	r11
	cmp	r11, r13
	mov	rbx, QWORD PTR compactHeightfield$GSCopy$1$[rsp]
	jl	$LL10@rcErodeWal
	mov	edx, DWORD PTR xSize$1$[rsp]
$LN5@rcErodeWal:

; 96   : 	{
; 97   : 		for (int x = 0; x < xSize; ++x)

	inc	ebp
	mov	rcx, QWORD PTR tv3746[rsp]
	add	rcx, 4
	mov	QWORD PTR tv3746[rsp], rcx
	cmp	ebp, edx
	jl	$LL7@rcErodeWal
	mov	rax, QWORD PTR tv3745[rsp]
	mov	rcx, QWORD PTR tv3744[rsp]
	mov	esi, DWORD PTR zSize$1$[rsp]
$LN2@rcErodeWal:

; 93   : 	
; 94   : 	// Mark boundary cells.
; 95   : 	for (int z = 0; z < zSize; ++z)

	inc	r15d
	add	rax, rcx
	mov	QWORD PTR tv3745[rsp], rax
	cmp	r15d, esi
	jl	$LL4@rcErodeWal

; 134  : 				}
; 135  : 			}
; 136  : 		}
; 137  : 	}
; 138  : 	
; 139  : 	unsigned char newDistance;
; 140  : 	
; 141  : 	// Pass 1
; 142  : 	for (int z = 0; z < zSize; ++z)

	mov	r15d, edx
	neg	r15d
	mov	DWORD PTR $T1[rsp], r15d
	mov	eax, esi
	mov	QWORD PTR tv3743[rsp], rax
	npad	4
$LL16@rcErodeWal:

; 143  : 	{
; 144  : 		for (int x = 0; x < xSize; ++x)

	mov	edi, r8d
	test	edx, edx
	jle	$LN228@rcErodeWal
	npad	5
$LL19@rcErodeWal:

; 145  : 		{
; 146  : 			const rcCompactCell& cell = compactHeightfield.cells[x + z * zStride];

	lea	r13d, DWORD PTR [r15+rdx]
	lea	eax, DWORD PTR [rdi+r13]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR [rax+rcx*4]

; 147  : 			const int maxSpanIndex = (int)(cell.index + cell.count);

	mov	eax, DWORD PTR [rdx]
	and	eax, 16777215				; 00ffffffH
	mov	r8d, eax
	movzx	ebp, BYTE PTR [rdx+3]
	add	ebp, eax

; 148  : 			for (int spanIndex = (int)cell.index; spanIndex < maxSpanIndex; ++spanIndex)

	cmp	r8, rbp
	jae	$LN17@rcErodeWal
	npad	5
$LL22@rcErodeWal:

; 149  : 			{
; 150  : 				const rcCompactSpan& span = compactHeightfield.spans[spanIndex];

	mov	r9, QWORD PTR [rbx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r9+r8*8+4]
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 152  : 				if (rcGetCon(span, 0) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	$LN46@rcErodeWal

; 153  : 				{
; 154  : 					// (-1,0)
; 155  : 					const int aX = x + rcGetDirOffsetX(0);

	lea	esi, DWORD PTR [rdi-1]

; 156  : 					const int aY = z + rcGetDirOffsetY(0);
; 157  : 					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 0);

	mov	r10, QWORD PTR [r14]
	lea	eax, DWORD PTR [rsi+r13]
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 158  : 					const rcCompactSpan& aSpan = compactHeightfield.spans[aIndex];

	lea	rbx, QWORD PTR [r9+rax*8]

; 159  : 					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 160  : 					if (newDistance < distanceToBoundary[spanIndex])

	movzx	r11d, BYTE PTR [r8+r12]
	cmp	dl, r11b
	jae	SHORT $LN44@rcErodeWal

; 161  : 					{
; 162  : 						distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
	mov	r10, QWORD PTR [r14]
	movzx	r11d, dl
$LN44@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rbx+4]
	shr	edx, 18
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 166  : 					if (rcGetCon(aSpan, 3) != RC_NOT_CONNECTED)

	mov	rbx, QWORD PTR compactHeightfield$GSCopy$1$[rsp]
	cmp	edx, 63					; 0000003fH
	je	SHORT $LN46@rcErodeWal

; 167  : 					{
; 168  : 						const int bX = aX + rcGetDirOffsetX(3);
; 169  : 						const int bY = aY + rcGetDirOffsetY(3);
; 170  : 						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 3);

	lea	eax, DWORD PTR [r15+rsi]
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 171  : 						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 172  : 						if (newDistance < distanceToBoundary[spanIndex])

	cmp	dl, r11b
	jae	SHORT $LN46@rcErodeWal

; 173  : 						{
; 174  : 							distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
$LN46@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r9+r8*8+4]
	shr	edx, 18
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 178  : 				if (rcGetCon(span, 3) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	$LN20@rcErodeWal

; 179  : 				{
; 180  : 					// (0,-1)
; 181  : 					const int aX = x + rcGetDirOffsetX(3);
; 182  : 					const int aY = z + rcGetDirOffsetY(3);
; 183  : 					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 3);

	mov	r9, QWORD PTR [r14]
	lea	eax, DWORD PTR [r15+rdi]
	movsxd	rcx, eax
	mov	ecx, DWORD PTR [r9+rcx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, edx

; 184  : 					const rcCompactSpan& aSpan = compactHeightfield.spans[aIndex];

	mov	rax, QWORD PTR [rbx+72]
	lea	r11, QWORD PTR [rax+rcx*8]

; 185  : 					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);

	movzx	ecx, BYTE PTR [rcx+r12]
	add	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 186  : 					if (newDistance < distanceToBoundary[spanIndex])

	movzx	r10d, BYTE PTR [r8+r12]
	cmp	dl, r10b
	jae	SHORT $LN48@rcErodeWal

; 187  : 					{
; 188  : 						distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
	mov	r9, QWORD PTR [r14]
	movzx	r10d, dl
$LN48@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	shr	edx, 12
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 192  : 					if (rcGetCon(aSpan, 2) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN20@rcErodeWal

; 193  : 					{
; 194  : 						const int bX = aX + rcGetDirOffsetX(2);
; 195  : 						const int bY = aY + rcGetDirOffsetY(2);
; 196  : 						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 2);

	lea	eax, DWORD PTR [rdi+1]
	add	eax, r15d
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r9+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 197  : 						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 198  : 						if (newDistance < distanceToBoundary[spanIndex])

	cmp	dl, r10b
	jae	SHORT $LN20@rcErodeWal

; 199  : 						{
; 200  : 							distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
$LN20@rcErodeWal:

; 148  : 			for (int spanIndex = (int)cell.index; spanIndex < maxSpanIndex; ++spanIndex)

	inc	r8
	cmp	r8, rbp
	jl	$LL22@rcErodeWal
$LN17@rcErodeWal:

; 143  : 	{
; 144  : 		for (int x = 0; x < xSize; ++x)

	inc	edi
	mov	edx, DWORD PTR xSize$1$[rsp]
	cmp	edi, edx
	jl	$LL19@rcErodeWal
	mov	r15d, r13d
	mov	rax, QWORD PTR tv3743[rsp]
	xor	r8d, r8d
	jmp	SHORT $LN14@rcErodeWal
$LN228@rcErodeWal:
	add	r15d, edx
$LN14@rcErodeWal:

; 134  : 				}
; 135  : 			}
; 136  : 		}
; 137  : 	}
; 138  : 	
; 139  : 	unsigned char newDistance;
; 140  : 	
; 141  : 	// Pass 1
; 142  : 	for (int z = 0; z < zSize; ++z)

	sub	rax, 1
	mov	QWORD PTR tv3743[rsp], rax
	jne	$LL16@rcErodeWal
	mov	ecx, DWORD PTR $T1[rsp]
	mov	esi, DWORD PTR zSize$1$[rsp]
	jmp	SHORT $LN15@rcErodeWal
$LN227@rcErodeWal:
	lea	r14, QWORD PTR [rbx+64]
	mov	edx, DWORD PTR xSize$1$[rsp]
	mov	ecx, edx
	neg	ecx
	mov	DWORD PTR $T1[rsp], ecx
$LN15@rcErodeWal:

; 201  : 						}
; 202  : 					}
; 203  : 				}
; 204  : 			}
; 205  : 		}
; 206  : 	}
; 207  : 
; 208  : 	// Pass 2
; 209  : 	for (int z = zSize - 1; z >= 0; --z)

	lea	r13d, DWORD PTR [rsi-1]
	test	r13d, r13d
	js	$LN24@rcErodeWal
	lea	eax, DWORD PTR [rdx-1]
	mov	DWORD PTR tv3766[rsp], eax
	mov	r15d, r13d
	imul	r15d, edx
	imul	esi, edx
	mov	DWORD PTR zSize$1$[rsp], esi
$LL25@rcErodeWal:

; 210  : 	{
; 211  : 		for (int x = xSize - 1; x >= 0; --x)

	mov	edi, eax
	test	eax, eax
	js	$LN23@rcErodeWal
	npad	6
$LL28@rcErodeWal:

; 212  : 		{
; 213  : 			const rcCompactCell& cell = compactHeightfield.cells[x + z * zStride];

	lea	eax, DWORD PTR [r15+rdi]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR [rax+rcx*4]

; 214  : 			const int maxSpanIndex = (int)(cell.index + cell.count);

	mov	eax, DWORD PTR [rdx]
	and	eax, 16777215				; 00ffffffH
	mov	r8d, eax
	movzx	ebp, BYTE PTR [rdx+3]
	add	ebp, eax

; 215  : 			for (int spanIndex = (int)cell.index; spanIndex < maxSpanIndex; ++spanIndex)

	cmp	r8, rbp
	jae	$LN26@rcErodeWal
	npad	9
$LL31@rcErodeWal:

; 216  : 			{
; 217  : 				const rcCompactSpan& span = compactHeightfield.spans[spanIndex];

	mov	r9, QWORD PTR [rbx+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r9+r8*8+4]
	shr	edx, 12
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 219  : 				if (rcGetCon(span, 2) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	$LN54@rcErodeWal

; 220  : 				{
; 221  : 					// (1,0)
; 222  : 					const int aX = x + rcGetDirOffsetX(2);

	lea	esi, DWORD PTR [rdi+1]

; 223  : 					const int aY = z + rcGetDirOffsetY(2);
; 224  : 					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 2);

	mov	r10, QWORD PTR [r14]
	lea	eax, DWORD PTR [r15+rsi]
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 225  : 					const rcCompactSpan& aSpan = compactHeightfield.spans[aIndex];

	lea	rbx, QWORD PTR [r9+rax*8]

; 226  : 					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 227  : 					if (newDistance < distanceToBoundary[spanIndex])

	movzx	r11d, BYTE PTR [r8+r12]
	cmp	dl, r11b
	jae	SHORT $LN52@rcErodeWal

; 228  : 					{
; 229  : 						distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
	mov	r10, QWORD PTR [r14]
	movzx	r11d, dl
$LN52@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rbx+4]
	shr	edx, 6
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 233  : 					if (rcGetCon(aSpan, 1) != RC_NOT_CONNECTED)

	mov	rbx, QWORD PTR compactHeightfield$GSCopy$1$[rsp]
	cmp	edx, 63					; 0000003fH
	je	SHORT $LN234@rcErodeWal

; 234  : 					{
; 235  : 						const int bX = aX + rcGetDirOffsetX(1);
; 236  : 						const int bY = aY + rcGetDirOffsetY(1);
; 237  : 						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 1);

	mov	eax, DWORD PTR zSize$1$[rsp]
	add	eax, esi
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 238  : 						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 239  : 						if (newDistance < distanceToBoundary[spanIndex])

	mov	esi, DWORD PTR zSize$1$[rsp]
	cmp	dl, r11b
	jae	SHORT $LN54@rcErodeWal

; 240  : 						{
; 241  : 							distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl

; 233  : 					if (rcGetCon(aSpan, 1) != RC_NOT_CONNECTED)

	jmp	SHORT $LN54@rcErodeWal
$LN234@rcErodeWal:
	mov	esi, DWORD PTR zSize$1$[rsp]
$LN54@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r9+r8*8+4]
	shr	edx, 6
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 245  : 				if (rcGetCon(span, 1) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	$LN29@rcErodeWal

; 246  : 				{
; 247  : 					// (0,1)
; 248  : 					const int aX = x + rcGetDirOffsetX(1);
; 249  : 					const int aY = z + rcGetDirOffsetY(1);
; 250  : 					const int aIndex = (int)compactHeightfield.cells[aX + aY * xSize].index + rcGetCon(span, 1);

	mov	r10, QWORD PTR [r14]
	lea	eax, DWORD PTR [rsi+rdi]
	movsxd	rcx, eax
	mov	ecx, DWORD PTR [r10+rcx*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, edx

; 251  : 					const rcCompactSpan& aSpan = compactHeightfield.spans[aIndex];

	mov	rax, QWORD PTR [rbx+72]
	lea	r11, QWORD PTR [rax+rcx*8]

; 252  : 					newDistance = (unsigned char)rcMin((int)distanceToBoundary[aIndex] + 2, 255);

	movzx	ecx, BYTE PTR [rcx+r12]
	add	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 253  : 					if (newDistance < distanceToBoundary[spanIndex])

	movzx	r9d, BYTE PTR [r8+r12]
	cmp	dl, r9b
	jae	SHORT $LN56@rcErodeWal

; 254  : 					{
; 255  : 						distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
	movzx	r9d, dl
	mov	r10, QWORD PTR [r14]
$LN56@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r11+4]
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 259  : 					if (rcGetCon(aSpan, 0) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN29@rcErodeWal

; 260  : 					{
; 261  : 						const int bX = aX + rcGetDirOffsetX(0);
; 262  : 						const int bY = aY + rcGetDirOffsetY(0);
; 263  : 						const int bIndex = (int)compactHeightfield.cells[bX + bY * xSize].index + rcGetCon(aSpan, 0);

	lea	eax, DWORD PTR [rsi-1]
	add	eax, edi
	movsxd	rcx, eax
	mov	eax, DWORD PTR [r10+rcx*4]
	and	eax, 16777215				; 00ffffffH
	add	eax, edx

; 264  : 						newDistance = (unsigned char)rcMin((int)distanceToBoundary[bIndex] + 3, 255);

	movzx	ecx, BYTE PTR [rax+r12]
	add	ecx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	mov	edx, 255				; 000000ffH
	movzx	eax, cl
	cmp	ecx, edx
	cmovb	edx, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 265  : 						if (newDistance < distanceToBoundary[spanIndex])

	cmp	dl, r9b
	jae	SHORT $LN29@rcErodeWal

; 266  : 						{
; 267  : 							distanceToBoundary[spanIndex] = newDistance;

	mov	BYTE PTR [r8+r12], dl
$LN29@rcErodeWal:

; 215  : 			for (int spanIndex = (int)cell.index; spanIndex < maxSpanIndex; ++spanIndex)

	inc	r8
	cmp	r8, rbp
	jl	$LL31@rcErodeWal
$LN26@rcErodeWal:

; 210  : 	{
; 211  : 		for (int x = xSize - 1; x >= 0; --x)

	sub	edi, 1
	jns	$LL28@rcErodeWal
	mov	eax, DWORD PTR tv3766[rsp]
	mov	ecx, DWORD PTR $T1[rsp]
$LN23@rcErodeWal:

; 201  : 						}
; 202  : 					}
; 203  : 				}
; 204  : 			}
; 205  : 		}
; 206  : 	}
; 207  : 
; 208  : 	// Pass 2
; 209  : 	for (int z = zSize - 1; z >= 0; --z)

	add	r15d, ecx
	add	esi, ecx
	mov	DWORD PTR zSize$1$[rsp], esi
	sub	r13d, 1
	jns	$LL25@rcErodeWal
$LN24@rcErodeWal:

; 268  : 						}
; 269  : 					}
; 270  : 				}
; 271  : 			}
; 272  : 		}
; 273  : 	}
; 274  : 
; 275  : 	const unsigned char minBoundaryDistance = (unsigned char)(erosionRadius * 2);

	mov	eax, DWORD PTR erosionRadius$1$[rsp]
	add	al, al
	mov	DWORD PTR erosionRadius$1$[rsp], eax

; 276  : 	for (int spanIndex = 0; spanIndex < compactHeightfield.spanCount; ++spanIndex)

	cmp	DWORD PTR [rbx+8], 0
	jle	SHORT $LN33@rcErodeWal
	xor	edx, edx
	mov	ecx, edx
	npad	7
$LL34@rcErodeWal:

; 277  : 	{
; 278  : 		if (distanceToBoundary[spanIndex] < minBoundaryDistance)

	cmp	BYTE PTR [rcx+r12], al
	jae	SHORT $LN32@rcErodeWal

; 279  : 		{
; 280  : 			compactHeightfield.areas[spanIndex] = RC_NULL_AREA;

	mov	rax, QWORD PTR [rbx+88]
	mov	BYTE PTR [rcx+rax], 0
	mov	eax, DWORD PTR erosionRadius$1$[rsp]
$LN32@rcErodeWal:

; 276  : 	for (int spanIndex = 0; spanIndex < compactHeightfield.spanCount; ++spanIndex)

	inc	edx
	inc	rcx
	cmp	edx, DWORD PTR [rbx+8]
	jl	SHORT $LL34@rcErodeWal
$LN33@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, r12
	call	QWORD PTR __imp_free
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 286  : 	return true;

	mov	bl, 1
	mov	rdi, QWORD PTR context$GSCopy$1$[rsp]
$LN62@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [rdi+9], 0
	je	SHORT $LN233@rcErodeWal
	mov	r8, QWORD PTR [rdi]
	mov	edx, 13
	mov	rcx, rdi
	call	QWORD PTR [r8+40]
	npad	1
$LN233@rcErodeWal:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastArea.cpp

; 287  : }

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+184]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z ENDP ; rcErodeWalkableArea
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
zSize$1$ = 32
tv3766 = 36
xSize$1$ = 36
compactHeightfield$GSCopy$1$ = 40
erosionRadius$1$ = 48
$T1 = 56
tv3746 = 56
tv3745 = 64
tv3743 = 64
distanceToBoundary$1$ = 72
tv3754 = 80
tv3744 = 88
timer$ = 88
context$GSCopy$1$ = 104
context$ = 176
erosionRadius$ = 184
compactHeightfield$ = 192
?dtor$0@?0??rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z@4HA PROC ; `rcErodeWalkableArea'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcErodeWalkableArea@@YA_NPEAVrcContext@@HAEAUrcCompactHeightfield@@@Z@4HA ENDP ; `rcErodeWalkableArea'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ?rcGetCon@@YAHAEBUrcCompactSpan@@H@Z
_TEXT	SEGMENT
span$ = 8
direction$ = 16
?rcGetCon@@YAHAEBUrcCompactSpan@@H@Z PROC		; rcGetCon, COMDAT

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;
; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	eax, DWORD PTR [rcx+4]
	lea	ecx, DWORD PTR [rdx+rdx*2]
	and	eax, 16777215				; 00ffffffH
	add	ecx, ecx
	shr	eax, cl
	and	eax, 63					; 0000003fH

; 1248 : }

	ret	0
?rcGetCon@@YAHAEBUrcCompactSpan@@H@Z ENDP		; rcGetCon
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcMin@H@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcMin@H@@YAHHH@Z PROC				; rcMin<int>, COMDAT

; 658  : template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }

	cmp	ecx, edx
	cmovl	edx, ecx
	mov	eax, edx
	ret	0
??$rcMin@H@@YAHHH@Z ENDP				; rcMin<int>
_TEXT	ENDS
END
