; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

;	COMDAT ?aWeight3@?1??bcdec_bc6h_half@@9@4PAHA
_DATA	SEGMENT
?aWeight3@?1??bcdec_bc6h_half@@9@4PAHA DD 00H		; `bcdec_bc6h_half'::`2'::aWeight3
	DD	09H
	DD	012H
	DD	01bH
	DD	025H
	DD	02eH
	DD	037H
	DD	040H
_DATA	ENDS
;	COMDAT ?aWeight2@?1??bcdec_bc7@@9@4PAHA
_DATA	SEGMENT
?aWeight2@?1??bcdec_bc7@@9@4PAHA DD 00H			; `bcdec_bc7'::`2'::aWeight2
	DD	015H
	DD	02bH
	DD	040H
_DATA	ENDS
;	COMDAT ?aWeight3@?1??bcdec_bc7@@9@4PAHA
_DATA	SEGMENT
?aWeight3@?1??bcdec_bc7@@9@4PAHA DD 00H			; `bcdec_bc7'::`2'::aWeight3
	DD	09H
	DD	012H
	DD	01bH
	DD	025H
	DD	02eH
	DD	037H
	DD	040H
_DATA	ENDS
;	COMDAT ?aWeight4@?1??bcdec_bc6h_half@@9@4PAHA
_DATA	SEGMENT
?aWeight4@?1??bcdec_bc6h_half@@9@4PAHA DD 00H		; `bcdec_bc6h_half'::`2'::aWeight4
	DD	04H
	DD	09H
	DD	0dH
	DD	011H
	DD	015H
	DD	01aH
	DD	01eH
	DD	022H
	DD	026H
	DD	02bH
	DD	02fH
	DD	033H
	DD	037H
	DD	03cH
	DD	040H
_DATA	ENDS
;	COMDAT ?magic@?1??bcdec__half_to_float_quick@@YAMG@Z@4TFP32@?1??1@YAMG@Z@B
CONST	SEGMENT
?magic@?1??bcdec__half_to_float_quick@@YAMG@Z@4TFP32@?1??1@YAMG@Z@B DD 038800000H ; `bcdec__half_to_float_quick'::`2'::magic
CONST	ENDS
;	COMDAT ?aWeight4@?1??bcdec_bc7@@9@4PAHA
_DATA	SEGMENT
?aWeight4@?1??bcdec_bc7@@9@4PAHA DD 00H			; `bcdec_bc7'::`2'::aWeight4
	DD	04H
	DD	09H
	DD	0dH
	DD	011H
	DD	015H
	DD	01aH
	DD	01eH
	DD	022H
	DD	026H
	DD	02bH
	DD	02fH
	DD	033H
	DD	037H
	DD	03cH
	DD	040H
PUBLIC	?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ; DecompressBlockDXT5
PUBLIC	?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ; DecompressBlockDXT1
PUBLIC	bcdec_bc4
PUBLIC	?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ; TextureFormatDecoder::DecodeASTC8x8UNorm
PUBLIC	?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ; TextureFormatDecoder::DecodeBC3SRG
PUBLIC	?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ; TextureFormatDecoder::DecodeBC4
PUBLIC	?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ; TextureFormatDecoder::DecodeBC1
PUBLIC	?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ; TextureFormatDecoder::DecodeASTC4x4UNorm
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z DD imagerel $LN65
	DD	imagerel $LN65+970
	DD	imagerel $unwind$?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z DD imagerel $LN55
	DD	imagerel $LN55+769
	DD	imagerel $unwind$?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z DD imagerel ?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z
	DD	imagerel ?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z+511
	DD	imagerel $unwind$?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+83
	DD	imagerel $LN30+146
	DD	imagerel $chain$5$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+146
	DD	imagerel $LN30+209
	DD	imagerel $chain$6$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+209
	DD	imagerel $LN30+253
	DD	imagerel $chain$7$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21
	DD	imagerel $LN21+71
	DD	imagerel $unwind$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21+71
	DD	imagerel $LN21+183
	DD	imagerel $chain$0$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21+183
	DD	imagerel $LN21+216
	DD	imagerel $chain$1$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN53
	DD	imagerel $LN53+84
	DD	imagerel $unwind$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN53+84
	DD	imagerel $LN53+147
	DD	imagerel $chain$1$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN53+147
	DD	imagerel $LN53+243
	DD	imagerel $chain$3$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN53+243
	DD	imagerel $LN53+272
	DD	imagerel $chain$4$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN53+272
	DD	imagerel $LN53+367
	DD	imagerel $chain$5$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21
	DD	imagerel $LN21+79
	DD	imagerel $unwind$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21+79
	DD	imagerel $LN21+184
	DD	imagerel $chain$0$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN21+184
	DD	imagerel $LN21+217
	DD	imagerel $chain$1$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+83
	DD	imagerel $LN30+143
	DD	imagerel $chain$5$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+143
	DD	imagerel $LN30+206
	DD	imagerel $chain$6$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD imagerel $LN30+206
	DD	imagerel $LN30+250
	DD	imagerel $chain$7$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020521H
	DD	0c7405H
	DD	imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 0a2e21H
	DD	06f42eH
	DD	07e426H
	DD	0dd415H
	DD	0b6410H
	DD	0a5405H
	DD	imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+79
	DD	imagerel $unwind$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020521H
	DD	0ff405H
	DD	imagerel $LN21
	DD	imagerel $LN21+79
	DD	imagerel $unwind$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 080f01H
	DD	0e00b520fH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020021H
	DD	05d400H
	DD	imagerel $LN53
	DD	imagerel $LN53+84
	DD	imagerel $unwind$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN53+84
	DD	imagerel $LN53+147
	DD	imagerel $chain$1$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 040c21H
	DD	04f40cH
	DD	06c405H
	DD	imagerel $LN53+84
	DD	imagerel $LN53+147
	DD	imagerel $chain$1$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 041121H
	DD	05d411H
	DD	0e5405H
	DD	imagerel $LN53
	DD	imagerel $LN53+84
	DD	imagerel $unwind$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 050a01H
	DD	0e006620aH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+71
	DD	imagerel $unwind$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020521H
	DD	0ff405H
	DD	imagerel $LN21
	DD	imagerel $LN21+71
	DD	imagerel $unwind$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 080f01H
	DD	0e00b520fH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 021H
	DD	imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020521H
	DD	0c7405H
	DD	imagerel $LN30+6
	DD	imagerel $LN30+83
	DD	imagerel $chain$4$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 0a2e21H
	DD	06f42eH
	DD	07e426H
	DD	0dd415H
	DD	0b6410H
	DD	0a5405H
	DD	imagerel $LN30
	DD	imagerel $LN30+6
	DD	imagerel $unwind$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z DD 040b01H
	DD	03740bH
	DD	023407H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z DD 091d01H
	DD	0f019421dH
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
	DD	0300eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z DD 091d01H
	DD	0f019621dH
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
	DD	0300eH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
_TEXT	SEGMENT
Width$ = 80
Height$ = 88
Data$ = 96
Dest$ = 104
TexToGo$ = 112
?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z PROC ; TextureFormatDecoder::DecodeASTC4x4UNorm, COMDAT

; 332  : {

$LN30:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+80], rbp

; 333  : 	// 1 decoded block contains 64 pixels
; 334  : 
; 335  : 	// Calculate the number of blocks in the image
; 336  : 	int NumBlocks = (Width + 7) / 8 * (Height + 7) / 8;

	lea	eax, DWORD PTR [rdx+7]
	lea	ebp, DWORD PTR [rcx+7]
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+104], r13
	mov	rbx, r9
	shr	ebp, 3
	mov	r13d, edx
	imul	ebp, eax
	mov	QWORD PTR [rsp+56], r14
	mov	r14, r8
	mov	QWORD PTR [rsp+48], r15
	mov	r15d, ecx

; 337  : 	Dest.resize(NumBlocks * 16 * 4); // Allocate space for all decoded pixels in RGB format, 4 bytes per pixel

	mov	rcx, r9
	shr	ebp, 3
	mov	eax, ebp
	shl	eax, 6
	movsxd	rdx, eax
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 338  : 
; 339  : 	unsigned char* DestPtr = Dest.data();

	mov	rsi, QWORD PTR [rbx]

; 340  : 
; 341  : 	// Split up the data into blocks
; 342  : 	for (int i = 0; i < NumBlocks; i++)

	xor	ebx, ebx
	test	ebp, ebp
	je	SHORT $LN3@DecodeASTC
	mov	QWORD PTR [rsp+96], rdi
	mov	edi, ebx
	npad	6
$LL4@DecodeASTC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 344  : 		basisu::astc::decompress((unsigned char*)DestPtr + i * 16 * 4, &Data[i * 16], false, 4, 4); // Pass the data pointer directly to the basisu::astc::decompress function

	mov	r9d, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 344  : 		basisu::astc::decompress((unsigned char*)DestPtr + i * 16 * 4, &Data[i * 16], false, 4, 4); // Pass the data pointer directly to the basisu::astc::decompress function

	mov	DWORD PTR [rsp+32], 4
	mov	rcx, rsi
	call	?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z ; basisu::astc::decompress
	add	rdi, 16
	add	rsi, 64					; 00000040H
	sub	rbp, 1
	jne	SHORT $LL4@DecodeASTC

; 340  : 
; 341  : 	// Split up the data into blocks
; 342  : 	for (int i = 0; i < NumBlocks; i++)

	mov	rdi, QWORD PTR [rsp+96]
$LN3@DecodeASTC:

; 345  : 	}
; 346  : 
; 347  : 	Data.resize(Width * Height * 4); //4 bytes per pixel, RGBA

	imul	r15d, r13d
	mov	rcx, r14
	shl	r15d, 2
	mov	edx, r15d
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14]
	mov	rdx, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 349  : 	for (int i = 0; i < Data.size() / 4; i++)

	mov	r15, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 349  : 	for (int i = 0; i < Data.size() / 4; i++)

	mov	r14, QWORD PTR [rsp+56]
	mov	r13, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]
	shr	rdx, 2
	test	rdx, rdx
	je	SHORT $LN6@DecodeASTC
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	add	rax, 3
$LL7@DecodeASTC:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 351  : 		if (Data[i * 4 + 3] != 255)

	cmp	BYTE PTR [rax], 255			; 000000ffH
	jne	SHORT $LN18@DecodeASTC

; 349  : 	for (int i = 0; i < Data.size() / 4; i++)

	inc	ebx
	add	rax, 4
	movsxd	rcx, ebx
	cmp	rcx, rdx
	jb	SHORT $LL7@DecodeASTC

; 354  : 			break;
; 355  : 		}
; 356  : 	}
; 357  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN18@DecodeASTC:

; 352  : 		{
; 353  : 			TexToGo->IsTransparent() = true;

	mov	rax, QWORD PTR TexToGo$[rsp]
	mov	BYTE PTR [rax+42], 1
$LN6@DecodeASTC:

; 354  : 			break;
; 355  : 		}
; 356  : 	}
; 357  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?DecodeASTC4x4UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ENDP ; TextureFormatDecoder::DecodeASTC4x4UNorm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
_TEXT	SEGMENT
tv185 = 112
Width$ = 112
Height$ = 120
tv184 = 128
Data$ = 128
Dest$ = 136
TexToGo$ = 144
?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z PROC ; TextureFormatDecoder::DecodeBC1, COMDAT

; 224  : {

$LN21:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 48					; 00000030H

; 225  : 	Dest.resize(Width * Height * 10);

	mov	eax, ecx

; 226  : 
; 227  : 	unsigned long BlockCountX = (Width + 3) / 4;
; 228  : 	unsigned long BlockCountY = (Height + 3) / 4;

	lea	r12d, DWORD PTR [rdx+3]
	imul	eax, edx
	mov	r13d, ecx
	mov	rcx, r9
	mov	r14, r9
	mov	rdi, r8
	mov	DWORD PTR tv185[rsp], eax
	lea	eax, DWORD PTR [rax+rax*4]
	lea	edx, DWORD PTR [rax+rax]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 229  : 	unsigned long BlockWidth = (Width < 4) ? Width : 4;
; 230  : 	unsigned long BlockHeight = (Height < 4) ? Height : 4;
; 231  : 	unsigned char* BlockStorage = Data.data();

	mov	rsi, QWORD PTR [rdi]
	lea	ebp, DWORD PTR [r13+3]
	shr	ebp, 2
	xor	edi, edi
	shr	r12d, 2

; 232  : 
; 233  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	test	r12d, r12d
	je	SHORT $LN3@DecodeBC1
	lea	eax, DWORD PTR [rbp*8]
	mov	QWORD PTR [rsp+120], r15
	mov	r15, QWORD PTR TexToGo$[rsp]
	mov	QWORD PTR tv184[rsp], rax
$LL4@DecodeBC1:

; 234  : 	{
; 235  : 		for (unsigned long i = 0; i < BlockCountX; i++) DecompressBlockDXT1(i * 4, j * 4, Width, BlockStorage + i * 8, Dest, TexToGo);

	xor	ebx, ebx
	test	ebp, ebp
	je	SHORT $LN6@DecodeBC1
	npad	6
$LL7@DecodeBC1:
	lea	r9d, DWORD PTR [rbx*8]
	mov	QWORD PTR [rsp+40], r15
	add	r9, rsi
	mov	QWORD PTR [rsp+32], r14
	lea	edx, DWORD PTR [rdi*4]
	mov	r8d, r13d
	lea	ecx, DWORD PTR [rbx*4]
	call	?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ; DecompressBlockDXT1
	inc	ebx
	cmp	ebx, ebp
	jb	SHORT $LL7@DecodeBC1
	mov	rax, QWORD PTR tv184[rsp]
$LN6@DecodeBC1:

; 236  : 		BlockStorage += BlockCountX * 8;

	add	rsi, rax
	inc	edi
	cmp	edi, r12d
	jb	SHORT $LL4@DecodeBC1

; 232  : 
; 233  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	mov	r15, QWORD PTR [rsp+120]
$LN3@DecodeBC1:

; 237  : 	}
; 238  : 
; 239  : 	Dest.resize(Width * Height * 4);

	mov	eax, DWORD PTR tv185[rsp]
	mov	rcx, r14
	lea	edx, DWORD PTR [rax*4]

; 240  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 237  : 	}
; 238  : 
; 239  : 	Dest.resize(Width * Height * 4);

	jmp	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
?DecodeBC1@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ENDP ; TextureFormatDecoder::DecodeBC1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
_TEXT	SEGMENT
BlockCountY$1$ = 96
Width$ = 96
tv467 = 104
Height$ = 104
Data$ = 112
Dest$ = 120
TexToGo$ = 128
?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z PROC ; TextureFormatDecoder::DecodeBC4, COMDAT

; 262  : {

$LN53:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 56					; 00000038H

; 263  : 	if (Width * Height <= 1)

	mov	eax, ecx
	mov	esi, ecx
	imul	eax, edx
	mov	r14, r9
	mov	rdi, r8
	mov	ebx, edx
	mov	rcx, r9
	mov	DWORD PTR tv467[rsp], eax
	cmp	eax, 1
	ja	SHORT $LN11@DecodeBC4

; 264  : 	{
; 265  : 		Dest.resize(4);

	mov	edx, 4
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 266  : 		Dest[0] = 128;

	mov	BYTE PTR [rax], 128			; 00000080H

; 267  : 		Dest[1] = 0;

	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+1], 0

; 268  : 		Dest[2] = 0;

	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+2], 0

; 269  : 		Dest[3] = 255;

	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rax+3], 255			; 000000ffH

; 301  : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN11@DecodeBC4:
	mov	QWORD PTR [rsp+112], rbp

; 270  : 		return;
; 271  : 	}
; 272  : 
; 273  : 	Dest.resize(Width * Height * 4);

	lea	edx, DWORD PTR [rax*4]
	mov	QWORD PTR [rsp+40], r13
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 274  : 
; 275  : 	unsigned long BlockCountX = (Width + 3) / 4;
; 276  : 	unsigned long BlockCountY = (Height + 3) / 4;
; 277  : 
; 278  : 	unsigned char* BlockStorage = Data.data();

	mov	rdi, QWORD PTR [rdi]
	add	ebx, 3
	shr	ebx, 2
	add	esi, 3

; 279  : 	unsigned char* BlockDest = new unsigned char[(BlockCountX * 4) * (BlockCountY * 4)]; //Allocating at heap

	mov	ecx, ebx
	shr	esi, 2
	imul	ecx, esi
	mov	DWORD PTR BlockCountY$1$[rsp], ebx
	shl	ecx, 4
	call	??_U@YAPEAX_K@Z				; operator new[]
	xor	ebp, ebp
	mov	r13, rax

; 280  : 
; 281  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	test	ebx, ebx
	je	SHORT $LN45@DecodeBC4
	mov	QWORD PTR [rsp+48], r12
	mov	eax, ebx
	mov	QWORD PTR [rsp+32], r15
	npad	1
$LL4@DecodeBC4:

; 282  : 	{
; 283  : 		for (unsigned long i = 0; i < BlockCountX; i++)

	xor	ebx, ebx
	test	esi, esi
	je	SHORT $LN2@DecodeBC4
	mov	ecx, ebp
	lea	r15d, DWORD PTR [rsi*4]
	imul	ecx, esi
	lea	r12d, DWORD PTR [rcx*4]
	npad	5
$LL7@DecodeBC4:

; 285  : 			bcdec_bc4(BlockStorage, BlockDest + ((j * 4) * (BlockCountX * 4) + (i * 4)), BlockCountX * 4);

	lea	edx, DWORD PTR [r12+rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h

; 275  :     bcdec__smooth_alpha_block(compressedBlock, decompressedBlock, destinationPitch, 1);

	mov	r8d, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 285  : 			bcdec_bc4(BlockStorage, BlockDest + ((j * 4) * (BlockCountX * 4) + (i * 4)), BlockCountX * 4);

	shl	edx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h

; 275  :     bcdec__smooth_alpha_block(compressedBlock, decompressedBlock, destinationPitch, 1);

	mov	rcx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 285  : 			bcdec_bc4(BlockStorage, BlockDest + ((j * 4) * (BlockCountX * 4) + (i * 4)), BlockCountX * 4);

	add	rdx, r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h

; 275  :     bcdec__smooth_alpha_block(compressedBlock, decompressedBlock, destinationPitch, 1);

	call	?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z ; bcdec__smooth_alpha_block
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 286  : 			BlockStorage += BCDEC_BC4_BLOCK_SIZE;

	add	rdi, 8
	inc	ebx
	cmp	ebx, esi
	jb	SHORT $LL7@DecodeBC4
	mov	eax, DWORD PTR BlockCountY$1$[rsp]
$LN2@DecodeBC4:

; 280  : 
; 281  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	inc	ebp
	cmp	ebp, eax
	jb	SHORT $LL4@DecodeBC4
	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+48]
$LN45@DecodeBC4:
	mov	r9d, DWORD PTR tv467[rsp]
	mov	rdx, r13
	mov	rbp, QWORD PTR [rsp+112]
	mov	r8d, 2
	npad	10
$LL10@DecodeBC4:

; 287  : 		}
; 288  : 	}
; 289  : 
; 290  : 	for (int i = 0; i < Width * Height; i++)
; 291  : 	{
; 292  : 		Dest[i * 4] = BlockDest[i];

	movzx	eax, BYTE PTR [rdx]
	lea	r8, QWORD PTR [r8+4]
	mov	rcx, QWORD PTR [r14]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [r8+rcx-6], al

; 293  : 		Dest[i * 4 + 1] = BlockDest[i];

	movzx	eax, BYTE PTR [rdx-1]
	mov	rcx, QWORD PTR [r14]
	mov	BYTE PTR [r8+rcx-5], al

; 294  : 		Dest[i * 4 + 2] = BlockDest[i];

	movzx	eax, BYTE PTR [rdx-1]
	mov	rcx, QWORD PTR [r14]
	mov	BYTE PTR [r8+rcx-4], al

; 295  : 		Dest[i * 4 + 3] = BlockDest[i];

	movzx	eax, BYTE PTR [rdx-1]
	mov	rcx, QWORD PTR [r14]
	mov	BYTE PTR [r8+rcx-3], al
	sub	r9, 1
	jne	SHORT $LL10@DecodeBC4

; 296  : 	}
; 297  : 
; 298  : 	TexToGo->IsTransparent() = true;

	mov	rax, QWORD PTR TexToGo$[rsp]

; 299  : 
; 300  : 	delete[] BlockDest;

	mov	rcx, r13
	mov	BYTE PTR [rax+42], 1
	mov	r13, QWORD PTR [rsp+40]

; 301  : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx

; 299  : 
; 300  : 	delete[] BlockDest;

	jmp	??_V@YAXPEAX@Z				; operator delete[]
?DecodeBC4@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ENDP ; TextureFormatDecoder::DecodeBC4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
_TEXT	SEGMENT
tv185 = 112
Width$ = 112
Height$ = 120
tv184 = 128
Data$ = 128
Dest$ = 136
TexToGo$ = 144
?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z PROC ; TextureFormatDecoder::DecodeBC3SRG, COMDAT

; 243  : {

$LN21:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 48					; 00000030H

; 244  : 	Dest.resize(Width * Height * 5);

	mov	eax, ecx

; 245  : 
; 246  : 	unsigned long BlockCountX = (Width + 3) / 4;
; 247  : 	unsigned long BlockCountY = (Height + 3) / 4;

	lea	r12d, DWORD PTR [rdx+3]
	imul	eax, edx
	mov	r13d, ecx
	mov	rcx, r9
	mov	r14, r9
	mov	rdi, r8
	mov	DWORD PTR tv185[rsp], eax
	lea	edx, DWORD PTR [rax+rax*4]
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 248  : 	unsigned long BlockWidth = (Width < 4) ? Width : 4;
; 249  : 	unsigned long BlockHeight = (Height < 4) ? Height : 4;
; 250  : 	unsigned char* BlockStorage = Data.data();

	mov	rsi, QWORD PTR [rdi]
	lea	ebp, DWORD PTR [r13+3]
	shr	ebp, 2
	xor	edi, edi
	shr	r12d, 2

; 251  : 
; 252  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	test	r12d, r12d
	je	SHORT $LN3@DecodeBC3S
	mov	eax, ebp
	mov	QWORD PTR [rsp+120], r15
	mov	r15, QWORD PTR TexToGo$[rsp]
	shl	eax, 4
	mov	QWORD PTR tv184[rsp], rax
	npad	1
$LL4@DecodeBC3S:

; 253  : 	{
; 254  : 		for (unsigned long i = 0; i < BlockCountX; i++) DecompressBlockDXT5(i * 4, j * 4, Width, BlockStorage + i * 16, Dest, TexToGo);

	xor	ebx, ebx
	test	ebp, ebp
	je	SHORT $LN6@DecodeBC3S
	npad	10
$LL7@DecodeBC3S:
	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], r15
	shl	r9d, 4
	lea	edx, DWORD PTR [rdi*4]
	add	r9, rsi
	mov	QWORD PTR [rsp+32], r14
	lea	ecx, DWORD PTR [rbx*4]
	mov	r8d, r13d
	call	?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ; DecompressBlockDXT5
	inc	ebx
	cmp	ebx, ebp
	jb	SHORT $LL7@DecodeBC3S
	mov	rax, QWORD PTR tv184[rsp]
$LN6@DecodeBC3S:

; 255  : 		BlockStorage += BlockCountX * 16;

	add	rsi, rax
	inc	edi
	cmp	edi, r12d
	jb	SHORT $LL4@DecodeBC3S

; 251  : 
; 252  : 	for (unsigned long j = 0; j < BlockCountY; j++)

	mov	r15, QWORD PTR [rsp+120]
$LN3@DecodeBC3S:

; 256  : 	}
; 257  : 
; 258  : 	Dest.resize(Width * Height * 4);

	mov	eax, DWORD PTR tv185[rsp]
	mov	rcx, r14
	lea	edx, DWORD PTR [rax*4]

; 259  : }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 256  : 	}
; 257  : 
; 258  : 	Dest.resize(Width * Height * 4);

	jmp	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
?DecodeBC3SRG@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ENDP ; TextureFormatDecoder::DecodeBC3SRG
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z
_TEXT	SEGMENT
Width$ = 80
Height$ = 88
Data$ = 96
Dest$ = 104
TexToGo$ = 112
?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z PROC ; TextureFormatDecoder::DecodeASTC8x8UNorm, COMDAT

; 304  : {

$LN30:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+80], rbp

; 305  : 	// 1 decoded block contains 64 pixels
; 306  : 
; 307  : 	// Calculate the number of blocks in the image
; 308  : 	int NumBlocks = (Width + 7) / 8 * (Height + 7) / 8;

	lea	eax, DWORD PTR [rdx+7]
	lea	ebp, DWORD PTR [rcx+7]
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+104], r13
	mov	rbx, r9
	shr	ebp, 3
	mov	r13d, edx
	imul	ebp, eax
	mov	QWORD PTR [rsp+56], r14
	mov	r14, r8
	mov	QWORD PTR [rsp+48], r15
	mov	r15d, ecx

; 309  : 	Dest.resize(NumBlocks * 64 * 4); // Allocate space for all decoded pixels in RGB format, 4 bytes per pixel

	mov	rcx, r9
	shr	ebp, 3
	mov	eax, ebp
	shl	eax, 8
	movsxd	rdx, eax
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 310  : 
; 311  : 	unsigned char* DestPtr = Dest.data();

	mov	rsi, QWORD PTR [rbx]

; 312  : 
; 313  : 	// Split up the data into blocks
; 314  : 	for (int i = 0; i < NumBlocks; i++)

	xor	ebx, ebx
	test	ebp, ebp
	je	SHORT $LN3@DecodeASTC
	mov	QWORD PTR [rsp+96], rdi
	mov	edi, ebx
	npad	6
$LL4@DecodeASTC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 316  : 		basisu::astc::decompress((unsigned char*)DestPtr + i * 64 * 4, &Data[i * 16], false, 8, 8); // Pass the data pointer directly to the basisu::astc::decompress function

	mov	r9d, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rdx, rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 316  : 		basisu::astc::decompress((unsigned char*)DestPtr + i * 64 * 4, &Data[i * 16], false, 8, 8); // Pass the data pointer directly to the basisu::astc::decompress function

	mov	DWORD PTR [rsp+32], 8
	mov	rcx, rsi
	call	?decompress@astc@basisu@@YA_NPEAEPEBE_NHH@Z ; basisu::astc::decompress
	add	rdi, 16
	add	rsi, 256				; 00000100H
	sub	rbp, 1
	jne	SHORT $LL4@DecodeASTC

; 312  : 
; 313  : 	// Split up the data into blocks
; 314  : 	for (int i = 0; i < NumBlocks; i++)

	mov	rdi, QWORD PTR [rsp+96]
$LN3@DecodeASTC:

; 317  : 	}
; 318  : 
; 319  : 	Data.resize(Width * Height * 4); //4 bytes per pixel, RGBA

	imul	r15d, r13d
	mov	rcx, r14
	shl	r15d, 2
	mov	edx, r15d
	call	?resize@?$vector@EV?$allocator@E@std@@@std@@QEAAX_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r14]
	mov	rdx, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 321  : 	for (int i = 0; i < Data.size() / 4; i++)

	mov	r15, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 321  : 	for (int i = 0; i < Data.size() / 4; i++)

	mov	r14, QWORD PTR [rsp+56]
	mov	r13, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]
	shr	rdx, 2
	test	rdx, rdx
	je	SHORT $LN6@DecodeASTC
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

	add	rax, 3
$LL7@DecodeASTC:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp

; 323  : 		if (Data[i * 4 + 3] != 255)

	cmp	BYTE PTR [rax], 255			; 000000ffH
	jne	SHORT $LN18@DecodeASTC

; 321  : 	for (int i = 0; i < Data.size() / 4; i++)

	inc	ebx
	add	rax, 4
	movsxd	rcx, ebx
	cmp	rcx, rdx
	jb	SHORT $LL7@DecodeASTC

; 326  : 			break;
; 327  : 		}
; 328  : 	}
; 329  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN18@DecodeASTC:

; 324  : 		{
; 325  : 			TexToGo->IsTransparent() = true;

	mov	rax, QWORD PTR TexToGo$[rsp]
	mov	BYTE PTR [rax+42], 1
$LN6@DecodeASTC:

; 326  : 			break;
; 327  : 		}
; 328  : 	}
; 329  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?DecodeASTC8x8UNorm@TextureFormatDecoder@@YAXIIAEAV?$vector@EV?$allocator@E@std@@@std@@0PEAVTextureToGo@@@Z ENDP ; TextureFormatDecoder::DecodeASTC8x8UNorm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h
;	COMDAT ?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z
_TEXT	SEGMENT
alpha$ = 8
compressedBlock$ = 8
decompressedBlock$ = 16
destinationPitch$ = 24
pixelSize$dead$ = 32
?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z PROC	; bcdec__smooth_alpha_block, COMDAT

; 180  : static void bcdec__smooth_alpha_block(const void* compressedBlock, void* decompressedBlock, int destinationPitch, int pixelSize) {

	mov	r11, rsp
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rdi

; 181  :     unsigned char* decompressed;
; 182  :     unsigned char alpha[8];
; 183  :     int i, j;
; 184  :     unsigned long long block, indices;
; 185  : 
; 186  :     block = *(unsigned long long*)compressedBlock;

	mov	rcx, QWORD PTR [rcx]
	mov	r9, rdx

; 187  :     decompressed = (unsigned char*)decompressedBlock;
; 188  : 
; 189  :     alpha[0] = block & 0xFF;

	movzx	edx, cl

; 190  :     alpha[1] = (block >> 8) & 0xFF;

	mov	rax, rcx
	shr	rax, 8
	mov	ebx, edx
	movzx	r10d, al
	mov	BYTE PTR alpha$[rsp], dl
	movsxd	rdi, r8d
	mov	BYTE PTR [r11+9], r10b
	cmp	dl, r10b

; 191  : 
; 192  :     if (alpha[0] > alpha[1]) {

	jbe	$LN8@bcdec__smo

; 193  :         /* 6 interpolated alpha values. */
; 194  :         alpha[2] = (6 * alpha[0] + alpha[1] + 1) / 7;   /* 6/7*alpha_0 + 1/7*alpha_1 */

	lea	eax, DWORD PTR [rdx+rdx*2]
	lea	r8d, DWORD PTR [rax*2+1]
	mov	eax, 613566757				; 24924925H
	add	r8d, r10d
	mul	r8d

; 195  :         alpha[3] = (5 * alpha[0] + 2 * alpha[1] + 1) / 7;   /* 5/7*alpha_0 + 2/7*alpha_1 */

	mov	eax, 613566757				; 24924925H
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [r11+10], r8b
	lea	r8d, DWORD PTR [rbx*4+1]
	add	r8d, ebx
	lea	r8d, DWORD PTR [r8+r10*2]
	mul	r8d

; 196  :         alpha[4] = (4 * alpha[0] + 3 * alpha[1] + 1) / 7;   /* 4/7*alpha_0 + 3/7*alpha_1 */

	lea	eax, DWORD PTR [r10+r10*2]
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [r11+11], r8b
	lea	r8d, DWORD PTR [rbx*4+1]
	add	r8d, eax
	mov	eax, 613566757				; 24924925H
	mul	r8d

; 197  :         alpha[5] = (3 * alpha[0] + 4 * alpha[1] + 1) / 7;   /* 3/7*alpha_0 + 4/7*alpha_1 */

	mov	eax, 613566757				; 24924925H
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [r11+12], r8b
	lea	r8d, DWORD PTR [rbx*2+1]
	add	r8d, ebx
	lea	r8d, DWORD PTR [r8+r10*4]
	mul	r8d

; 198  :         alpha[6] = (2 * alpha[0] + 5 * alpha[1] + 1) / 7;   /* 2/7*alpha_0 + 5/7*alpha_1 */

	lea	eax, DWORD PTR [r10+r10*4]
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [r11+13], r8b
	lea	r8d, DWORD PTR [rbx*2+1]
	add	r8d, eax
	mov	eax, 613566757				; 24924925H
	mul	r8d

; 199  :         alpha[7] = (alpha[0] + 6 * alpha[1] + 1) / 7;   /* 1/7*alpha_0 + 6/7*alpha_1 */

	mov	eax, 613566757				; 24924925H
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	lea	edx, DWORD PTR [r10+r10*2]
	shr	r8d, 2
	mov	BYTE PTR [r11+14], r8b
	lea	r8d, DWORD PTR [rbx+1]
	lea	r8d, DWORD PTR [r8+rdx*2]
	mul	r8d
	sub	r8d, edx
	shr	r8d, 1
	add	r8d, edx
	shr	r8d, 2
	mov	BYTE PTR [r11+15], r8b

; 200  :     }

	jmp	SHORT $LN9@bcdec__smo
$LN8@bcdec__smo:

; 201  :     else {
; 202  :         /* 4 interpolated alpha values. */
; 203  :         alpha[2] = (4 * alpha[0] + alpha[1] + 1) / 5;   /* 4/5*alpha_0 + 1/5*alpha_1 */

	lea	edx, DWORD PTR [rdx*4+1]

; 204  :         alpha[3] = (3 * alpha[0] + 2 * alpha[1] + 1) / 5;   /* 3/5*alpha_0 + 2/5*alpha_1 */
; 205  :         alpha[4] = (2 * alpha[0] + 3 * alpha[1] + 1) / 5;   /* 2/5*alpha_0 + 3/5*alpha_1 */
; 206  :         alpha[5] = (alpha[0] + 4 * alpha[1] + 1) / 5;   /* 1/5*alpha_0 + 4/5*alpha_1 */
; 207  :         alpha[6] = 0x00;

	mov	WORD PTR alpha$[rsp+6], 65280		; 0000ff00H
	add	edx, r10d
	lea	r8d, DWORD PTR [rbx*2+1]
	add	r8d, ebx
	mov	eax, -858993459				; cccccccdH
	mul	edx
	lea	r8d, DWORD PTR [r8+r10*2]
	mov	eax, -858993459				; cccccccdH
	shr	edx, 2
	mov	BYTE PTR alpha$[rsp+2], dl
	mul	r8d
	lea	r8d, DWORD PTR [rbx*2+1]
	mov	eax, -858993459				; cccccccdH
	shr	edx, 2
	mov	BYTE PTR alpha$[rsp+3], dl
	lea	edx, DWORD PTR [r10+r10*2]
	add	r8d, edx
	mul	r8d
	mov	eax, -858993459				; cccccccdH
	shr	edx, 2
	mov	BYTE PTR alpha$[rsp+4], dl
	lea	edx, DWORD PTR [rbx+1]
	lea	edx, DWORD PTR [rdx+r10*4]
	mul	edx
	shr	edx, 2
	mov	BYTE PTR alpha$[rsp+5], dl
$LN9@bcdec__smo:

; 208  :         alpha[7] = 0xFF;
; 209  :     }
; 210  : 
; 211  :     indices = block >> 16;

	shr	rcx, 16
	mov	edx, 4
	npad	4
$LL4@bcdec__smo:

; 212  :     for (i = 0; i < 4; ++i) {
; 213  :         for (j = 0; j < 4; ++j) {
; 214  :             decompressed[j * pixelSize] = alpha[indices & 0x07];

	mov	rax, rcx

; 215  :             indices >>= 3;

	shr	rcx, 3
	and	eax, 7
	movzx	eax, BYTE PTR alpha$[rsp+rax]
	mov	BYTE PTR [r9], al
	mov	rax, rcx
	and	eax, 7
	shr	rcx, 3
	movzx	eax, BYTE PTR alpha$[rsp+rax]
	mov	BYTE PTR [r9+1], al
	mov	rax, rcx
	and	eax, 7
	shr	rcx, 3
	movzx	eax, BYTE PTR alpha$[rsp+rax]
	mov	BYTE PTR [r9+2], al
	mov	rax, rcx
	and	eax, 7
	shr	rcx, 3
	movzx	eax, BYTE PTR alpha$[rsp+rax]
	mov	BYTE PTR [r9+3], al

; 216  :         }
; 217  : 
; 218  :         decompressed += destinationPitch;

	add	r9, rdi
	sub	rdx, 1
	jne	SHORT $LL4@bcdec__smo

; 219  :     }
; 220  : }

	mov	rbx, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z ENDP	; bcdec__smooth_alpha_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bcdec.h
;	COMDAT bcdec_bc4
_TEXT	SEGMENT
compressedBlock$ = 8
decompressedBlock$ = 16
destinationPitch$ = 24
bcdec_bc4 PROC						; COMDAT

; 275  :     bcdec__smooth_alpha_block(compressedBlock, decompressedBlock, destinationPitch, 1);

	jmp	?bcdec__smooth_alpha_block@@YAXPEBXPEAXHH@Z ; bcdec__smooth_alpha_block
bcdec_bc4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z
_TEXT	SEGMENT
color0$1$ = 0
code$1$ = 4
tv713 = 8
tv714 = 16
tv715 = 24
x$ = 112
y$ = 120
width$ = 128
color1$1$ = 136
blockStorage$ = 136
Image$ = 144
TexToGo$ = 152
?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z PROC ; DecompressBlockDXT1, COMDAT

; 12   : {

$LN55:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 13   : 	unsigned short color0 = *reinterpret_cast<const unsigned short*>(blockStorage);

	movzx	eax, WORD PTR [r9]
	mov	r13d, edx

; 14   : 	unsigned short color1 = *reinterpret_cast<const unsigned short*>(blockStorage + 2);

	movzx	edx, WORD PTR [r9+2]

; 15   : 
; 16   : 	unsigned long temp;
; 17   : 
; 18   : 	temp = (color0 >> 11) * 255 + 16;

	mov	r11d, eax
	mov	WORD PTR color0$1$[rsp], ax
	shr	eax, 11
	imul	r10d, eax, 255				; 000000ffH

; 19   : 	unsigned char r0 = (unsigned char)((temp / 32 + temp) / 32);
; 20   : 	temp = ((color0 & 0x07E0) >> 5) * 255 + 32;

	mov	eax, r11d
	shr	eax, 5

; 21   : 	unsigned char g0 = (unsigned char)((temp / 64 + temp) / 64);
; 22   : 	temp = (color0 & 0x001F) * 255 + 16;

	and	r11d, 31
	and	eax, 63					; 0000003fH
	mov	WORD PTR color1$1$[rsp], dx
	imul	ecx, eax, 255				; 000000ffH
	imul	eax, r11d, 255				; 000000ffH
	add	r10d, 16
	mov	QWORD PTR tv715[rsp], 4
	mov	ebx, r10d
	shr	ebx, 5
	add	ecx, 32					; 00000020H
	add	ebx, r10d
	add	eax, 16
	shr	ebx, 5

; 23   : 	unsigned char b0 = (unsigned char)((temp / 32 + temp) / 32);

	mov	esi, eax
	mov	edi, ecx
	shr	esi, 5
	add	esi, eax
	shr	edi, 6
	add	edi, ecx
	shr	esi, 5

; 24   : 
; 25   : 	temp = (color1 >> 11) * 255 + 16;

	mov	eax, edx
	shr	edi, 6
	shr	eax, 11
	imul	ecx, eax, 255				; 000000ffH

; 26   : 	unsigned char r1 = (unsigned char)((temp / 32 + temp) / 32);
; 27   : 	temp = ((color1 & 0x07E0) >> 5) * 255 + 32;

	mov	eax, edx
	shr	eax, 5

; 28   : 	unsigned char g1 = (unsigned char)((temp / 64 + temp) / 64);
; 29   : 	temp = (color1 & 0x001F) * 255 + 16;

	and	edx, 31
	and	eax, 63					; 0000003fH
	add	ecx, 16
	mov	ebp, ecx
	shr	ebp, 5
	add	ebp, ecx
	imul	ecx, eax, 255				; 000000ffH
	imul	eax, edx, 255				; 000000ffH
	shr	ebp, 5
	add	ecx, 32					; 00000020H
	add	eax, 16
	mov	r14d, ecx
	shr	r14d, 6

; 30   : 	unsigned char b1 = (unsigned char)((temp / 32 + temp) / 32);

	mov	r15d, eax
	shr	r15d, 5
	add	r14d, ecx

; 31   : 
; 32   : 	unsigned long code = *reinterpret_cast<const unsigned long*>(blockStorage + 4);

	mov	ecx, DWORD PTR [r9+4]
	add	r15d, eax
	shr	r15d, 5
	shr	r14d, 6
	xor	r12d, r12d
	mov	DWORD PTR code$1$[rsp], ecx
	npad	5
$LL4@Decompress:

; 35   : 	{
; 36   : 		for (int i = 0; i < 4; i++)

	mov	r11d, DWORD PTR x$[rsp]
	mov	eax, r13d
	imul	eax, r8d
	mov	edx, 4
	mov	QWORD PTR tv714[rsp], rdx
	mov	DWORD PTR tv713[rsp], eax
	add	r11d, eax
	npad	3
$LL7@Decompress:

; 37   : 		{
; 38   : 			unsigned char FinalColorR = 0;
; 39   : 			unsigned char FinalColorG = 0;
; 40   : 			unsigned char FinalColorB = 0;
; 41   : 			unsigned char FinalColorA = 255;
; 42   : 			unsigned char positionCode = (code >> 2 * (4 * j + i)) & 0x03;

	mov	eax, ecx
	xor	r9b, r9b
	mov	ecx, r12d
	xor	r10b, r10b
	shr	eax, cl
	xor	r8b, r8b

; 43   : 
; 44   : 			if (color0 > color1)

	movzx	ecx, WORD PTR color1$1$[rsp]
	and	eax, 3
	mov	r13b, 255				; 000000ffH
	cmp	WORD PTR color0$1$[rsp], cx
	jbe	$LN12@Decompress

; 45   : 			{
; 46   : 				switch (positionCode)

	test	eax, eax
	je	$LN18@Decompress
	sub	eax, 1
	je	$LN19@Decompress
	sub	eax, 1
	je	SHORT $LN16@Decompress
	cmp	eax, 1
	jne	$LN10@Decompress

; 63   : 				case 3:
; 64   : 					FinalColorR = (r0 + 2 * r1) / 3;

	movzx	ecx, bpl
	movzx	eax, bl
	lea	edx, DWORD PTR [rax+rcx*2]

; 65   : 					FinalColorG = (g0 + 2 * g1) / 3;

	movzx	ecx, r14b
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	movzx	eax, dil
	mov	r9d, edx
	shr	r9d, 1
	lea	r8d, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	r8d

; 66   : 					FinalColorB = (b0 + 2 * b1) / 3;

	movzx	eax, sil
	mov	r10d, edx
	movzx	ecx, r15b
	shr	r10d, 1
	lea	r8d, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	r8d
	mov	r8d, edx
	mov	rdx, QWORD PTR tv714[rsp]
	shr	r8d, 1
	jmp	$LN10@Decompress
$LN16@Decompress:

; 47   : 				{
; 48   : 				case 0:
; 49   : 					FinalColorR = r0;
; 50   : 					FinalColorG = g0;
; 51   : 					FinalColorB = b0;
; 52   : 					break;
; 53   : 				case 1:
; 54   : 					FinalColorR = r1;
; 55   : 					FinalColorG = g1;
; 56   : 					FinalColorB = b1;
; 57   : 					break;
; 58   : 				case 2:
; 59   : 					FinalColorR = (2 * r0 + r1) / 3;

	movzx	ecx, bl
	movzx	eax, bpl
	lea	edx, DWORD PTR [rax+rcx*2]

; 60   : 					FinalColorG = (2 * g0 + g1) / 3;

	movzx	ecx, dil
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	movzx	eax, r14b
	shr	edx, 1
	movzx	r9d, dl
	lea	edx, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx

; 61   : 					FinalColorB = (2 * b0 + b1) / 3;

	movzx	eax, r15b
	shr	edx, 1
	movzx	r10d, dl
	movzx	ecx, sil
	lea	edx, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
	movzx	r8d, dl

; 62   : 					break;

	mov	rdx, QWORD PTR tv714[rsp]

; 67   : 					break;
; 68   : 				}
; 69   : 			}

	jmp	SHORT $LN10@Decompress
$LN12@Decompress:

; 70   : 			else
; 71   : 			{
; 72   : 				switch (positionCode)

	test	eax, eax
	je	SHORT $LN18@Decompress
	sub	eax, 1
	je	SHORT $LN19@Decompress
	sub	eax, 1
	je	SHORT $LN20@Decompress
	cmp	eax, 1
	jne	SHORT $LN10@Decompress

; 88   : 					break;
; 89   : 				case 3:
; 90   : 					FinalColorA = 0;
; 91   : 					TexToGo->IsTransparent() = true;

	mov	rax, QWORD PTR TexToGo$[rsp]
	xor	r13b, r13b
	mov	BYTE PTR [rax+42], 1
	jmp	SHORT $LN10@Decompress
$LN20@Decompress:

; 73   : 				{
; 74   : 				case 0:
; 75   : 					FinalColorR = r0;
; 76   : 					FinalColorG = g0;
; 77   : 					FinalColorB = b0;
; 78   : 					break;
; 79   : 				case 1:
; 80   : 					FinalColorR = r1;
; 81   : 					FinalColorG = g1;
; 82   : 					FinalColorB = b1;
; 83   : 					break;
; 84   : 				case 2:
; 85   : 					FinalColorR = (r0 + r1) / 2;

	movzx	eax, bl
	movzx	r9d, bpl
	add	r9d, eax

; 86   : 					FinalColorG = (g0 + g1) / 2;

	movzx	r10d, r14b
	movzx	eax, dil
	add	r10d, eax

; 87   : 					FinalColorB = (b0 + b1) / 2;

	movzx	r8d, r15b
	movzx	eax, sil
	add	r8d, eax
	shr	r9d, 1
	shr	r10d, 1
	shr	r8d, 1

; 92   : 					break;
; 93   : 				}
; 94   : 			}
; 95   : 
; 96   : 			if (x + i < width) {

	jmp	SHORT $LN10@Decompress
$LN19@Decompress:
	movzx	r8d, r15b
	movzx	r10d, r14b
	movzx	r9d, bpl
	jmp	SHORT $LN10@Decompress
$LN18@Decompress:
	movzx	r8d, sil
	movzx	r10d, dil
	movzx	r9d, bl
$LN10@Decompress:
	mov	eax, r11d
	sub	eax, DWORD PTR tv713[rsp]
	cmp	eax, DWORD PTR width$[rsp]
	jae	SHORT $LN5@Decompress

; 97   : 				Image[((y + j) * width + (x + i)) * 4] = FinalColorR;

	mov	rax, QWORD PTR Image$[rsp]
	lea	edx, DWORD PTR [r11*4]

; 98   : 				Image[((y + j) * width + (x + i)) * 4 + 1] = FinalColorG;

	lea	ecx, DWORD PTR [rdx+1]
	mov	rax, QWORD PTR [rax]
	mov	BYTE PTR [rdx+rax], r9b
	mov	r9, QWORD PTR Image$[rsp]
	mov	rax, QWORD PTR [r9]
	mov	BYTE PTR [rcx+rax], r10b

; 99   : 				Image[((y + j) * width + (x + i)) * 4 + 2] = FinalColorB;

	lea	ecx, DWORD PTR [rdx+2]
	mov	rax, QWORD PTR [r9]
	mov	BYTE PTR [rcx+rax], r8b

; 100  : 				Image[((y + j) * width + (x + i)) * 4 + 3] = FinalColorA;

	lea	ecx, DWORD PTR [rdx+3]
	mov	rax, QWORD PTR [r9]
	mov	rdx, QWORD PTR tv714[rsp]
	mov	BYTE PTR [rcx+rax], r13b
$LN5@Decompress:

; 35   : 	{
; 36   : 		for (int i = 0; i < 4; i++)

	mov	ecx, DWORD PTR code$1$[rsp]
	add	r12d, 2
	inc	r11d
	sub	rdx, 1
	mov	QWORD PTR tv714[rsp], rdx
	jne	$LL7@Decompress

; 33   : 
; 34   : 	for (int j = 0; j < 4; j++)

	mov	r13d, DWORD PTR y$[rsp]
	mov	r8d, DWORD PTR width$[rsp]
	inc	r13d
	sub	QWORD PTR tv715[rsp], 1
	mov	DWORD PTR y$[rsp], r13d
	jne	$LL4@Decompress

; 101  : 			}
; 102  : 		}
; 103  : 	}
; 104  : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?DecompressBlockDXT1@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ENDP ; DecompressBlockDXT1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\TextureFormatDecoder.cpp
;	COMDAT ?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z
_TEXT	SEGMENT
tv952 = 0
tv946 = 4
tv941 = 8
tv957 = 12
alphaCode1$1$ = 16
code$1$ = 20
tv850 = 24
tv838 = 28
tv848 = 32
x$ = 128
y$ = 136
width$ = 144
alphaCode2$1$ = 152
blockStorage$ = 152
Image$ = 160
TexToGo$ = 168
?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z PROC ; DecompressBlockDXT5, COMDAT

; 107  : {

$LN65:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 108  : 	unsigned char alpha0 = *reinterpret_cast<const unsigned char*>(blockStorage);
; 109  : 	unsigned char alpha1 = *reinterpret_cast<const unsigned char*>(blockStorage + 1);
; 110  : 
; 111  : 	const unsigned char* bits = blockStorage + 2;
; 112  : 	unsigned long alphaCode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24);

	movzx	eax, BYTE PTR [r9+6]
	mov	edi, ecx

; 113  : 	unsigned short alphaCode2 = bits[0] | (bits[1] << 8);

	movzx	r10d, BYTE PTR [r9+3]
	mov	ebx, r8d
	movzx	r8d, BYTE PTR [r9+7]
	mov	r11d, edx

; 114  : 
; 115  : 	unsigned short color0 = *reinterpret_cast<const unsigned short*>(blockStorage + 8);
; 116  : 	unsigned short color1 = *reinterpret_cast<const unsigned short*>(blockStorage + 10);
; 117  : 
; 118  : 	unsigned long temp;
; 119  : 
; 120  : 	temp = (color0 >> 11) * 255 + 16;

	movzx	edx, WORD PTR [r9+8]
	movzx	esi, BYTE PTR [r9]
	movzx	ebp, BYTE PTR [r9+1]
	mov	r14, QWORD PTR Image$[rsp]
	shl	r8d, 8
	or	r8d, eax
	shl	r10w, 8
	movzx	eax, BYTE PTR [r9+5]
	shl	r8d, 8
	or	r8d, eax
	movzx	eax, BYTE PTR [r9+4]
	shl	r8d, 8
	or	r8d, eax
	movzx	eax, BYTE PTR [r9+2]
	or	r10w, ax
	mov	DWORD PTR alphaCode1$1$[rsp], r8d
	mov	eax, edx
	mov	WORD PTR alphaCode2$1$[rsp], r10w
	shr	eax, 11
	imul	ecx, eax, 255				; 000000ffH

; 121  : 	unsigned char r0 = (unsigned char)((temp / 32 + temp) / 32);
; 122  : 	temp = ((color0 & 0x07E0) >> 5) * 255 + 32;

	mov	eax, edx
	shr	eax, 5

; 123  : 	unsigned char g0 = (unsigned char)((temp / 64 + temp) / 64);
; 124  : 	temp = (color0 & 0x001F) * 255 + 16;

	and	edx, 31
	and	eax, 63					; 0000003fH
	add	ecx, 16
	mov	r12d, ecx
	shr	r12d, 5
	add	r12d, ecx
	imul	ecx, eax, 255				; 000000ffH
	imul	eax, edx, 255				; 000000ffH

; 125  : 	unsigned char b0 = (unsigned char)((temp / 32 + temp) / 32);
; 126  : 
; 127  : 	temp = (color1 >> 11) * 255 + 16;

	movzx	edx, WORD PTR [r9+10]
	shr	r12d, 5
	add	ecx, 32					; 00000020H
	add	eax, 16
	mov	r13d, ecx
	shr	r13d, 6
	add	r13d, ecx
	mov	ecx, eax
	shr	ecx, 5
	add	ecx, eax
	shr	r13d, 6
	shr	ecx, 5
	mov	eax, edx
	shr	eax, 11
	mov	DWORD PTR tv957[rsp], ecx
	imul	ecx, eax, 255				; 000000ffH
	add	ecx, 16

; 128  : 	unsigned char r1 = (unsigned char)((temp / 32 + temp) / 32);

	mov	eax, ecx
	shr	eax, 5
	add	eax, ecx
	shr	eax, 5
	mov	DWORD PTR tv952[rsp], eax

; 129  : 	temp = ((color1 & 0x07E0) >> 5) * 255 + 32;

	mov	eax, edx
	shr	eax, 5

; 130  : 	unsigned char g1 = (unsigned char)((temp / 64 + temp) / 64);
; 131  : 	temp = (color1 & 0x001F) * 255 + 16;

	and	edx, 31
	and	eax, 63					; 0000003fH
	imul	ecx, eax, 255				; 000000ffH
	add	ecx, 32					; 00000020H
	mov	eax, ecx
	shr	eax, 6
	add	eax, ecx
	shr	eax, 6
	mov	DWORD PTR tv946[rsp], eax
	imul	eax, edx, 255				; 000000ffH
	add	eax, 16

; 132  : 	unsigned char b1 = (unsigned char)((temp / 32 + temp) / 32);

	mov	ecx, eax
	shr	ecx, 5
	add	ecx, eax

; 133  : 
; 134  : 	unsigned long code = *reinterpret_cast<const unsigned long*>(blockStorage + 12);

	mov	eax, DWORD PTR [r9+12]
	shr	ecx, 5
	mov	DWORD PTR tv941[rsp], ecx
	mov	ecx, r11d
	neg	ecx
	mov	DWORD PTR code$1$[rsp], eax
	mov	DWORD PTR tv838[rsp], ecx
	npad	12
$LL4@Decompress:

; 137  : 	{
; 138  : 		for (int i = 0; i < 4; i++)

	mov	eax, r11d
	mov	QWORD PTR tv848[rsp], 4
	imul	eax, ebx
	lea	r15d, DWORD PTR [rcx+r11]
	shl	r15d, 2
	sub	r15d, eax
	mov	DWORD PTR tv850[rsp], eax
	sub	r15d, edi
	lea	ebx, DWORD PTR [rax+rdi]
$LL7@Decompress:

; 139  : 		{
; 140  : 			int alphaCodeIndex = 3 * (4 * j + i);

	lea	edi, DWORD PTR [r15+rbx]
	lea	ecx, DWORD PTR [rdi+rdi*2]

; 141  : 			int alphaCode;
; 142  : 
; 143  : 			if (alphaCodeIndex <= 12)

	cmp	ecx, 12
	jg	SHORT $LN10@Decompress

; 144  : 			{
; 145  : 				alphaCode = (alphaCode2 >> alphaCodeIndex) & 0x07;

	movzx	eax, r10w

; 146  : 			}

	jmp	SHORT $LN62@Decompress
$LN10@Decompress:

; 147  : 			else if (alphaCodeIndex == 15)

	cmp	ecx, 15
	jne	SHORT $LN12@Decompress

; 148  : 			{
; 149  : 				alphaCode = (alphaCode2 >> 15) | ((alphaCode1 << 1) & 0x06);

	mov	ecx, r8d
	movzx	eax, r10w
	and	ecx, 3
	shr	eax, 15
	add	ecx, ecx
	or	eax, ecx

; 150  : 			}

	jmp	SHORT $LN13@Decompress
$LN12@Decompress:

; 151  : 			else // alphaCodeIndex >= 18 && alphaCodeIndex <= 45
; 152  : 			{
; 153  : 				alphaCode = (alphaCode1 >> (alphaCodeIndex - 16)) & 0x07;

	add	ecx, -16
	mov	eax, r8d
$LN62@Decompress:

; 154  : 			}
; 155  : 
; 156  : 			unsigned char finalAlpha;
; 157  : 			if (alphaCode == 0)

	shr	eax, cl
	and	eax, 7
$LN13@Decompress:
	test	eax, eax
	jne	SHORT $LN14@Decompress

; 158  : 			{
; 159  : 				finalAlpha = alpha0;

	movzx	r9d, sil

; 160  : 			}

	jmp	SHORT $LN23@Decompress
$LN14@Decompress:

; 161  : 			else if (alphaCode == 1)

	cmp	eax, 1
	jne	SHORT $LN16@Decompress

; 162  : 			{
; 163  : 				finalAlpha = alpha1;

	movzx	r9d, bpl

; 164  : 			}

	jmp	SHORT $LN23@Decompress
$LN16@Decompress:

; 165  : 			else
; 166  : 			{
; 167  : 				if (alpha0 > alpha1)

	cmp	sil, bpl
	jbe	SHORT $LN18@Decompress

; 168  : 				{
; 169  : 					finalAlpha = ((8 - alphaCode) * alpha0 + (alphaCode - 1) * alpha1) / 7;

	lea	ecx, DWORD PTR [rax-1]
	mov	r8d, 8
	sub	r8d, eax
	imul	ecx, ebp
	imul	r8d, esi
	mov	eax, -1840700269			; ffffffff92492493H
	add	r8d, ecx
	imul	r8d
	lea	r9d, DWORD PTR [r8+rdx]
	sar	r9d, 2
	mov	eax, r9d
	shr	eax, 31
	add	r9d, eax

; 170  : 				}

	jmp	SHORT $LN23@Decompress
$LN18@Decompress:

; 171  : 				else
; 172  : 				{
; 173  : 					if (alphaCode == 6)

	cmp	eax, 6
	jne	SHORT $LN20@Decompress

; 174  : 						finalAlpha = 0;

	xor	r9b, r9b
	jmp	SHORT $LN23@Decompress
$LN20@Decompress:

; 175  : 					else if (alphaCode == 7)

	cmp	eax, 7
	jne	SHORT $LN22@Decompress

; 176  : 						finalAlpha = 255;

	mov	r9b, 255				; 000000ffH
	jmp	SHORT $LN23@Decompress
$LN22@Decompress:

; 177  : 					else
; 178  : 						finalAlpha = ((6 - alphaCode) * alpha0 + (alphaCode - 1) * alpha1) / 5;

	lea	ecx, DWORD PTR [rax-1]
	mov	edx, 6
	sub	edx, eax
	imul	ecx, ebp
	imul	edx, esi
	mov	eax, 1717986919				; 66666667H
	add	edx, ecx
	imul	edx
	sar	edx, 1
	mov	r9d, edx
	shr	r9d, 31
	add	r9d, edx
$LN23@Decompress:

; 179  : 				}
; 180  : 			}
; 181  : 
; 182  : 			unsigned char colorCode = (code >> 2 * (4 * j + i)) & 0x03;

	mov	edx, DWORD PTR code$1$[rsp]
	lea	ecx, DWORD PTR [rdi+rdi]
	shr	edx, cl

; 183  : 
; 184  : 			unsigned char FinalColorR = 0;

	xor	r10b, r10b

; 185  : 			unsigned char FinalColorG = 0;

	xor	r11b, r11b

; 186  : 			unsigned char FinalColorB = 0;

	xor	r8b, r8b
	and	edx, 3

; 187  : 			switch (colorCode)

	je	$LN24@Decompress
	sub	edx, 1
	je	$LN25@Decompress
	sub	edx, 1
	je	SHORT $LN26@Decompress
	cmp	edx, 1
	jne	$LN8@Decompress

; 204  : 			case 3:
; 205  : 				FinalColorR = (r0 + 2 * r1) / 3;

	movzx	ecx, BYTE PTR tv952[rsp]
	movzx	eax, r12b
	lea	edx, DWORD PTR [rax+rcx*2]

; 206  : 				FinalColorG = (g0 + 2 * g1) / 3;

	movzx	ecx, BYTE PTR tv946[rsp]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	movzx	eax, r13b
	mov	r10d, edx
	shr	r10d, 1
	lea	r8d, DWORD PTR [rax+rcx*2]

; 207  : 				FinalColorB = (b0 + 2 * b1) / 3;

	movzx	ecx, BYTE PTR tv941[rsp]
	mov	eax, -1431655765			; aaaaaaabH
	mul	r8d
	movzx	eax, BYTE PTR tv957[rsp]
	mov	r11d, edx
	shr	r11d, 1
	lea	r8d, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	r8d
	mov	r8d, edx
	shr	r8d, 1
	jmp	SHORT $LN8@Decompress
$LN26@Decompress:

; 199  : 			case 2:
; 200  : 				FinalColorR = (2 * r0 + r1) / 3;

	movzx	eax, BYTE PTR tv952[rsp]
	movzx	ecx, r12b
	lea	edx, DWORD PTR [rax+rcx*2]

; 201  : 				FinalColorG = (2 * g0 + g1) / 3;

	movzx	ecx, r13b
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	movzx	eax, BYTE PTR tv946[rsp]
	shr	edx, 1
	movzx	r10d, dl
	lea	edx, DWORD PTR [rax+rcx*2]

; 202  : 				FinalColorB = (2 * b0 + b1) / 3;

	movzx	ecx, BYTE PTR tv957[rsp]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	movzx	eax, BYTE PTR tv941[rsp]
	shr	edx, 1
	movzx	r11d, dl
	lea	edx, DWORD PTR [rax+rcx*2]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 1
	movzx	r8d, dl

; 203  : 				break;

	jmp	SHORT $LN8@Decompress
$LN25@Decompress:

; 193  : 				break;
; 194  : 			case 1:
; 195  : 				FinalColorR = r1;

	movzx	r10d, BYTE PTR tv952[rsp]

; 196  : 				FinalColorG = g1;

	movzx	r11d, BYTE PTR tv946[rsp]

; 197  : 				FinalColorB = b1;

	movzx	r8d, BYTE PTR tv941[rsp]

; 198  : 				break;

	jmp	SHORT $LN8@Decompress
$LN24@Decompress:

; 188  : 			{
; 189  : 			case 0:
; 190  : 				FinalColorR = r0;
; 191  : 				FinalColorG = g0;
; 192  : 				FinalColorB = b0;

	movzx	r8d, BYTE PTR tv957[rsp]
	movzx	r10d, r12b
	movzx	r11d, r13b
$LN8@Decompress:

; 208  : 				break;
; 209  : 			}
; 210  : 
; 211  : 			if (x + i < width) {

	mov	eax, ebx
	sub	eax, DWORD PTR tv850[rsp]
	cmp	eax, DWORD PTR width$[rsp]
	jae	SHORT $LN5@Decompress

; 212  : 				Image[((y + j) * width + (x + i)) * 4] = FinalColorR;

	mov	rax, QWORD PTR [r14]
	lea	edx, DWORD PTR [rbx*4]

; 213  : 				Image[((y + j) * width + (x + i)) * 4 + 1] = FinalColorG;

	lea	ecx, DWORD PTR [rdx+1]
	mov	BYTE PTR [rdx+rax], r10b
	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rcx+rax], r11b

; 214  : 				Image[((y + j) * width + (x + i)) * 4 + 2] = FinalColorB;

	lea	ecx, DWORD PTR [rdx+2]
	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rcx+rax], r8b

; 215  : 				Image[((y + j) * width + (x + i)) * 4 + 3] = finalAlpha;

	lea	ecx, DWORD PTR [rdx+3]
	mov	rax, QWORD PTR [r14]
	mov	BYTE PTR [rcx+rax], r9b

; 216  : 				if (finalAlpha != 255)

	cmp	r9b, 255				; 000000ffH
	je	SHORT $LN5@Decompress

; 217  : 					TexToGo->IsTransparent() = true;

	mov	rax, QWORD PTR TexToGo$[rsp]
	mov	BYTE PTR [rax+42], 1
$LN5@Decompress:

; 137  : 	{
; 138  : 		for (int i = 0; i < 4; i++)

	mov	r8d, DWORD PTR alphaCode1$1$[rsp]
	inc	ebx
	sub	QWORD PTR tv848[rsp], 1
	movzx	r10d, WORD PTR alphaCode2$1$[rsp]
	jne	$LL7@Decompress

; 135  : 
; 136  : 	for (int j = 0; j < 4; j++)

	mov	r11d, DWORD PTR y$[rsp]
	mov	ecx, DWORD PTR tv838[rsp]
	inc	r11d
	mov	ebx, DWORD PTR width$[rsp]
	mov	edi, DWORD PTR x$[rsp]
	mov	DWORD PTR y$[rsp], r11d
	lea	eax, DWORD PTR [rcx+r11]
	cmp	eax, 4
	jl	$LL4@Decompress

; 218  : 			}
; 219  : 		}
; 220  : 	}
; 221  : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?DecompressBlockDXT5@@YAXKKKPEBEAEAV?$vector@EV?$allocator@E@std@@@std@@PEAVTextureToGo@@@Z ENDP ; DecompressBlockDXT5
_TEXT	ENDS
END
