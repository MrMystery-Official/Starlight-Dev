; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0GN@POGINCEH@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0DA@DNDMOMEJ@mergeHoles?3?5Failed?5to?5merge?5con@ ; `string'
PUBLIC	??_C@_0DH@FDPHPCPH@mergeHoles?3?5Failed?5to?5find?5merg@ ; `string'
PUBLIC	??_C@_0DA@NAIMHHAE@mergeRegionHoles?3?5Failed?5to?5all@ ; `string'
PUBLIC	??_C@_0CN@KNOPFNDB@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0DH@EDAAIGNC@rcBuildContours?3?5Expanding?5max?5@ ; `string'
PUBLIC	??_C@_0CN@HPMMFJFL@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_03EDDGELHM@ctx@				; `string'
PUBLIC	??_C@_0CN@DNNFBKCB@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CP@BBLIMKHO@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CM@MFPKMJMI@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0CO@JLFENFEL@rcBuildContours?3?5Out?5of?5memory?5@ ; `string'
PUBLIC	??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@ ; `string'
PUBLIC	??_C@_0FN@FGHNLJHD@rcBuildContours?3?5Bad?5outline?5fo@ ; `string'
PUBLIC	??_C@_0DC@MJMGNADI@rcBuildContours?3?5Multiple?5outli@ ; `string'
PUBLIC	??_C@_0BM@NGJCLDED@min_capacity?5?$DM?$DN?5RC_SIZE_MAX@ ; `string'
PUBLIC	??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@ ; `string'
PUBLIC	??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@ ; `string'
;	COMDAT ??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
CONST	SEGMENT
??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@ DB 'i >= 0 '
	DB	'&& i < m_size', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
CONST	SEGMENT
??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@ DB 'RC_SIZE_MAX'
	DB	' / static_cast<rcSizeType>(sizeof(T)) >= size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NGJCLDED@min_capacity?5?$DM?$DN?5RC_SIZE_MAX@
CONST	SEGMENT
??_C@_0BM@NGJCLDED@min_capacity?5?$DM?$DN?5RC_SIZE_MAX@ DB 'min_capacity '
	DB	'<= RC_SIZE_MAX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MJMGNADI@rcBuildContours?3?5Multiple?5outli@
CONST	SEGMENT
??_C@_0DC@MJMGNADI@rcBuildContours?3?5Multiple?5outli@ DB 'rcBuildContour'
	DB	's: Multiple outlines for region %d.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@FGHNLJHD@rcBuildContours?3?5Bad?5outline?5fo@
CONST	SEGMENT
??_C@_0FN@FGHNLJHD@rcBuildContours?3?5Bad?5outline?5fo@ DB 'rcBuildContou'
	DB	'rs: Bad outline for region %d, contour simplification is like'
	DB	'ly too aggressive.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastAlloc.h', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JLFENFEL@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CO@JLFENFEL@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''rverts'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MFPKMJMI@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CM@MFPKMJMI@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''hole'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BBLIMKHO@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CP@BBLIMKHO@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''regions'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DNNFBKCB@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CN@DNNFBKCB@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''holes'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDDGELHM@ctx@
CONST	SEGMENT
??_C@_03EDDGELHM@ctx@ DB 'ctx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HPMMFJFL@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CN@HPMMFJFL@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''flags'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDAAIGNC@rcBuildContours?3?5Expanding?5max?5@
CONST	SEGMENT
??_C@_0DH@EDAAIGNC@rcBuildContours?3?5Expanding?5max?5@ DB 'rcBuildContou'
	DB	'rs: Expanding max contours from %d to %d.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KNOPFNDB@rcBuildContours?3?5Out?5of?5memory?5@
CONST	SEGMENT
??_C@_0CN@KNOPFNDB@rcBuildContours?3?5Out?5of?5memory?5@ DB 'rcBuildConto'
	DB	'urs: Out of memory ''verts'' (%d).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NAIMHHAE@mergeRegionHoles?3?5Failed?5to?5all@
CONST	SEGMENT
??_C@_0DA@NAIMHHAE@mergeRegionHoles?3?5Failed?5to?5all@ DB 'mergeRegionHo'
	DB	'les: Failed to allocated diags %d.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FDPHPCPH@mergeHoles?3?5Failed?5to?5find?5merg@
CONST	SEGMENT
??_C@_0DH@FDPHPCPH@mergeHoles?3?5Failed?5to?5find?5merg@ DB 'mergeHoles: '
	DB	'Failed to find merge points for %p and %p.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNDMOMEJ@mergeHoles?3?5Failed?5to?5merge?5con@
CONST	SEGMENT
??_C@_0DA@DNDMOMEJ@mergeHoles?3?5Failed?5to?5merge?5con@ DB 'mergeHoles: '
	DB	'Failed to merge contours %p and %p.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@POGINCEH@H?3?2Paul?2switchemulator?2Zelda?5To@
CONST	SEGMENT
??_C@_0GN@POGINCEH@H?3?2Paul?2switchemulator?2Zelda?5To@ DB 'H:\Paul\swit'
	DB	'chemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recast'
	DB	'navigation\recast\RecastContour.cpp', 00H	; `string'
PUBLIC	?copy_range@?$rcVectorBase@H$00@@CAXPEAHPEBH1@Z	; rcVectorBase<int,1>::copy_range
PUBLIC	?construct@?$rcVectorBase@H$00@@CAXPEAH@Z	; rcVectorBase<int,1>::construct
PUBLIC	?get_new_capacity@?$rcVectorBase@H$00@@AEAA_J_J@Z ; rcVectorBase<int,1>::get_new_capacity
PUBLIC	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
PUBLIC	?construct_range@?$rcVectorBase@H$00@@CAXPEAH0@Z ; rcVectorBase<int,1>::construct_range
PUBLIC	?construct_range@?$rcVectorBase@H$00@@CAXPEAH0AEBH@Z ; rcVectorBase<int,1>::construct_range
PUBLIC	?construct@?$rcVectorBase@H$00@@CAXPEAHAEBH@Z	; rcVectorBase<int,1>::construct
PUBLIC	??$rcSwap@H@@YAXAEAH0@Z				; rcSwap<int>
PUBLIC	?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z	; rcVectorBase<int,1>::push_back
PUBLIC	?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z	; rcVectorBase<int,1>::resize_impl
PUBLIC	?destroy_range@?$rcVectorBase@H$00@@AEAAX_J0@Z	; rcVectorBase<int,1>::destroy_range
PUBLIC	?resize@?$rcVectorBase@H$00@@QEAAX_JAEBH@Z	; rcVectorBase<int,1>::resize
PUBLIC	??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z		; rcVectorBase<int,1>::rcVectorBase<int,1>
PUBLIC	??1?$rcVectorBase@H$00@@QEAA@XZ			; rcVectorBase<int,1>::~rcVectorBase<int,1>
PUBLIC	?resize@?$rcVectorBase@H$00@@QEAAX_J@Z		; rcVectorBase<int,1>::resize
PUBLIC	?clear@?$rcVectorBase@H$00@@QEAAXXZ		; rcVectorBase<int,1>::clear
PUBLIC	?size@?$rcVectorBase@H$00@@QEBA_JXZ		; rcVectorBase<int,1>::size
PUBLIC	??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z		; rcVectorBase<int,1>::operator[]
PUBLIC	??0?$rcTempVector@H@@QEAA@_JAEBH@Z		; rcTempVector<int>::rcTempVector<int>
PUBLIC	??0?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@PEAUrcPotentialDiagonal@@@Z ; rcScopedDelete<rcPotentialDiagonal>::rcScopedDelete<rcPotentialDiagonal>
PUBLIC	??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ ; rcScopedDelete<rcPotentialDiagonal>::~rcScopedDelete<rcPotentialDiagonal>
PUBLIC	??B?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAPEAUrcPotentialDiagonal@@XZ ; rcScopedDelete<rcPotentialDiagonal>::operator rcPotentialDiagonal *
PUBLIC	??0?$rcScopedDelete@E@@QEAA@PEAE@Z		; rcScopedDelete<unsigned char>::rcScopedDelete<unsigned char>
PUBLIC	??1?$rcScopedDelete@E@@QEAA@XZ			; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>
PUBLIC	??B?$rcScopedDelete@E@@QEAAPEAEXZ		; rcScopedDelete<unsigned char>::operator unsigned char *
PUBLIC	??0?$rcScopedDelete@C@@QEAA@PEAC@Z		; rcScopedDelete<signed char>::rcScopedDelete<signed char>
PUBLIC	??1?$rcScopedDelete@C@@QEAA@XZ			; rcScopedDelete<signed char>::~rcScopedDelete<signed char>
PUBLIC	??B?$rcScopedDelete@C@@QEAAPEACXZ		; rcScopedDelete<signed char>::operator signed char *
PUBLIC	??0?$rcScopedDelete@UrcContourRegion@@@@QEAA@PEAUrcContourRegion@@@Z ; rcScopedDelete<rcContourRegion>::rcScopedDelete<rcContourRegion>
PUBLIC	??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ	; rcScopedDelete<rcContourRegion>::~rcScopedDelete<rcContourRegion>
PUBLIC	??B?$rcScopedDelete@UrcContourRegion@@@@QEAAPEAUrcContourRegion@@XZ ; rcScopedDelete<rcContourRegion>::operator rcContourRegion *
PUBLIC	??0?$rcScopedDelete@UrcContourHole@@@@QEAA@PEAUrcContourHole@@@Z ; rcScopedDelete<rcContourHole>::rcScopedDelete<rcContourHole>
PUBLIC	??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ	; rcScopedDelete<rcContourHole>::~rcScopedDelete<rcContourHole>
PUBLIC	??B?$rcScopedDelete@UrcContourHole@@@@QEAAPEAUrcContourHole@@XZ ; rcScopedDelete<rcContourHole>::operator rcContourHole *
PUBLIC	?__autoclassinit2@?$rcScopedDelete@UrcContourHole@@@@QEAAX_K@Z ; rcScopedDelete<rcContourHole>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$rcScopedDelete@UrcContourRegion@@@@QEAAX_K@Z ; rcScopedDelete<rcContourRegion>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$rcScopedDelete@C@@QEAAX_K@Z	; rcScopedDelete<signed char>::__autoclassinit2
PUBLIC	?__autoclassinit2@rcIntArray@@QEAAX_K@Z		; rcIntArray::__autoclassinit2
PUBLIC	??1rcIntArray@@QEAA@XZ				; rcIntArray::~rcIntArray
PUBLIC	?__autoclassinit2@?$rcScopedDelete@E@@QEAAX_K@Z	; rcScopedDelete<unsigned char>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAX_K@Z ; rcScopedDelete<rcPotentialDiagonal>::__autoclassinit2
PUBLIC	?collinear@@YA_NPEBH00@Z			; collinear
PUBLIC	?leftOn@@YA_NPEBH00@Z				; leftOn
PUBLIC	?left@@YA_NPEBH00@Z				; left
PUBLIC	?xorb@@YA_N_N0@Z				; xorb
PUBLIC	?area2@@YAHPEBH00@Z				; area2
PUBLIC	?next@@YAHHH@Z					; next
PUBLIC	?prev@@YAHHH@Z					; prev
PUBLIC	??1?$rcTempVector@H@@QEAA@XZ			; rcTempVector<int>::~rcTempVector<int>
PUBLIC	??ArcIntArray@@QEAAAEAHH@Z			; rcIntArray::operator[]
PUBLIC	?size@rcIntArray@@QEBAHXZ			; rcIntArray::size
PUBLIC	?clear@rcIntArray@@QEAAXXZ			; rcIntArray::clear
PUBLIC	?resize@rcIntArray@@QEAAXH@Z			; rcIntArray::resize
PUBLIC	?push@rcIntArray@@QEAAXH@Z			; rcIntArray::push
PUBLIC	??0rcIntArray@@QEAA@H@Z				; rcIntArray::rcIntArray
PUBLIC	?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z ; rcBuildContours
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z DD imagerel $LN35
	DD	imagerel $LN35+147
	DD	imagerel $unwind$?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD imagerel $LN63
	DD	imagerel $LN63+80
	DD	imagerel $unwind$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD imagerel $LN63+80
	DD	imagerel $LN63+85
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD imagerel $LN63+85
	DD	imagerel $LN63+269
	DD	imagerel $chain$1$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD imagerel $LN63+269
	DD	imagerel $LN63+284
	DD	imagerel $chain$2$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD imagerel $LN63+284
	DD	imagerel $LN63+296
	DD	imagerel $chain$3$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD imagerel $LN66
	DD	imagerel $LN66+129
	DD	imagerel $unwind$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD imagerel $LN66+129
	DD	imagerel $LN66+259
	DD	imagerel $chain$1$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD imagerel $LN66+259
	DD	imagerel $LN66+278
	DD	imagerel $chain$2$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcVectorBase@H$00@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+17
	DD	imagerel $unwind$??1?$rcVectorBase@H$00@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD imagerel $LN55
	DD	imagerel $LN55+42
	DD	imagerel $unwind$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD imagerel $LN55+42
	DD	imagerel $LN55+143
	DD	imagerel $chain$1$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD imagerel $LN55+143
	DD	imagerel $LN55+157
	DD	imagerel $chain$2$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z DD imagerel $LN10
	DD	imagerel $LN10+79
	DD	imagerel $unwind$??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$rcTempVector@H@@QEAA@_JAEBH@Z DD imagerel $LN10
	DD	imagerel $LN10+36
	DD	imagerel $unwind$??0?$rcTempVector@H@@QEAA@_JAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@E@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@E@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@C@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@C@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+16
	DD	imagerel $unwind$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1rcIntArray@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+25
	DD	imagerel $unwind$??1rcIntArray@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z DD imagerel ?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
	DD	imagerel ?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z+1751
	DD	imagerel $unwind$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z DD imagerel ?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z
	DD	imagerel ?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z+138
	DD	imagerel $unwind$?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+75
	DD	imagerel $unwind$?mergeContours@@YA_NAEAUrcContour@@0HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+75
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+290
	DD	imagerel $chain$0$?mergeContours@@YA_NAEAUrcContour@@0HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+290
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+332
	DD	imagerel $chain$1$?mergeContours@@YA_NAEAUrcContour@@0HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+46
	DD	imagerel $unwind$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+46
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+905
	DD	imagerel $chain$4$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+905
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+914
	DD	imagerel $chain$5$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?inCone@@YA_NHHPEBH0@Z DD imagerel ?inCone@@YA_NHHPEBH0@Z
	DD	imagerel ?inCone@@YA_NHHPEBH0@Z+269
	DD	imagerel $unwind$?inCone@@YA_NHHPEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?intersectSegContour@@YA_NPEBH0HH0@Z DD imagerel ?intersectSegContour@@YA_NPEBH0HH0@Z
	DD	imagerel ?intersectSegContour@@YA_NPEBH0HH0@Z+540
	DD	imagerel $unwind$?intersectSegContour@@YA_NPEBH0HH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?intersect@@YA_NPEBH000@Z DD imagerel ?intersect@@YA_NPEBH000@Z
	DD	imagerel ?intersect@@YA_NPEBH000@Z+294
	DD	imagerel $unwind$?intersect@@YA_NPEBH000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?between@@YA_NPEBH00@Z DD imagerel ?between@@YA_NPEBH00@Z
	DD	imagerel ?between@@YA_NPEBH00@Z+131
	DD	imagerel $unwind$?between@@YA_NPEBH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?intersectProp@@YA_NPEBH000@Z DD imagerel ?intersectProp@@YA_NPEBH000@Z
	DD	imagerel ?intersectProp@@YA_NPEBH000@Z+195
	DD	imagerel $unwind$?intersectProp@@YA_NPEBH000@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel $unwind$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel $chain$1$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+2445
	DD	imagerel $chain$2$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+2445
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+4767
	DD	imagerel $chain$11$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+4767
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+4787
	DD	imagerel $chain$12$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+4787
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+6563
	DD	imagerel $chain$13$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+6563
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+6935
	DD	imagerel $chain$14$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?distancePtSeg@@YAMHHHHHH@Z DD imagerel ?distancePtSeg@@YAMHHHHHH@Z
	DD	imagerel ?distancePtSeg@@YAMHHHHHH@Z+200
	DD	imagerel $unwind$?distancePtSeg@@YAMHHHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z DD imagerel ?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z
	DD	imagerel ?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z+1646
	DD	imagerel $unwind$?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z DD imagerel ?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z
	DD	imagerel ?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z+803
	DD	imagerel $unwind$?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$rcTempVector@H@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+25
	DD	imagerel $unwind$??1?$rcTempVector@H@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ArcIntArray@@QEAAAEAHH@Z DD imagerel $LN12
	DD	imagerel $LN12+78
	DD	imagerel $unwind$??ArcIntArray@@QEAAAEAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@rcIntArray@@QEAAXH@Z DD imagerel $LN57
	DD	imagerel $LN57+47
	DD	imagerel $unwind$?resize@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@rcIntArray@@QEAAXH@Z DD imagerel $LN57+47
	DD	imagerel $LN57+137
	DD	imagerel $chain$0$?resize@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@rcIntArray@@QEAAXH@Z DD imagerel $LN57+137
	DD	imagerel $LN57+156
	DD	imagerel $chain$1$?resize@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@rcIntArray@@QEAAXH@Z DD imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$?push@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push@rcIntArray@@QEAAXH@Z DD imagerel $LN65+74
	DD	imagerel $LN65+79
	DD	imagerel $chain$0$?push@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push@rcIntArray@@QEAAXH@Z DD imagerel $LN65+79
	DD	imagerel $LN65+264
	DD	imagerel $chain$1$?push@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?push@rcIntArray@@QEAAXH@Z DD imagerel $LN65+264
	DD	imagerel $LN65+279
	DD	imagerel $chain$2$?push@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?push@rcIntArray@@QEAAXH@Z DD imagerel $LN65+279
	DD	imagerel $LN65+290
	DD	imagerel $chain$3$?push@rcIntArray@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0rcIntArray@@QEAA@H@Z DD imagerel $LN102
	DD	imagerel $LN102+73
	DD	imagerel $unwind$??0rcIntArray@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0rcIntArray@@QEAA@H@Z DD imagerel $LN102+73
	DD	imagerel $LN102+244
	DD	imagerel $chain$0$??0rcIntArray@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0rcIntArray@@QEAA@H@Z DD imagerel $LN102+244
	DD	imagerel $LN102+263
	DD	imagerel $chain$1$??0rcIntArray@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z DD imagerel $LN1416
	DD	imagerel $LN1416+3109
	DD	imagerel $unwind$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z DB 01eH
	DB	0e8H
	DB	00H
	DB	'v'
	DB	02H
	DB	0f1H, 03H
	DB	06H
	DB	0a9H, 09H
	DB	0cH
	DB	'4'
	DB	0eH
	DB	']', 0fH
	DB	' '
	DB	'F'
	DB	0eH
	DB	'|'
	DB	' '
	DB	08dH, 03H
	DB	','
	DB	09aH
	DB	':'
	DB	'J'
	DB	'>'
	DB	'M', 02H
	DB	':'
	DB	0f9H, 04H
	DB	'<'
	DB	0d0H
	DB	'P'
	DB	01eH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z DB 050H
	DB	0aH
	DD	imagerel ??1rcScopedTimer@@QEAA@XZ
	DB	01H
	DB	02H
	DB	040H
	DB	042H
	DD	imagerel ??1?$rcScopedDelete@E@@QEAA@XZ
	DB	061H
	DB	03H
	DB	078H
	DB	088H
	DB	04aH
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	01H
	DB	03H
	DB	03aH
	DD	imagerel ??1rcIntArray@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	070H
	DB	0c0H
	DB	011H
	DB	02H
	DB	041H
	DB	02H
	DB	0a0H
	DB	0f0H
	DB	071H
	DB	02H
	DB	0a1H
	DB	02H
	DB	09aH
	DD	imagerel ??1?$rcScopedDelete@C@@QEAA@XZ
	DB	081H
	DB	02H
	DB	0d0H
	DB	021H
	DB	02H
	DB	0d1H
	DB	02H
	DB	071H
	DB	03H
	DB	0a1H
	DB	03H
	DB	082H
	DD	imagerel ??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ
	DB	061H
	DB	02H
	DB	0b8H
	DB	0b1H
	DB	02H
	DB	041H
	DB	03H
	DB	0f1H
	DB	03H
	DB	091H
	DB	04H
	DB	0c1H
	DB	04H
	DB	092H
	DD	imagerel ??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ
	DB	041H
	DB	02H
	DB	0ceH
	DD	imagerel __imp___std_terminate
	DB	0edH
	DB	02H
	DD	imagerel __imp___std_terminate
	DB	07dH
	DB	04H
	DD	imagerel __imp___std_terminate
	DB	041H
	DB	05H
	DB	0f1H
	DB	05H
	DB	091H
	DB	06H
	DB	0c1H
	DB	06H
	DB	0cdH
	DB	05H
	DD	imagerel __imp___std_terminate
	DB	0bdH
	DB	06H
	DD	imagerel __imp___std_terminate
	DB	09dH
	DB	07H
	DD	imagerel __imp___std_terminate
	DB	0dH
	DB	08H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z
	DD	imagerel $ip2state$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z DD 0c2f19H
	DD	0f6821H
	DD	0210119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z
	DD	0e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0rcIntArray@@QEAA@H@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+73
	DD	imagerel $unwind$??0rcIntArray@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0rcIntArray@@QEAA@H@Z DD 020521H
	DD	066405H
	DD	imagerel $LN102
	DD	imagerel $LN102+73
	DD	imagerel $unwind$??0rcIntArray@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0rcIntArray@@QEAA@H@Z DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?push@rcIntArray@@QEAAXH@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$?push@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?push@rcIntArray@@QEAAXH@Z DD 021H
	DD	imagerel $LN65+74
	DD	imagerel $LN65+79
	DD	imagerel $chain$0$?push@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push@rcIntArray@@QEAAXH@Z DD 020521H
	DD	087405H
	DD	imagerel $LN65+74
	DD	imagerel $LN65+79
	DD	imagerel $chain$0$?push@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push@rcIntArray@@QEAAXH@Z DD 020521H
	DD	076405H
	DD	imagerel $LN65
	DD	imagerel $LN65+74
	DD	imagerel $unwind$?push@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@rcIntArray@@QEAAXH@Z DD 040a01H
	DD	09340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@rcIntArray@@QEAAXH@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+47
	DD	imagerel $unwind$?resize@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@rcIntArray@@QEAAXH@Z DD 020521H
	DD	065405H
	DD	imagerel $LN57
	DD	imagerel $LN57+47
	DD	imagerel $unwind$?resize@rcIntArray@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@rcIntArray@@QEAAXH@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ArcIntArray@@QEAAAEAHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcTempVector@H@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$rcTempVector@H@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcTempVector@H@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$rcTempVector@H@@QEAA@XZ
	DD	imagerel $ip2state$??1?$rcTempVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcTempVector@H@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcTempVector@H@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z DD 0c1c01H
	DD	0b641cH
	DD	09541cH
	DD	08341cH
	DD	0f018121cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z DD 091101H
	DD	0f00de211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?distancePtSeg@@YAMHHHHHH@Z DD 031201H
	DD	06812H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 021H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel $unwind$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 021H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel $chain$1$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 021H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+2445
	DD	imagerel $chain$2$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 0125321H
	DD	07e853H
	DD	08d849H
	DD	09c840H
	DD	0ab837H
	DD	0ba82eH
	DD	0c9825H
	DD	0d881cH
	DD	0e7813H
	DD	0f6808H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+2445
	DD	imagerel $chain$2$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 020621H
	DD	06f806H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+46
	DD	imagerel $chain$1$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 041521H
	DD	028f415H
	DD	026c404H
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
	DD	imagerel ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z+23
	DD	imagerel $unwind$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z DD 091501H
	DD	0293415H
	DD	0200115H
	DD	0d00ce00eH
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?intersectProp@@YA_NPEBH000@Z DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?between@@YA_NPEBH00@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?intersect@@YA_NPEBH000@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?intersectSegContour@@YA_NPEBH0HH0@Z DD 0c2101H
	DD	0106421H
	DD	0f5421H
	DD	0e3421H
	DD	0f01d7221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?inCone@@YA_NHHPEBH0@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD 021H
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+46
	DD	imagerel $unwind$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD 0a1b21H
	DD	04e41bH
	DD	05d416H
	DD	0cc411H
	DD	0b740cH
	DD	0a6405H
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
	DD	imagerel ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z+46
	DD	imagerel $unwind$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z DD 040901H
	DD	0f0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD 021H
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+75
	DD	imagerel $unwind$?mergeContours@@YA_NAEAUrcContour@@0HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD 020521H
	DD	087405H
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z
	DD	imagerel ?mergeContours@@YA_NAEAUrcContour@@0HH@Z+75
	DD	imagerel $unwind$?mergeContours@@YA_NAEAUrcContour@@0HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mergeContours@@YA_NAEAUrcContour@@0HH@Z DD 081301H
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z DB 08H
	DB	01dH, 06H
	DB	00H
	DB	'L'
	DB	02H
	DB	0c1H, 013H
	DB	06H
	DB	'4'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ
	DB	061H
	DB	02H
	DB	040H
	DB	04eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
	DD	imagerel $ip2state$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z DD 0b2919H
	DD	0203417H
	DD	0160117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
	DD	0a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1rcIntArray@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1rcIntArray@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1rcIntArray@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1rcIntArray@@QEAA@XZ
	DD	imagerel $ip2state$??1rcIntArray@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1rcIntArray@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1rcIntArray@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@C@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@C@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@C@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@C@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@C@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@E@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@E@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@E@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@E@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@E@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$rcTempVector@H@@QEAA@_JAEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+42
	DD	imagerel $unwind$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD 040a21H
	DD	07640aH
	DD	065405H
	DD	imagerel $LN55
	DD	imagerel $LN55+42
	DD	imagerel $unwind$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$rcVectorBase@H$00@@QEAAX_J@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$rcVectorBase@H$00@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$rcVectorBase@H$00@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$rcVectorBase@H$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$rcVectorBase@H$00@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$rcVectorBase@H$00@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+129
	DD	imagerel $unwind$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD 040a21H
	DD	07e40aH
	DD	065405H
	DD	imagerel $LN66
	DD	imagerel $LN66+129
	DD	imagerel $unwind$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+80
	DD	imagerel $unwind$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD 021H
	DD	imagerel $LN63+80
	DD	imagerel $LN63+85
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD 020521H
	DD	077405H
	DD	imagerel $LN63+80
	DD	imagerel $LN63+85
	DD	imagerel $chain$0$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN63
	DD	imagerel $LN63+80
	DD	imagerel $unwind$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z DD 040b01H
	DD	08340bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z
_TEXT	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z PROC ; rcBuildContours, COMDAT

; 826  : {

$LN1416:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-8]
	sub	rsp, 264				; 00000108H
	movaps	XMMWORD PTR [rsp+240], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	DWORD PTR maxEdgeLen$GSCopy$1$[rsp], r9d
	movaps	xmm6, xmm2
	mov	rbx, rdx
	mov	QWORD PTR chf$GSCopy$1$[rbp-256], rdx
	mov	r12, rcx
	mov	QWORD PTR timer$2$[rsp], rcx
	mov	r14, QWORD PTR cset$[rbp-256]
	mov	QWORD PTR cset$GSCopy$1$[rsp], r14

; 827  : 	rcAssert(ctx);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN49@rcBuildCon
	test	rcx, rcx
	jne	SHORT $LN49@rcBuildCon
	mov	r8d, 827				; 0000033bH
	lea	rdx, OFFSET FLAT:??_C@_0GN@POGINCEH@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_03EDDGELHM@ctx@
	call	rax
$LN49@rcBuildCon:

; 828  : 	
; 829  : 	const int w = chf.width;

	mov	edi, DWORD PTR [rbx]
	mov	DWORD PTR w$1$[rsp], edi

; 830  : 	const int h = chf.height;

	mov	eax, DWORD PTR [rbx+4]
	mov	DWORD PTR h$1$[rsp], eax

; 831  : 	const int borderSize = chf.borderSize;

	mov	r15d, DWORD PTR [rbx+20]
	mov	DWORD PTR borderSize$1$[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 202  : 	inline rcScopedTimer(rcContext* ctx, const rcTimerLabel label) : m_ctx(ctx), m_label(label) { m_ctx->startTimer(m_label); }

	mov	QWORD PTR timer$[rbp-256], r12
	mov	DWORD PTR timer$[rbp-248], 4

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN988@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 4
	mov	rcx, r12
	call	QWORD PTR [rax+32]
	npad	1
$LN988@rcBuildCon:

; 774  : 	dest[0] = v[0];

	movss	xmm0, DWORD PTR [rbx+28]
	movss	DWORD PTR [r14+12], xmm0

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [r14+16], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [rbx+36]
	mov	DWORD PTR [r14+20], eax

; 774  : 	dest[0] = v[0];

	movss	xmm2, DWORD PTR [rbx+40]
	movss	DWORD PTR [r14+24], xmm2

; 775  : 	dest[1] = v[1];

	mov	eax, DWORD PTR [rbx+44]
	mov	DWORD PTR [r14+28], eax

; 776  : 	dest[2] = v[2];

	mov	eax, DWORD PTR [rbx+48]
	mov	DWORD PTR [r14+32], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 837  : 	if (borderSize > 0)

	test	r15d, r15d
	jle	SHORT $LN50@rcBuildCon
	movd	xmm1, r15d

; 838  : 	{
; 839  : 		// If the heightfield was build with bordersize, remove the offset.
; 840  : 		const float pad = borderSize*chf.cs;

	cvtdq2ps xmm1, xmm1
	mulss	xmm1, DWORD PTR [rbx+52]

; 841  : 		cset.bmin[0] += pad;

	addss	xmm0, xmm1
	movss	DWORD PTR [r14+12], xmm0

; 842  : 		cset.bmin[2] += pad;

	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [r14+20]
	movss	DWORD PTR [r14+20], xmm0

; 843  : 		cset.bmax[0] -= pad;

	subss	xmm2, xmm1
	movss	DWORD PTR [r14+24], xmm2

; 844  : 		cset.bmax[2] -= pad;

	movss	xmm0, DWORD PTR [r14+32]
	subss	xmm0, xmm1
	movss	DWORD PTR [r14+32], xmm0
$LN50@rcBuildCon:

; 845  : 	}
; 846  : 	cset.cs = chf.cs;

	mov	eax, DWORD PTR [rbx+52]
	mov	DWORD PTR [r14+36], eax

; 847  : 	cset.ch = chf.ch;

	mov	eax, DWORD PTR [rbx+56]
	mov	DWORD PTR [r14+40], eax

; 848  : 	cset.width = chf.width - chf.borderSize*2;

	mov	ecx, DWORD PTR [rbx+20]
	add	ecx, ecx
	mov	eax, DWORD PTR [rbx]
	sub	eax, ecx
	mov	DWORD PTR [r14+44], eax

; 849  : 	cset.height = chf.height - chf.borderSize*2;

	mov	ecx, DWORD PTR [rbx+20]
	add	ecx, ecx
	mov	eax, DWORD PTR [rbx+4]
	sub	eax, ecx
	mov	DWORD PTR [r14+48], eax

; 850  : 	cset.borderSize = chf.borderSize;

	mov	eax, DWORD PTR [rbx+20]
	mov	DWORD PTR [r14+52], eax

; 851  : 	cset.maxError = maxError;

	movss	DWORD PTR [r14+56], xmm6

; 852  : 	
; 853  : 	int maxContours = rcMax((int)chf.maxRegions, 8);

	movzx	ecx, WORD PTR [rbx+26]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	mov	eax, 8
	cmp	ecx, eax
	cmova	eax, ecx
	mov	ecx, eax
	mov	QWORD PTR tv5092[rbp-256], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 854  : 	cset.conts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);

	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 854  : 	cset.conts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);

	mov	QWORD PTR [r14], rax

; 855  : 	if (!cset.conts)

	test	rax, rax
	jne	SHORT $LN51@rcBuildCon
	xor	bl, bl
	jmp	$LN103@rcBuildCon
$LN51@rcBuildCon:

; 856  : 		return false;
; 857  : 	cset.nconts = 0;

	xor	r13d, r13d
	mov	QWORD PTR tv5252[rsp], r13
	mov	DWORD PTR [r14+8], r13d

; 858  : 	
; 859  : 	rcScopedDelete<unsigned char> flags((unsigned char*)rcAlloc(sizeof(unsigned char)*chf.spanCount, RC_ALLOC_TEMP));

	movsxd	rcx, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
	mov	QWORD PTR flags$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR flags$[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 860  : 	if (!flags)

	test	rax, rax
	jne	SHORT $LN52@rcBuildCon

; 861  : 	{
; 862  : 		ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'flags' (%d).", chf.spanCount);

	mov	r9d, DWORD PTR [rbx+8]
	lea	r8, OFFSET FLAT:??_C@_0CN@HPMMFJFL@rcBuildContours?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	$LN119@rcBuildCon
$LN52@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN1023@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 5
	mov	rcx, r12
	call	QWORD PTR [rax+32]
$LN1023@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 869  : 	for (int y = 0; y < h; ++y)

	mov	r12d, r13d
	mov	eax, DWORD PTR h$1$[rsp]
	test	eax, eax
	jle	$LN3@rcBuildCon
	mov	r9d, DWORD PTR w$1$[rsp]
	npad	8
$LL4@rcBuildCon:

; 870  : 	{
; 871  : 		for (int x = 0; x < w; ++x)

	mov	r14d, r13d
	test	r9d, r9d
	jle	$LN2@rcBuildCon
	mov	r15d, r12d
	imul	r15d, r9d
	npad	13
$LL7@rcBuildCon:

; 872  : 		{
; 873  : 			const rcCompactCell& c = chf.cells[x+y*w];

	lea	eax, DWORD PTR [r15+r14]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+64]

; 874  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	edx, DWORD PTR [rax+rcx*4]
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	mov	edi, eax
	shr	edx, 24
	add	eax, edx
	mov	QWORD PTR tv5109[rsp], rax
	cmp	rdi, rax
	jae	$LN5@rcBuildCon
	npad	6
$LL10@rcBuildCon:

; 875  : 			{
; 876  : 				unsigned char res = 0;
; 877  : 				const rcCompactSpan& s = chf.spans[i];

	mov	rbx, QWORD PTR [rbx+72]

; 878  : 				if (!chf.spans[i].reg || (chf.spans[i].reg & RC_BORDER_REG))

	movzx	r11d, WORD PTR [rbx+rdi*8+2]
	test	r11w, r11w
	je	$LN54@rcBuildCon
	js	$LN54@rcBuildCon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r9d, DWORD PTR [rbx+rdi*8+4]
	and	r9d, 16777215				; 00ffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 885  : 					unsigned short r = 0;

	movzx	eax, r13w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, r9d
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 886  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN1403@rcBuildCon

; 890  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	lea	eax, DWORD PTR [r15-1]
	add	eax, r14d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$GSCopy$1$[rbp-256]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d

; 891  : 						r = chf.spans[ai].reg;

	movzx	eax, WORD PTR [rbx+rdx*8+2]
$LN1403@rcBuildCon:

; 885  : 					unsigned short r = 0;

	cmp	ax, r11w
	sete	r8b
	movzx	eax, r13w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, r9d
	shr	r10d, 6
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 886  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN1404@rcBuildCon

; 887  : 					{
; 888  : 						const int ax = x + rcGetDirOffsetX(dir);
; 889  : 						const int ay = y + rcGetDirOffsetY(dir);

	lea	eax, DWORD PTR [r12+1]

; 890  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, r14d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$GSCopy$1$[rbp-256]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r10d

; 891  : 						r = chf.spans[ai].reg;

	movzx	eax, WORD PTR [rbx+rdx*8+2]
$LN1404@rcBuildCon:

; 892  : 					}
; 893  : 					if (r == chf.spans[i].reg)

	cmp	ax, r11w
	jne	SHORT $LN1356@rcBuildCon

; 894  : 						res |= (1 << dir);

	movzx	r8d, r8b
	bts	r8d, 1
$LN1356@rcBuildCon:

; 885  : 					unsigned short r = 0;

	movzx	eax, r13w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r10d, r9d
	shr	r10d, 12
	and	r10d, 63				; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 886  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r10d, 63				; 0000003fH
	je	SHORT $LN1405@rcBuildCon

; 890  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	lea	eax, DWORD PTR [r15+1]
	add	eax, r14d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$GSCopy$1$[rbp-256]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r10d

; 891  : 						r = chf.spans[ai].reg;

	movzx	eax, WORD PTR [rbx+rdx*8+2]
$LN1405@rcBuildCon:

; 892  : 					}
; 893  : 					if (r == chf.spans[i].reg)

	cmp	ax, r11w
	jne	SHORT $LN1359@rcBuildCon

; 894  : 						res |= (1 << dir);

	movzx	r8d, r8b
	bts	r8d, 2
$LN1359@rcBuildCon:

; 885  : 					unsigned short r = 0;

	movzx	eax, r13w
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r9d, 18
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 886  : 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r9d, 63					; 0000003fH
	je	SHORT $LN1402@rcBuildCon

; 887  : 					{
; 888  : 						const int ax = x + rcGetDirOffsetX(dir);
; 889  : 						const int ay = y + rcGetDirOffsetY(dir);

	lea	eax, DWORD PTR [r12-1]

; 890  : 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);

	imul	eax, DWORD PTR w$1$[rsp]
	add	eax, r14d
	movsxd	rcx, eax
	mov	rax, QWORD PTR chf$GSCopy$1$[rbp-256]
	mov	rax, QWORD PTR [rax+64]
	mov	edx, DWORD PTR [rax+rcx*4]
	and	edx, 16777215				; 00ffffffH
	add	edx, r9d

; 891  : 						r = chf.spans[ai].reg;

	movzx	eax, WORD PTR [rbx+rdx*8+2]
$LN1402@rcBuildCon:

; 892  : 					}
; 893  : 					if (r == chf.spans[i].reg)

	cmp	ax, r11w
	jne	SHORT $LN1362@rcBuildCon

; 894  : 						res |= (1 << dir);

	movzx	r8d, r8b
	bts	r8d, 3
$LN1362@rcBuildCon:

; 895  : 				}
; 896  : 				flags[i] = res ^ 0xf; // Inverse, mark non connected edges.

	xor	r8b, 15

; 897  : 			}

	mov	rax, QWORD PTR tv5109[rsp]
	jmp	SHORT $LN8@rcBuildCon
$LN54@rcBuildCon:

; 879  : 				{
; 880  : 					flags[i] = 0;

	xor	r8b, r8b
$LN8@rcBuildCon:

; 874  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	BYTE PTR [rsi+rdi], r8b
	inc	rdi
	cmp	rdi, rax
	mov	rbx, QWORD PTR chf$GSCopy$1$[rbp-256]
	jl	$LL10@rcBuildCon
	mov	r9d, DWORD PTR w$1$[rsp]
$LN5@rcBuildCon:

; 870  : 	{
; 871  : 		for (int x = 0; x < w; ++x)

	inc	r14d
	cmp	r14d, r9d
	jl	$LL7@rcBuildCon
	mov	eax, DWORD PTR h$1$[rsp]
$LN2@rcBuildCon:

; 869  : 	for (int y = 0; y < h; ++y)

	inc	r12d
	cmp	r12d, eax
	jl	$LL4@rcBuildCon
	mov	r14, QWORD PTR cset$GSCopy$1$[rsp]
	mov	r15d, DWORD PTR borderSize$1$[rsp]
	mov	edi, DWORD PTR w$1$[rsp]
$LN3@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	mov	r12, QWORD PTR timer$2$[rsp]
	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN983@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 5
	mov	rcx, r12
	call	QWORD PTR [rax+40]
$LN983@rcBuildCon:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR verts$[rbp-256], xmm0
	mov	QWORD PTR verts$[rbp-240], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 903  : 	rcIntArray verts(256);

	mov	edx, 256				; 00000100H
	lea	rcx, QWORD PTR verts$[rbp-256]
	call	??0rcIntArray@@QEAA@H@Z			; rcIntArray::rcIntArray
	npad	1
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR simplified$[rbp-256], xmm0
	mov	QWORD PTR simplified$[rbp-240], rax

; 904  : 	rcIntArray simplified(64);

	lea	edx, QWORD PTR [rax+64]
	lea	rcx, QWORD PTR simplified$[rbp-256]
	call	??0rcIntArray@@QEAA@H@Z			; rcIntArray::rcIntArray
	npad	1

; 905  : 	
; 906  : 	for (int y = 0; y < h; ++y)

	mov	r9d, r13d
	mov	DWORD PTR y$1$[rsp], r13d
	mov	eax, DWORD PTR h$1$[rsp]
	test	eax, eax
	jle	$LN1409@rcBuildCon

; 903  : 	rcIntArray verts(256);

	mov	r10d, r13d
	mov	DWORD PTR tv5088[rsp], r13d
	npad	5
$LL16@rcBuildCon:

; 907  : 	{
; 908  : 		for (int x = 0; x < w; ++x)

	mov	r8d, r13d
	mov	DWORD PTR x$1$[rsp], r13d
	test	edi, edi
	jle	$LN14@rcBuildCon
$LL19@rcBuildCon:

; 909  : 		{
; 910  : 			const rcCompactCell& c = chf.cells[x+y*w];

	lea	eax, DWORD PTR [r10+r8]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx+64]

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	edx, DWORD PTR [rax+rcx*4]
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	mov	QWORD PTR tv5106[rbp-256], rax
	shr	edx, 24
	lea	edi, DWORD PTR [rax+rdx]
	mov	QWORD PTR tv5105[rsp], rdi
	cmp	rax, rdi
	jae	$LN17@rcBuildCon
	mov	edi, eax
	mov	QWORD PTR $T1[rsp], rax
$LL22@rcBuildCon:

; 912  : 			{
; 913  : 				if (flags[i] == 0 || flags[i] == 0xf)

	movzx	eax, BYTE PTR [rdi+rsi]
	test	al, al
	je	$LN58@rcBuildCon
	cmp	al, 15
	je	$LN58@rcBuildCon

; 916  : 					continue;
; 917  : 				}
; 918  : 				const unsigned short reg = chf.spans[i].reg;

	mov	rax, QWORD PTR [rbx+72]
	movzx	eax, WORD PTR [rax+rdi*8+2]
	mov	WORD PTR reg$1$[rsp], ax

; 919  : 				if (!reg || (reg & RC_BORDER_REG))

	test	ax, ax
	je	$LN20@rcBuildCon
	js	$LN20@rcBuildCon

; 920  : 					continue;
; 921  : 				const unsigned char area = chf.areas[i];

	mov	rax, QWORD PTR [rbx+88]
	movzx	eax, BYTE PTR [rdi+rax]
	mov	BYTE PTR area$1$[rsp], al

; 922  : 				
; 923  : 				verts.clear();

	mov	QWORD PTR verts$[rbp-256], r13

; 924  : 				simplified.clear();

	mov	QWORD PTR simplified$[rbp-256], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN214@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 5
	mov	rcx, r12
	call	QWORD PTR [rax+32]
$LN214@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 927  : 				walkContour(x, y, i, chf, flags, verts);

	lea	rax, QWORD PTR verts$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rsi
	mov	r9, rbx
	mov	r8d, DWORD PTR tv5106[rbp-256]
	mov	edx, DWORD PTR y$1$[rsp]
	mov	ecx, DWORD PTR x$1$[rsp]
	call	?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z ; walkContour
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN904@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 5
	mov	rcx, r12
	call	QWORD PTR [rax+40]

; 150  : 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN904@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 6
	mov	rcx, r12
	call	QWORD PTR [rax+32]
$LN904@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 931  : 				simplifyContour(verts, simplified, maxError, maxEdgeLen, buildFlags);

	mov	DWORD PTR [rsp+32], 1
	mov	r9d, DWORD PTR maxEdgeLen$GSCopy$1$[rsp]
	movaps	xmm2, xmm6
	lea	rdx, QWORD PTR simplified$[rbp-256]
	lea	rcx, QWORD PTR verts$[rbp-256]
	call	?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z ; simplifyContour

; 932  : 				removeDegenerateSegments(simplified);

	lea	rcx, QWORD PTR simplified$[rbp-256]
	call	?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z ; removeDegenerateSegments
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN899@rcBuildCon
	mov	rax, QWORD PTR [r12]
	mov	edx, 6
	mov	rcx, r12
	call	QWORD PTR [rax+40]
$LN899@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 938  : 				if (simplified.size()/4 >= 3)

	mov	r8, QWORD PTR simplified$[rbp-256]
	mov	eax, r8d
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	eax, 3
	jl	$LN20@rcBuildCon

; 939  : 				{
; 940  : 					if (cset.nconts >= maxContours)

	mov	rax, QWORD PTR tv5092[rbp-256]
	cmp	DWORD PTR [r14+8], eax
	jl	$LN62@rcBuildCon

; 941  : 					{
; 942  : 						// Allocate more contours.
; 943  : 						// This happens when a region has holes.
; 944  : 						const int oldMax = maxContours;

	mov	edi, eax

; 945  : 						maxContours *= 2;

	add	eax, eax
	mov	QWORD PTR tv5092[rbp-256], rax

; 946  : 						rcContour* newConts = (rcContour*)rcAlloc(sizeof(rcContour)*maxContours, RC_ALLOC_PERM);

	movsxd	rcx, eax
	shl	rcx, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 947  : 						for (int j = 0; j < cset.nconts; ++j)

	mov	r8d, r13d
	cmp	DWORD PTR [r14+8], r13d
	jle	SHORT $LN24@rcBuildCon

; 945  : 						maxContours *= 2;

	mov	rdx, r13
	npad	8
$LL25@rcBuildCon:

; 948  : 						{
; 949  : 							newConts[j] = cset.conts[j];

	mov	rcx, QWORD PTR [r14]
	movups	xmm0, XMMWORD PTR [rcx+rdx]
	movups	XMMWORD PTR [rdx+rbx], xmm0
	movups	xmm1, XMMWORD PTR [rcx+rdx+16]
	movups	XMMWORD PTR [rdx+rbx+16], xmm1

; 950  : 							// Reset source pointers to prevent data deletion.
; 951  : 							cset.conts[j].verts = 0;

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rdx+rax], r13

; 952  : 							cset.conts[j].rverts = 0;

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rax+rdx+16], r13

; 947  : 						for (int j = 0; j < cset.nconts; ++j)

	inc	r8d
	lea	rdx, QWORD PTR [rdx+32]
	cmp	r8d, DWORD PTR [r14+8]
	jl	SHORT $LL25@rcBuildCon
$LN24@rcBuildCon:

; 953  : 						}
; 954  : 						rcFree(cset.conts);

	mov	rcx, QWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN201@rcBuildCon

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN201@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 955  : 						cset.conts = newConts;

	mov	QWORD PTR [r14], rbx

; 956  : 						
; 957  : 						ctx->log(RC_LOG_WARNING, "rcBuildContours: Expanding max contours from %d to %d.", oldMax, maxContours);

	mov	rcx, QWORD PTR tv5092[rbp-256]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, edi
	lea	r8, OFFSET FLAT:??_C@_0DH@EDAAIGNC@rcBuildContours?3?5Expanding?5max?5@
	mov	edx, 2
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	mov	r8, QWORD PTR simplified$[rbp-256]
	mov	rdi, QWORD PTR $T1[rsp]
$LN62@rcBuildCon:

; 958  : 					}
; 959  : 					
; 960  : 					rcContour* cont = &cset.conts[cset.nconts++];

	movsxd	rcx, DWORD PTR [r14+8]
	mov	rbx, rcx
	shl	rbx, 5
	add	rbx, QWORD PTR [r14]
	inc	ecx
	mov	DWORD PTR [r14+8], ecx

; 961  : 					
; 962  : 					cont->nverts = simplified.size()/4;

	mov	eax, r8d
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR [rbx+8], eax

; 963  : 					cont->verts = (int*)rcAlloc(sizeof(int)*cont->nverts*4, RC_ALLOC_PERM);

	movsxd	rcx, eax
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 963  : 					cont->verts = (int*)rcAlloc(sizeof(int)*cont->nverts*4, RC_ALLOC_PERM);

	mov	QWORD PTR [rbx], rax

; 964  : 					if (!cont->verts)

	test	rax, rax
	je	$LN1333@rcBuildCon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN919@rcBuildCon
	cmp	QWORD PTR simplified$[rbp-256], 0
	jg	SHORT $LN919@rcBuildCon
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN919@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 969  : 					memcpy(cont->verts, &simplified[0], sizeof(int)*cont->nverts*4);

	movsxd	r8, DWORD PTR [rbx+8]
	shl	r8, 4
	mov	rdx, QWORD PTR simplified$[rbp-240]
	mov	rcx, QWORD PTR [rbx]
	call	memcpy

; 970  : 					if (borderSize > 0)

	test	r15d, r15d
	jle	SHORT $LN27@rcBuildCon

; 971  : 					{
; 972  : 						// If the heightfield was build with bordersize, remove the offset.
; 973  : 						for (int j = 0; j < cont->nverts; ++j)

	mov	edx, r13d
	cmp	DWORD PTR [rbx+8], edx
	jle	SHORT $LN27@rcBuildCon
	mov	rcx, r13
	npad	13
$LL28@rcBuildCon:

; 974  : 						{
; 975  : 							int* v = &cont->verts[j*4];

	mov	rax, QWORD PTR [rbx]

; 976  : 							v[0] -= borderSize;

	sub	DWORD PTR [rcx+rax], r15d

; 977  : 							v[2] -= borderSize;

	sub	DWORD PTR [rcx+rax+8], r15d

; 971  : 					{
; 972  : 						// If the heightfield was build with bordersize, remove the offset.
; 973  : 						for (int j = 0; j < cont->nverts; ++j)

	inc	edx
	lea	rcx, QWORD PTR [rcx+16]
	cmp	edx, DWORD PTR [rbx+8]
	jl	SHORT $LL28@rcBuildCon
$LN27@rcBuildCon:

; 978  : 						}
; 979  : 					}
; 980  : 					
; 981  : 					cont->nrverts = verts.size()/4;

	mov	eax, DWORD PTR verts$[rbp-256]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR [rbx+24], eax

; 982  : 					cont->rverts = (int*)rcAlloc(sizeof(int)*cont->nrverts*4, RC_ALLOC_PERM);

	movsxd	rcx, eax
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 982  : 					cont->rverts = (int*)rcAlloc(sizeof(int)*cont->nrverts*4, RC_ALLOC_PERM);

	mov	QWORD PTR [rbx+16], rax

; 983  : 					if (!cont->rverts)

	test	rax, rax
	je	$LN1334@rcBuildCon
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN210@rcBuildCon
	cmp	QWORD PTR verts$[rbp-256], 0
	jg	SHORT $LN210@rcBuildCon
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN210@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 988  : 					memcpy(cont->rverts, &verts[0], sizeof(int)*cont->nrverts*4);

	movsxd	r8, DWORD PTR [rbx+24]
	shl	r8, 4
	mov	rdx, QWORD PTR verts$[rbp-240]
	mov	rcx, QWORD PTR [rbx+16]
	call	memcpy

; 989  : 					if (borderSize > 0)

	test	r15d, r15d
	jle	SHORT $LN30@rcBuildCon

; 990  : 					{
; 991  : 						// If the heightfield was build with bordersize, remove the offset.
; 992  : 						for (int j = 0; j < cont->nrverts; ++j)

	mov	edx, r13d
	cmp	DWORD PTR [rbx+24], edx
	jle	SHORT $LN30@rcBuildCon
	mov	rcx, r13
	npad	2
$LL31@rcBuildCon:

; 993  : 						{
; 994  : 							int* v = &cont->rverts[j*4];

	mov	rax, QWORD PTR [rbx+16]

; 995  : 							v[0] -= borderSize;

	sub	DWORD PTR [rcx+rax], r15d

; 996  : 							v[2] -= borderSize;

	sub	DWORD PTR [rcx+rax+8], r15d

; 990  : 					{
; 991  : 						// If the heightfield was build with bordersize, remove the offset.
; 992  : 						for (int j = 0; j < cont->nrverts; ++j)

	inc	edx
	lea	rcx, QWORD PTR [rcx+16]
	cmp	edx, DWORD PTR [rbx+24]
	jl	SHORT $LL31@rcBuildCon
$LN30@rcBuildCon:

; 997  : 						}
; 998  : 					}
; 999  : 					
; 1000 : 					cont->reg = reg;

	movzx	eax, WORD PTR reg$1$[rsp]
	mov	WORD PTR [rbx+28], ax

; 1001 : 					cont->area = area;

	movzx	eax, BYTE PTR area$1$[rsp]
	mov	BYTE PTR [rbx+30], al

; 1002 : 				}
; 1003 : 			}

	mov	rbx, QWORD PTR chf$GSCopy$1$[rbp-256]
	jmp	SHORT $LN20@rcBuildCon
$LN58@rcBuildCon:

; 914  : 				{
; 915  : 					flags[i] = 0;

	mov	BYTE PTR [rdi+rsi], 0
$LN20@rcBuildCon:

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	inc	DWORD PTR tv5106[rbp-256]
	inc	rdi
	mov	QWORD PTR $T1[rsp], rdi
	cmp	rdi, QWORD PTR tv5105[rsp]
	jl	$LL22@rcBuildCon
	mov	r8d, DWORD PTR x$1$[rsp]
	mov	r10d, DWORD PTR tv5088[rsp]
$LN17@rcBuildCon:

; 907  : 	{
; 908  : 		for (int x = 0; x < w; ++x)

	inc	r8d
	mov	DWORD PTR x$1$[rsp], r8d
	mov	edi, DWORD PTR w$1$[rsp]
	cmp	r8d, edi
	jl	$LL19@rcBuildCon
	mov	r9d, DWORD PTR y$1$[rsp]
	mov	eax, DWORD PTR h$1$[rsp]
$LN14@rcBuildCon:

; 905  : 	
; 906  : 	for (int y = 0; y < h; ++y)

	inc	r9d
	mov	DWORD PTR y$1$[rsp], r9d
	add	r10d, edi
	mov	DWORD PTR tv5088[rsp], r10d
	cmp	r9d, eax
	jl	$LL16@rcBuildCon
$LN1409@rcBuildCon:

; 1004 : 		}
; 1005 : 	}
; 1006 : 	
; 1007 : 	// Merge holes if needed.
; 1008 : 	if (cset.nconts > 0)

	movsxd	rax, DWORD PTR [r14+8]
	test	eax, eax
	jle	$LN145@rcBuildCon

; 1011 : 		rcScopedDelete<signed char> winding((signed char*)rcAlloc(sizeof(signed char)*cset.nconts, RC_ALLOC_TEMP));

	mov	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	QWORD PTR winding$4[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1011 : 		rcScopedDelete<signed char> winding((signed char*)rcAlloc(sizeof(signed char)*cset.nconts, RC_ALLOC_TEMP));

	mov	eax, DWORD PTR [r14+8]

; 1012 : 		if (!winding)

	test	rdi, rdi
	jne	SHORT $LN68@rcBuildCon

; 1013 : 		{
; 1014 : 			ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'hole' (%d).", cset.nconts);

	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_0CM@MFPKMJMI@rcBuildContours?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rdi+3]
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	jmp	$LN953@rcBuildCon
$LN1334@rcBuildCon:

; 984  : 					{
; 985  : 						ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'rverts' (%d).", cont->nrverts);
; 986  : 						return false;

	lea	r8, OFFSET FLAT:??_C@_0CO@JLFENFEL@rcBuildContours?3?5Out?5of?5memory?5@
	mov	r9d, DWORD PTR [rbx+24]
	mov	edx, 3
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	$LN95@rcBuildCon
$LN1333@rcBuildCon:

; 965  : 					{
; 966  : 						ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'verts' (%d).", cont->nverts);

	lea	r8, OFFSET FLAT:??_C@_0CN@KNOPFNDB@rcBuildContours?3?5Out?5of?5memory?5@
	mov	r9d, DWORD PTR [rbx+8]
	mov	edx, 3
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	bl, bl
	jmp	$LN95@rcBuildCon
$LN68@rcBuildCon:

; 1015 : 			return false;
; 1016 : 		}
; 1017 : 		int nholes = 0;

	mov	r14d, r13d

; 1018 : 		for (int i = 0; i < cset.nconts; ++i)

	mov	r15d, r13d
	test	eax, eax
	jle	$LN155@rcBuildCon

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r12, rdi
	mov	rbx, r13
	mov	rsi, QWORD PTR cset$GSCopy$1$[rsp]
$LL34@rcBuildCon:

; 1019 : 		{
; 1020 : 			rcContour& cont = cset.conts[i];

	mov	rax, QWORD PTR [rsi]

; 1021 : 			// If the contour is wound backwards, it is a hole.
; 1022 : 			winding[i] = calcAreaOfPolygon2D(cont.verts, cont.nverts) < 0 ? -1 : 1;

	movsxd	rcx, DWORD PTR [rbx+rax+8]
	mov	r9, QWORD PTR [rbx+rax]

; 455  : 	int area = 0;

	mov	r11d, r13d

; 456  : 	for (int i = 0, j = nverts-1; i < nverts; j=i++)

	lea	eax, DWORD PTR [rcx-1]
	mov	r10, rcx
	test	ecx, ecx
	jle	SHORT $LN911@rcBuildCon
	movsxd	rdx, eax
	shl	rdx, 4
	mov	r8, r9
$LL912@rcBuildCon:

; 457  : 	{
; 458  : 		const int* vi = &verts[i*4];
; 459  : 		const int* vj = &verts[j*4];
; 460  : 		area += vi[0] * vj[2] - vj[0] * vi[2];

	mov	ecx, DWORD PTR [r9+rdx+8]
	imul	ecx, DWORD PTR [r8]
	mov	eax, DWORD PTR [r8+8]
	imul	eax, DWORD PTR [r9+rdx]
	sub	ecx, eax
	add	r11d, ecx

; 456  : 	for (int i = 0, j = nverts-1; i < nverts; j=i++)

	mov	rdx, r8
	sub	rdx, r9
	add	r8, 16
	sub	r10, 1
	jne	SHORT $LL912@rcBuildCon
$LN911@rcBuildCon:

; 461  : 	}
; 462  : 	return (area+1) / 2;

	lea	eax, DWORD PTR [r11+1]
	cdq
	sub	eax, edx
	sar	eax, 1

; 1021 : 			// If the contour is wound backwards, it is a hole.
; 1022 : 			winding[i] = calcAreaOfPolygon2D(cont.verts, cont.nverts) < 0 ? -1 : 1;

	mov	ecx, 1
	mov	edx, -1					; ffffffffH
	cmovs	ecx, edx
	mov	BYTE PTR [r12], cl

; 1018 : 		for (int i = 0; i < cset.nconts; ++i)

	lea	ecx, DWORD PTR [r14+1]
	test	eax, eax
	cmovns	ecx, r14d
	mov	r14d, ecx
	inc	r15d
	add	rbx, 32					; 00000020H
	inc	r12
	cmp	r15d, DWORD PTR [rsi+8]
	jl	$LL34@rcBuildCon

; 1023 : 			if (winding[i] < 0)
; 1024 : 				nholes++;
; 1025 : 		}
; 1026 : 		
; 1027 : 		if (nholes > 0)

	test	ecx, ecx
	mov	rsi, QWORD PTR flags$1$[rsp]
	jle	$LN1411@rcBuildCon

; 1028 : 		{
; 1029 : 			// Collect outline contour and holes contours per region.
; 1030 : 			// We assume that there is one outline and multiple holes.
; 1031 : 			const int nregions = chf.maxRegions+1;

	mov	rax, QWORD PTR chf$GSCopy$1$[rbp-256]
	movzx	r15d, WORD PTR [rax+26]
	inc	r15d
	mov	DWORD PTR nregions$1$[rsp], r15d

; 1032 : 			rcScopedDelete<rcContourRegion> regions((rcContourRegion*)rcAlloc(sizeof(rcContourRegion)*nregions, RC_ALLOC_TEMP));

	mov	r13d, r15d
	mov	QWORD PTR tv5173[rsp], r13
	lea	rbx, QWORD PTR [r15*2]
	add	rbx, r13
	shl	rbx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR regions$3[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1033 : 			if (!regions)

	test	rax, rax
	jne	SHORT $LN71@rcBuildCon

; 1034 : 			{
; 1035 : 				ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'regions' (%d).", nregions);

	mov	r9d, r15d
	lea	r8, OFFSET FLAT:??_C@_0CP@BBLIMKHO@rcBuildContours?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rax+3]
	mov	r12, QWORD PTR timer$2$[rsp]
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	jmp	SHORT $LN1003@rcBuildCon
$LN71@rcBuildCon:

; 1036 : 				return false;
; 1037 : 			}
; 1038 : 			memset(regions, 0, sizeof(rcContourRegion)*nregions);

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, r14
	call	memset

; 1040 : 			rcScopedDelete<rcContourHole> holes((rcContourHole*)rcAlloc(sizeof(rcContourHole)*cset.nconts, RC_ALLOC_TEMP));

	mov	r12, QWORD PTR cset$GSCopy$1$[rsp]
	movsxd	rax, DWORD PTR [r12+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR holes$2[rbp-256], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1040 : 			rcScopedDelete<rcContourHole> holes((rcContourHole*)rcAlloc(sizeof(rcContourHole)*cset.nconts, RC_ALLOC_TEMP));

	movsxd	rax, DWORD PTR [r12+8]

; 1041 : 			if (!holes)

	test	rbx, rbx
	jne	SHORT $LN72@rcBuildCon

; 1042 : 			{
; 1043 : 				ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'holes' (%d).", cset.nconts);

	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_0CN@DNNFBKCB@rcBuildContours?3?5Out?5of?5memory?5@
	lea	edx, QWORD PTR [rbx+3]
	mov	r12, QWORD PTR timer$2$[rsp]
	mov	rcx, r12
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	npad	1
$LN1003@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	r14, r14
	je	SHORT $LN958@rcBuildCon

; 28   : 	free(ptr);

	mov	rcx, r14
	call	QWORD PTR __imp_free
	npad	1
$LN958@rcBuildCon:
$LN953@rcBuildCon:

; 47   : 	if (ptr != NULL)

	test	rdi, rdi
	je	SHORT $LN928@rcBuildCon

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN928@rcBuildCon:
	xor	bl, bl
	jmp	$LN95@rcBuildCon
$LN72@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1046 : 			memset(holes, 0, sizeof(rcContourHole)*cset.nconts);

	lea	r8, QWORD PTR [rax+rax*2]
	shl	r8, 3
	xor	edx, edx
	mov	rcx, rbx
	call	memset

; 1047 : 			
; 1048 : 			for (int i = 0; i < cset.nconts; ++i)

	xor	r11d, r11d
	mov	r12d, r11d
	mov	r8, QWORD PTR cset$GSCopy$1$[rsp]
	cmp	DWORD PTR [r8+8], r11d
	jle	$LN36@rcBuildCon

; 1058 : 				else
; 1059 : 				{
; 1060 : 					regions[cont.reg].nholes++;

	mov	r13, rdi
	mov	edx, r11d
	mov	QWORD PTR tv5080[rsp], rdx
	mov	rsi, QWORD PTR timer$2$[rsp]
	npad	8
$LL37@rcBuildCon:

; 1049 : 			{
; 1050 : 				rcContour& cont = cset.conts[i];

	mov	r15, QWORD PTR [r8]
	add	r15, rdx

; 1051 : 				// Positively would contours are outlines, negative holes.
; 1052 : 				if (winding[i] > 0)

	movzx	ecx, WORD PTR [r15+28]
	lea	rax, QWORD PTR [rcx+rcx*2]
	cmp	BYTE PTR [r13], 0
	jle	SHORT $LN73@rcBuildCon

; 1053 : 				{
; 1054 : 					if (regions[cont.reg].outline)

	cmp	QWORD PTR [r14+rax*8], 0
	je	SHORT $LN75@rcBuildCon

; 1055 : 						ctx->log(RC_LOG_ERROR, "rcBuildContours: Multiple outlines for region %d.", cont.reg);

	mov	r9d, ecx
	lea	r8, OFFSET FLAT:??_C@_0DC@MJMGNADI@rcBuildContours?3?5Multiple?5outli@
	mov	edx, 3
	mov	rcx, rsi
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	mov	rdx, QWORD PTR tv5080[rsp]
	mov	r8, QWORD PTR cset$GSCopy$1$[rsp]
$LN75@rcBuildCon:

; 1056 : 					regions[cont.reg].outline = &cont;

	movzx	eax, WORD PTR [r15+28]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR [r14+rcx*8], r15

; 1057 : 				}

	jmp	SHORT $LN35@rcBuildCon
$LN73@rcBuildCon:

; 1058 : 				else
; 1059 : 				{
; 1060 : 					regions[cont.reg].nholes++;

	inc	DWORD PTR [r14+rax*8+16]
$LN35@rcBuildCon:

; 1047 : 			
; 1048 : 			for (int i = 0; i < cset.nconts; ++i)

	inc	r12d
	add	rdx, 32					; 00000020H
	mov	QWORD PTR tv5080[rsp], rdx
	inc	r13
	cmp	r12d, DWORD PTR [r8+8]
	jl	SHORT $LL37@rcBuildCon
	mov	rsi, QWORD PTR flags$1$[rsp]
	mov	r13, QWORD PTR tv5173[rsp]
	mov	r15d, DWORD PTR nregions$1$[rsp]
	xor	r11d, r11d
$LN36@rcBuildCon:

; 1061 : 				}
; 1062 : 			}
; 1063 : 			int index = 0;

	mov	r9d, r11d

; 1064 : 			for (int i = 0; i < nregions; i++)

	test	r15d, r15d
	je	SHORT $LN39@rcBuildCon

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r8, r11
	lea	rdx, QWORD PTR [r14+16]
$LL1351@rcBuildCon:

; 1065 : 			{
; 1066 : 				if (regions[i].nholes > 0)

	mov	r10d, DWORD PTR [rdx]
	test	r10d, r10d
	jle	SHORT $LN1352@rcBuildCon

; 1067 : 				{
; 1068 : 					regions[i].holes = &holes[index];

	movsxd	rax, r9d
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rbx+rcx*8]
	mov	QWORD PTR [rdx-8], rax

; 1069 : 					index += regions[i].nholes;

	add	r9d, r10d

; 1070 : 					regions[i].nholes = 0;

	mov	DWORD PTR [rdx], r11d
$LN1352@rcBuildCon:

; 1064 : 			for (int i = 0; i < nregions; i++)

	inc	r8
	add	rdx, 24
	cmp	r8, r13
	jl	SHORT $LL1351@rcBuildCon
$LN39@rcBuildCon:

; 1071 : 				}
; 1072 : 			}
; 1073 : 			for (int i = 0; i < cset.nconts; ++i)

	mov	r8d, r11d
	mov	r12, QWORD PTR cset$GSCopy$1$[rsp]
	cmp	DWORD PTR [r12+8], 0
	jle	SHORT $LN42@rcBuildCon

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r9, rdi
	mov	r10, r11
	npad	9
$LL43@rcBuildCon:

; 1074 : 			{
; 1075 : 				rcContour& cont = cset.conts[i];

	mov	r11, QWORD PTR [r12]
	add	r11, r10

; 1076 : 				rcContourRegion& reg = regions[cont.reg];

	movzx	eax, WORD PTR [r11+28]
	lea	rdx, QWORD PTR [rax+rax*2]

; 1077 : 				if (winding[i] < 0)

	cmp	BYTE PTR [r9], 0
	jge	SHORT $LN41@rcBuildCon

; 1078 : 					reg.holes[reg.nholes++].contour = &cont;

	movsxd	rax, DWORD PTR [r14+rdx*8+16]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r14+rdx*8+8]
	mov	QWORD PTR [rax+rcx*8], r11
	inc	DWORD PTR [r14+rdx*8+16]
$LN41@rcBuildCon:

; 1071 : 				}
; 1072 : 			}
; 1073 : 			for (int i = 0; i < cset.nconts; ++i)

	inc	r8d
	add	r10, 32					; 00000020H
	inc	r9
	cmp	r8d, DWORD PTR [r12+8]
	jl	SHORT $LL43@rcBuildCon
	xor	r11d, r11d
$LN42@rcBuildCon:

; 1079 : 			}
; 1080 : 			
; 1081 : 			// Finally merge each regions holes into the outline.
; 1082 : 			for (int i = 0; i < nregions; i++)

	test	r15d, r15d
	je	SHORT $LN45@rcBuildCon

; 911  : 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)

	mov	r12, r11
	mov	r15, r14
	mov	rsi, QWORD PTR timer$2$[rsp]
$LL46@rcBuildCon:

; 1083 : 			{
; 1084 : 				rcContourRegion& reg = regions[i];
; 1085 : 				if (!reg.nholes) continue;

	cmp	DWORD PTR [r15+16], 0
	je	SHORT $LN44@rcBuildCon

; 1086 : 				
; 1087 : 				if (reg.outline)

	mov	rcx, rsi
	cmp	QWORD PTR [r15], 0
	je	SHORT $LN79@rcBuildCon

; 1088 : 				{
; 1089 : 					mergeRegionHoles(ctx, reg);

	mov	rdx, r15
	call	?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z ; mergeRegionHoles

; 1090 : 				}

	jmp	SHORT $LN1413@rcBuildCon
$LN79@rcBuildCon:

; 1091 : 				else
; 1092 : 				{
; 1093 : 					// The region does not have an outline.
; 1094 : 					// This can happen if the contour becaomes selfoverlapping because of
; 1095 : 					// too aggressive simplification settings.
; 1096 : 					ctx->log(RC_LOG_ERROR, "rcBuildContours: Bad outline for region %d, contour simplification is likely too aggressive.", i);

	mov	r9d, r11d
	lea	r8, OFFSET FLAT:??_C@_0FN@FGHNLJHD@rcBuildContours?3?5Bad?5outline?5fo@
	mov	edx, 3
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
$LN1413@rcBuildCon:

; 1079 : 			}
; 1080 : 			
; 1081 : 			// Finally merge each regions holes into the outline.
; 1082 : 			for (int i = 0; i < nregions; i++)

	mov	r11, QWORD PTR tv5252[rsp]
$LN44@rcBuildCon:
	inc	r11d
	mov	QWORD PTR tv5252[rsp], r11
	inc	r12
	add	r15, 24
	cmp	r12, r13
	jl	SHORT $LL46@rcBuildCon
	mov	rsi, QWORD PTR flags$1$[rsp]
$LN45@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
	mov	rcx, r14
	call	QWORD PTR __imp_free
	npad	1
$LN1411@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1101 : 	}

	mov	r12, QWORD PTR timer$2$[rsp]
$LN155@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 28   : 	free(ptr);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
	npad	1
$LN145@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1103 : 	return true;

	mov	bl, 1
$LN95@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR simplified$[rbp-240]
	test	rcx, rcx
	je	SHORT $LN140@rcBuildCon

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN140@rcBuildCon:

; 47   : 	if (ptr != NULL)

	mov	rcx, QWORD PTR verts$[rbp-240]
	test	rcx, rcx
	je	SHORT $LN124@rcBuildCon

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN124@rcBuildCon:
$LN119@rcBuildCon:

; 47   : 	if (ptr != NULL)

	test	rsi, rsi
	je	SHORT $LN108@rcBuildCon

; 28   : 	free(ptr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
	npad	1
$LN108@rcBuildCon:
$LN103@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 154  : 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }

	cmp	BYTE PTR [r12+9], 0
	je	SHORT $LN1410@rcBuildCon
	mov	r8, QWORD PTR [r12]
	mov	edx, 4
	mov	rcx, r12
	call	QWORD PTR [r8+40]
	npad	1
$LN1410@rcBuildCon:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 1104 : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+240]
	add	rsp, 264				; 00000108H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z ENDP ; rcBuildContours
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$0@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$0
	lea	rcx, QWORD PTR timer$[rdx]
	jmp	??1rcScopedTimer@@QEAA@XZ		; rcScopedTimer::~rcScopedTimer
?dtor$0@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$1@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$1
	lea	rcx, QWORD PTR flags$[rdx]
	jmp	??1?$rcScopedDelete@E@@QEAA@XZ		; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>
?dtor$1@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$2@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$2
	lea	rcx, QWORD PTR verts$[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$2@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$3@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$3
	lea	rcx, QWORD PTR simplified$[rdx]
	jmp	??1rcIntArray@@QEAA@XZ
?dtor$3@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$4@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$4
	lea	rcx, QWORD PTR winding$4[rdx]
	jmp	??1?$rcScopedDelete@C@@QEAA@XZ		; rcScopedDelete<signed char>::~rcScopedDelete<signed char>
?dtor$4@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$5@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$5
	lea	rcx, QWORD PTR regions$3[rdx]
	jmp	??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ ; rcScopedDelete<rcContourRegion>::~rcScopedDelete<rcContourRegion>
?dtor$5@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
area$1$ = 48
w$1$ = 52
h$1$ = 56
tv5088 = 60
borderSize$1$ = 60
reg$1$ = 64
x$1$ = 68
y$1$ = 72
maxEdgeLen$GSCopy$1$ = 76
nregions$1$ = 76
timer$2$ = 80
tv5109 = 88
tv5080 = 88
$T1 = 88
cset$GSCopy$1$ = 96
tv5252 = 104
flags$1$ = 112
tv5173 = 120
tv5105 = 120
timer$ = 128
chf$GSCopy$1$ = 144
holes$2 = 144
tv5092 = 152
regions$3 = 152
tv5106 = 160
winding$4 = 160
simplified$ = 168
verts$ = 192
flags$ = 216
__$ArrayPad$ = 224
ctx$ = 336
chf$ = 344
maxError$ = 352
maxEdgeLen$ = 360
cset$ = 368
buildFlags$dead$ = 376
?dtor$6@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA PROC ; `rcBuildContours'::`1'::dtor$6
	lea	rcx, QWORD PTR holes$2[rdx]
	jmp	??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ ; rcScopedDelete<rcContourHole>::~rcScopedDelete<rcContourHole>
?dtor$6@?0??rcBuildContours@@YA_NPEAVrcContext@@AEBUrcCompactHeightfield@@MHAEAUrcContourSet@@H@Z@4HA ENDP ; `rcBuildContours'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0rcIntArray@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 48
n$ = 56
??0rcIntArray@@QEAA@H@Z PROC				; rcIntArray::rcIntArray, COMDAT

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

$LN102:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	xor	ebp, ebp

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

	movsxd	rdi, edx

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	mov	QWORD PTR [rcx], rbp

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

	mov	rbx, rcx

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	mov	QWORD PTR [rcx+8], rbp
	mov	QWORD PTR [rcx+16], rbp

; 232  : 	if (size < m_size) {

	test	edx, edx
	jns	SHORT $LN99@rcIntArray

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;

	mov	QWORD PTR [rcx], rdi

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

	mov	rax, rcx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN99@rcIntArray:

; 235  : 	} else if (size > m_size) {

	jle	$LN88@rcIntArray

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA

; 235  : 	} else if (size > m_size) {

	mov	QWORD PTR [rsp+48], rsi

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	rax, rax
	je	SHORT $LN42@rcIntArray
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN42@rcIntArray
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN42@rcIntArray:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN53@rcIntArray

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN53@rcIntArray

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL54@rcIntArray:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN52@rcIntArray
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN52@rcIntArray:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL54@rcIntArray
$LN53@rcIntArray:

; 249  : 				construct_range(new_data + m_size, new_data + size, *value);

	mov	rax, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [rsi+rdi*4]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 286  : 	for (T* p = begin; p < end; p++) {

	cmp	rcx, rdx
	jae	SHORT $LN62@rcIntArray
$LL63@rcIntArray:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN61@rcIntArray
	mov	DWORD PTR [rcx], ebp
$LN61@rcIntArray:

; 286  : 	for (T* p = begin; p < end; p++) {

	add	rcx, 4
	cmp	rcx, rdx
	jb	SHORT $LL63@rcIntArray
$LN62@rcIntArray:

; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN72@rcIntArray

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN72@rcIntArray:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 255  : 			m_data = new_data;

	mov	QWORD PTR [rbx+16], rsi

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

	mov	rsi, QWORD PTR [rsp+48]

; 256  : 			m_cap = new_cap;

	mov	QWORD PTR [rbx+8], rdi

; 257  : 			m_size = size;

	mov	QWORD PTR [rbx], rdi
$LN88@rcIntArray:

; 332  : 	rcIntArray(int n) : m_impl(n, 0) {}

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0rcIntArray@@QEAA@H@Z ENDP				; rcIntArray::rcIntArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?push@rcIntArray@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
item$ = 56
?push@rcIntArray@@QEAAXH@Z PROC				; rcIntArray::push, COMDAT

; 333  : 	void push(int item) { m_impl.push_back(item); }

$LN65:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	sub	rsp, 32					; 00000020H

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	r8, QWORD PTR [rcx]

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	ebp, edx

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rax, QWORD PTR [rcx+8]

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	rbx, rcx

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	r8, rax
	jge	SHORT $LN4@push

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [rax+r8*4]
	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	$LN3@push
	mov	DWORD PTR [rcx], edx

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
$LN4@push:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+64], rdi

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN14@push

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN16@push
$LN14@push:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN16@push:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN21@push
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN21@push
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN21@push:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN32@push

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN32@push

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	4
$LL33@push:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN31@push
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN31@push:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL33@push
$LN32@push:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN41@push
	mov	DWORD PTR [rcx], ebp
$LN41@push:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
	mov	rdi, QWORD PTR [rsp+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN46@push

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN46@push:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
	mov	rsi, QWORD PTR [rsp+56]
$LN3@push:

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?push@rcIntArray@@QEAAXH@Z ENDP				; rcIntArray::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?resize@rcIntArray@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
?resize@rcIntArray@@QEAAXH@Z PROC			; rcIntArray::resize, COMDAT

; 334  : 	void resize(int size) { m_impl.resize(size); }

$LN57:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	movsxd	rdi, edx
	mov	rbx, rcx

; 232  : 	if (size < m_size) {

	cmp	rdi, QWORD PTR [rcx]
	jl	SHORT $LN49@resize

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN10@resize

; 236  : 		if (size <= m_cap) {

	mov	rsi, QWORD PTR [rcx+8]
	cmp	rdi, rsi
	jle	SHORT $LN49@resize

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 236  : 		if (size <= m_cap) {

	mov	QWORD PTR [rsp+48], rbp

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rsi, rax
	jl	SHORT $LN29@resize

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN25@resize
$LN29@resize:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rsi, rsi
	cmp	rsi, rdi
	cmovle	rsi, rdi
$LN25@resize:

; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rsi
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {
; 249  : 				construct_range(new_data + m_size, new_data + size, *value);
; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN45@resize

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN45@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 255  : 			m_data = new_data;

	mov	QWORD PTR [rbx+16], rbp

; 256  : 			m_cap = new_cap;
; 257  : 			m_size = size;

	mov	rbp, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbx+8], rsi
	mov	QWORD PTR [rbx], rdi

; 334  : 	void resize(int size) { m_impl.resize(size); }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN49@resize:

; 242  : 			m_size = size;

	mov	QWORD PTR [rcx], rdi
$LN10@resize:

; 334  : 	void resize(int size) { m_impl.resize(size); }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@rcIntArray@@QEAAXH@Z ENDP			; rcIntArray::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?clear@rcIntArray@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@rcIntArray@@QEAAXXZ PROC				; rcIntArray::clear, COMDAT

; 335  : 	void clear() { m_impl.clear(); }

	mov	QWORD PTR [rcx], 0
	ret	0
?clear@rcIntArray@@QEAAXXZ ENDP				; rcIntArray::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?size@rcIntArray@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size@rcIntArray@@QEBAHXZ PROC				; rcIntArray::size, COMDAT

; 342  : 	int size() const { return static_cast<int>(m_impl.size()); }

	mov	eax, DWORD PTR [rcx]
	ret	0
?size@rcIntArray@@QEBAHXZ ENDP				; rcIntArray::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??ArcIntArray@@QEAAAEAHH@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
??ArcIntArray@@QEAAAEAHH@Z PROC				; rcIntArray::operator[], COMDAT

; 343  : 	int& operator[](int index) { return m_impl[index]; }

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	rdi, rcx
	movsxd	rbx, edx

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	rax, rax
	je	SHORT $LN6@operator
	test	edx, edx
	js	SHORT $LN7@operator
	cmp	rbx, QWORD PTR [rcx]
	jl	SHORT $LN6@operator
$LN7@operator:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN6@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rax+rbx*4]

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??ArcIntArray@@QEAAAEAHH@Z ENDP				; rcIntArray::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1?$rcTempVector@H@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$rcTempVector@H@@QEAA@XZ PROC			; rcTempVector<int>::~rcTempVector<int>, COMDAT
$LN16:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN13@rcTempVect

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN13@rcTempVect:
	add	rsp, 40					; 00000028H
	ret	0
??1?$rcTempVector@H@@QEAA@XZ ENDP			; rcTempVector<int>::~rcTempVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z
_TEXT	SEGMENT
regs$ = 0
x$ = 64
y$ = 72
ay$1$ = 80
i$ = 80
dir$ = 88
chf$ = 96
isBorderVertex$ = 104
?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z PROC ; getCornerHeight, COMDAT

; 31   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 16

; 32   : 	const rcCompactSpan& s = chf.spans[i];

	mov	rsi, QWORD PTR chf$[rsp]

; 34   : 	int dirp = (dir+1) & 0x3;

	lea	r10d, DWORD PTR [r9+1]
	mov	r12d, ecx
	movsxd	rax, r8d

; 36   : 	unsigned int regs[4] = {0,0,0,0};

	xor	ecx, ecx

; 42   : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	lea	r13, OFFSET FLAT:__ImageBase
	mov	QWORD PTR regs$[rsp+4], rcx
	mov	r11d, r9d
	mov	rbx, QWORD PTR [rsi+72]
	mov	r15d, edx
	mov	rdi, QWORD PTR [rsi+88]
	lea	r8, QWORD PTR [rbx+rax*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r9d, DWORD PTR [r8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 34   : 	int dirp = (dir+1) & 0x3;

	and	r10d, 3
	movzx	r14d, WORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ebp, DWORD PTR [r11+r11*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 36   : 	unsigned int regs[4] = {0,0,0,0};

	mov	DWORD PTR regs$[rsp+12], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r9d, 16777215				; 00ffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 40   : 	regs[0] = chf.spans[i].reg | (chf.areas[i] << 16);

	movzx	ecx, BYTE PTR [rdi+rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	add	ebp, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 40   : 	regs[0] = chf.spans[i].reg | (chf.areas[i] << 16);

	movzx	eax, WORD PTR [r8+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 40   : 	regs[0] = chf.spans[i].reg | (chf.areas[i] << 16);

	shl	ecx, 16
	or	ecx, eax
	mov	DWORD PTR regs$[rsp], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	ecx, ebp
	shr	edx, cl
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 42   : 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	$LN6@getCornerH

; 46   : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	mov	r8, QWORD PTR [rsi+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	mov	eax, r11d
	and	eax, 3
	lea	rcx, QWORD PTR [rax*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 44   : 		const int ax = x + rcGetDirOffsetX(dir);

	mov	r13d, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+r13]

; 45   : 		const int ay = y + rcGetDirOffsetY(dir);

	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+rax]
	add	r13d, r12d

; 46   : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dir);

	mov	eax, DWORD PTR [rsi]
	add	ecx, r15d
	imul	eax, ecx
	mov	DWORD PTR ay$1$[rsp], ecx
	add	eax, r13d
	cdqe
	mov	ecx, DWORD PTR [r8+rax*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, edx

; 47   : 		const rcCompactSpan& as = chf.spans[ai];

	mov	edx, ecx

; 48   : 		ch = rcMax(ch, (int)as.y);

	movzx	eax, WORD PTR [rbx+rcx*8]

; 49   : 		regs[1] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	movzx	ecx, BYTE PTR [rdi+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	r14d, eax

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [rbx+rdx*8+4]

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmova	eax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 49   : 		regs[1] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	shl	ecx, 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	and	r8d, 16777215				; 00ffffffH

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 49   : 		regs[1] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	movzx	eax, WORD PTR [rbx+rdx*8+2]
	or	ecx, eax
	mov	DWORD PTR regs$[rsp+4], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [r10+r10*2]
	add	ecx, ecx

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r8d, cl
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 50   : 		if (rcGetCon(as, dirp) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN73@getCornerH

; 51   : 		{
; 52   : 			const int ax2 = ax + rcGetDirOffsetX(dirp);
; 53   : 			const int ay2 = ay + rcGetDirOffsetY(dirp);
; 54   : 			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dirp);

	mov	rcx, QWORD PTR [rsi+64]
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rdx+r10*4]
	add	eax, DWORD PTR ay$1$[rsp]
	imul	eax, DWORD PTR [rsi]
	add	eax, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rdx+r10*4]
	add	eax, r13d
	cdqe
	mov	ecx, DWORD PTR [rcx+rax*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r8d

; 55   : 			const rcCompactSpan& as2 = chf.spans[ai2];

	mov	edx, ecx

; 56   : 			ch = rcMax(ch, (int)as2.y);

	movzx	eax, WORD PTR [rbx+rcx*8]

; 57   : 			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);

	movzx	ecx, BYTE PTR [rdi+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	r14d, eax
	cmova	eax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 57   : 			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);

	shl	ecx, 16
	mov	r14d, eax
	movzx	eax, WORD PTR [rbx+rdx*8+2]
	or	ecx, eax
	mov	DWORD PTR regs$[rsp+8], ecx
$LN73@getCornerH:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	r13, OFFSET FLAT:__ImageBase
$LN6@getCornerH:
	lea	ecx, DWORD PTR [r10+r10*2]
	add	ecx, ecx

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	r9d, cl
	and	r9d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 60   : 	if (rcGetCon(s, dirp) != RC_NOT_CONNECTED)

	cmp	r9d, 63					; 0000003fH
	je	$LN8@getCornerH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	lea	rcx, QWORD PTR [r10*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 63   : 		const int ay = y + rcGetDirOffsetY(dirp);

	add	r15d, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+r13]
	mov	r10d, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+r13]
	add	r10d, r12d

; 64   : 		const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(s, dirp);

	mov	r12d, DWORD PTR [rsi]
	mov	rsi, QWORD PTR [rsi+64]
	mov	eax, r12d
	imul	eax, r15d
	add	eax, r10d
	cdqe
	mov	ecx, DWORD PTR [rsi+rax*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, r9d

; 65   : 		const rcCompactSpan& as = chf.spans[ai];
; 66   : 		ch = rcMax(ch, (int)as.y);

	movzx	eax, WORD PTR [rbx+rcx*8]
	lea	r8, QWORD PTR [rbx+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 67   : 		regs[3] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	movzx	edx, BYTE PTR [rdi+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmova	eax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 67   : 		regs[3] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	shl	edx, 16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	mov	r14d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 67   : 		regs[3] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	movzx	eax, WORD PTR [r8+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	ecx, ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 67   : 		regs[3] = chf.spans[ai].reg | (chf.areas[ai] << 16);

	or	edx, eax
	mov	DWORD PTR regs$[rsp+12], edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [r8+4]
	and	edx, 16777215				; 00ffffffH
	shr	edx, cl
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 68   : 		if (rcGetCon(as, dir) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN8@getCornerH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	mov	eax, r11d
	and	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 71   : 			const int ay2 = ay + rcGetDirOffsetY(dir);

	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[r13+rax*4]
	add	ecx, r15d

; 72   : 			const int ai2 = (int)chf.cells[ax2+ay2*chf.width].index + rcGetCon(as, dir);

	imul	ecx, r12d
	add	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[r13+rax*4]
	lea	eax, DWORD PTR [r10+rcx]
	cdqe
	mov	ecx, DWORD PTR [rsi+rax*4]
	and	ecx, 16777215				; 00ffffffH
	add	ecx, edx

; 73   : 			const rcCompactSpan& as2 = chf.spans[ai2];

	mov	edx, ecx

; 74   : 			ch = rcMax(ch, (int)as2.y);

	movzx	eax, WORD PTR [rbx+rcx*8]

; 75   : 			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);

	movzx	ecx, BYTE PTR [rdi+rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 664  : template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }

	cmp	r14d, eax
	cmova	eax, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 75   : 			regs[2] = chf.spans[ai2].reg | (chf.areas[ai2] << 16);

	shl	ecx, 16
	mov	r14d, eax
	movzx	eax, WORD PTR [rbx+rdx*8+2]
	or	ecx, eax
	mov	DWORD PTR regs$[rsp+8], ecx
$LN8@getCornerH:

; 76   : 		}
; 77   : 	}
; 78   : 
; 79   : 	// Check if the vertex is special edge vertex, these vertices will be removed later.
; 80   : 	for (int j = 0; j < 4; ++j)

	mov	ecx, 2
	lea	rdi, QWORD PTR regs$[rsp]
	npad	11
$LL4@getCornerH:

; 81   : 	{
; 82   : 		const int a = j;
; 83   : 		const int b = (j+1) & 0x3;
; 84   : 		const int c = (j+2) & 0x3;
; 85   : 		const int d = (j+3) & 0x3;
; 86   : 		
; 87   : 		// The vertex is a border vertex there are two same exterior cells in a row,
; 88   : 		// followed by two interior cells and none of the regions are out of bounds.
; 89   : 		const bool twoSameExts = (regs[a] & regs[b] & RC_BORDER_REG) != 0 && regs[a] == regs[b];

	mov	r8d, DWORD PTR [rdi]
	lea	eax, DWORD PTR [rcx-1]
	and	eax, 3
	lea	ebp, DWORD PTR [rcx+1]
	mov	r9d, ecx
	mov	r10d, ebp
	and	r9d, 3
	and	r10d, 3
	mov	edx, DWORD PTR regs$[rsp+rax*4]
	mov	eax, edx
	and	eax, r8d
	bt	eax, 15
	jae	SHORT $LN70@getCornerH
	cmp	r8d, edx
	jne	SHORT $LN70@getCornerH
	mov	sil, 1
	jmp	SHORT $LN12@getCornerH
$LN70@getCornerH:
	xor	sil, sil
$LN12@getCornerH:

; 90   : 		const bool twoInts = ((regs[c] | regs[d]) & RC_BORDER_REG) == 0;

	mov	r10d, DWORD PTR regs$[rsp+r10*4]
	mov	eax, r10d
	mov	r9d, DWORD PTR regs$[rsp+r9*4]

; 91   : 		const bool intsSameArea = (regs[c]>>16) == (regs[d]>>16);

	mov	r11d, r10d
	shr	eax, 15
	mov	ecx, r9d
	shr	ecx, 15
	mov	ebx, r9d
	or	al, cl
	shr	r11d, 16
	not	al
	shr	ebx, 16
	and	al, 1

; 92   : 		const bool noZeros = regs[a] != 0 && regs[b] != 0 && regs[c] != 0 && regs[d] != 0;

	test	r8d, r8d
	je	SHORT $LN13@getCornerH
	test	edx, edx
	je	SHORT $LN13@getCornerH
	test	r9d, r9d
	je	SHORT $LN13@getCornerH
	test	r10d, r10d
	je	SHORT $LN13@getCornerH
	mov	cl, 1
	jmp	SHORT $LN14@getCornerH
$LN13@getCornerH:
	xor	cl, cl
$LN14@getCornerH:

; 93   : 		if (twoSameExts && twoInts && intsSameArea && noZeros)

	test	sil, sil
	je	SHORT $LN2@getCornerH
	test	al, al
	je	SHORT $LN2@getCornerH
	cmp	ebx, r11d
	jne	SHORT $LN2@getCornerH
	test	cl, cl
	jne	SHORT $LN56@getCornerH
$LN2@getCornerH:

; 76   : 		}
; 77   : 	}
; 78   : 
; 79   : 	// Check if the vertex is special edge vertex, these vertices will be removed later.
; 80   : 	for (int j = 0; j < 4; ++j)

	add	rdi, 4
	lea	eax, DWORD PTR [rbp-2]
	mov	ecx, ebp
	cmp	eax, 4
	jl	$LL4@getCornerH
	jmp	SHORT $LN72@getCornerH
$LN56@getCornerH:

; 94   : 		{
; 95   : 			isBorderVertex = true;

	mov	rcx, QWORD PTR isBorderVertex$[rsp]
	mov	BYTE PTR [rcx], 1
$LN72@getCornerH:

; 96   : 			break;
; 97   : 		}
; 98   : 	}
; 99   : 	
; 100  : 	return ch;
; 101  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, r14d
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 16
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z ENDP ; getCornerHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z
_TEXT	SEGMENT
isBorderVertex$1 = 48
area$1$ = 49
startDir$1$ = 50
x$GSCopy$1$ = 52
y$GSCopy$1$ = 56
item$1$ = 60
i$GSCopy$1$ = 64
iter$1$ = 68
starti$1$ = 72
chf$GSCopy$1$ = 80
tv1941 = 88
flags$GSCopy$1$ = 96
x$ = 192
y$ = 200
i$ = 208
chf$ = 216
flags$ = 224
points$ = 232
?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z PROC ; walkContour, COMDAT

; 106  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 120				; 00000078H
	mov	rsi, QWORD PTR flags$[rsp]
	mov	r12d, edx
	mov	rbx, QWORD PTR points$[rsp]
	mov	r10d, ecx
	mov	DWORD PTR y$GSCopy$1$[rsp], edx

; 107  : 	// Choose the first non-connected edge
; 108  : 	unsigned char dir = 0;

	xor	r14b, r14b

; 109  : 	while ((flags[i] & (1 << dir)) == 0)

	movsxd	rdx, r8d
	mov	DWORD PTR x$GSCopy$1$[rsp], ecx
	mov	QWORD PTR chf$GSCopy$1$[rsp], r9
	mov	DWORD PTR i$GSCopy$1$[rsp], r8d
	movzx	ecx, BYTE PTR [rsi+rdx]
	mov	QWORD PTR flags$GSCopy$1$[rsp], rsi
	test	cl, 1
	jne	SHORT $LN3@walkContou
	npad	3
$LL2@walkContou:

; 110  : 		dir++;

	inc	r14b
	movzx	eax, r14b
	bt	ecx, eax
	jae	SHORT $LL2@walkContou
$LN3@walkContou:

; 111  : 	
; 112  : 	unsigned char startDir = dir;
; 113  : 	int starti = i;
; 114  : 	
; 115  : 	const unsigned char area = chf.areas[i];

	mov	rax, QWORD PTR [r9+88]

; 116  : 	
; 117  : 	int iter = 0;
; 118  : 	while (++iter < 40000)

	lea	r15, OFFSET FLAT:__ImageBase
	movzx	ebp, r14b
	mov	BYTE PTR startDir$1$[rsp], r14b
	mov	DWORD PTR starti$1$[rsp], r8d
	movzx	eax, BYTE PTR [rdx+rax]
	mov	edx, 1
	mov	r11d, edx
	mov	DWORD PTR iter$1$[rsp], edx
	mov	BYTE PTR area$1$[rsp], al
	npad	7
$LL4@walkContou:

; 119  : 	{
; 120  : 		if (flags[i] & (1 << dir))

	movsxd	rdi, r8d
	lea	rax, QWORD PTR [rsi+rdi]
	movzx	r13d, r14b
	mov	ecx, r13d
	mov	QWORD PTR tv1941[rsp], rax
	shl	edx, cl
	test	dl, BYTE PTR [rax]
	je	$LN8@walkContou

; 121  : 		{
; 122  : 			// Choose the edge corner
; 123  : 			bool isBorderVertex = false;
; 124  : 			bool isAreaBorder = false;
; 125  : 			int px = x;
; 126  : 			int py = getCornerHeight(x, y, i, dir, chf, isBorderVertex);

	lea	rax, QWORD PTR isBorderVertex$1[rsp]
	mov	BYTE PTR isBorderVertex$1[rsp], 0
	mov	QWORD PTR [rsp+40], rax
	mov	edx, r12d
	mov	QWORD PTR [rsp+32], r9
	mov	ecx, r10d
	mov	r9d, r13d
	xor	sil, sil
	mov	ebp, r10d
	call	?getCornerHeight@@YAHHHHHAEBUrcCompactHeightfield@@AEA_N@Z ; getCornerHeight

; 127  : 			int pz = y;
; 128  : 			switch(dir)

	mov	r10d, DWORD PTR x$GSCopy$1$[rsp]
	mov	r15d, eax
	mov	r11d, DWORD PTR y$GSCopy$1$[rsp]
	mov	edx, r13d
	test	r14b, r14b
	je	SHORT $LN10@walkContou
	sub	edx, 1
	je	SHORT $LN11@walkContou
	cmp	edx, 1
	jne	SHORT $LN6@walkContou

; 132  : 				case 2: px++; break;

	lea	ebp, DWORD PTR [r10+1]
	jmp	SHORT $LN6@walkContou
$LN11@walkContou:

; 129  : 			{
; 130  : 				case 0: pz++; break;
; 131  : 				case 1: px++; pz++; break;

	lea	ebp, DWORD PTR [r10+1]
$LN10@walkContou:

; 134  : 			int r = 0;

	lea	r12d, DWORD PTR [r11+1]
$LN6@walkContou:

; 135  : 			const rcCompactSpan& s = chf.spans[i];

	mov	r9, QWORD PTR chf$GSCopy$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [r13*2]
	add	ecx, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 134  : 			int r = 0;

	xor	edx, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	add	ecx, ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 135  : 			const rcCompactSpan& s = chf.spans[i];

	mov	r9, QWORD PTR [r9+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	r8d, DWORD PTR [r9+rdi*8+4]
	and	r8d, 16777215				; 00ffffffH
	shr	r8d, cl
	and	r8d, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 136  : 			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	r8d, 63					; 0000003fH
	je	SHORT $LN14@walkContou
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	movzx	eax, r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 139  : 				const int ay = y + rcGetDirOffsetY(dir);

	lea	rdx, OFFSET FLAT:__ImageBase
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1266 : 	return offset[direction & 0x03];

	and	eax, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 142  : 				if (area != chf.areas[ai])

	movzx	esi, sil
	mov	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rdx+rax*4]
	add	ecx, r11d
	mov	r11, QWORD PTR chf$GSCopy$1$[rsp]
	imul	ecx, DWORD PTR [r11]
	add	ecx, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rdx+rax*4]
	mov	rax, QWORD PTR [r11+64]
	add	ecx, r10d
	movsxd	rcx, ecx
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [r11+88]
	and	edx, 16777215				; 00ffffffH
	add	edx, r8d
	movzx	r8d, BYTE PTR area$1$[rsp]
	mov	ecx, edx
	movzx	edx, WORD PTR [r9+rdx*8+2]
	cmp	r8b, BYTE PTR [rcx+rax]
	mov	eax, 1
	cmovne	esi, eax
$LN14@walkContou:

; 143  : 					isAreaBorder = true;
; 144  : 			}
; 145  : 			if (isBorderVertex)

	cmp	BYTE PTR isBorderVertex$1[rsp], 0
	je	SHORT $LN15@walkContou

; 146  : 				r |= RC_BORDER_VERTEX;

	bts	edx, 16
$LN15@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 149  : 			points.push(px);

	mov	eax, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rdi, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 149  : 			points.push(px);

	bts	eax, 17
	test	sil, sil
	cmove	eax, edx
	mov	DWORD PTR item$1$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	rcx, rdi
	jge	SHORT $LN32@walkContou

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN31@walkContou
	mov	DWORD PTR [rdx], ebp
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]

; 207  : 		return;

	jmp	$LN31@walkContou
$LN32@walkContou:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rcx, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, rax
	jl	SHORT $LN42@walkContou

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN44@walkContou
$LN42@walkContou:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	mov	rdi, rcx
	cmp	rax, rcx
	cmovg	rdi, rax
$LN44@walkContou:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN49@walkContou
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN49@walkContou
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN49@walkContou:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN60@walkContou

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN60@walkContou

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL61@walkContou:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN59@walkContou
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN59@walkContou:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL61@walkContou
$LN60@walkContou:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN69@walkContou
	mov	DWORD PTR [rcx], ebp
$LN69@walkContou:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rax, rax
	je	SHORT $LN74@walkContou

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
$LN74@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
$LN31@walkContou:

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	rcx, rdi
	jge	SHORT $LN81@walkContou

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	SHORT $LN85@walkContou
	mov	DWORD PTR [rdx], r15d
	mov	rcx, QWORD PTR [rbx]
$LN85@walkContou:

; 207  : 		return;

	mov	rbp, 4611686018427387903		; 3fffffffffffffffH
	jmp	$LN80@walkContou
$LN81@walkContou:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rbp, 4611686018427387903		; 3fffffffffffffffH

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rsi, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, rbp
	jl	SHORT $LN91@walkContou

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN93@walkContou
$LN91@walkContou:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	cmp	rax, rsi
	cmovg	rsi, rax
$LN93@walkContou:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN98@walkContou
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rsi, rcx
	jle	SHORT $LN98@walkContou
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN98@walkContou:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN109@walkContou

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN109@walkContou

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	1
$LL110@walkContou:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN108@walkContou
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN108@walkContou:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL110@walkContou
$LN109@walkContou:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN118@walkContou
	mov	DWORD PTR [rcx], r15d
$LN118@walkContou:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+8], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rax, rax
	je	SHORT $LN123@walkContou

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx]
$LN123@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rdi
$LN80@walkContou:

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rdi, QWORD PTR [rbx+8]
	cmp	rcx, rdi
	jge	SHORT $LN130@walkContou

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN129@walkContou
	mov	DWORD PTR [rdx], r12d
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]

; 207  : 		return;

	jmp	$LN129@walkContou
$LN130@walkContou:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rcx, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, rbp
	jl	SHORT $LN140@walkContou

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN142@walkContou
$LN140@walkContou:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	mov	rdi, rcx
	cmp	rax, rcx
	cmovg	rdi, rax
$LN142@walkContou:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN147@walkContou
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN147@walkContou
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN147@walkContou:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN158@walkContou

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN158@walkContou

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL159@walkContou:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN157@walkContou
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN157@walkContou:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL159@walkContou
$LN158@walkContou:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN167@walkContou
	mov	DWORD PTR [rcx], r12d
$LN167@walkContou:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rax, rax
	je	SHORT $LN172@walkContou

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
$LN172@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
$LN129@walkContou:

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	rcx, rdi
	jge	SHORT $LN179@walkContou

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN178@walkContou
	mov	eax, DWORD PTR item$1$[rsp]
	mov	DWORD PTR [rdx], eax

; 207  : 		return;

	jmp	$LN178@walkContou
$LN179@walkContou:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rsi, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, rbp
	jl	SHORT $LN189@walkContou

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN191@walkContou
$LN189@walkContou:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	cmp	rax, rsi
	cmovg	rsi, rax
$LN191@walkContou:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN196@walkContou
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rsi, rcx
	jle	SHORT $LN196@walkContou
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN196@walkContou:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN207@walkContou

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN207@walkContou

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	2
$LL208@walkContou:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN206@walkContou
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN206@walkContou:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL208@walkContou
$LN207@walkContou:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN216@walkContou
	mov	eax, DWORD PTR item$1$[rsp]
	mov	DWORD PTR [rcx], eax
$LN216@walkContou:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN221@walkContou

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN221@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rdi
$LN178@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 154  : 			flags[i] &= ~(1 << dir); // Remove visited edges

	mov	rcx, QWORD PTR tv1941[rsp]

; 155  : 			dir = (dir+1) & 0x3;  // Rotate CW
; 156  : 		}

	lea	r15, OFFSET FLAT:__ImageBase
	mov	r8d, DWORD PTR i$GSCopy$1$[rsp]
	mov	r10d, DWORD PTR x$GSCopy$1$[rsp]
	mov	r12d, DWORD PTR y$GSCopy$1$[rsp]
	movzx	eax, BYTE PTR [rcx]
	mov	r9, QWORD PTR chf$GSCopy$1$[rsp]
	btr	eax, r13d
	mov	r11d, DWORD PTR iter$1$[rsp]
	inc	r14b
	mov	rsi, QWORD PTR flags$GSCopy$1$[rsp]
	movzx	ebp, BYTE PTR startDir$1$[rsp]
	mov	BYTE PTR [rcx], al
	jmp	SHORT $LN9@walkContou
$LN8@walkContou:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1256 : 	return offset[direction & 0x03];

	movzx	eax, r14b
	and	eax, 3
	lea	rcx, QWORD PTR [rax*4]

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	rax, QWORD PTR [r9+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 160  : 			const int nx = x + rcGetDirOffsetX(dir);

	add	r10d, DWORD PTR ?offset@?1??rcGetDirOffsetX@@YAHH@Z@4QBHB[rcx+r15]

; 161  : 			const int ny = y + rcGetDirOffsetY(dir);

	add	r12d, DWORD PTR ?offset@?1??rcGetDirOffsetY@@YAHH@Z@4QBHB[rcx+r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1246 : 	const unsigned int shift = (unsigned int)direction * 6;

	lea	ecx, DWORD PTR [r13*2]
	add	ecx, r13d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 160  : 			const int nx = x + rcGetDirOffsetX(dir);

	mov	DWORD PTR x$GSCopy$1$[rsp], r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	mov	edx, DWORD PTR [rax+rdi*8+4]
	add	ecx, ecx
	and	edx, 16777215				; 00ffffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 161  : 			const int ny = y + rcGetDirOffsetY(dir);

	mov	DWORD PTR y$GSCopy$1$[rsp], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 1247 : 	return (span.con >> shift) & 0x3f;

	shr	edx, cl
	and	edx, 63					; 0000003fH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 163  : 			if (rcGetCon(s, dir) != RC_NOT_CONNECTED)

	cmp	edx, 63					; 0000003fH
	je	SHORT $LN239@walkContou

; 164  : 			{
; 165  : 				const rcCompactCell& nc = chf.cells[nx+ny*chf.width];

	mov	eax, r12d
	imul	eax, DWORD PTR [r9]
	add	eax, r10d
	movsxd	rcx, eax

; 166  : 				ni = (int)nc.index + rcGetCon(s, dir);

	mov	rax, QWORD PTR [r9+64]
	mov	r8d, DWORD PTR [rax+rcx*4]
	and	r8d, 16777215				; 00ffffffH
	add	r8d, edx
	mov	DWORD PTR i$GSCopy$1$[rsp], r8d

; 167  : 			}
; 168  : 			if (ni == -1)
; 169  : 			{
; 170  : 				// Should not happen.
; 171  : 				return;
; 172  : 			}
; 173  : 			x = nx;
; 174  : 			y = ny;
; 175  : 			i = ni;
; 176  : 			dir = (dir+3) & 0x3;	// Rotate CCW

	dec	r14b
$LN9@walkContou:

; 177  : 		}
; 178  : 		
; 179  : 		if (starti == i && startDir == dir)

	and	r14b, 3
	cmp	DWORD PTR starti$1$[rsp], r8d
	jne	SHORT $LN19@walkContou
	cmp	bpl, r14b
	je	SHORT $LN239@walkContou
$LN19@walkContou:

; 116  : 	
; 117  : 	int iter = 0;
; 118  : 	while (++iter < 40000)

	inc	r11d
	mov	edx, 1
	mov	DWORD PTR iter$1$[rsp], r11d
	cmp	r11d, 40000				; 00009c40H
	jl	$LL4@walkContou
$LN239@walkContou:

; 180  : 		{
; 181  : 			break;
; 182  : 		}
; 183  : 	}
; 184  : }

	add	rsp, 120				; 00000078H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?walkContour@@YAXHHHAEBUrcCompactHeightfield@@PEAEAEAVrcIntArray@@@Z ENDP ; walkContour
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?distancePtSeg@@YAMHHHHHH@Z
_TEXT	SEGMENT
x$ = 32
z$ = 40
px$ = 48
pz$ = 56
qx$ = 64
qz$ = 72
?distancePtSeg@@YAMHHHHHH@Z PROC			; distancePtSeg, COMDAT

; 189  : {

	sub	rsp, 24

; 190  : 	float pqx = (float)(qx - px);

	mov	eax, DWORD PTR qx$[rsp]
	xorps	xmm4, xmm4
	sub	eax, r8d
	movaps	XMMWORD PTR [rsp], xmm6
	movd	xmm5, eax

; 191  : 	float pqz = (float)(qz - pz);

	mov	eax, DWORD PTR qz$[rsp]
	sub	eax, r9d
	cvtdq2ps xmm5, xmm5
	movd	xmm6, eax

; 192  : 	float dx = (float)(x - px);

	mov	eax, ecx
	sub	eax, r8d

; 193  : 	float dz = (float)(z - pz);
; 194  : 	float d = pqx*pqx + pqz*pqz;

	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	cvtdq2ps xmm6, xmm6
	movd	xmm1, eax
	mov	eax, edx
	sub	eax, r9d
	movaps	xmm2, xmm6
	cvtdq2ps xmm1, xmm1
	mulss	xmm2, xmm6

; 195  : 	float t = pqx*dx + pqz*dz;

	mulss	xmm1, xmm5
	addss	xmm2, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0

; 196  : 	if (d > 0)

	comiss	xmm2, xmm4
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	jbe	SHORT $LN2@distancePt

; 197  : 		t /= d;

	divss	xmm1, xmm2
$LN2@distancePt:

; 198  : 	if (t < 0)

	comiss	xmm4, xmm1
	ja	SHORT $LN5@distancePt

; 199  : 		t = 0;
; 200  : 	else if (t > 1)

	movss	xmm4, DWORD PTR __real@3f800000
	minss	xmm4, xmm1
$LN5@distancePt:

; 201  : 		t = 1;
; 202  : 	
; 203  : 	dx = px + t*pqx - x;

	movaps	xmm3, xmm4
	xorps	xmm1, xmm1

; 204  : 	dz = pz + t*pqz - z;

	mulss	xmm4, xmm6
	xorps	xmm0, xmm0

; 205  : 	
; 206  : 	return dx*dx + dz*dz;
; 207  : }

	movaps	xmm6, XMMWORD PTR [rsp]
	xorps	xmm2, xmm2
	mulss	xmm3, xmm5
	cvtsi2ss xmm1, ecx
	cvtsi2ss xmm0, r8d
	cvtsi2ss xmm2, edx
	addss	xmm3, xmm0
	subss	xmm3, xmm1
	xorps	xmm1, xmm1
	cvtsi2ss xmm1, r9d
	mulss	xmm3, xmm3
	addss	xmm4, xmm1
	subss	xmm4, xmm2
	mulss	xmm4, xmm4
	addss	xmm4, xmm3
	movaps	xmm0, xmm4
	add	rsp, 24
	ret	0
?distancePtSeg@@YAMHHHHHH@Z ENDP			; distancePtSeg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z
_TEXT	SEGMENT
points$1$ = 32
pn$1$ = 40
llz$1$ = 40
i$1$ = 44
tv7809 = 44
i$1$ = 44
lli$1$ = 44
tv7782 = 48
tv7767 = 48
lly$1$ = 48
ni$1$ = 48
endi$1$ = 52
ury$1$ = 52
maxi$2$ = 56
uri$1$ = 56
$T1 = 64
$T2 = 64
$T3 = 64
maxEdgeLen$1$ = 72
simplified$GSCopy$1$ = 80
tv7968 = 88
points$ = 304
simplified$ = 312
maxError$ = 320
maxEdgeLen$ = 328
buildFlags$dead$ = 336
?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z PROC	; simplifyContour, COMDAT

; 211  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	sub	rsp, 256				; 00000100H

; 212  : 	// Add initial points.
; 213  : 	bool hasConnections = false;
; 214  : 	for (int i = 0; i < points.size(); i += 4)

	xor	ebp, ebp
	mov	QWORD PTR [rax+8], r12
	mov	rbx, rdx
	mov	QWORD PTR simplified$GSCopy$1$[rsp], rdx
	mov	edx, DWORD PTR [rcx]
	mov	r14, rcx
	mov	QWORD PTR [rax+24], r15
	mov	esi, ebp
	movaps	XMMWORD PTR [rsp+96], xmm15
	movaps	xmm15, xmm2
	mov	DWORD PTR maxEdgeLen$1$[rsp], r9d
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR points$1$[rsp], rcx
	mov	QWORD PTR tv7968[rsp], rbp
	test	edx, edx
	jle	$LN6@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	lea	edi, QWORD PTR [rbp+3]
	mov	eax, edx
	npad	5
$LL4@simplifyCo:

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	r8d, edx
	mov	edx, eax
	test	r9, r9
	je	SHORT $LN942@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1058@simplifyCo
	mov	rdx, QWORD PTR [r14]
	mov	r8d, edx
	cmp	rdi, rdx
	jl	SHORT $LN942@simplifyCo
$LN1058@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r8d, DWORD PTR [r14]
	mov	edx, r8d
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN942@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 216  : 		if ((points[i+3] & RC_CONTOUR_REG_MASK) != 0)

	mov	rax, QWORD PTR [r14+16]
	movzx	ecx, WORD PTR [rax+rdi*4]
	test	ecx, ecx
	jne	SHORT $LN962@simplifyCo

; 212  : 	// Add initial points.
; 213  : 	bool hasConnections = false;
; 214  : 	for (int i = 0; i < points.size(); i += 4)

	add	esi, 4
	add	rdi, 4
	mov	eax, edx
	cmp	esi, edx
	jl	SHORT $LL4@simplifyCo

; 216  : 		if ((points[i+3] & RC_CONTOUR_REG_MASK) != 0)

	jmp	$LN6@simplifyCo
$LN962@simplifyCo:

; 227  : 		for (int i = 0, ni = points.size()/4; i < ni; ++i)

	mov	eax, r8d
	mov	r12d, ebp
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR ni$1$[rsp], eax
	mov	r8d, eax
	test	eax, eax
	jle	$LN6@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 333  : 	void push(int item) { m_impl.push_back(item); }

	mov	rcx, rbp
	mov	QWORD PTR $T1[rsp], rcx
$LL7@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 229  : 			int ii = (i+1) % ni;

	lea	eax, DWORD PTR [r12+1]
	mov	DWORD PTR tv7809[rsp], eax

; 230  : 			const bool differentRegs = (points[i*4+3] & RC_CONTOUR_REG_MASK) != (points[ii*4+3] & RC_CONTOUR_REG_MASK);

	lea	r13, QWORD PTR [rcx*4]
	cdq
	lea	rsi, QWORD PTR [r13+3]
	idiv	r8d
	mov	edi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN658@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1059@simplifyCo
	cmp	rsi, QWORD PTR [r14]
	jl	SHORT $LN658@simplifyCo
$LN1059@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN658@simplifyCo:
	mov	rbp, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 230  : 			const bool differentRegs = (points[i*4+3] & RC_CONTOUR_REG_MASK) != (points[ii*4+3] & RC_CONTOUR_REG_MASK);

	lea	eax, DWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax
	add	rdi, 3

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN666@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1061@simplifyCo
	cmp	rdi, QWORD PTR [r14]
	jl	SHORT $LN666@simplifyCo
$LN1061@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN666@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 230  : 			const bool differentRegs = (points[i*4+3] & RC_CONTOUR_REG_MASK) != (points[ii*4+3] & RC_CONTOUR_REG_MASK);

	mov	rax, QWORD PTR [r14+16]
	movzx	r15d, WORD PTR [rbp+rsi*4]
	movzx	r14d, WORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN1115@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1062@simplifyCo
	mov	rax, QWORD PTR points$1$[rsp]
	cmp	rdi, QWORD PTR [rax]
	jl	SHORT $LN642@simplifyCo
$LN1062@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN1115@simplifyCo:
	mov	rax, QWORD PTR points$1$[rsp]
$LN642@simplifyCo:
	mov	rbp, QWORD PTR [rax+16]
	test	r9, r9
	je	SHORT $LN650@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1060@simplifyCo
	cmp	rsi, QWORD PTR [rax]
	jl	SHORT $LN650@simplifyCo
$LN1060@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN650@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 232  : 			if (differentRegs || areaBorders)

	cmp	r15d, r14d
	mov	r14, QWORD PTR points$1$[rsp]
	jne	SHORT $LN1063@simplifyCo

; 231  : 			const bool areaBorders = (points[i*4+3] & RC_AREA_BORDER) != (points[ii*4+3] & RC_AREA_BORDER);

	mov	rax, QWORD PTR [r14+16]
	mov	ecx, DWORD PTR [rax+rsi*4]
	xor	ecx, DWORD PTR [rbp+rdi*4]
	bt	ecx, 17

; 232  : 			if (differentRegs || areaBorders)

	jae	$LN5@simplifyCo
$LN1063@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN788@simplifyCo
	test	r13, r13
	js	SHORT $LN1064@simplifyCo
	cmp	r13, QWORD PTR [r14]
	jl	SHORT $LN788@simplifyCo
$LN1064@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN788@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 234  : 				simplified.push(points[i*4+0]);

	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 234  : 				simplified.push(points[i*4+0]);

	mov	ebp, DWORD PTR [rax+r13*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN737@simplifyCo

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	SHORT $LN741@simplifyCo
	mov	DWORD PTR [rdx], ebp
$LN741@simplifyCo:

; 207  : 		return;

	mov	r15, 4611686018427387903		; 3fffffffffffffffH
	jmp	$LN736@simplifyCo
$LN737@simplifyCo:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	r15, 4611686018427387903		; 3fffffffffffffffH

; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, r15
	jl	SHORT $LN747@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN749@simplifyCo
$LN747@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN749@simplifyCo:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN754@simplifyCo
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jle	SHORT $LN754@simplifyCo
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN754@simplifyCo:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN765@simplifyCo

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN765@simplifyCo

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL766@simplifyCo:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN764@simplifyCo
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN764@simplifyCo:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL766@simplifyCo
$LN765@simplifyCo:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN774@simplifyCo
	mov	DWORD PTR [rcx], ebp
$LN774@simplifyCo:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN779@simplifyCo

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN779@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], rsi
$LN736@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 235  : 				simplified.push(points[i*4+1]);

	lea	rdi, QWORD PTR [r13+1]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN731@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1065@simplifyCo
	cmp	rdi, QWORD PTR [r14]
	jl	SHORT $LN731@simplifyCo
$LN1065@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN731@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 235  : 				simplified.push(points[i*4+1]);

	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 235  : 				simplified.push(points[i*4+1]);

	mov	ebp, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN843@simplifyCo

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN842@simplifyCo
	mov	DWORD PTR [rdx], ebp

; 207  : 		return;

	jmp	$LN842@simplifyCo
$LN843@simplifyCo:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, r15
	jl	SHORT $LN853@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN855@simplifyCo
$LN853@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN855@simplifyCo:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN860@simplifyCo
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jle	SHORT $LN860@simplifyCo
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN860@simplifyCo:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN871@simplifyCo

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN871@simplifyCo

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	6
$LL872@simplifyCo:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN870@simplifyCo
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN870@simplifyCo:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL872@simplifyCo
$LN871@simplifyCo:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN880@simplifyCo
	mov	DWORD PTR [rcx], ebp
$LN880@simplifyCo:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN885@simplifyCo

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN885@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], rsi
$LN842@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 236  : 				simplified.push(points[i*4+2]);

	lea	rdi, QWORD PTR [r13+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN723@simplifyCo
	test	rdi, rdi
	js	SHORT $LN724@simplifyCo
	cmp	rdi, QWORD PTR [r14]
	jl	SHORT $LN723@simplifyCo
$LN724@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN723@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 236  : 				simplified.push(points[i*4+2]);

	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 236  : 				simplified.push(points[i*4+2]);

	mov	ebp, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rdi, QWORD PTR [rbx+8]
	cmp	rcx, rdi
	jge	SHORT $LN794@simplifyCo

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	inc	rcx
	mov	QWORD PTR [rbx], rcx

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN793@simplifyCo
	mov	DWORD PTR [rdx], ebp
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]

; 207  : 		return;

	jmp	$LN793@simplifyCo
$LN794@simplifyCo:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rcx, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, r15
	jl	SHORT $LN804@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN806@simplifyCo
$LN804@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	mov	rdi, rcx
	cmp	rax, rcx
	cmovg	rdi, rax
$LN806@simplifyCo:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN811@simplifyCo
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rax
	jle	SHORT $LN811@simplifyCo
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN811@simplifyCo:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN822@simplifyCo

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN822@simplifyCo

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL823@simplifyCo:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN821@simplifyCo
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN821@simplifyCo:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL823@simplifyCo
$LN822@simplifyCo:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN831@simplifyCo
	mov	DWORD PTR [rcx], ebp
$LN831@simplifyCo:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+8], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rax, rax
	je	SHORT $LN836@simplifyCo

; 28   : 	free(ptr);

	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
$LN836@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], rsi
$LN793@simplifyCo:

; 205  : 	if (rcLikely(m_size < m_cap)) {

	cmp	rcx, rdi
	jge	SHORT $LN672@simplifyCo

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	$LN5@simplifyCo
	mov	DWORD PTR [rdx], r12d

; 207  : 		return;

	jmp	$LN5@simplifyCo
$LN672@simplifyCo:

; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rsi, QWORD PTR [rdi+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rdi, r15
	jl	SHORT $LN682@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN684@simplifyCo
$LN682@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	lea	rax, QWORD PTR [rdi+rdi]
	cmp	rax, rsi
	cmovg	rsi, rax
$LN684@simplifyCo:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	test	r9, r9
	je	SHORT $LN689@simplifyCo
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rsi, rax
	jle	SHORT $LN689@simplifyCo
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	r9
$LN689@simplifyCo:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rdi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN700@simplifyCo

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN700@simplifyCo

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
	npad	4
$LL701@simplifyCo:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN699@simplifyCo
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN699@simplifyCo:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL701@simplifyCo
$LN700@simplifyCo:

; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN709@simplifyCo
	mov	DWORD PTR [rcx], r12d
$LN709@simplifyCo:

; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN714@simplifyCo

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN714@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], rdi
$LN5@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 227  : 		for (int i = 0, ni = points.size()/4; i < ni; ++i)

	mov	rcx, QWORD PTR $T1[rsp]
	mov	r12d, DWORD PTR tv7809[rsp]
	inc	rcx
	mov	r8d, DWORD PTR ni$1$[rsp]
	mov	QWORD PTR $T1[rsp], rcx
	cmp	r12d, r8d
	jl	$LL7@simplifyCo

; 212  : 	// Add initial points.
; 213  : 	bool hasConnections = false;
; 214  : 	for (int i = 0; i < points.size(); i += 4)

	xor	ebp, ebp
$LN6@simplifyCo:

; 237  : 				simplified.push(i);
; 238  : 			}
; 239  : 		}
; 240  : 	}
; 241  : 	
; 242  : 	if (simplified.size() == 0)

	cmp	DWORD PTR [rbx], 0
	jne	$LN1068@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN910@simplifyCo
	cmp	QWORD PTR [r14], 0
	jg	SHORT $LN910@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN910@simplifyCo:
	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 247  : 		int llx = points[0];

	mov	r12d, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN902@simplifyCo
	cmp	QWORD PTR [r14], 1
	jg	SHORT $LN902@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN902@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 248  : 		int lly = points[1];

	mov	rax, QWORD PTR [r14+16]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR lly$1$[rsp], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN894@simplifyCo
	cmp	QWORD PTR [r14], 2
	jg	SHORT $LN894@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN894@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 249  : 		int llz = points[2];

	mov	rax, QWORD PTR [r14+16]

; 250  : 		int lli = 0;

	mov	DWORD PTR lli$1$[rsp], ebp
	mov	edi, DWORD PTR [rax+8]
	mov	DWORD PTR llz$1$[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN918@simplifyCo
	cmp	QWORD PTR [r14], 0
	jg	SHORT $LN918@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN918@simplifyCo:
	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 251  : 		int urx = points[0];

	mov	r15d, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN926@simplifyCo
	cmp	QWORD PTR [r14], 1
	jg	SHORT $LN926@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN926@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 252  : 		int ury = points[1];

	mov	rax, QWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	mov	r8, QWORD PTR points$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 252  : 		int ury = points[1];

	mov	r14d, DWORD PTR [rax+4]
	mov	DWORD PTR ury$1$[rsp], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN934@simplifyCo
	cmp	QWORD PTR [r8], 2
	jg	SHORT $LN934@simplifyCo
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8, QWORD PTR points$1$[rsp]
$LN934@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 255  : 		for (int i = 0; i < points.size(); i += 4)

	cmp	DWORD PTR [r8], 0
	mov	esi, ebp
	mov	rax, QWORD PTR [r8+16]
	mov	DWORD PTR uri$1$[rsp], ebp
	mov	r13d, DWORD PTR [rax+8]
	jle	$LN9@simplifyCo
	mov	ebx, DWORD PTR llz$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	edi, 2
$LL10@simplifyCo:

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN624@simplifyCo
	lea	rax, QWORD PTR [rdi-2]
	test	rax, rax
	js	SHORT $LN1066@simplifyCo
	cmp	rax, QWORD PTR [r8]
	jl	SHORT $LN624@simplifyCo
$LN1066@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8, QWORD PTR points$1$[rsp]
$LN624@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 257  : 			int x = points[i+0];

	mov	rax, QWORD PTR [r8+16]
	mov	esi, DWORD PTR [rax+rdi*4-8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN616@simplifyCo
	test	rdi, rdi
	jle	SHORT $LN1067@simplifyCo
	cmp	rdi, QWORD PTR [r8]
	jle	SHORT $LN616@simplifyCo
$LN1067@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8, QWORD PTR points$1$[rsp]
$LN616@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 258  : 			int y = points[i+1];

	mov	rax, QWORD PTR [r8+16]
	mov	r14d, DWORD PTR [rax+rdi*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN632@simplifyCo
	test	rdi, rdi
	js	SHORT $LN633@simplifyCo
	cmp	rdi, QWORD PTR [r8]
	jl	SHORT $LN632@simplifyCo
$LN633@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8, QWORD PTR points$1$[rsp]
$LN632@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 259  : 			int z = points[i+2];

	mov	rax, QWORD PTR [r8+16]
	mov	ecx, DWORD PTR [rax+rdi*4]

; 260  : 			if (x < llx || (x == llx && z < llz))

	cmp	esi, r12d
	jl	SHORT $LN34@simplifyCo
	jne	SHORT $LN33@simplifyCo
	cmp	ecx, ebx
	jge	SHORT $LN33@simplifyCo
$LN34@simplifyCo:

; 261  : 			{
; 262  : 				llx = x;
; 263  : 				lly = y;
; 264  : 				llz = z;
; 265  : 				lli = i/4;

	mov	eax, ebp
	mov	DWORD PTR lly$1$[rsp], r14d
	cdq
	mov	r12d, esi
	and	edx, 3
	mov	ebx, ecx
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR lli$1$[rsp], eax
$LN33@simplifyCo:

; 266  : 			}
; 267  : 			if (x > urx || (x == urx && z > urz))

	cmp	esi, r15d
	jg	SHORT $LN36@simplifyCo
	jne	SHORT $LN8@simplifyCo
	cmp	ecx, r13d
	jle	SHORT $LN8@simplifyCo
$LN36@simplifyCo:

; 268  : 			{
; 269  : 				urx = x;
; 270  : 				ury = y;
; 271  : 				urz = z;
; 272  : 				uri = i/4;

	mov	eax, ebp
	mov	DWORD PTR ury$1$[rsp], r14d
	cdq
	mov	r15d, esi
	and	edx, 3
	mov	r13d, ecx
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR uri$1$[rsp], eax
$LN8@simplifyCo:

; 255  : 		for (int i = 0; i < points.size(); i += 4)

	add	ebp, 4
	add	rdi, 4
	cmp	ebp, DWORD PTR [r8]
	jl	$LL10@simplifyCo
	mov	esi, DWORD PTR uri$1$[rsp]
	mov	r14d, DWORD PTR ury$1$[rsp]
	mov	DWORD PTR llz$1$[rsp], ebx
	mov	edi, DWORD PTR llz$1$[rsp]
	mov	rbx, QWORD PTR simplified$GSCopy$1$[rsp]
$LN9@simplifyCo:

; 273  : 			}
; 274  : 		}
; 275  : 		simplified.push(llx);

	mov	edx, r12d
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 276  : 		simplified.push(lly);

	mov	edx, DWORD PTR lly$1$[rsp]
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 277  : 		simplified.push(llz);

	mov	edx, edi
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 278  : 		simplified.push(lli);

	mov	edx, DWORD PTR lli$1$[rsp]
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 279  : 		
; 280  : 		simplified.push(urx);

	mov	edx, r15d
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 281  : 		simplified.push(ury);

	mov	edx, r14d
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 282  : 		simplified.push(urz);

	mov	edx, r13d
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push

; 283  : 		simplified.push(uri);

	mov	edx, esi
	mov	rcx, rbx
	call	?push@rcIntArray@@QEAAXH@Z		; rcIntArray::push
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN1068@simplifyCo:

; 284  : 	}
; 285  : 	
; 286  : 	// Add points until all raw points are within
; 287  : 	// error tolerance to the simplified shape.
; 288  : 	const int pn = points.size()/4;

	mov	r13, QWORD PTR points$1$[rsp]

; 289  : 	for (int i = 0; i < simplified.size()/4; )

	xor	r11d, r11d
	mov	ecx, DWORD PTR [rbx]
	mov	r8d, r11d
	mov	DWORD PTR i$1$[rsp], r11d
	mov	eax, DWORD PTR [r13]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR pn$1$[rsp], eax
	mov	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	test	eax, eax
	jle	$LN1090@simplifyCo
	movaps	XMMWORD PTR [rsp+240], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	r12d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 289  : 	for (int i = 0; i < simplified.size()/4; )

	movaps	XMMWORD PTR [rsp+224], xmm7
	movaps	XMMWORD PTR [rsp+208], xmm8
	movaps	XMMWORD PTR [rsp+192], xmm9
	movaps	XMMWORD PTR [rsp+176], xmm10
	movaps	XMMWORD PTR [rsp+160], xmm11
	movaps	XMMWORD PTR [rsp+144], xmm12
	movaps	XMMWORD PTR [rsp+128], xmm13
	xorps	xmm13, xmm13
	movaps	XMMWORD PTR [rsp+112], xmm14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movss	xmm14, DWORD PTR __real@3f800000
	mov	QWORD PTR $T2[rsp], r11
	npad	2
$LL11@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 291  : 		int ii = (i+1) % (simplified.size()/4);

	mov	eax, ecx

; 293  : 		int ax = simplified[i*4+0];

	lea	rbp, QWORD PTR [r12*4]
	cdq
	inc	r8d
	and	edx, 3
	mov	DWORD PTR tv7782[rsp], r8d
	lea	ecx, DWORD PTR [rdx+rax]
	mov	eax, r8d
	sar	ecx, 2
	cdq
	idiv	ecx
	mov	esi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN448@simplifyCo
	test	rbp, rbp
	js	SHORT $LN1071@simplifyCo
	cmp	rbp, QWORD PTR [rbx]
	jl	SHORT $LN448@simplifyCo
$LN1071@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN448@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 293  : 		int ax = simplified[i*4+0];

	mov	rax, QWORD PTR [rbx+16]

; 294  : 		int az = simplified[i*4+2];

	lea	rdi, QWORD PTR [rbp+2]
	mov	r12d, DWORD PTR [rax+rbp*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN456@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1072@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN456@simplifyCo
$LN1072@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN456@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 294  : 		int az = simplified[i*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	r13d, DWORD PTR [rax+rdi*4]

; 295  : 		int ai = simplified[i*4+3];

	lea	rdi, QWORD PTR [rbp+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN438@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1073@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN438@simplifyCo
$LN1073@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN438@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 295  : 		int ai = simplified[i*4+3];

	mov	rax, QWORD PTR [rbx+16]
	mov	r14d, DWORD PTR [rax+rdi*4]

; 297  : 		int bx = simplified[ii*4+0];

	lea	eax, DWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 295  : 		int ai = simplified[i*4+3];

	mov	DWORD PTR endi$1$[rsp], r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN464@simplifyCo
	test	eax, eax
	js	SHORT $LN1074@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN464@simplifyCo
$LN1074@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN464@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 297  : 		int bx = simplified[ii*4+0];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	lea	rsi, QWORD PTR [rdi+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 297  : 		int bx = simplified[ii*4+0];

	mov	ebp, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN472@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1075@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN472@simplifyCo
$LN1075@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN472@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 298  : 		int bz = simplified[ii*4+2];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	add	rdi, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 298  : 		int bz = simplified[ii*4+2];

	mov	esi, DWORD PTR [rax+rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN422@simplifyCo
	test	rdi, rdi
	js	SHORT $LN423@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN422@simplifyCo
$LN423@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN422@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 299  : 		int bi = simplified[ii*4+3];

	mov	rax, QWORD PTR [rbx+16]

; 300  : 
; 301  : 		// Find maximum deviation from the segment.
; 302  : 		float maxd = 0;

	movaps	xmm7, xmm13

; 303  : 		int maxi = -1;

	mov	DWORD PTR maxi$2$[rsp], -1
	mov	ecx, DWORD PTR [rax+rdi*4]

; 304  : 		int ci, cinc, endi;
; 305  : 
; 306  : 		// Traverse the segment in lexilogical order so that the
; 307  : 		// max deviation is calculated similarly when traversing
; 308  : 		// opposite segments.
; 309  : 		if (bx > ax || (bx == ax && bz > az))

	cmp	ebp, r12d
	jg	SHORT $LN39@simplifyCo
	jne	SHORT $LN37@simplifyCo
	cmp	esi, r13d
	jg	SHORT $LN39@simplifyCo
$LN37@simplifyCo:

; 314  : 		}
; 315  : 		else
; 316  : 		{
; 317  : 			cinc = pn-1;

	mov	r8d, DWORD PTR pn$1$[rsp]
	lea	r15d, DWORD PTR [r8-1]

; 318  : 			ci = (bi+cinc) % pn;

	lea	eax, DWORD PTR [r15+rcx]
	cdq
	idiv	r8d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	eax, r12d
	mov	r12d, ebp
	mov	ebp, eax
	mov	eax, r13d
	mov	r13d, esi
	mov	esi, eax
	jmp	SHORT $LN1342@simplifyCo
$LN39@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 312  : 			ci = (ai+cinc) % pn;

	lea	eax, DWORD PTR [r14+1]

; 313  : 			endi = bi;

	mov	DWORD PTR endi$1$[rsp], ecx
	cdq
	mov	r15d, 1
	idiv	DWORD PTR pn$1$[rsp]
$LN1342@simplifyCo:

; 325  : 		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||

	lea	eax, DWORD PTR [rdx*4]
	mov	r14d, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax
	add	rdi, 3

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN1117@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1076@simplifyCo
	mov	rdx, QWORD PTR points$1$[rsp]
	cmp	rdi, QWORD PTR [rdx]
	jl	SHORT $LN430@simplifyCo
$LN1076@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN1117@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 325  : 		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||

	mov	rdx, QWORD PTR points$1$[rsp]
$LN430@simplifyCo:
	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, WORD PTR [rax+rdi*4]
	test	ecx, ecx
	je	SHORT $LN957@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN548@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1077@simplifyCo
	cmp	rdi, QWORD PTR [rdx]
	jl	SHORT $LN548@simplifyCo
$LN1077@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdx, QWORD PTR points$1$[rsp]
$LN548@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 325  : 		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||

	mov	rax, QWORD PTR [rdx+16]
	test	DWORD PTR [rax+rdi*4], 131072		; 00020000H
	je	$LN43@simplifyCo
$LN957@simplifyCo:

; 326  : 			(points[ci*4+3] & RC_AREA_BORDER))
; 327  : 		{
; 328  : 			while (ci != endi)

	cmp	r14d, DWORD PTR endi$1$[rsp]
	je	$LN43@simplifyCo
	mov	ebx, DWORD PTR endi$1$[rsp]
	sub	ebp, r12d
	sub	esi, r13d
	movd	xmm11, r12d
	movd	xmm12, r13d
	cvtdq2ps xmm11, xmm11
	movd	xmm10, esi
	cvtdq2ps xmm10, xmm10
	movd	xmm9, ebp
	cvtdq2ps xmm9, xmm9
	movaps	xmm6, xmm10
	movaps	xmm0, xmm9
	mulss	xmm6, xmm10
	mulss	xmm0, xmm9
	cvtdq2ps xmm12, xmm12
	addss	xmm6, xmm0
$LL14@simplifyCo:

; 330  : 				float d = distancePtSeg(points[ci*4+0], points[ci*4+2], ax, az, bx, bz);

	lea	eax, DWORD PTR [r14*4]
	movaps	xmm8, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rsi, eax
	lea	rdi, QWORD PTR [rsi+2]

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN114@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1078@simplifyCo
	cmp	rdi, QWORD PTR [rdx]
	jl	SHORT $LN114@simplifyCo
$LN1078@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdx, QWORD PTR points$1$[rsp]
$LN114@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 330  : 				float d = distancePtSeg(points[ci*4+0], points[ci*4+2], ax, az, bx, bz);

	mov	rax, QWORD PTR [rdx+16]
	mov	edi, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN106@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1006@simplifyCo
	cmp	rsi, QWORD PTR [rdx]
	jl	SHORT $LN106@simplifyCo
$LN1006@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdx, QWORD PTR points$1$[rsp]
$LN106@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 330  : 				float d = distancePtSeg(points[ci*4+0], points[ci*4+2], ax, az, bx, bz);

	mov	rax, QWORD PTR [rdx+16]
	mov	ecx, DWORD PTR [rax+rsi*4]

; 193  : 	float dz = (float)(z - pz);

	mov	eax, edi
	sub	eax, r13d
	movd	xmm1, eax

; 192  : 	float dx = (float)(x - px);

	mov	eax, ecx
	sub	eax, r12d

; 196  : 	if (d > 0)

	comiss	xmm6, xmm13
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax

; 192  : 	float dx = (float)(x - px);

	cvtdq2ps xmm0, xmm0

; 194  : 	float d = pqx*pqx + pqz*pqz;
; 195  : 	float t = pqx*dx + pqz*dz;

	mulss	xmm1, xmm10
	mulss	xmm0, xmm9
	addss	xmm1, xmm0

; 196  : 	if (d > 0)

	jbe	SHORT $LN118@simplifyCo

; 197  : 		t /= d;

	divss	xmm1, xmm6
$LN118@simplifyCo:

; 198  : 	if (t < 0)

	comiss	xmm13, xmm1
	jbe	SHORT $LN119@simplifyCo

; 199  : 		t = 0;

	movaps	xmm2, xmm13
	jmp	SHORT $LN121@simplifyCo
$LN119@simplifyCo:

; 200  : 	else if (t > 1)

	movaps	xmm2, xmm14
	minss	xmm2, xmm1
$LN121@simplifyCo:

; 201  : 		t = 1;
; 202  : 	
; 203  : 	dx = px + t*pqx - x;

	movaps	xmm1, xmm2
	xorps	xmm0, xmm0

; 204  : 	dz = pz + t*pqz - z;

	mulss	xmm2, xmm10
	mulss	xmm1, xmm9
	cvtsi2ss xmm0, ecx
	addss	xmm2, xmm12
	addss	xmm1, xmm11
	subss	xmm1, xmm0
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, edi

; 205  : 	
; 206  : 	return dx*dx + dz*dz;

	mulss	xmm1, xmm1
	subss	xmm2, xmm0
	mulss	xmm2, xmm2
	addss	xmm2, xmm1

; 331  : 				if (d > maxd)

	comiss	xmm2, xmm7
	jbe	SHORT $LN42@simplifyCo

; 332  : 				{
; 333  : 					maxd = d;

	movaps	xmm7, xmm2
$LN42@simplifyCo:

; 334  : 					maxi = ci;
; 335  : 				}
; 336  : 				ci = (ci+cinc) % pn;

	comiss	xmm2, xmm8
	lea	eax, DWORD PTR [r14+r15]
	mov	ecx, r14d
	cdq
	cmovbe	ecx, DWORD PTR maxi$2$[rsp]
	idiv	DWORD PTR pn$1$[rsp]
	mov	DWORD PTR maxi$2$[rsp], ecx
	mov	r14d, edx
	cmp	edx, ebx
	mov	rdx, QWORD PTR points$1$[rsp]
	jne	$LL14@simplifyCo

; 337  : 			}
; 338  : 		}
; 339  : 		
; 340  : 		
; 341  : 		// If the max deviation is larger than accepted error,
; 342  : 		// add new point, else continue to next segment.
; 343  : 		if (maxi != -1 && maxd > (maxError*maxError))

	mov	rbx, QWORD PTR simplified$GSCopy$1$[rsp]
	cmp	ecx, -1
	je	$LN43@simplifyCo
	movaps	xmm0, xmm15
	mulss	xmm0, xmm15
	comiss	xmm7, xmm0
	jbe	$LN43@simplifyCo

; 346  : 			simplified.resize(simplified.size()+4);

	mov	ebp, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 232  : 	if (size < m_size) {

	mov	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 346  : 			simplified.resize(simplified.size()+4);

	add	ebp, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 334  : 	void resize(int size) { m_impl.resize(size); }

	movsxd	rdi, ebp

; 232  : 	if (size < m_size) {

	cmp	rdi, rax
	jl	SHORT $LN1343@simplifyCo

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN568@simplifyCo

; 236  : 		if (size <= m_cap) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rdi, rax
	jle	SHORT $LN1343@simplifyCo

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN587@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN589@simplifyCo
$LN587@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	mov	rsi, rdi
	cmp	rax, rdi
	cmovg	rsi, rax
$LN589@simplifyCo:

; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {
; 249  : 				construct_range(new_data + m_size, new_data + size, *value);
; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN603@simplifyCo

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN603@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 257  : 			m_size = size;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], r14
	mov	QWORD PTR [rbx+8], rsi
$LN1343@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 347  : 			const int n = simplified.size()/4;

	mov	QWORD PTR [rbx], rdi
	mov	eax, ebp
$LN568@simplifyCo:

; 348  : 			for (int j = n-1; j > i; --j)

	mov	r12, QWORD PTR $T2[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 342  : 	int size() const { return static_cast<int>(m_impl.size()); }

	movsxd	r14, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 348  : 			for (int j = n-1; j > i; --j)

	cmp	r14, r12
	jle	$LN17@simplifyCo

; 347  : 			const int n = simplified.size()/4;

	mov	rbp, r14
	lea	rdi, QWORD PTR [r14*4-3]
	shl	rbp, 4
	sub	r14, r12
$LL18@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN326@simplifyCo
	test	rdi, rdi
	jle	SHORT $LN1084@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jle	SHORT $LN326@simplifyCo
$LN1084@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN326@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 350  : 				simplified[j*4+0] = simplified[(j-1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN334@simplifyCo
	lea	rax, QWORD PTR [rdi+3]
	test	rax, rax
	js	SHORT $LN1085@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN334@simplifyCo
$LN1085@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN334@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 350  : 				simplified[j*4+0] = simplified[(j-1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+12], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN414@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1086@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN414@simplifyCo
$LN1086@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN414@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 351  : 				simplified[j*4+1] = simplified[(j-1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN374@simplifyCo
	lea	rax, QWORD PTR [rdi+4]
	test	rax, rax
	js	SHORT $LN1079@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN374@simplifyCo
$LN1079@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN374@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 351  : 				simplified[j*4+1] = simplified[(j-1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+16], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN316@simplifyCo
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN1080@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN316@simplifyCo
$LN1080@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN316@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 352  : 				simplified[j*4+2] = simplified[(j-1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN308@simplifyCo
	lea	rax, QWORD PTR [rdi+5]
	test	rax, rax
	js	SHORT $LN1081@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN308@simplifyCo
$LN1081@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN308@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 352  : 				simplified[j*4+2] = simplified[(j-1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+20], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN300@simplifyCo
	lea	rax, QWORD PTR [rdi+3]
	test	rax, rax
	jle	SHORT $LN1082@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jle	SHORT $LN300@simplifyCo
$LN1082@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN300@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 353  : 				simplified[j*4+3] = simplified[(j-1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rbp-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN292@simplifyCo
	lea	rax, QWORD PTR [rdi+6]
	test	rax, rax
	js	SHORT $LN1083@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN292@simplifyCo
$LN1083@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN292@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 353  : 				simplified[j*4+3] = simplified[(j-1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	sub	rbp, 16
	mov	DWORD PTR [rax+rdi*4+24], esi
	sub	rdi, 4
	sub	r14, 1
	jne	$LL18@simplifyCo
$LN17@simplifyCo:

; 356  : 			simplified[(i+1)*4+0] = points[maxi*4+0];

	mov	r15d, DWORD PTR maxi$2$[rsp]
	lea	eax, DWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN284@simplifyCo
	test	eax, eax
	js	SHORT $LN1087@simplifyCo
	mov	rax, QWORD PTR points$1$[rsp]
	cmp	rdi, QWORD PTR [rax]
	jl	SHORT $LN284@simplifyCo
$LN1087@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN284@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 356  : 			simplified[(i+1)*4+0] = points[maxi*4+0];

	mov	r13, QWORD PTR points$1$[rsp]
	lea	rsi, QWORD PTR [r12*4+4]
	mov	rax, QWORD PTR [r13+16]
	mov	ebp, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN276@simplifyCo
	test	rsi, rsi
	js	SHORT $LN277@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN276@simplifyCo
$LN277@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN276@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 356  : 			simplified[(i+1)*4+0] = points[maxi*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rsi*4], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	lea	rsi, QWORD PTR [rdi+1]

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN342@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1088@simplifyCo
	cmp	rsi, QWORD PTR [r13]
	jl	SHORT $LN342@simplifyCo
$LN1088@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN342@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 357  : 			simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	rax, QWORD PTR [r13+16]
	mov	ebp, DWORD PTR [rax+rsi*4]
	lea	rsi, QWORD PTR [r12*4+5]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN268@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1089@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN268@simplifyCo
$LN1089@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN268@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 357  : 			simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	add	rdi, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 357  : 			simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	DWORD PTR [rax+rsi*4], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN260@simplifyCo
	test	rdi, rdi
	js	SHORT $LN261@simplifyCo
	cmp	rdi, QWORD PTR [r13]
	jl	SHORT $LN260@simplifyCo
$LN261@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN260@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 358  : 			simplified[(i+1)*4+2] = points[maxi*4+2];

	mov	rax, QWORD PTR [r13+16]
	mov	esi, DWORD PTR [rax+rdi*4]
	lea	rdi, QWORD PTR [r12*4+6]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN252@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1069@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN252@simplifyCo
$LN1069@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN252@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 358  : 			simplified[(i+1)*4+2] = points[maxi*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4], esi

; 359  : 			simplified[(i+1)*4+3] = maxi;

	lea	rdi, QWORD PTR [r12*4+7]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN366@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1070@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN366@simplifyCo
$LN1070@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN366@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 359  : 			simplified[(i+1)*4+3] = maxi;

	mov	rax, QWORD PTR [rbx+16]

; 360  : 		}

	mov	r8d, DWORD PTR i$1$[rsp]
	mov	DWORD PTR [rax+rdi*4], r15d
	jmp	SHORT $LN44@simplifyCo
$LN43@simplifyCo:

; 361  : 		else
; 362  : 		{
; 363  : 			++i;

	mov	r12, QWORD PTR $T2[rsp]
	mov	r8d, DWORD PTR tv7782[rsp]
	inc	r12
	mov	r13, QWORD PTR points$1$[rsp]
	mov	QWORD PTR $T2[rsp], r12
	mov	DWORD PTR i$1$[rsp], r8d
$LN44@simplifyCo:

; 289  : 	for (int i = 0; i < simplified.size()/4; )

	mov	ecx, DWORD PTR [rbx]
	mov	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	r8d, eax
	jl	$LL11@simplifyCo
	movaps	xmm14, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	xor	r11d, r11d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 289  : 	for (int i = 0; i < simplified.size()/4; )

	movaps	xmm13, XMMWORD PTR [rsp+128]
	movaps	xmm12, XMMWORD PTR [rsp+144]
	movaps	xmm11, XMMWORD PTR [rsp+160]
	movaps	xmm10, XMMWORD PTR [rsp+176]
	movaps	xmm9, XMMWORD PTR [rsp+192]
	movaps	xmm8, XMMWORD PTR [rsp+208]
	movaps	xmm7, XMMWORD PTR [rsp+224]
	movaps	xmm6, XMMWORD PTR [rsp+240]
$LN1090@simplifyCo:

; 364  : 		}
; 365  : 	}
; 366  : 	
; 367  : 	// Split too long edges.
; 368  : 	if (maxEdgeLen > 0 && (buildFlags & (RC_CONTOUR_TESS_WALL_EDGES|RC_CONTOUR_TESS_AREA_EDGES)) != 0)

	cmp	DWORD PTR maxEdgeLen$1$[rsp], 0
	mov	r8d, ecx
	movaps	xmm15, XMMWORD PTR [rsp+96]
	jle	$LN20@simplifyCo

; 369  : 	{
; 370  : 		for (int i = 0; i < simplified.size()/4; )

	mov	eax, ecx
	mov	DWORD PTR i$1$[rsp], r11d
	cdq
	mov	r10d, r11d
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	test	eax, eax
	jle	$LN20@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	r12, r11
	mov	QWORD PTR $T3[rsp], r11
	npad	10
$LL19@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 372  : 			const int ii = (i+1) % (simplified.size()/4);

	mov	eax, ecx
	lea	r8d, DWORD PTR [r10+1]
	cdq
	mov	DWORD PTR tv7767[rsp], r8d
	and	edx, 3

; 374  : 			const int ax = simplified[i*4+0];

	lea	rbp, QWORD PTR [r12*4]
	lea	ecx, DWORD PTR [rdx+rax]
	mov	eax, r8d
	sar	ecx, 2
	cdq
	idiv	ecx
	mov	esi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN350@simplifyCo
	test	rbp, rbp
	js	SHORT $LN1094@simplifyCo
	cmp	rbp, QWORD PTR [rbx]
	jl	SHORT $LN350@simplifyCo
$LN1094@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN350@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 374  : 			const int ax = simplified[i*4+0];

	mov	rax, QWORD PTR [rbx+16]

; 375  : 			const int az = simplified[i*4+2];

	lea	rdi, QWORD PTR [rbp+2]
	mov	r12d, DWORD PTR [rax+rbp*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN358@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1095@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN358@simplifyCo
$LN1095@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN358@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 375  : 			const int az = simplified[i*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	r13d, DWORD PTR [rax+rdi*4]

; 376  : 			const int ai = simplified[i*4+3];

	lea	rdi, QWORD PTR [rbp+3]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN382@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1096@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN382@simplifyCo
$LN1096@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN382@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 376  : 			const int ai = simplified[i*4+3];

	mov	rax, QWORD PTR [rbx+16]
	mov	ebp, DWORD PTR [rax+rdi*4]

; 378  : 			const int bx = simplified[ii*4+0];

	lea	eax, DWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN390@simplifyCo
	test	eax, eax
	js	SHORT $LN1097@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN390@simplifyCo
$LN1097@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN390@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 378  : 			const int bx = simplified[ii*4+0];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	lea	rsi, QWORD PTR [rdi+2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 378  : 			const int bx = simplified[ii*4+0];

	mov	r14d, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN398@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1027@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN398@simplifyCo
$LN1027@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN398@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 379  : 			const int bz = simplified[ii*4+2];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	add	rdi, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 379  : 			const int bz = simplified[ii*4+2];

	mov	r15d, DWORD PTR [rax+rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN406@simplifyCo
	test	rdi, rdi
	js	SHORT $LN407@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN406@simplifyCo
$LN407@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN406@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 380  : 			const int bi = simplified[ii*4+3];

	mov	rax, QWORD PTR [rbx+16]

; 381  : 			
; 382  : 			// Find maximum deviation from the segment.
; 383  : 			int maxi = -1;
; 384  : 			int ci = (ai+1) % pn;

	mov	r8d, DWORD PTR pn$1$[rsp]
	mov	esi, DWORD PTR [rax+rdi*4]
	lea	eax, DWORD PTR [rbp+1]
	cdq
	idiv	r8d

; 389  : 			if ((buildFlags & RC_CONTOUR_TESS_WALL_EDGES) && (points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0)

	lea	edx, DWORD PTR [rdx*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, edx
	add	rdi, 3

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN1114@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1028@simplifyCo
	mov	rax, QWORD PTR points$1$[rsp]
	cmp	rdi, QWORD PTR [rax]
	jl	SHORT $LN536@simplifyCo
$LN1028@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	r8d, DWORD PTR pn$1$[rsp]
$LN1114@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 389  : 			if ((buildFlags & RC_CONTOUR_TESS_WALL_EDGES) && (points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0)

	mov	rax, QWORD PTR points$1$[rsp]
$LN536@simplifyCo:
	mov	rax, QWORD PTR [rax+16]
	movzx	ecx, WORD PTR [rax+rdi*4]
	test	ecx, ecx
	jne	$LN54@simplifyCo

; 390  : 				tess = true;
; 391  : 			// Edges between areas.
; 392  : 			if ((buildFlags & RC_CONTOUR_TESS_AREA_EDGES) && (points[ci*4+3] & RC_AREA_BORDER))
; 393  : 				tess = true;
; 394  : 			
; 395  : 			if (tess)
; 396  : 			{
; 397  : 				int dx = bx - ax;

	mov	eax, r14d

; 398  : 				int dz = bz - az;

	mov	ecx, r15d
	sub	eax, r12d
	sub	ecx, r13d

; 399  : 				if (dx*dx + dz*dz > maxEdgeLen*maxEdgeLen)

	imul	eax, eax
	imul	ecx, ecx
	add	ecx, eax
	mov	eax, DWORD PTR maxEdgeLen$1$[rsp]
	imul	eax, eax
	cmp	ecx, eax
	jle	$LN54@simplifyCo

; 400  : 				{
; 401  : 					// Round based on the segments in lexilogical order so that the
; 402  : 					// max tesselation is consistent regardless in which direction
; 403  : 					// segments are traversed.
; 404  : 					const int n = bi < ai ? (bi+pn - ai) : (bi - ai);

	mov	eax, esi
	sub	eax, ebp

; 405  : 					if (n > 1)

	cmp	esi, ebp
	lea	ecx, DWORD PTR [rax+r8]
	cmovge	ecx, eax
	cmp	ecx, 1
	jle	$LN54@simplifyCo

; 406  : 					{
; 407  : 						if (bx > ax || (bx == ax && bz > az))

	cmp	r14d, r12d
	jg	SHORT $LN53@simplifyCo
	jne	SHORT $LN51@simplifyCo
	cmp	r15d, r13d
	jg	SHORT $LN53@simplifyCo
$LN51@simplifyCo:

; 409  : 						else
; 410  : 							maxi = (ai + (n+1)/2) % pn;

	lea	eax, DWORD PTR [rcx+1]
	jmp	SHORT $LN1344@simplifyCo
$LN53@simplifyCo:

; 408  : 							maxi = (ai + n/2) % pn;

	mov	eax, ecx
$LN1344@simplifyCo:

; 411  : 					}
; 412  : 				}
; 413  : 			}
; 414  : 			
; 415  : 			// If the max deviation is larger than accepted error,
; 416  : 			// add new point, else continue to next segment.
; 417  : 			if (maxi != -1)

	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ebp
	cdq
	idiv	r8d
	mov	r15d, edx
	cmp	edx, -1
	je	$LN54@simplifyCo

; 420  : 				simplified.resize(simplified.size()+4);

	mov	ebp, DWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 232  : 	if (size < m_size) {

	mov	rax, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 420  : 				simplified.resize(simplified.size()+4);

	add	ebp, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 334  : 	void resize(int size) { m_impl.resize(size); }

	movsxd	rdi, ebp

; 232  : 	if (size < m_size) {

	cmp	rdi, rax
	jl	SHORT $LN1345@simplifyCo

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN484@simplifyCo

; 236  : 		if (size <= m_cap) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rdi, rax
	jle	SHORT $LN1345@simplifyCo

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN503@simplifyCo

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN505@simplifyCo
$LN503@simplifyCo:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	mov	rsi, rdi
	cmp	rax, rdi
	cmovg	rsi, rax
$LN505@simplifyCo:

; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {
; 249  : 				construct_range(new_data + m_size, new_data + size, *value);
; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	r14, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN519@simplifyCo

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN519@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 257  : 			m_size = size;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], r14
	mov	QWORD PTR [rbx+8], rsi
$LN1345@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 421  : 				const int n = simplified.size()/4;

	mov	QWORD PTR [rbx], rdi
	mov	eax, ebp
$LN484@simplifyCo:

; 422  : 				for (int j = n-1; j > i; --j)

	mov	r12, QWORD PTR $T3[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	dec	eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 342  : 	int size() const { return static_cast<int>(m_impl.size()); }

	movsxd	r14, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 422  : 				for (int j = n-1; j > i; --j)

	cmp	r14, r12
	jle	$LN23@simplifyCo

; 421  : 				const int n = simplified.size()/4;

	mov	rbp, r14
	lea	rdi, QWORD PTR [r14*4-3]
	shl	rbp, 4
	sub	r14, r12
$LL24@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN234@simplifyCo
	test	rdi, rdi
	jle	SHORT $LN1103@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jle	SHORT $LN234@simplifyCo
$LN1103@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN234@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 424  : 					simplified[j*4+0] = simplified[(j-1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN226@simplifyCo
	lea	rax, QWORD PTR [rdi+3]
	test	rax, rax
	js	SHORT $LN1104@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN226@simplifyCo
$LN1104@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN226@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 424  : 					simplified[j*4+0] = simplified[(j-1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+12], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN210@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1105@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN210@simplifyCo
$LN1105@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN210@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 425  : 					simplified[j*4+1] = simplified[(j-1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN202@simplifyCo
	lea	rax, QWORD PTR [rdi+4]
	test	rax, rax
	js	SHORT $LN1098@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN202@simplifyCo
$LN1098@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN202@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 425  : 					simplified[j*4+1] = simplified[(j-1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+16], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN194@simplifyCo
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN1099@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN194@simplifyCo
$LN1099@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN194@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 426  : 					simplified[j*4+2] = simplified[(j-1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN186@simplifyCo
	lea	rax, QWORD PTR [rdi+5]
	test	rax, rax
	js	SHORT $LN1100@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN186@simplifyCo
$LN1100@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN186@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 426  : 					simplified[j*4+2] = simplified[(j-1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4+20], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN178@simplifyCo
	lea	rax, QWORD PTR [rdi+3]
	test	rax, rax
	jle	SHORT $LN1101@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jle	SHORT $LN178@simplifyCo
$LN1101@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN178@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 427  : 					simplified[j*4+3] = simplified[(j-1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rbp-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN242@simplifyCo
	lea	rax, QWORD PTR [rdi+6]
	test	rax, rax
	js	SHORT $LN1102@simplifyCo
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN242@simplifyCo
$LN1102@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN242@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 427  : 					simplified[j*4+3] = simplified[(j-1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	sub	rbp, 16
	mov	DWORD PTR [rax+rdi*4+24], esi
	sub	rdi, 4
	sub	r14, 1
	jne	$LL24@simplifyCo
$LN23@simplifyCo:

; 430  : 				simplified[(i+1)*4+0] = points[maxi*4+0];

	lea	eax, DWORD PTR [r15*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN218@simplifyCo
	test	eax, eax
	js	SHORT $LN1106@simplifyCo
	mov	rax, QWORD PTR points$1$[rsp]
	cmp	rdi, QWORD PTR [rax]
	jl	SHORT $LN218@simplifyCo
$LN1106@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN218@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 430  : 				simplified[(i+1)*4+0] = points[maxi*4+0];

	mov	r13, QWORD PTR points$1$[rsp]
	lea	rsi, QWORD PTR [r12*4+4]
	mov	rax, QWORD PTR [r13+16]
	mov	ebp, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN170@simplifyCo
	test	rsi, rsi
	js	SHORT $LN171@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN170@simplifyCo
$LN171@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN170@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 430  : 				simplified[(i+1)*4+0] = points[maxi*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rsi*4], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	lea	rsi, QWORD PTR [rdi+1]

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN162@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1107@simplifyCo
	cmp	rsi, QWORD PTR [r13]
	jl	SHORT $LN162@simplifyCo
$LN1107@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN162@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 431  : 				simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	rax, QWORD PTR [r13+16]
	mov	ebp, DWORD PTR [rax+rsi*4]
	lea	rsi, QWORD PTR [r12*4+5]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN154@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1091@simplifyCo
	cmp	rsi, QWORD PTR [rbx]
	jl	SHORT $LN154@simplifyCo
$LN1091@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN154@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 431  : 				simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	rax, QWORD PTR [rbx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	add	rdi, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 431  : 				simplified[(i+1)*4+1] = points[maxi*4+1];

	mov	DWORD PTR [rax+rsi*4], ebp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN146@simplifyCo
	test	rdi, rdi
	js	SHORT $LN147@simplifyCo
	cmp	rdi, QWORD PTR [r13]
	jl	SHORT $LN146@simplifyCo
$LN147@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN146@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 432  : 				simplified[(i+1)*4+2] = points[maxi*4+2];

	mov	rax, QWORD PTR [r13+16]
	mov	esi, DWORD PTR [rax+rdi*4]
	lea	rdi, QWORD PTR [r12*4+6]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN138@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1092@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN138@simplifyCo
$LN1092@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN138@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 432  : 				simplified[(i+1)*4+2] = points[maxi*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4], esi

; 433  : 				simplified[(i+1)*4+3] = maxi;

	lea	rdi, QWORD PTR [r12*4+7]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN130@simplifyCo
	test	rdi, rdi
	js	SHORT $LN1093@simplifyCo
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN130@simplifyCo
$LN1093@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN130@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 433  : 				simplified[(i+1)*4+3] = maxi;

	mov	rax, QWORD PTR [rbx+16]

; 434  : 			}

	mov	r10d, DWORD PTR i$1$[rsp]
	mov	DWORD PTR [rax+rdi*4], r15d
	jmp	SHORT $LN55@simplifyCo
$LN54@simplifyCo:

; 435  : 			else
; 436  : 			{
; 437  : 				++i;

	mov	r12, QWORD PTR $T3[rsp]
	mov	r10d, DWORD PTR tv7767[rsp]
	inc	r12
	mov	r13, QWORD PTR points$1$[rsp]
	mov	QWORD PTR $T3[rsp], r12
	mov	DWORD PTR i$1$[rsp], r10d
$LN55@simplifyCo:

; 369  : 	{
; 370  : 		for (int i = 0; i < simplified.size()/4; )

	mov	r8d, DWORD PTR [rbx]
	mov	eax, r8d
	cdq
	mov	ecx, r8d
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	r10d, eax
	jl	$LL19@simplifyCo
$LN20@simplifyCo:

; 438  : 			}
; 439  : 		}
; 440  : 	}
; 441  : 	
; 442  : 	for (int i = 0; i < simplified.size()/4; ++i)

	mov	r15, QWORD PTR [rsp+320]
	mov	eax, r8d
	mov	r12, QWORD PTR [rsp+304]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	test	eax, eax
	jle	$LN26@simplifyCo
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	mov	ebp, 3
$LL27@simplifyCo:

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN98@simplifyCo
	test	rbp, rbp
	js	SHORT $LN1109@simplifyCo
	cmp	rbp, QWORD PTR [rbx]
	jl	SHORT $LN98@simplifyCo
$LN1109@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN98@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 446  : 		const int ai = (simplified[i*4+3]+1) % pn;

	mov	rax, QWORD PTR [rbx+16]
	mov	eax, DWORD PTR [rax+rbp*4]
	inc	eax
	cdq
	idiv	DWORD PTR pn$1$[rsp]
	mov	edi, edx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN90@simplifyCo
	test	rbp, rbp
	js	SHORT $LN1111@simplifyCo
	cmp	rbp, QWORD PTR [rbx]
	jl	SHORT $LN90@simplifyCo
$LN1111@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN90@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 448  : 		simplified[i*4+3] = (points[ai*4+3] & (RC_CONTOUR_REG_MASK|RC_AREA_BORDER)) | (points[bi*4+3] & RC_BORDER_VERTEX);

	mov	rax, QWORD PTR [rbx+16]
	mov	ecx, DWORD PTR [rax+rbp*4]
	shl	ecx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rsi, ecx
	add	rsi, 3

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN66@simplifyCo
	test	rsi, rsi
	js	SHORT $LN1110@simplifyCo
	cmp	rsi, QWORD PTR [r13]
	jl	SHORT $LN66@simplifyCo
$LN1110@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN66@simplifyCo:
	mov	r14, QWORD PTR [r13+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 448  : 		simplified[i*4+3] = (points[ai*4+3] & (RC_CONTOUR_REG_MASK|RC_AREA_BORDER)) | (points[bi*4+3] & RC_BORDER_VERTEX);

	lea	eax, DWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 343  : 	int& operator[](int index) { return m_impl[index]; }

	movsxd	rdi, eax
	add	rdi, 3

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN82@simplifyCo
	test	rdi, rdi
	js	SHORT $LN83@simplifyCo
	cmp	rdi, QWORD PTR [r13]
	jl	SHORT $LN82@simplifyCo
$LN83@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN82@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 448  : 		simplified[i*4+3] = (points[ai*4+3] & (RC_CONTOUR_REG_MASK|RC_AREA_BORDER)) | (points[bi*4+3] & RC_BORDER_VERTEX);

	mov	rax, QWORD PTR [r13+16]
	mov	edi, DWORD PTR [rax+rdi*4]
	mov	eax, DWORD PTR [r14+rsi*4]
	and	edi, 196607				; 0002ffffH
	and	eax, 65536				; 00010000H
	or	edi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN74@simplifyCo
	test	rbp, rbp
	js	SHORT $LN1108@simplifyCo
	cmp	rbp, QWORD PTR [rbx]
	jl	SHORT $LN74@simplifyCo
$LN1108@simplifyCo:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN74@simplifyCo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 448  : 		simplified[i*4+3] = (points[ai*4+3] & (RC_CONTOUR_REG_MASK|RC_AREA_BORDER)) | (points[bi*4+3] & RC_BORDER_VERTEX);

	mov	rax, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR tv7968[rsp]
	inc	ecx
	mov	QWORD PTR tv7968[rsp], rcx
	mov	DWORD PTR [rax+rbp*4], edi
	add	rbp, 4
	mov	eax, DWORD PTR [rbx]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ecx, eax
	jl	$LL27@simplifyCo
$LN26@simplifyCo:

; 449  : 	}
; 450  : 	
; 451  : }

	mov	rbx, QWORD PTR [rsp+328]
	add	rsp, 256				; 00000100H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?simplifyContour@@YAXAEAVrcIntArray@@0MHH@Z ENDP	; simplifyContour
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?calcAreaOfPolygon2D@@YAHPEBHH@Z
_TEXT	SEGMENT
verts$ = 8
nverts$ = 16
?calcAreaOfPolygon2D@@YAHPEBHH@Z PROC			; calcAreaOfPolygon2D, COMDAT

; 455  : 	int area = 0;

	xor	r9d, r9d
	mov	r10, rcx

; 456  : 	for (int i = 0, j = nverts-1; i < nverts; j=i++)

	test	edx, edx
	jle	SHORT $LN3@calcAreaOf
	movsxd	rax, edx
	mov	r8, rcx
	shl	rax, 4
	sub	rax, 16
	mov	edx, edx
	npad	6
$LL4@calcAreaOf:

; 457  : 	{
; 458  : 		const int* vi = &verts[i*4];
; 459  : 		const int* vj = &verts[j*4];
; 460  : 		area += vi[0] * vj[2] - vj[0] * vi[2];

	mov	ecx, DWORD PTR [r8+8]
	imul	ecx, DWORD PTR [rax+r10]
	mov	eax, DWORD PTR [rax+r10+8]
	imul	eax, DWORD PTR [r8]
	sub	eax, ecx
	add	r9d, eax
	mov	rax, r8
	sub	rax, r10
	add	r8, 16
	sub	rdx, 1
	jne	SHORT $LL4@calcAreaOf
$LN3@calcAreaOf:

; 461  : 	}
; 462  : 	return (area+1) / 2;

	lea	eax, DWORD PTR [r9+1]
	cdq
	sub	eax, edx
	sar	eax, 1

; 463  : }

	ret	0
?calcAreaOfPolygon2D@@YAHPEBHH@Z ENDP			; calcAreaOfPolygon2D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?prev@@YAHHH@Z
_TEXT	SEGMENT
i$ = 8
n$ = 16
?prev@@YAHHH@Z PROC					; prev, COMDAT

; 467  : inline int prev(int i, int n) { return i-1 >= 0 ? i-1 : n-1; }

	lea	eax, DWORD PTR [rcx-1]
	test	eax, eax
	cmovs	ecx, edx
	lea	eax, DWORD PTR [rcx-1]
	ret	0
?prev@@YAHHH@Z ENDP					; prev
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?next@@YAHHH@Z
_TEXT	SEGMENT
i$ = 8
n$ = 16
?next@@YAHHH@Z PROC					; next, COMDAT

; 468  : inline int next(int i, int n) { return i+1 < n ? i+1 : 0; }

	lea	eax, DWORD PTR [rcx+1]
	xor	ecx, ecx
	cmp	eax, edx
	cmovge	eax, ecx
	ret	0
?next@@YAHHH@Z ENDP					; next
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?area2@@YAHPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?area2@@YAHPEBH00@Z PROC				; area2, COMDAT

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r9d, DWORD PTR [rcx+8]
	mov	r10d, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rdx]
	mov	edx, DWORD PTR [rdx+8]
	sub	ecx, r10d
	mov	eax, DWORD PTR [r8+8]
	sub	edx, r9d
	sub	eax, r9d
	imul	eax, ecx
	mov	ecx, DWORD PTR [r8]
	sub	ecx, r10d
	imul	edx, ecx
	sub	eax, edx

; 473  : }

	ret	0
?area2@@YAHPEBH00@Z ENDP				; area2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?xorb@@YA_N_N0@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?xorb@@YA_N_N0@Z PROC					; xorb, COMDAT

; 481  : 	return !x ^ !y;

	xor	cl, dl
	movzx	eax, cl

; 482  : }

	ret	0
?xorb@@YA_N_N0@Z ENDP					; xorb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?left@@YA_NPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?left@@YA_NPEBH00@Z PROC				; left, COMDAT

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r9d, DWORD PTR [rcx+8]
	mov	r10d, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rdx]
	mov	edx, DWORD PTR [rdx+8]
	sub	ecx, r10d
	mov	eax, DWORD PTR [r8+8]
	sub	edx, r9d
	sub	eax, r9d
	imul	eax, ecx
	mov	ecx, DWORD PTR [r8]
	sub	ecx, r10d
	imul	edx, ecx
	sub	eax, edx

; 488  : 	return area2(a, b, c) < 0;

	shr	eax, 31

; 489  : }

	ret	0
?left@@YA_NPEBH00@Z ENDP				; left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?leftOn@@YA_NPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?leftOn@@YA_NPEBH00@Z PROC				; leftOn, COMDAT

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r10d, DWORD PTR [rcx]
	mov	r9d, DWORD PTR [rcx+8]
	mov	r11d, DWORD PTR [r8+8]
	mov	eax, DWORD PTR [rdx]
	sub	r11d, r9d
	mov	ecx, DWORD PTR [rdx+8]
	sub	eax, r10d
	imul	r11d, eax
	sub	ecx, r9d
	mov	eax, DWORD PTR [r8]
	sub	eax, r10d
	imul	ecx, eax
	sub	r11d, ecx

; 493  : 	return area2(a, b, c) <= 0;

	test	r11d, r11d
	setle	al

; 494  : }

	ret	0
?leftOn@@YA_NPEBH00@Z ENDP				; leftOn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?collinear@@YA_NPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?collinear@@YA_NPEBH00@Z PROC				; collinear, COMDAT

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r10d, DWORD PTR [rcx]
	mov	r9d, DWORD PTR [rcx+8]
	mov	r11d, DWORD PTR [r8+8]
	mov	eax, DWORD PTR [rdx]
	sub	r11d, r9d
	mov	ecx, DWORD PTR [rdx+8]
	sub	eax, r10d
	imul	r11d, eax
	sub	ecx, r9d
	mov	eax, DWORD PTR [r8]
	sub	eax, r10d
	imul	ecx, eax

; 498  : 	return area2(a, b, c) == 0;

	cmp	r11d, ecx
	sete	al

; 499  : }

	ret	0
?collinear@@YA_NPEBH00@Z ENDP				; collinear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?intersectProp@@YA_NPEBH000@Z
_TEXT	SEGMENT
a$ = 16
b$ = 24
c$ = 32
d$ = 40
?intersectProp@@YA_NPEBH000@Z PROC			; intersectProp, COMDAT

; 505  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [r8]
	mov	eax, ebp
	mov	esi, DWORD PTR [r8+8]
	mov	r8d, esi
	mov	r10d, DWORD PTR [rcx+8]
	sub	r8d, r10d
	mov	ebx, DWORD PTR [rcx]
	sub	eax, ebx
	mov	r11d, DWORD PTR [rdx]
	mov	r14d, r11d
	mov	ecx, DWORD PTR [rdx+8]
	sub	r14d, ebx
	mov	edx, ecx
	imul	r8d, r14d
	sub	edx, r10d
	imul	eax, edx
	sub	r8d, eax

; 506  : 	// Eliminate improper cases.
; 507  : 	if (collinear(a,b,c) || collinear(a,b,d) ||
; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	edi, DWORD PTR [r9+8]
	mov	r9d, DWORD PTR [r9]
	mov	eax, r9d
	sub	eax, ebx
	imul	eax, edx
	mov	edx, edi
	sub	edx, r10d
	imul	edx, r14d
	sub	edx, eax

; 506  : 	// Eliminate improper cases.
; 507  : 	if (collinear(a,b,c) || collinear(a,b,d) ||
; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r9d, ebp
	sub	edi, esi
	sub	ebx, ebp
	sub	r10d, esi
	imul	ebx, edi
	imul	r10d, r9d
	sub	r10d, ebx

; 506  : 	// Eliminate improper cases.
; 507  : 	if (collinear(a,b,c) || collinear(a,b,d) ||
; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r11d, ebp
	sub	ecx, esi
	imul	r11d, edi
	imul	ecx, r9d
	sub	ecx, r11d

; 506  : 	// Eliminate improper cases.
; 507  : 	if (collinear(a,b,c) || collinear(a,b,d) ||
; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN3@intersectP

; 481  : 	return !x ^ !y;

	shr	edx, 31
	shr	r8d, 31
	xor	dl, r8b

; 509  : 		return false;
; 510  : 	
; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN3@intersectP

; 481  : 	return !x ^ !y;

	shr	ecx, 31
	shr	r10d, 31
	xor	cl, r10b

; 509  : 		return false;
; 510  : 	
; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN3@intersectP
	mov	al, 1
	jmp	SHORT $LN1@intersectP
$LN3@intersectP:

; 512  : }

	xor	al, al
$LN1@intersectP:
	mov	rbx, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+40]
	pop	r14
	ret	0
?intersectProp@@YA_NPEBH000@Z ENDP			; intersectProp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?between@@YA_NPEBH00@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
c$ = 24
?between@@YA_NPEBH00@Z PROC				; between, COMDAT

; 517  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebx, DWORD PTR [rcx+8]
	mov	edi, DWORD PTR [rdx+8]
	mov	r11d, DWORD PTR [rcx]
	mov	r9d, DWORD PTR [r8]
	mov	ecx, r9d
	mov	r10d, DWORD PTR [r8+8]
	sub	ecx, r11d
	mov	r8d, DWORD PTR [rdx]
	mov	eax, r10d
	sub	eax, ebx
	mov	edx, r8d
	sub	edx, r11d
	imul	edx, eax
	mov	eax, edi
	sub	eax, ebx
	imul	ecx, eax
	cmp	edx, ecx

; 518  : 	if (!collinear(a, b, c))

	jne	SHORT $LN11@between

; 519  : 		return false;
; 520  : 	// If ab not vertical, check betweenness on x; else on y.
; 521  : 	if (a[0] != b[0])

	cmp	r11d, r8d
	je	SHORT $LN3@between

; 522  : 		return	((a[0] <= c[0]) && (c[0] <= b[0])) || ((a[0] >= c[0]) && (c[0] >= b[0]));

	cmp	r11d, r9d
	jg	SHORT $LN25@between
	cmp	r9d, r8d
	jle	SHORT $LN12@between
	cmp	r11d, r9d
	jl	SHORT $LN11@between
$LN25@between:
	cmp	r9d, r8d
	jmp	SHORT $LN26@between
$LN3@between:

; 523  : 	else
; 524  : 		return	((a[2] <= c[2]) && (c[2] <= b[2])) || ((a[2] >= c[2]) && (c[2] >= b[2]));

	cmp	ebx, r10d
	jg	SHORT $LN28@between
	cmp	r10d, edi
	jle	SHORT $LN12@between
	cmp	ebx, r10d
	jl	SHORT $LN11@between
$LN28@between:
	cmp	r10d, edi
$LN26@between:

; 525  : }

	jl	SHORT $LN11@between
$LN12@between:
	mov	al, 1
	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN11@between:
	mov	rbx, QWORD PTR [rsp+8]
	xor	al, al
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?between@@YA_NPEBH00@Z ENDP				; between
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?intersect@@YA_NPEBH000@Z
_TEXT	SEGMENT
a$ = 80
b$ = 88
c$ = 96
d$ = 104
?intersect@@YA_NPEBH000@Z PROC				; intersect, COMDAT

; 529  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r10d, DWORD PTR [rdx+8]

; 529  : {

	mov	r14, rdx

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r11d, DWORD PTR [rcx+8]

; 529  : {

	mov	rsi, r8

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r13d, DWORD PTR [r8+8]

; 529  : {

	mov	rdi, rcx

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r8d, DWORD PTR [rdx]

; 529  : {

	mov	rbx, r9

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r9d, DWORD PTR [rcx]
	mov	r12d, r8d
	mov	eax, DWORD PTR [rsi]
	sub	r12d, r9d
	sub	eax, r9d
	mov	ecx, r10d
	sub	ecx, r11d
	mov	edx, r13d
	sub	edx, r11d
	imul	eax, ecx
	imul	edx, r12d
	sub	edx, eax

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN2@intersect

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [rbx]
	mov	eax, ebp
	mov	r15d, DWORD PTR [rbx+8]
	sub	eax, r9d
	imul	eax, ecx
	mov	ecx, r15d
	sub	ecx, r11d
	imul	ecx, r12d
	sub	ecx, eax

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN2@intersect

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	eax, DWORD PTR [rsi]
	sub	r15d, r13d
	sub	ebp, eax
	sub	r9d, eax
	sub	r11d, r13d
	imul	r9d, r15d
	imul	r11d, ebp
	sub	r11d, r9d

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN2@intersect

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r8d, eax
	sub	r10d, r13d
	imul	r8d, r15d
	imul	r10d, ebp
	sub	r10d, r8d

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN2@intersect

; 481  : 	return !x ^ !y;

	shr	ecx, 31
	shr	edx, 31
	xor	cl, dl

; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN2@intersect

; 481  : 	return !x ^ !y;

	shr	r10d, 31
	shr	r11d, 31
	xor	r10b, r11b

; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	jne	SHORT $LN6@intersect
$LN2@intersect:

; 530  : 	if (intersectProp(a, b, c, d))
; 531  : 		return true;
; 532  : 	else if (between(a, b, c) || between(a, b, d) ||
; 533  : 			 between(c, d, a) || between(c, d, b))

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rdi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN6@intersect
	mov	r8, rbx
	mov	rdx, r14
	mov	rcx, rdi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN6@intersect
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN6@intersect
	mov	r8, r14
	mov	rdx, rbx
	mov	rcx, rsi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	setne	al
	jmp	SHORT $LN5@intersect
$LN6@intersect:

; 534  : 		return true;

	mov	al, 1
$LN5@intersect:

; 535  : 	else
; 536  : 		return false;
; 537  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?intersect@@YA_NPEBH000@Z ENDP				; intersect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?vequal@@YA_NPEBH0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
?vequal@@YA_NPEBH0@Z PROC				; vequal, COMDAT

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jne	SHORT $LN3@vequal
	mov	eax, DWORD PTR [rdx+8]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN3@vequal
	mov	al, 1

; 542  : }

	ret	0
$LN3@vequal:

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	xor	al, al

; 542  : }

	ret	0
?vequal@@YA_NPEBH0@Z ENDP				; vequal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?intersectSegContour@@YA_NPEBH0HH0@Z
_TEXT	SEGMENT
tv944 = 32
tv952 = 36
tv963 = 40
tv967 = 48
tv976 = 56
d0$ = 112
d1$ = 120
i$ = 128
n$ = 136
verts$ = 144
?intersectSegContour@@YA_NPEBH0HH0@Z PROC		; intersectSegContour, COMDAT

; 545  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	DWORD PTR [rsp+32], r9d
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	rsi, rdx
	mov	r14, rcx

; 546  : 	// For each edge (k,k+1) of P
; 547  : 	for (int k = 0; k < n; k++)

	test	r9d, r9d
	jle	$LN3@intersectS

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	rcx, QWORD PTR verts$[rsp]
	mov	r12d, 1

; 548  : 	{
; 549  : 		int k1 = next(k, n);
; 550  : 		// Skip edges incident to i.
; 551  : 		if (i == k || i == k1)

	movsxd	rax, r8d
	xor	r8d, r8d
	mov	edi, r8d
	mov	QWORD PTR tv967[rsp], rax

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	DWORD PTR tv944[rsp], r12d
$LL4@intersectS:

; 548  : 	{
; 549  : 		int k1 = next(k, n);
; 550  : 		// Skip edges incident to i.
; 551  : 		if (i == k || i == k1)

	lea	rdx, QWORD PTR [rdi+1]
	cmp	r12d, r9d
	mov	rbx, rdx
	mov	QWORD PTR tv976[rsp], rdx
	cmovge	rbx, r8
	cmp	rax, rdi
	je	$LN2@intersectS
	cmp	rax, rbx
	je	$LN2@intersectS

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	ebp, DWORD PTR [r14]

; 552  : 			continue;
; 553  : 		const int* p0 = &verts[k * 4];

	shl	rdi, 4
	add	rdi, rcx

; 554  : 		const int* p1 = &verts[k1 * 4];

	shl	rbx, 4
	add	rbx, rcx

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	r15d, DWORD PTR [rdi]
	cmp	ebp, r15d
	jne	SHORT $LN92@intersectS
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [r14+8], eax
	je	$LN105@intersectS
$LN92@intersectS:
	mov	r10d, DWORD PTR [rsi]
	cmp	r10d, r15d
	jne	SHORT $LN98@intersectS
	mov	eax, DWORD PTR [rdi+8]
	cmp	DWORD PTR [rsi+8], eax
	je	$LN105@intersectS
$LN98@intersectS:
	mov	r11d, DWORD PTR [rbx]
	cmp	ebp, r11d
	jne	SHORT $LN93@intersectS
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [r14+8], eax
	je	$LN105@intersectS
$LN93@intersectS:
	cmp	r10d, r11d
	jne	SHORT $LN96@intersectS
	mov	eax, DWORD PTR [rbx+8]
	cmp	DWORD PTR [rsi+8], eax
	je	$LN105@intersectS
$LN96@intersectS:

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r9d, DWORD PTR [rdi+8]
	mov	r13d, r10d
	mov	ecx, DWORD PTR [r14+8]
	sub	r13d, ebp
	mov	edx, DWORD PTR [rsi+8]
	mov	eax, r15d
	mov	DWORD PTR tv963[rsp], r9d
	sub	eax, ebp
	sub	r9d, ecx
	mov	r8d, edx
	sub	r8d, ecx
	imul	r9d, r13d
	imul	eax, r8d
	mov	DWORD PTR tv952[rsp], r8d
	sub	r9d, eax

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN40@intersectS

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r12d, DWORD PTR [rbx+8]
	mov	eax, r11d
	sub	eax, ebp
	mov	r8d, r12d
	imul	eax, DWORD PTR tv952[rsp]
	sub	r8d, ecx
	imul	r8d, r13d
	sub	r8d, eax

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN103@intersectS

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	eax, DWORD PTR tv963[rsp]
	sub	r11d, r15d
	sub	r12d, eax
	sub	ecx, eax
	sub	ebp, r15d
	imul	ecx, r11d
	imul	ebp, r12d
	sub	ecx, ebp

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN103@intersectS

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	edx, eax
	sub	r10d, r15d
	imul	edx, r11d
	imul	r10d, r12d
	sub	edx, r10d

; 508  : 		collinear(c,d,a) || collinear(c,d,b))

	je	SHORT $LN103@intersectS

; 481  : 	return !x ^ !y;

	shr	r8d, 31
	shr	r9d, 31
	xor	r8b, r9b

; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	je	SHORT $LN103@intersectS

; 481  : 	return !x ^ !y;

	shr	ecx, 31
	shr	edx, 31
	xor	cl, dl

; 511  : 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));

	jne	$LN81@intersectS
$LN103@intersectS:

; 533  : 			 between(c, d, a) || between(c, d, b))

	mov	r12d, DWORD PTR tv944[rsp]
$LN40@intersectS:
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, r14
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	$LN81@intersectS
	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r14
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN81@intersectS
	mov	r8, r14
	mov	rdx, rbx
	mov	rcx, rdi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN81@intersectS
	mov	r8, rsi
	mov	rdx, rbx
	mov	rcx, rdi
	call	?between@@YA_NPEBH00@Z			; between
	test	al, al
	jne	SHORT $LN81@intersectS
	mov	rdx, QWORD PTR tv976[rsp]

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	xor	r8d, r8d
	mov	r9d, DWORD PTR n$[rsp]
$LN105@intersectS:

; 546  : 	// For each edge (k,k+1) of P
; 547  : 	for (int k = 0; k < n; k++)

	mov	rax, QWORD PTR tv967[rsp]
	mov	rcx, QWORD PTR verts$[rsp]
$LN2@intersectS:
	mov	rdi, rdx
	inc	r12d
	movsxd	rdx, r9d
	mov	DWORD PTR tv944[rsp], r12d
	cmp	rdi, rdx
	jl	$LL4@intersectS
$LN3@intersectS:

; 560  : 	}
; 561  : 	return false;

	xor	al, al
$LN1@intersectS:

; 562  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN81@intersectS:

; 555  : 		if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
; 556  : 			continue;
; 557  : 		
; 558  : 		if (intersect(d0, d1, p0, p1))
; 559  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@intersectS
?intersectSegContour@@YA_NPEBH0HH0@Z ENDP		; intersectSegContour
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?inCone@@YA_NHHPEBH0@Z
_TEXT	SEGMENT
i$ = 24
n$ = 32
verts$ = 40
pj$ = 48
?inCone@@YA_NHHPEBH0@Z PROC				; inCone, COMDAT

; 565  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 566  : 	const int* pi = &verts[i * 4];

	lea	eax, DWORD PTR [rcx*4]
	mov	r11, r8
	movsxd	r10, eax

; 567  : 	const int* pi1 = &verts[next(i, n) * 4];

	xor	r8d, r8d
	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, edx

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebx, DWORD PTR [r11+r10*4]

; 567  : 	const int* pi1 = &verts[next(i, n) * 4];

	cmovge	eax, r8d
	shl	eax, 2
	cdqe

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	esi, DWORD PTR [r11+rax*4+8]

; 567  : 	const int* pi1 = &verts[next(i, n) * 4];

	lea	r8, QWORD PTR [r11+rax*4]
	lea	eax, DWORD PTR [rcx-1]

; 568  : 	const int* pin1 = &verts[prev(i, n) * 4];

	test	eax, eax
	cmovs	ecx, edx
	lea	eax, DWORD PTR [rcx*4-4]
	movsxd	rcx, eax

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ebp, DWORD PTR [r11+rcx*4+8]
	mov	edi, DWORD PTR [r11+rcx*4]
	mov	ecx, ebx
	mov	r11d, DWORD PTR [r11+r10*4+8]
	sub	ecx, edi
	mov	r10d, DWORD PTR [r8]
	mov	eax, r11d
	mov	r8d, DWORD PTR [r9]
	sub	eax, ebp
	mov	r9d, DWORD PTR [r9+8]
	mov	edx, r10d
	sub	edx, edi
	mov	r14d, r8d
	imul	edx, eax
	mov	r15d, r9d
	mov	eax, esi
	sub	r14d, ebx
	sub	eax, ebp
	sub	r15d, r11d
	imul	ecx, eax
	sub	ecx, edx

; 493  : 	return area2(a, b, c) <= 0;

	test	ecx, ecx

; 569  : 	
; 570  : 	// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].
; 571  : 	if (leftOn(pin1, pi, pi1))

	jg	SHORT $LN2@inCone

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	ebp, r11d
	sub	edi, ebx
	imul	ebp, r14d
	imul	edi, r15d
	cmp	ebp, edi

; 572  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN4@inCone

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	r10d, r8d
	sub	r11d, r9d
	sub	ebx, r8d
	imul	r10d, r11d
	sub	esi, r9d
	imul	ebx, esi
	cmp	ebx, r10d

; 572  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN4@inCone
$LN6@inCone:

; 576  : }

	mov	al, 1
$LN7@inCone:
	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	pop	r15
	pop	r14
	ret	0
$LN2@inCone:

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	esi, r11d
	sub	r10d, ebx
	imul	esi, r14d
	imul	r10d, r15d
	sub	esi, r10d

; 493  : 	return area2(a, b, c) <= 0;

	test	esi, esi

; 573  : 	// Assume (i-1,i,i+1) not collinear.
; 574  : 	// else P[i] is reflex.
; 575  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inCone

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	ebx, r8d
	sub	edi, r8d
	sub	r11d, r9d
	sub	ebp, r9d
	imul	edi, r11d
	imul	ebx, ebp
	sub	ebx, edi

; 493  : 	return area2(a, b, c) <= 0;

	test	ebx, ebx

; 573  : 	// Assume (i-1,i,i+1) not collinear.
; 574  : 	// else P[i] is reflex.
; 575  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN6@inCone
$LN4@inCone:

; 576  : }

	xor	al, al
	jmp	SHORT $LN7@inCone
?inCone@@YA_NHHPEBH0@Z ENDP				; inCone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z
_TEXT	SEGMENT
simplified$ = 80
?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z PROC	; removeDegenerateSegments, COMDAT

; 580  : {

	push	rbx
	push	rbp
	push	r15
	sub	rsp, 48					; 00000030H

; 581  : 	// Remove adjacent vertices which are equal on xz-plane,
; 582  : 	// or else the triangulator will get confused.
; 583  : 	int npts = simplified.size()/4;

	mov	eax, DWORD PTR [rcx]
	mov	rbx, rcx
	cdq
	and	edx, 3
	lea	r15d, DWORD PTR [rdx+rax]

; 584  : 	for (int i = 0; i < npts; ++i)

	xor	eax, eax
	sar	r15d, 2
	mov	ebp, eax
	test	r15d, r15d
	jle	$LN3@removeDege
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 334  : 	void resize(int size) { m_impl.resize(size); }

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 584  : 	for (int i = 0; i < npts; ++i)

	mov	QWORD PTR [rsp+80], rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 334  : 	void resize(int size) { m_impl.resize(size); }

	mov	esi, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 584  : 	for (int i = 0; i < npts; ++i)

	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+96], r12
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], r14
	npad	7
$LL4@removeDege:

; 588  : 		if (vequal(&simplified[i*4], &simplified[ni*4]))

	lea	r12d, DWORD PTR [rbp+1]
	cmp	r12d, r15d
	lea	r13, QWORD PTR [rsi+1]
	mov	rdi, r13
	cmovge	rdi, rax
	shl	rdi, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN135@removeDege
	test	rdi, rdi
	js	SHORT $LN173@removeDege
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN135@removeDege
$LN173@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN135@removeDege:
	mov	rax, QWORD PTR [rbx+16]
	lea	r14, QWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 588  : 		if (vequal(&simplified[i*4], &simplified[ni*4]))

	lea	rdi, QWORD PTR [rsi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN143@removeDege
	test	rdi, rdi
	js	SHORT $LN171@removeDege
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN143@removeDege
$LN171@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN143@removeDege:
	mov	rax, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 541  : 	return a[0] == b[0] && a[2] == b[2];

	mov	eax, DWORD PTR [r14]
	cmp	DWORD PTR [rcx], eax
	jne	$LN2@removeDege
	mov	eax, DWORD PTR [r14+8]
	cmp	DWORD PTR [rcx+8], eax
	jne	$LN2@removeDege

; 589  : 		{
; 590  : 			// Degenerate segment, remove.
; 591  : 			for (int j = i; j < simplified.size()/4-1; ++j)

	mov	ecx, DWORD PTR [rbx]
	mov	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	dec	eax
	cmp	ebp, eax
	jge	$LN6@removeDege
	add	rdi, 5
	npad	5
$LL7@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN17@removeDege
	test	rdi, rdi
	jle	SHORT $LN179@removeDege
	cmp	rdi, QWORD PTR [rbx]
	jle	SHORT $LN17@removeDege
$LN179@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN17@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 593  : 				simplified[j*4+0] = simplified[(j+1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN25@removeDege
	lea	rax, QWORD PTR [rdi-5]
	test	rax, rax
	js	SHORT $LN180@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN25@removeDege
$LN180@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN25@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 593  : 				simplified[j*4+0] = simplified[(j+1)*4+0];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4-20], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN33@removeDege
	test	rdi, rdi
	js	SHORT $LN181@removeDege
	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN33@removeDege
$LN181@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN33@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 594  : 				simplified[j*4+1] = simplified[(j+1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN41@removeDege
	lea	rax, QWORD PTR [rdi-4]
	test	rax, rax
	js	SHORT $LN174@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN41@removeDege
$LN174@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN41@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 594  : 				simplified[j*4+1] = simplified[(j+1)*4+1];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4-16], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN49@removeDege
	lea	rax, QWORD PTR [rdi+1]
	test	rax, rax
	js	SHORT $LN175@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN49@removeDege
$LN175@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN49@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 595  : 				simplified[j*4+2] = simplified[(j+1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN57@removeDege
	lea	rax, QWORD PTR [rdi-3]
	test	rax, rax
	js	SHORT $LN176@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN57@removeDege
$LN176@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN57@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 595  : 				simplified[j*4+2] = simplified[(j+1)*4+2];

	mov	rax, QWORD PTR [rbx+16]
	mov	DWORD PTR [rax+rdi*4-12], esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN65@removeDege
	lea	rax, QWORD PTR [rdi+2]
	test	rax, rax
	js	SHORT $LN177@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN65@removeDege
$LN177@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN65@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 596  : 				simplified[j*4+3] = simplified[(j+1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	mov	esi, DWORD PTR [rax+rdi*4+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

	test	r9, r9
	je	SHORT $LN73@removeDege
	lea	rax, QWORD PTR [rdi-2]
	test	rax, rax
	js	SHORT $LN178@removeDege
	cmp	rax, QWORD PTR [rbx]
	jl	SHORT $LN73@removeDege
$LN178@removeDege:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	r9
	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
$LN73@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 596  : 				simplified[j*4+3] = simplified[(j+1)*4+3];

	mov	rax, QWORD PTR [rbx+16]
	inc	ebp
	mov	DWORD PTR [rax+rdi*4-8], esi
	add	rdi, 4
	mov	ecx, DWORD PTR [rbx]
	mov	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	dec	eax
	cmp	ebp, eax
	jl	$LL7@removeDege
$LN6@removeDege:

; 597  : 			}
; 598  : 			simplified.resize(simplified.size()-4);

	lea	eax, DWORD PTR [rcx-4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 334  : 	void resize(int size) { m_impl.resize(size); }

	movsxd	rdi, eax

; 232  : 	if (size < m_size) {

	cmp	rdi, QWORD PTR [rbx]
	jl	SHORT $LN183@removeDege

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN87@removeDege

; 236  : 		if (size <= m_cap) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	rdi, rax
	jle	SHORT $LN183@removeDege

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN106@removeDege

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN108@removeDege
$LN106@removeDege:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	mov	rsi, rdi
	cmp	rax, rdi
	cmovg	rsi, rax
$LN108@removeDege:

; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {
; 249  : 				construct_range(new_data + m_size, new_data + size, *value);
; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN122@removeDege

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN122@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 257  : 			m_size = size;

	mov	r9, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	QWORD PTR [rbx+16], rbp
	mov	QWORD PTR [rbx+8], rsi
$LN183@removeDege:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 599  : 			npts--;

	mov	QWORD PTR [rbx], rdi
$LN87@removeDege:
	dec	r15d
$LN2@removeDege:

; 584  : 	for (int i = 0; i < npts; ++i)

	mov	ebp, r12d
	mov	rsi, r13
	mov	eax, 0
	cmp	r12d, r15d
	jl	$LL4@removeDege
	mov	r14, QWORD PTR [rsp+32]
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
$LN3@removeDege:

; 600  : 		}
; 601  : 	}
; 602  : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	rbp
	pop	rbx
	ret	0
?removeDegenerateSegments@@YAXAEAVrcIntArray@@@Z ENDP	; removeDegenerateSegments
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?mergeContours@@YA_NAEAUrcContour@@0HH@Z
_TEXT	SEGMENT
ca$ = 64
cb$ = 72
ia$ = 80
ib$ = 88
?mergeContours@@YA_NAEAUrcContour@@0HH@Z PROC		; mergeContours, COMDAT

; 606  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 607  : 	const int maxVerts = ca.nverts + cb.nverts + 2;

	mov	eax, DWORD PTR [rcx+8]
	mov	rsi, rcx
	mov	r10d, DWORD PTR [rdx+8]
	add	eax, 2
	add	r10d, eax
	mov	r15d, r9d

; 608  : 	int* verts = (int*)rcAlloc(sizeof(int)*maxVerts*4, RC_ALLOC_PERM);

	movsxd	rcx, r10d
	mov	r14d, r8d
	shl	rcx, 4
	mov	rbx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 609  : 	if (!verts)

	test	rax, rax
	je	$LN1@mergeConto
$LN8@mergeConto:

; 610  : 		return false;
; 611  : 	
; 612  : 	int nv = 0;
; 613  : 	
; 614  : 	// Copy contour A.
; 615  : 	for (int i = 0; i <= ca.nverts; ++i)

	mov	ecx, DWORD PTR [rsi+8]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+64], rdi
	xor	edi, edi
	test	ecx, ecx
	js	SHORT $LN52@mergeConto
	lea	r8, QWORD PTR [rax+8]
	npad	6
$LL4@mergeConto:

; 616  : 	{
; 617  : 		int* dst = &verts[nv*4];
; 618  : 		const int* src = &ca.verts[((ia+i)%ca.nverts)*4];

	lea	eax, DWORD PTR [r9+r14]

; 619  : 		dst[0] = src[0];
; 620  : 		dst[1] = src[1];
; 621  : 		dst[2] = src[2];
; 622  : 		dst[3] = src[3];
; 623  : 		nv++;

	inc	edi
	cdq
	lea	r8, QWORD PTR [r8+16]
	idiv	ecx
	mov	rax, QWORD PTR [rsi]
	inc	r9d
	shl	edx, 2
	movsxd	rcx, edx
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR [r8-24], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8-20], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8-16], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [r8-12], eax
	mov	ecx, DWORD PTR [rsi+8]
	cmp	r9d, ecx
	jle	SHORT $LL4@mergeConto
$LN52@mergeConto:

; 624  : 	}
; 625  : 
; 626  : 	// Copy contour B
; 627  : 	for (int i = 0; i <= cb.nverts; ++i)

	mov	ecx, DWORD PTR [rbx+8]
	xor	r9d, r9d
	test	ecx, ecx
	js	SHORT $LN53@mergeConto
	movsxd	r8, edi
	shl	r8, 4
	add	r8, 8
	add	r8, rbp
	npad	7
$LL7@mergeConto:

; 628  : 	{
; 629  : 		int* dst = &verts[nv*4];
; 630  : 		const int* src = &cb.verts[((ib+i)%cb.nverts)*4];

	lea	eax, DWORD PTR [r9+r15]

; 631  : 		dst[0] = src[0];
; 632  : 		dst[1] = src[1];
; 633  : 		dst[2] = src[2];
; 634  : 		dst[3] = src[3];
; 635  : 		nv++;

	inc	edi
	cdq
	lea	r8, QWORD PTR [r8+16]
	idiv	ecx
	mov	rax, QWORD PTR [rbx]
	inc	r9d
	shl	edx, 2
	movsxd	rcx, edx
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR [r8-24], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8-20], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8-16], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [r8-12], eax
	mov	ecx, DWORD PTR [rbx+8]
	cmp	r9d, ecx
	jle	SHORT $LL7@mergeConto
$LN53@mergeConto:

; 636  : 	}
; 637  : 	
; 638  : 	rcFree(ca.verts);

	mov	rcx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN19@mergeConto

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN19@mergeConto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 640  : 	ca.nverts = nv;

	mov	DWORD PTR [rsi+8], edi

; 641  : 	
; 642  : 	rcFree(cb.verts);

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi], rbp
	mov	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN26@mergeConto

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN26@mergeConto:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 643  : 	cb.verts = 0;

	mov	QWORD PTR [rbx], 0

; 644  : 	cb.nverts = 0;
; 645  : 	
; 646  : 	return true;

	mov	al, 1
	mov	DWORD PTR [rbx+8], 0
$LN1@mergeConto:

; 647  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
?mergeContours@@YA_NAEAUrcContour@@0HH@Z ENDP		; mergeContours
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z
_TEXT	SEGMENT
contour$ = 8
minx$ = 16
minz$ = 24
leftmost$ = 32
?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z PROC	; findLeftMostVertex, COMDAT

; 670  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 671  : 	*minx = contour->verts[0];

	mov	rax, QWORD PTR [rcx]
	mov	rsi, r9
	mov	rbx, r8
	mov	rdi, rdx
	mov	r11, rcx
	mov	r10d, DWORD PTR [rax]
	mov	DWORD PTR [rdx], r10d

; 672  : 	*minz = contour->verts[2];

	mov	rax, QWORD PTR [rcx]
	mov	r10d, DWORD PTR [rax+8]

; 673  : 	*leftmost = 0;
; 674  : 	for (int i = 1; i < contour->nverts; i++)

	mov	eax, 1
	mov	DWORD PTR [r8], r10d
	mov	DWORD PTR [r9], 0
	cmp	DWORD PTR [rcx+8], eax
	jle	SHORT $LN3@findLeftMo
	mov	r8d, 16
	npad	11
$LL4@findLeftMo:

; 675  : 	{
; 676  : 		const int x = contour->verts[i*4+0];

	mov	rcx, QWORD PTR [r11]
	mov	edx, DWORD PTR [rcx+r8]

; 677  : 		const int z = contour->verts[i*4+2];

	mov	r9d, DWORD PTR [rcx+r8+8]

; 678  : 		if (x < *minx || (x == *minx && z < *minz))

	cmp	edx, DWORD PTR [rdi]
	jl	SHORT $LN6@findLeftMo
	jne	SHORT $LN2@findLeftMo
	cmp	r9d, DWORD PTR [rbx]
	jge	SHORT $LN2@findLeftMo
$LN6@findLeftMo:

; 679  : 		{
; 680  : 			*minx = x;

	mov	DWORD PTR [rdi], edx

; 681  : 			*minz = z;

	mov	DWORD PTR [rbx], r9d

; 682  : 			*leftmost = i;

	mov	DWORD PTR [rsi], eax
$LN2@findLeftMo:

; 673  : 	*leftmost = 0;
; 674  : 	for (int i = 1; i < contour->nverts; i++)

	inc	eax
	add	r8, 16
	cmp	eax, DWORD PTR [r11+8]
	jl	SHORT $LL4@findLeftMo
$LN3@findLeftMo:

; 683  : 		}
; 684  : 	}
; 685  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
?findLeftMostVertex@@YAXPEAUrcContour@@PEAH11@Z ENDP	; findLeftMostVertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?compareHoles@@YAHPEBX0@Z
_TEXT	SEGMENT
va$ = 8
vb$ = 16
?compareHoles@@YAHPEBX0@Z PROC				; compareHoles, COMDAT

; 689  : 	const rcContourHole* a = (const rcContourHole*)va;
; 690  : 	const rcContourHole* b = (const rcContourHole*)vb;
; 691  : 	if (a->minx == b->minx)

	mov	r8d, DWORD PTR [rcx+8]
	mov	r9d, DWORD PTR [rdx+8]
	cmp	r8d, r9d
	jne	SHORT $LN2@compareHol

; 692  : 	{
; 693  : 		if (a->minz < b->minz)

	mov	eax, DWORD PTR [rcx+12]
	cmp	eax, DWORD PTR [rdx+12]
	jl	SHORT $LN11@compareHol

; 694  : 			return -1;
; 695  : 		if (a->minz > b->minz)

	jg	SHORT $LN9@compareHol

; 704  : 	}
; 705  : 	return 0;

	xor	eax, eax

; 706  : }

	ret	0
$LN9@compareHol:

; 703  : 			return 1;

	mov	eax, 1

; 706  : }

	ret	0
$LN2@compareHol:

; 696  : 			return 1;
; 697  : 	}
; 698  : 	else
; 699  : 	{
; 700  : 		if (a->minx < b->minx)

	jge	SHORT $LN6@compareHol
$LN11@compareHol:

; 701  : 			return -1;

	mov	eax, -1

; 706  : }

	ret	0
$LN6@compareHol:

; 702  : 		if (a->minx > b->minx)

	xor	eax, eax
	cmp	r8d, r9d
	setg	al

; 706  : }

	ret	0
?compareHoles@@YAHPEBX0@Z ENDP				; compareHoles
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?compareDiagDist@@YAHPEBX0@Z
_TEXT	SEGMENT
va$ = 8
vb$ = 16
?compareDiagDist@@YAHPEBX0@Z PROC			; compareDiagDist, COMDAT

; 711  : 	const rcPotentialDiagonal* a = (const rcPotentialDiagonal*)va;
; 712  : 	const rcPotentialDiagonal* b = (const rcPotentialDiagonal*)vb;
; 713  : 	if (a->dist < b->dist)

	mov	r8d, DWORD PTR [rcx+4]
	mov	ecx, DWORD PTR [rdx+4]
	cmp	r8d, ecx
	jge	SHORT $LN2@compareDia

; 714  : 		return -1;

	mov	eax, -1

; 716  : 		return 1;
; 717  : 	return 0;
; 718  : }

	ret	0
$LN2@compareDia:

; 715  : 	if (a->dist > b->dist)

	xor	eax, eax
	cmp	r8d, ecx
	setg	al

; 716  : 		return 1;
; 717  : 	return 0;
; 718  : }

	ret	0
?compareDiagDist@@YAHPEBX0@Z ENDP			; compareDiagDist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp
;	COMDAT ?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z
_TEXT	SEGMENT
ndiags$1$ = 48
tv2697 = 48
index$1$ = 48
$T1 = 56
bestVertex$1$ = 64
$T2 = 72
corner$1$ = 72
iter$1$ = 80
i$1$ = 84
hole$1$ = 88
region$GSCopy$1$ = 96
outline$1$ = 104
tv2682 = 112
tv2651 = 120
$T3 = 128
$T4 = 136
tv2672 = 136
ctx$GSCopy$1$ = 144
diags$ = 152
__$ArrayPad$ = 160
ctx$ = 240
region$ = 248
?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z PROC ; mergeRegionHoles, COMDAT

; 722  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r15, rdx
	mov	QWORD PTR region$GSCopy$1$[rsp], rdx
	mov	rbp, rcx
	mov	QWORD PTR ctx$GSCopy$1$[rsp], rcx

; 723  : 	// Sort holes from left to right.
; 724  : 	for (int i = 0; i < region.nholes; i++)

	xor	r12d, r12d
	mov	edi, r12d
	mov	eax, DWORD PTR [rdx+16]
	lea	r14, QWORD PTR [rdx+8]
	mov	QWORD PTR $T3[rsp], r14
	test	eax, eax
	jle	$LN214@mergeRegio
	mov	esi, r12d
	npad	4
$LL4@mergeRegio:

; 725  : 		findLeftMostVertex(region.holes[i].contour, &region.holes[i].minx, &region.holes[i].minz, &region.holes[i].leftmost);

	mov	r8, QWORD PTR [r14]
	add	r8, rsi
	mov	rbx, QWORD PTR [r8]

; 671  : 	*minx = contour->verts[0];

	mov	rax, QWORD PTR [rbx]
	mov	edx, DWORD PTR [rax]
	mov	DWORD PTR [r8+8], edx

; 672  : 	*minz = contour->verts[2];

	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR [r8+12], ecx

; 673  : 	*leftmost = 0;

	mov	DWORD PTR [r8+16], r12d

; 674  : 	for (int i = 1; i < contour->nverts; i++)

	mov	r9d, 1
	cmp	DWORD PTR [rbx+8], r9d
	jle	SHORT $LN2@mergeRegio

; 725  : 		findLeftMostVertex(region.holes[i].contour, &region.holes[i].minx, &region.holes[i].minz, &region.holes[i].leftmost);

	mov	r10d, 16
	npad	14
$LL119@mergeRegio:

; 676  : 		const int x = contour->verts[i*4+0];

	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+r10]

; 677  : 		const int z = contour->verts[i*4+2];

	mov	r11d, DWORD PTR [rax+r10+8]

; 678  : 		if (x < *minx || (x == *minx && z < *minz))

	cmp	ecx, edx
	jl	SHORT $LN121@mergeRegio
	jne	SHORT $LN117@mergeRegio
	cmp	r11d, DWORD PTR [r8+12]
	jge	SHORT $LN117@mergeRegio
$LN121@mergeRegio:

; 679  : 		{
; 680  : 			*minx = x;

	mov	DWORD PTR [r8+8], ecx

; 681  : 			*minz = z;

	mov	DWORD PTR [r8+12], r11d

; 682  : 			*leftmost = i;

	mov	DWORD PTR [r8+16], r9d
	mov	edx, ecx
$LN117@mergeRegio:

; 674  : 	for (int i = 1; i < contour->nverts; i++)

	inc	r9d
	add	r10, 16
	cmp	r9d, DWORD PTR [rbx+8]
	jl	SHORT $LL119@mergeRegio
$LN2@mergeRegio:

; 723  : 	// Sort holes from left to right.
; 724  : 	for (int i = 0; i < region.nholes; i++)

	inc	edi
	add	rsi, 24
	mov	eax, DWORD PTR [r15+16]
	cmp	edi, eax
	jl	$LL4@mergeRegio
	jmp	SHORT $LN3@mergeRegio
$LN214@mergeRegio:
	mov	QWORD PTR $T3[rsp], r14
$LN3@mergeRegio:
	mov	ebx, r12d
	mov	edi, r12d

; 726  : 	
; 727  : 	qsort(region.holes, region.nholes, sizeof(rcContourHole), compareHoles);

	movsxd	rdx, eax
	lea	r9, OFFSET FLAT:?compareHoles@@YAHPEBX0@Z ; compareHoles
	mov	r8d, 24
	mov	rcx, QWORD PTR [r14]
	call	QWORD PTR __imp_qsort

; 728  : 	
; 729  : 	int maxVerts = region.outline->nverts;

	mov	rax, QWORD PTR [r15]
	mov	esi, DWORD PTR [rax+8]

; 730  : 	for (int i = 0; i < region.nholes; i++)

	movsxd	r9, DWORD PTR [r15+16]
	mov	r8, r12
	cmp	r9, 2
	jl	SHORT $LC190@mergeRegio

; 731  : 		maxVerts += region.holes[i].contour->nverts;

	mov	r10, QWORD PTR [r14]
	mov	rcx, r10
	lea	rdx, QWORD PTR [r9-2]
	shr	rdx, 1
	inc	rdx
	lea	r8, QWORD PTR [rdx+rdx]
	npad	11
$LL191@mergeRegio:
	mov	rax, QWORD PTR [rcx]
	add	ebx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+24]
	add	edi, DWORD PTR [rax+8]
	lea	rcx, QWORD PTR [rcx+48]
	sub	rdx, 1
	jne	SHORT $LL191@mergeRegio

; 730  : 	for (int i = 0; i < region.nholes; i++)

	cmp	r8, r9
	jl	SHORT $LL215@mergeRegio
	jmp	SHORT $LN189@mergeRegio
$LC190@mergeRegio:
	test	r9, r9
	jle	SHORT $LN189@mergeRegio

; 731  : 		maxVerts += region.holes[i].contour->nverts;

	mov	r10, QWORD PTR [r14]
	npad	10
$LL215@mergeRegio:
	lea	rax, QWORD PTR [r8+r8*2]
	mov	rcx, QWORD PTR [r10+rax*8]
	add	esi, DWORD PTR [rcx+8]
$LN189@mergeRegio:
	lea	eax, DWORD PTR [rdi+rbx]
	add	esi, eax

; 732  : 	
; 733  : 	rcScopedDelete<rcPotentialDiagonal> diags((rcPotentialDiagonal*)rcAlloc(sizeof(rcPotentialDiagonal)*maxVerts, RC_ALLOC_TEMP));

	movsxd	rcx, esi
	shl	rcx, 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbx, rax
	mov	QWORD PTR diags$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 734  : 	if (!diags)

	test	rax, rax
	jne	SHORT $LN23@mergeRegio

; 735  : 	{
; 736  : 		ctx->log(RC_LOG_WARNING, "mergeRegionHoles: Failed to allocated diags %d.", maxVerts);

	mov	r9d, esi
	lea	r8, OFFSET FLAT:??_C@_0DA@NAIMHHAE@mergeRegionHoles?3?5Failed?5to?5all@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, rbp
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	jmp	$LN9@mergeRegio
$LN23@mergeRegio:

; 737  : 		return;
; 738  : 	}
; 739  : 	
; 740  : 	rcContour* outline = region.outline;

	mov	rsi, QWORD PTR [r15]
	mov	QWORD PTR outline$1$[rsp], rsi

; 741  : 	
; 742  : 	// Merge holes into the outline one by one.
; 743  : 	for (int i = 0; i < region.nholes; i++)

	xor	r10d, r10d
	mov	DWORD PTR i$1$[rsp], r10d
	cmp	DWORD PTR [r15+16], r10d
	jle	$LN9@mergeRegio

; 780  : 				bool intersect = intersectSegContour(pt, corner, diags[i].vert, outline->nverts, outline->verts);

	mov	ebp, r10d
	mov	QWORD PTR $T1[rsp], r10

; 782  : 					intersect |= intersectSegContour(pt, corner, -1, region.holes[k].contour->nverts, region.holes[k].contour->verts);

	mov	r12d, r10d
	mov	QWORD PTR tv2651[rsp], r10
	mov	QWORD PTR tv2682[rsp], rax
	mov	rdi, QWORD PTR region$GSCopy$1$[rsp]
	npad	5
$LL10@mergeRegio:

; 744  : 	{
; 745  : 		rcContour* hole = region.holes[i].contour;

	mov	rax, QWORD PTR [r14]
	mov	r15, QWORD PTR [r12+rax]
	mov	QWORD PTR hole$1$[rsp], r15

; 746  : 		
; 747  : 		int index = -1;

	mov	r14d, -1

; 748  : 		int bestVertex = region.holes[i].leftmost;

	mov	r13d, DWORD PTR [r12+rax+16]
	mov	DWORD PTR bestVertex$1$[rsp], r13d

; 749  : 		for (int iter = 0; iter < hole->nverts; iter++)

	mov	DWORD PTR iter$1$[rsp], r10d
	cmp	DWORD PTR [r15+8], 0
	jle	$LN144@mergeRegio
	npad	4
$LL13@mergeRegio:

; 750  : 		{
; 751  : 			// Find potential diagonals.
; 752  : 			// The 'best' vertex must be in the cone described by 3 consecutive vertices of the outline.
; 753  : 			// ..o j-1
; 754  : 			//   |
; 755  : 			//   |   * best
; 756  : 			//   |
; 757  : 			// j o-----o j+1
; 758  : 			//         :
; 759  : 			int ndiags = 0;

	mov	edi, r10d

; 760  : 			const int* corner = &hole->verts[bestVertex*4];

	lea	eax, DWORD PTR [r13*4]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r15]
	lea	r13, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR corner$1$[rsp], r13

; 761  : 			for (int j = 0; j < outline->nverts; j++)

	mov	r14d, r10d
	mov	rax, r10
	mov	ecx, DWORD PTR [rsi+8]
	test	ecx, ecx
	jle	$LN15@mergeRegio

; 731  : 		maxVerts += region.holes[i].contour->nverts;

	mov	r15, rbx
	mov	ebx, eax
$LL16@mergeRegio:

; 762  : 			{
; 763  : 				if (inCone(j, outline->nverts, outline->verts, corner))

	mov	r8, QWORD PTR [rsi]

; 566  : 	const int* pi = &verts[i * 4];

	mov	r9, rax
	add	r9, r9

; 567  : 	const int* pi1 = &verts[next(i, n) * 4];

	lea	rdx, QWORD PTR [rax+1]
	mov	QWORD PTR $T4[rsp], rdx
	lea	eax, DWORD PTR [r14+1]
	cmp	eax, ecx
	cmovge	rdx, r10
	add	rdx, rdx

; 568  : 	const int* pin1 = &verts[prev(i, n) * 4];

	mov	eax, r14d
	test	r14d, r14d
	cmovle	eax, ecx
	lea	eax, DWORD PTR [rax*4-4]
	movsxd	rcx, eax

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	r10d, DWORD PTR [r8+rcx*4+8]
	mov	edi, DWORD PTR [r8+r9*8+8]
	mov	esi, DWORD PTR [r8+rcx*4]
	mov	ebp, DWORD PTR [r8+rdx*8]
	mov	r11d, DWORD PTR [r8+rdx*8+8]
	mov	r12d, DWORD PTR [r8+r9*8]
	mov	r9d, DWORD PTR [r13+8]
	mov	r13d, r9d
	sub	r13d, edi
	mov	rax, QWORD PTR corner$1$[rsp]
	mov	ecx, DWORD PTR [rax]
	mov	eax, ecx
	sub	eax, r12d
	mov	DWORD PTR tv2697[rsp], eax
	mov	eax, r12d
	sub	eax, ecx
	mov	r8d, r12d
	sub	r8d, esi
	mov	ecx, r11d
	sub	ecx, r10d
	imul	r8d, ecx
	mov	edx, ebp
	sub	edx, esi
	mov	ecx, edi
	sub	ecx, r10d
	imul	edx, ecx
	sub	r8d, edx

; 493  : 	return area2(a, b, c) <= 0;

	test	r8d, r8d

; 571  : 	if (leftOn(pin1, pi, pi1))

	jg	SHORT $LN62@mergeRegio

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	esi, r12d
	imul	esi, r13d
	sub	r10d, edi
	imul	r10d, DWORD PTR tv2697[rsp]
	cmp	r10d, esi

; 572  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN218@mergeRegio

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ecx, edi
	sub	ecx, r9d
	mov	r8, QWORD PTR corner$1$[rsp]
	sub	ebp, DWORD PTR [r8]
	imul	ecx, ebp
	sub	r11d, r9d
	imul	r11d, eax
	cmp	r11d, ecx

; 572  : 		return left(pi, pj, pin1) && left(pj, pi, pi1);

	jns	SHORT $LN218@mergeRegio
	mov	cl, 1
	jmp	SHORT $LN65@mergeRegio
$LN218@mergeRegio:
	xor	cl, cl
$LN65@mergeRegio:

; 762  : 			{
; 763  : 				if (inCone(j, outline->nverts, outline->verts, corner))

	test	cl, cl
	je	SHORT $LN222@mergeRegio
	jmp	SHORT $LN217@mergeRegio
$LN62@mergeRegio:

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	sub	ebp, r12d
	imul	ebp, r13d
	sub	r11d, edi
	imul	r11d, DWORD PTR tv2697[rsp]
	sub	r11d, ebp

; 493  : 	return area2(a, b, c) <= 0;

	test	r11d, r11d

; 575  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jg	SHORT $LN217@mergeRegio

; 472  : 	return (b[0] - a[0]) * (c[2] - a[2]) - (c[0] - a[0]) * (b[2] - a[2]);

	mov	ecx, edi
	sub	ecx, r9d
	mov	r13, QWORD PTR corner$1$[rsp]
	sub	esi, DWORD PTR [r13]
	imul	ecx, esi
	sub	r10d, r9d
	imul	r10d, eax
	sub	r10d, ecx

; 493  : 	return area2(a, b, c) <= 0;

	test	r10d, r10d

; 575  : 	return !(leftOn(pi, pj, pi1) && leftOn(pj, pi, pin1));

	jle	SHORT $LN14@mergeRegio
$LN217@mergeRegio:

; 764  : 				{
; 765  : 					int dx = outline->verts[j*4+0] - corner[0];
; 766  : 					int dz = outline->verts[j*4+2] - corner[2];

	sub	edi, r9d

; 767  : 					diags[ndiags].vert = j;

	mov	DWORD PTR [r15], r14d

; 768  : 					diags[ndiags].dist = dx*dx + dz*dz;

	imul	edi, edi
	imul	eax, eax
	add	edi, eax
	mov	DWORD PTR [r15+4], edi

; 769  : 					ndiags++;

	inc	ebx
	add	r15, 8
$LN222@mergeRegio:

; 761  : 			for (int j = 0; j < outline->nverts; j++)

	mov	r13, QWORD PTR corner$1$[rsp]
$LN14@mergeRegio:
	inc	r14d
	mov	rsi, QWORD PTR outline$1$[rsp]
	mov	ecx, DWORD PTR [rsi+8]
	cmp	r14d, ecx
	mov	rax, QWORD PTR $T4[rsp]
	mov	r10d, 0
	jl	$LL16@mergeRegio
	mov	DWORD PTR ndiags$1$[rsp], ebx
	mov	rbx, QWORD PTR diags$[rsp]
	mov	edi, DWORD PTR ndiags$1$[rsp]
	mov	rbp, QWORD PTR $T1[rsp]
	mov	r15, QWORD PTR hole$1$[rsp]
$LN15@mergeRegio:

; 770  : 				}
; 771  : 			}
; 772  : 			// Sort potential diagonals by distance, we want to make the connection as short as possible.
; 773  : 			qsort(diags, ndiags, sizeof(rcPotentialDiagonal), compareDiagDist);

	movsxd	rax, edi
	mov	QWORD PTR tv2672[rsp], rax
	lea	r9, OFFSET FLAT:?compareDiagDist@@YAHPEBX0@Z ; compareDiagDist
	mov	r8d, 8
	mov	rdx, rax
	mov	rcx, rbx
	call	QWORD PTR __imp_qsort

; 774  : 			
; 775  : 			// Find a diagonal that is not intersecting the outline not the remaining holes.
; 776  : 			index = -1;

	mov	r14d, -1
	mov	DWORD PTR index$1$[rsp], r14d

; 777  : 			for (int j = 0; j < ndiags; j++)

	xor	r10d, r10d
	mov	r12d, r10d
	test	edi, edi
	jle	$LN211@mergeRegio

; 778  : 			{
; 779  : 				const int* pt = &outline->verts[diags[j].vert*4];

	mov	rdx, QWORD PTR [rsi]
	mov	QWORD PTR $T2[rsp], rdx
	mov	rax, QWORD PTR region$GSCopy$1$[rsp]
	movsxd	r15, DWORD PTR [rax+16]
	npad	1
$LL19@mergeRegio:
	mov	edi, DWORD PTR [rbx+r12*8]
	lea	eax, DWORD PTR [rdi*4]
	movsxd	r14, eax
	shl	r14, 2
	add	r14, rdx

; 780  : 				bool intersect = intersectSegContour(pt, corner, diags[i].vert, outline->nverts, outline->verts);

	mov	QWORD PTR [rsp+32], rdx
	mov	r9d, DWORD PTR [rsi+8]
	mov	rax, QWORD PTR tv2682[rsp]
	mov	r8d, DWORD PTR [rax]
	mov	rdx, r13
	mov	rcx, r14
	call	?intersectSegContour@@YA_NPEBH0HH0@Z	; intersectSegContour

; 781  : 				for (int k = i; k < region.nholes && !intersect; k++)

	cmp	QWORD PTR $T1[rsp], r15
	jge	SHORT $LN216@mergeRegio

; 778  : 			{
; 779  : 				const int* pt = &outline->verts[diags[j].vert*4];

	mov	rsi, QWORD PTR tv2651[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	rdi, QWORD PTR [rcx]
$LL22@mergeRegio:

; 781  : 				for (int k = i; k < region.nholes && !intersect; k++)

	test	al, al
	jne	SHORT $LN219@mergeRegio

; 782  : 					intersect |= intersectSegContour(pt, corner, -1, region.holes[k].contour->nverts, region.holes[k].contour->verts);

	mov	r9, QWORD PTR [rdi+rsi]
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR [r9+8]
	mov	r8d, -1
	mov	rdx, r13
	mov	rcx, r14
	call	?intersectSegContour@@YA_NPEBH0HH0@Z	; intersectSegContour

; 781  : 				for (int k = i; k < region.nholes && !intersect; k++)

	inc	rbp
	add	rsi, 24
	cmp	rbp, r15
	jl	SHORT $LL22@mergeRegio
	mov	edi, DWORD PTR [rbx+r12*8]
$LN216@mergeRegio:

; 783  : 				if (!intersect)

	test	al, al
	je	SHORT $LN143@mergeRegio
$LN219@mergeRegio:

; 777  : 			for (int j = 0; j < ndiags; j++)

	inc	r12
	cmp	r12, QWORD PTR tv2672[rsp]
	mov	rdx, QWORD PTR $T2[rsp]
	mov	rsi, QWORD PTR outline$1$[rsp]
	mov	rbp, QWORD PTR $T1[rsp]
	jl	$LL19@mergeRegio

; 786  : 					break;
; 787  : 				}
; 788  : 			}
; 789  : 			// If found non-intersecting diagonal, stop looking.
; 790  : 			if (index != -1)

	mov	r14d, DWORD PTR index$1$[rsp]
	jmp	SHORT $LN224@mergeRegio
$LN143@mergeRegio:

; 784  : 				{
; 785  : 					index = diags[j].vert;

	mov	r14d, edi

; 786  : 					break;
; 787  : 				}
; 788  : 			}
; 789  : 			// If found non-intersecting diagonal, stop looking.
; 790  : 			if (index != -1)

	cmp	edi, -1
	jne	SHORT $LN223@mergeRegio
$LN224@mergeRegio:

; 791  : 				break;
; 792  : 			// All the potential diagonals for the current vertex were intersecting, try next vertex.
; 793  : 			bestVertex = (bestVertex + 1) % hole->nverts;

	xor	r10d, r10d
	mov	r15, QWORD PTR hole$1$[rsp]
$LN211@mergeRegio:
	mov	eax, DWORD PTR bestVertex$1$[rsp]
	inc	eax
	cdq
	idiv	DWORD PTR [r15+8]
	mov	r13d, edx
	mov	DWORD PTR bestVertex$1$[rsp], edx

; 749  : 		for (int iter = 0; iter < hole->nverts; iter++)

	mov	edx, DWORD PTR iter$1$[rsp]
	inc	edx
	mov	DWORD PTR iter$1$[rsp], edx
	cmp	edx, DWORD PTR [r15+8]
	mov	rsi, QWORD PTR outline$1$[rsp]
	mov	rbp, QWORD PTR $T1[rsp]
	jl	$LL13@mergeRegio

; 786  : 					break;
; 787  : 				}
; 788  : 			}
; 789  : 			// If found non-intersecting diagonal, stop looking.
; 790  : 			if (index != -1)

	jmp	SHORT $LN221@mergeRegio
$LN223@mergeRegio:
	mov	r15, QWORD PTR hole$1$[rsp]
	mov	r13d, DWORD PTR bestVertex$1$[rsp]
$LN221@mergeRegio:
	mov	rbp, QWORD PTR $T1[rsp]
	mov	r12, QWORD PTR tv2651[rsp]
	mov	rdi, QWORD PTR region$GSCopy$1$[rsp]
$LN144@mergeRegio:

; 794  : 		}
; 795  : 		
; 796  : 		if (index == -1)

	mov	rsi, QWORD PTR [rdi]
	cmp	r14d, -1
	jne	SHORT $LN27@mergeRegio

; 797  : 		{
; 798  : 			ctx->log(RC_LOG_WARNING, "mergeHoles: Failed to find merge points for %p and %p.", region.outline, hole);

	mov	QWORD PTR [rsp+32], r15
	mov	r9, rsi
	lea	r8, OFFSET FLAT:??_C@_0DH@FDPHPCPH@mergeHoles?3?5Failed?5to?5find?5merg@
	lea	edx, QWORD PTR [r14+3]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log

; 799  : 			continue;

	xor	r10d, r10d
	jmp	$LN8@mergeRegio
$LN27@mergeRegio:

; 607  : 	const int maxVerts = ca.nverts + cb.nverts + 2;

	mov	ecx, DWORD PTR [rsi+8]
	mov	eax, DWORD PTR [r15+8]
	add	eax, 2
	add	ecx, eax

; 608  : 	int* verts = (int*)rcAlloc(sizeof(int)*maxVerts*4, RC_ALLOC_PERM);

	movsxd	rcx, ecx
	shl	rcx, 4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 609  : 	if (!verts)

	test	rax, rax
	jne	SHORT $LN39@mergeRegio

; 800  : 		}
; 801  : 		if (!mergeContours(*region.outline, *hole, index, bestVertex))
; 802  : 		{
; 803  : 			ctx->log(RC_LOG_WARNING, "mergeHoles: Failed to merge contours %p and %p.", region.outline, hole);

	mov	QWORD PTR [rsp+32], r15
	mov	r9, QWORD PTR [rdi]
	lea	r8, OFFSET FLAT:??_C@_0DA@DNDMOMEJ@mergeHoles?3?5Failed?5to?5merge?5con@
	lea	edx, QWORD PTR [rax+2]
	mov	rcx, QWORD PTR ctx$GSCopy$1$[rsp]
	call	?log@rcContext@@QEAAXW4rcLogCategory@@PEBDZZ ; rcContext::log
	xor	r10d, r10d
	jmp	$LN225@mergeRegio
$LN39@mergeRegio:

; 612  : 	int nv = 0;

	xor	r11d, r11d
	mov	edi, r11d
	mov	r10d, r11d

; 613  : 	
; 614  : 	// Copy contour A.
; 615  : 	for (int i = 0; i <= ca.nverts; ++i)

	mov	r9d, r11d
	mov	ecx, DWORD PTR [rsi+8]
	test	ecx, ecx
	js	SHORT $LN195@mergeRegio

; 731  : 		maxVerts += region.holes[i].contour->nverts;

	lea	r8, QWORD PTR [rax+8]
$LL35@mergeRegio:

; 618  : 		const int* src = &ca.verts[((ia+i)%ca.nverts)*4];

	lea	eax, DWORD PTR [r9+r14]
	cdq
	idiv	ecx
	shl	edx, 2
	movsxd	rcx, edx
	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR [rax+rcx*4]

; 619  : 		dst[0] = src[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8-8], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8-4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [r8+4], eax

; 620  : 		dst[1] = src[1];
; 621  : 		dst[2] = src[2];
; 622  : 		dst[3] = src[3];
; 623  : 		nv++;

	inc	edi
	inc	r10
	lea	r8, QWORD PTR [r8+16]

; 613  : 	
; 614  : 	// Copy contour A.
; 615  : 	for (int i = 0; i <= ca.nverts; ++i)

	inc	r9d
	mov	ecx, DWORD PTR [rsi+8]
	cmp	r9d, ecx
	jle	SHORT $LL35@mergeRegio
$LN195@mergeRegio:

; 624  : 	}
; 625  : 
; 626  : 	// Copy contour B
; 627  : 	for (int i = 0; i <= cb.nverts; ++i)

	mov	r9d, r11d
	mov	ecx, DWORD PTR [r15+8]
	test	ecx, ecx
	js	SHORT $LN196@mergeRegio

; 731  : 		maxVerts += region.holes[i].contour->nverts;

	shl	r10, 4
	lea	r8, QWORD PTR [r10+8]
	add	r8, rbp
	npad	5
$LL38@mergeRegio:

; 630  : 		const int* src = &cb.verts[((ib+i)%cb.nverts)*4];

	lea	eax, DWORD PTR [r9+r13]
	cdq
	idiv	ecx
	shl	edx, 2
	movsxd	rcx, edx
	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR [rax+rcx*4]

; 631  : 		dst[0] = src[0];

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8-8], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8-4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [r8+4], eax

; 632  : 		dst[1] = src[1];
; 633  : 		dst[2] = src[2];
; 634  : 		dst[3] = src[3];
; 635  : 		nv++;

	inc	edi
	lea	r8, QWORD PTR [r8+16]

; 624  : 	}
; 625  : 
; 626  : 	// Copy contour B
; 627  : 	for (int i = 0; i <= cb.nverts; ++i)

	inc	r9d
	mov	ecx, DWORD PTR [r15+8]
	cmp	r9d, ecx
	jle	SHORT $LL38@mergeRegio
$LN196@mergeRegio:

; 636  : 	}
; 637  : 	
; 638  : 	rcFree(ca.verts);

	mov	rcx, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN50@mergeRegio

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN50@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 639  : 	ca.verts = verts;

	mov	QWORD PTR [rsi], rbp

; 640  : 	ca.nverts = nv;

	mov	DWORD PTR [rsi+8], edi

; 641  : 	
; 642  : 	rcFree(cb.verts);

	mov	rcx, QWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN57@mergeRegio

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN57@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 643  : 	cb.verts = 0;

	xor	r10d, r10d
	mov	QWORD PTR [r15], r10

; 644  : 	cb.nverts = 0;

	mov	DWORD PTR [r15+8], r10d
	mov	rdi, QWORD PTR region$GSCopy$1$[rsp]
$LN225@mergeRegio:

; 741  : 	
; 742  : 	// Merge holes into the outline one by one.
; 743  : 	for (int i = 0; i < region.nholes; i++)

	mov	rbp, QWORD PTR $T1[rsp]
$LN8@mergeRegio:
	mov	ecx, DWORD PTR i$1$[rsp]
	inc	ecx
	mov	DWORD PTR i$1$[rsp], ecx
	inc	rbp
	mov	QWORD PTR $T1[rsp], rbp
	add	QWORD PTR tv2682[rsp], 8
	add	r12, 24
	mov	QWORD PTR tv2651[rsp], r12
	cmp	ecx, DWORD PTR [rdi+16]
	mov	rsi, QWORD PTR outline$1$[rsp]
	mov	r14, QWORD PTR $T3[rsp]
	jl	$LL10@mergeRegio
$LN9@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rbx, rbx
	je	SHORT $LN220@mergeRegio

; 28   : 	free(ptr);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	npad	1
$LN220@mergeRegio:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastContour.cpp

; 807  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+256]
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z ENDP ; mergeRegionHoles
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
ndiags$1$ = 48
tv2697 = 48
index$1$ = 48
$T1 = 56
bestVertex$1$ = 64
$T2 = 72
corner$1$ = 72
iter$1$ = 80
i$1$ = 84
hole$1$ = 88
region$GSCopy$1$ = 96
outline$1$ = 104
tv2682 = 112
tv2651 = 120
$T3 = 128
$T4 = 136
tv2672 = 136
ctx$GSCopy$1$ = 144
diags$ = 152
__$ArrayPad$ = 160
ctx$ = 240
region$ = 248
?dtor$0@?0??mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z@4HA PROC ; `mergeRegionHoles'::`1'::dtor$0
	lea	rcx, QWORD PTR diags$[rdx]
	jmp	??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ ; rcScopedDelete<rcPotentialDiagonal>::~rcScopedDelete<rcPotentialDiagonal>
?dtor$0@?0??mergeRegionHoles@@YAXPEAVrcContext@@AEAUrcContourRegion@@@Z@4HA ENDP ; `mergeRegionHoles'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAX_K@Z PROC ; rcScopedDelete<rcPotentialDiagonal>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAX_K@Z ENDP ; rcScopedDelete<rcPotentialDiagonal>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@E@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@E@@QEAAX_K@Z PROC	; rcScopedDelete<unsigned char>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@E@@QEAAX_K@Z ENDP	; rcScopedDelete<unsigned char>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
;	COMDAT ??1rcIntArray@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1rcIntArray@@QEAA@XZ PROC				; rcIntArray::~rcIntArray, COMDAT
$LN19:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN16@rcIntArray

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
	npad	1
$LN16@rcIntArray:
	add	rsp, 40					; 00000028H
	ret	0
??1rcIntArray@@QEAA@XZ ENDP				; rcIntArray::~rcIntArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@rcIntArray@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@rcIntArray@@QEAAX_K@Z PROC		; rcIntArray::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@rcIntArray@@QEAAX_K@Z ENDP		; rcIntArray::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@C@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@C@@QEAAX_K@Z PROC	; rcScopedDelete<signed char>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@C@@QEAAX_K@Z ENDP	; rcScopedDelete<signed char>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@UrcContourRegion@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@UrcContourRegion@@@@QEAAX_K@Z PROC ; rcScopedDelete<rcContourRegion>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@UrcContourRegion@@@@QEAAX_K@Z ENDP ; rcScopedDelete<rcContourRegion>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$rcScopedDelete@UrcContourHole@@@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$rcScopedDelete@UrcContourHole@@@@QEAAX_K@Z PROC ; rcScopedDelete<rcContourHole>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$rcScopedDelete@UrcContourHole@@@@QEAAX_K@Z ENDP ; rcScopedDelete<rcContourHole>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@UrcContourHole@@@@QEAAPEAUrcContourHole@@XZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@UrcContourHole@@@@QEAAPEAUrcContourHole@@XZ PROC ; rcScopedDelete<rcContourHole>::operator rcContourHole *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@UrcContourHole@@@@QEAAPEAUrcContourHole@@XZ ENDP ; rcScopedDelete<rcContourHole>::operator rcContourHole *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ PROC	; rcScopedDelete<rcContourHole>::~rcScopedDelete<rcContourHole>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@UrcContourHole@@@@QEAA@XZ ENDP	; rcScopedDelete<rcContourHole>::~rcScopedDelete<rcContourHole>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@UrcContourHole@@@@QEAA@PEAUrcContourHole@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@UrcContourHole@@@@QEAA@PEAUrcContourHole@@@Z PROC ; rcScopedDelete<rcContourHole>::rcScopedDelete<rcContourHole>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@UrcContourHole@@@@QEAA@PEAUrcContourHole@@@Z ENDP ; rcScopedDelete<rcContourHole>::rcScopedDelete<rcContourHole>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@UrcContourRegion@@@@QEAAPEAUrcContourRegion@@XZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@UrcContourRegion@@@@QEAAPEAUrcContourRegion@@XZ PROC ; rcScopedDelete<rcContourRegion>::operator rcContourRegion *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@UrcContourRegion@@@@QEAAPEAUrcContourRegion@@XZ ENDP ; rcScopedDelete<rcContourRegion>::operator rcContourRegion *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ PROC	; rcScopedDelete<rcContourRegion>::~rcScopedDelete<rcContourRegion>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@UrcContourRegion@@@@QEAA@XZ ENDP	; rcScopedDelete<rcContourRegion>::~rcScopedDelete<rcContourRegion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@UrcContourRegion@@@@QEAA@PEAUrcContourRegion@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@UrcContourRegion@@@@QEAA@PEAUrcContourRegion@@@Z PROC ; rcScopedDelete<rcContourRegion>::rcScopedDelete<rcContourRegion>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@UrcContourRegion@@@@QEAA@PEAUrcContourRegion@@@Z ENDP ; rcScopedDelete<rcContourRegion>::rcScopedDelete<rcContourRegion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@C@@QEAAPEACXZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@C@@QEAAPEACXZ PROC			; rcScopedDelete<signed char>::operator signed char *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@C@@QEAAPEACXZ ENDP			; rcScopedDelete<signed char>::operator signed char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@C@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@C@@QEAA@XZ PROC			; rcScopedDelete<signed char>::~rcScopedDelete<signed char>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@C@@QEAA@XZ ENDP			; rcScopedDelete<signed char>::~rcScopedDelete<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@C@@QEAA@PEAC@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@C@@QEAA@PEAC@Z PROC			; rcScopedDelete<signed char>::rcScopedDelete<signed char>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@C@@QEAA@PEAC@Z ENDP			; rcScopedDelete<signed char>::rcScopedDelete<signed char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@E@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@E@@QEAAPEAEXZ PROC			; rcScopedDelete<unsigned char>::operator unsigned char *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@E@@QEAAPEAEXZ ENDP			; rcScopedDelete<unsigned char>::operator unsigned char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@E@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@E@@QEAA@XZ PROC			; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@E@@QEAA@XZ ENDP			; rcScopedDelete<unsigned char>::~rcScopedDelete<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@E@@QEAA@PEAE@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@E@@QEAA@PEAE@Z PROC			; rcScopedDelete<unsigned char>::rcScopedDelete<unsigned char>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@E@@QEAA@PEAE@Z ENDP			; rcScopedDelete<unsigned char>::rcScopedDelete<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??B?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAPEAUrcPotentialDiagonal@@XZ
_TEXT	SEGMENT
this$ = 8
??B?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAPEAUrcPotentialDiagonal@@XZ PROC ; rcScopedDelete<rcPotentialDiagonal>::operator rcPotentialDiagonal *, COMDAT

; 364  : 	inline operator T*() { return ptr; }

	mov	rax, QWORD PTR [rcx]
	ret	0
??B?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAAPEAUrcPotentialDiagonal@@XZ ENDP ; rcScopedDelete<rcPotentialDiagonal>::operator rcPotentialDiagonal *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ PROC ; rcScopedDelete<rcPotentialDiagonal>::~rcScopedDelete<rcPotentialDiagonal>, COMDAT

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

$LN12:
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcScopedDe

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcScopedDe:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 360  : 	inline ~rcScopedDelete() { rcFree(ptr); }

	ret	0
??1?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@XZ ENDP ; rcScopedDelete<rcPotentialDiagonal>::~rcScopedDelete<rcPotentialDiagonal>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@PEAUrcPotentialDiagonal@@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
??0?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@PEAUrcPotentialDiagonal@@@Z PROC ; rcScopedDelete<rcPotentialDiagonal>::rcScopedDelete<rcPotentialDiagonal>, COMDAT

; 359  : 	inline rcScopedDelete(T* p) : ptr(p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$rcScopedDelete@UrcPotentialDiagonal@@@@QEAA@PEAUrcPotentialDiagonal@@@Z ENDP ; rcScopedDelete<rcPotentialDiagonal>::rcScopedDelete<rcPotentialDiagonal>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcTempVector@H@@QEAA@_JAEBH@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
value$ = 64
??0?$rcTempVector@H@@QEAA@_JAEBH@Z PROC			; rcTempVector<int>::rcTempVector<int>, COMDAT

; 310  : 	rcTempVector(rcSizeType size, const T& value) : Base(size, value) {}

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	xor	eax, eax

; 310  : 	rcTempVector(rcSizeType size, const T& value) : Base(size, value) {}

	mov	rbx, rcx

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 138  : 	void resize(rcSizeType size, const T& value) { resize_impl(size, &value); }

	call	?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z ; rcVectorBase<int,1>::resize_impl

; 310  : 	rcTempVector(rcSizeType size, const T& value) : Base(size, value) {}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$rcTempVector@H@@QEAA@_JAEBH@Z ENDP			; rcTempVector<int>::rcTempVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z PROC		; rcVectorBase<int,1>::operator[], COMDAT

; 150  : 	T& operator[](rcSizeType i) { rcAssert(i >= 0 && i < m_size); return m_data[i]; }

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rbx, rdx
	mov	rdi, rcx
	test	rax, rax
	je	SHORT $LN4@operator
	test	rdx, rdx
	js	SHORT $LN5@operator
	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN4@operator
$LN5@operator:
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0BF@MODPPAME@i?5?$DO?$DN?50?5?$CG?$CG?5i?5?$DM?5m_size@
	call	rax
$LN4@operator:
	mov	rax, QWORD PTR [rdi+16]
	lea	rax, QWORD PTR [rax+rbx*4]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??A?$rcVectorBase@H$00@@QEAAAEAH_J@Z ENDP		; rcVectorBase<int,1>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?size@?$rcVectorBase@H$00@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?size@?$rcVectorBase@H$00@@QEBA_JXZ PROC		; rcVectorBase<int,1>::size, COMDAT

; 145  : 	rcSizeType size() const { return m_size; }

	mov	rax, QWORD PTR [rcx]
	ret	0
?size@?$rcVectorBase@H$00@@QEBA_JXZ ENDP		; rcVectorBase<int,1>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?clear@?$rcVectorBase@H$00@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$rcVectorBase@H$00@@QEAAXXZ PROC		; rcVectorBase<int,1>::clear, COMDAT

; 140  : 	void clear() { destroy_range(0, m_size); m_size = 0; }

	mov	QWORD PTR [rcx], 0
	ret	0
?clear@?$rcVectorBase@H$00@@QEAAXXZ ENDP		; rcVectorBase<int,1>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?resize@?$rcVectorBase@H$00@@QEAAX_J@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
?resize@?$rcVectorBase@H$00@@QEAAX_J@Z PROC		; rcVectorBase<int,1>::resize, COMDAT

; 137  : 	void resize(rcSizeType size) { resize_impl(size, NULL); }

$LN55:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 232  : 	if (size < m_size) {

	cmp	rdx, QWORD PTR [rcx]
	jl	SHORT $LN47@resize

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	SHORT $LN8@resize

; 236  : 		if (size <= m_cap) {

	mov	rax, QWORD PTR [rcx+8]
	cmp	rdx, rax
	jle	SHORT $LN47@resize

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH

; 236  : 		if (size <= m_cap) {

	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rsi

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN27@resize

; 226  : 		return RC_SIZE_MAX;

	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN29@resize
$LN27@resize:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	mov	rsi, rbx
	cmp	rax, rbx
	cmovg	rsi, rax
$LN29@resize:

; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rsi
	mov	rcx, rdi
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {
; 249  : 				construct_range(new_data + m_size, new_data + size, *value);
; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rdi+16]
	mov	rbp, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN43@resize

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN43@resize:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 255  : 			m_data = new_data;

	mov	QWORD PTR [rdi+16], rbp

; 256  : 			m_cap = new_cap;
; 257  : 			m_size = size;

	mov	rbp, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+8], rsi
	mov	rsi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi], rbx

; 137  : 	void resize(rcSizeType size) { resize_impl(size, NULL); }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN47@resize:

; 242  : 			m_size = size;

	mov	QWORD PTR [rcx], rbx
$LN8@resize:

; 137  : 	void resize(rcSizeType size) { resize_impl(size, NULL); }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$rcVectorBase@H$00@@QEAAX_J@Z ENDP		; rcVectorBase<int,1>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??1?$rcVectorBase@H$00@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$rcVectorBase@H$00@@QEAA@XZ PROC			; rcVectorBase<int,1>::~rcVectorBase<int,1>, COMDAT

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

$LN12:
	mov	rcx, QWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN6@rcVectorBa

; 28   : 	free(ptr);

	rex_jmp	QWORD PTR __imp_free
$LN6@rcVectorBa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 129  : 	~rcVectorBase() { destroy_range(0, m_size); rcFree(m_data); }

	ret	0
??1?$rcVectorBase@H$00@@QEAA@XZ ENDP			; rcVectorBase<int,1>::~rcVectorBase<int,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z
_TEXT	SEGMENT
this$ = 48
count$ = 56
value$ = 64
??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z PROC		; rcVectorBase<int,1>::rcVectorBase<int,1>, COMDAT

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 138  : 	void resize(rcSizeType size, const T& value) { resize_impl(size, &value); }

	call	?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z ; rcVectorBase<int,1>::resize_impl

; 127  : 	rcVectorBase(rcSizeType count, const T& value) : m_size(0), m_cap(0), m_data(0) { resize(count, value); }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$rcVectorBase@H$00@@QEAA@_JAEBH@Z ENDP		; rcVectorBase<int,1>::rcVectorBase<int,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?resize@?$rcVectorBase@H$00@@QEAAX_JAEBH@Z
_TEXT	SEGMENT
this$ = 8
size$ = 16
value$ = 24
?resize@?$rcVectorBase@H$00@@QEAAX_JAEBH@Z PROC		; rcVectorBase<int,1>::resize, COMDAT

; 138  : 	void resize(rcSizeType size, const T& value) { resize_impl(size, &value); }

	jmp	?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z ; rcVectorBase<int,1>::resize_impl
?resize@?$rcVectorBase@H$00@@QEAAX_JAEBH@Z ENDP		; rcVectorBase<int,1>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?destroy_range@?$rcVectorBase@H$00@@AEAAX_J0@Z
_TEXT	SEGMENT
this$dead$ = 8
begin$dead$ = 16
end$dead$ = 24
?destroy_range@?$rcVectorBase@H$00@@AEAAX_J0@Z PROC	; rcVectorBase<int,1>::destroy_range, COMDAT

; 299  : 	for (rcSizeType i = begin; i < end; i++) {
; 300  : 		m_data[i].~T();
; 301  : 	}
; 302  : }

	ret	0
?destroy_range@?$rcVectorBase@H$00@@AEAAX_J0@Z ENDP	; rcVectorBase<int,1>::destroy_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
value$ = 64
?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z PROC	; rcVectorBase<int,1>::resize_impl, COMDAT

; 231  : void rcVectorBase<T, H>::resize_impl(rcSizeType size, const T* value) {

$LN66:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbx, r8

; 232  : 	if (size < m_size) {

	mov	rcx, QWORD PTR [rcx]
	mov	rsi, rdx
	cmp	rdx, rcx
	jl	$LN14@resize_imp

; 233  : 		destroy_range(size, m_size);
; 234  : 		m_size = size;
; 235  : 	} else if (size > m_size) {

	jle	$LN6@resize_imp

; 236  : 		if (size <= m_cap) {

	mov	rax, QWORD PTR [rdi+8]
	cmp	rdx, rax
	jg	SHORT $LN5@resize_imp

; 237  : 			if (value) {

	test	rbx, rbx
	je	$LN14@resize_imp

; 238  : 				construct_range(m_data + m_size, m_data + size, *value);

	mov	rax, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rax+rdx*4]
	lea	rcx, QWORD PTR [rax+rcx*4]

; 286  : 	for (T* p = begin; p < end; p++) {

	cmp	rcx, rdx
	jae	$LN14@resize_imp
$LL15@resize_imp:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN13@resize_imp
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
$LN13@resize_imp:

; 286  : 	for (T* p = begin; p < end; p++) {

	add	rcx, 4
	cmp	rcx, rdx
	jb	SHORT $LL15@resize_imp

; 258  : 		}
; 259  : 	}
; 260  : }

	mov	QWORD PTR [rdi], rsi
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@resize_imp:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], r14
	cmp	rax, rcx
	jl	SHORT $LN25@resize_imp

; 226  : 		return RC_SIZE_MAX;

	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN27@resize_imp
$LN25@resize_imp:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	mov	rbp, rsi
	cmp	rax, rsi
	cmovg	rbp, rax
$LN27@resize_imp:

; 239  : 			} else {
; 240  : 				construct_range(m_data + m_size, m_data + size);
; 241  : 			}
; 242  : 			m_size = size;
; 243  : 		} else {
; 244  : 			const rcSizeType new_cap = get_new_capacity(size);
; 245  : 			T* new_data = allocate_and_copy(new_cap);

	mov	rdx, rbp
	mov	rcx, rdi
	call	?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ; rcVectorBase<int,1>::allocate_and_copy
	mov	r14, rax

; 246  : 			// We defer deconstructing/freeing old data until after constructing
; 247  : 			// new elements in case "value" is there.
; 248  : 			if (value) {

	test	rbx, rbx
	je	SHORT $LN31@resize_imp

; 249  : 				construct_range(new_data + m_size, new_data + size, *value);

	mov	rcx, QWORD PTR [rdi]
	lea	r8, QWORD PTR [rax+rsi*4]
	lea	rdx, QWORD PTR [rax+rcx*4]

; 286  : 	for (T* p = begin; p < end; p++) {

	cmp	rdx, r8
	jae	SHORT $LN31@resize_imp
	npad	4
$LL32@resize_imp:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rdx, rdx
	je	SHORT $LN30@resize_imp
	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rdx], eax
$LN30@resize_imp:

; 286  : 	for (T* p = begin; p < end; p++) {

	add	rdx, 4
	cmp	rdx, r8
	jb	SHORT $LL32@resize_imp
$LN31@resize_imp:

; 250  : 			} else {
; 251  : 				construct_range(new_data + m_size, new_data + size);
; 252  : 			}
; 253  : 			destroy_range(0, m_size);
; 254  : 			rcFree(m_data);

	mov	rcx, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN41@resize_imp

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN41@resize_imp:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 255  : 			m_data = new_data;

	mov	QWORD PTR [rdi+16], r14

; 256  : 			m_cap = new_cap;
; 257  : 			m_size = size;

	mov	r14, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+8], rbp
	mov	rbp, QWORD PTR [rsp+48]
$LN14@resize_imp:

; 258  : 		}
; 259  : 	}
; 260  : }

	mov	QWORD PTR [rdi], rsi
$LN6@resize_imp:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize_impl@?$rcVectorBase@H$00@@AEAAX_JPEBH@Z ENDP	; rcVectorBase<int,1>::resize_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z
_TEXT	SEGMENT
this$ = 48
value$ = 56
?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z PROC	; rcVectorBase<int,1>::push_back, COMDAT

; 202  : void rcVectorBase<T, H>::push_back(const T& value) {

$LN63:
	mov	QWORD PTR [rsp+24], rbx
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	r14, rdx

; 203  : 	// rcLikely increases performance by ~50% on BM_rcVector_PushPreallocated,
; 204  : 	// and by ~2-5% on BM_rcVector_Push.
; 205  : 	if (rcLikely(m_size < m_cap)) {

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+8]
	cmp	rcx, rax
	jge	SHORT $LN2@push_back

; 206  : 		construct(m_data + m_size++, value);

	mov	rax, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rax+rcx*4]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx], rax

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	r8, r8
	je	$LN1@push_back
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN2@push_back:

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi

; 207  : 		return;
; 208  : 	}
; 209  : 
; 210  : 	const rcSizeType new_cap = get_new_capacity(m_cap + 1);

	lea	rdi, QWORD PTR [rax+1]

; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	cmp	rax, rcx
	jl	SHORT $LN12@push_back

; 226  : 		return RC_SIZE_MAX;

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	jmp	SHORT $LN14@push_back
$LN12@push_back:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdi
	cmovg	rdi, rax
$LN14@push_back:

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	test	rax, rax
	je	SHORT $LN19@push_back
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdi, rcx
	jle	SHORT $LN19@push_back
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN19@push_back:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	rsi, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN30@push_back

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r8, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN30@push_back

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r8, rax
$LL31@push_back:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN29@push_back
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rcx], eax
$LN29@push_back:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL31@push_back
$LN30@push_back:

; 211  : 	T* data = allocate_and_copy(new_cap);
; 212  : 	// construct between allocate and destroy+free in case value is
; 213  : 	// in this vector.
; 214  : 	construct(data + m_size, value);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rsi+rax*4]

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN39@push_back
	mov	eax, DWORD PTR [r14]
	mov	DWORD PTR [rcx], eax
$LN39@push_back:

; 215  : 	destroy_range(0, m_size);
; 216  : 	m_size++;

	inc	QWORD PTR [rbx]

; 217  : 	m_cap = new_cap;
; 218  : 	rcFree(m_data);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], rdi
	mov	rdi, QWORD PTR [rsp+56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 47   : 	if (ptr != NULL)

	test	rcx, rcx
	je	SHORT $LN44@push_back

; 28   : 	free(ptr);

	call	QWORD PTR __imp_free
$LN44@push_back:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 219  : 	m_data = data;

	mov	QWORD PTR [rbx+16], rsi
	mov	rsi, QWORD PTR [rsp+48]
$LN1@push_back:

; 220  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?push_back@?$rcVectorBase@H$00@@QEAAXAEBH@Z ENDP	; rcVectorBase<int,1>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\Recast.h
;	COMDAT ??$rcSwap@H@@YAXAEAH0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$rcSwap@H@@YAXAEAH0@Z PROC				; rcSwap<int>, COMDAT

; 652  : template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }

	mov	r8d, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	DWORD PTR [rdx], r8d
	ret	0
??$rcSwap@H@@YAXAEAH0@Z ENDP				; rcSwap<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct@?$rcVectorBase@H$00@@CAXPEAHAEBH@Z
_TEXT	SEGMENT
p$ = 8
v$ = 16
?construct@?$rcVectorBase@H$00@@CAXPEAHAEBH@Z PROC	; rcVectorBase<int,1>::construct, COMDAT

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
$LN3@construct:
	ret	0
?construct@?$rcVectorBase@H$00@@CAXPEAHAEBH@Z ENDP	; rcVectorBase<int,1>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct_range@?$rcVectorBase@H$00@@CAXPEAH0AEBH@Z
_TEXT	SEGMENT
begin$ = 8
end$ = 16
value$ = 24
?construct_range@?$rcVectorBase@H$00@@CAXPEAH0AEBH@Z PROC ; rcVectorBase<int,1>::construct_range, COMDAT

; 286  : 	for (T* p = begin; p < end; p++) {

	cmp	rcx, rdx
	jae	SHORT $LN3@construct_
$LL4@construct_:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN2@construct_
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
$LN2@construct_:

; 286  : 	for (T* p = begin; p < end; p++) {

	add	rcx, 4
	cmp	rcx, rdx
	jb	SHORT $LL4@construct_
$LN3@construct_:

; 287  : 		construct(p, value);
; 288  : 	}
; 289  : }

	ret	0
?construct_range@?$rcVectorBase@H$00@@CAXPEAH0AEBH@Z ENDP ; rcVectorBase<int,1>::construct_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct_range@?$rcVectorBase@H$00@@CAXPEAH0@Z
_TEXT	SEGMENT
begin$dead$ = 8
end$dead$ = 16
?construct_range@?$rcVectorBase@H$00@@CAXPEAH0@Z PROC	; rcVectorBase<int,1>::construct_range, COMDAT

; 279  : 	for (T* p = begin; p < end; p++) {
; 280  : 		construct(p);
; 281  : 	}
; 282  : }

	ret	0
?construct_range@?$rcVectorBase@H$00@@CAXPEAH0@Z ENDP	; rcVectorBase<int,1>::construct_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z
_TEXT	SEGMENT
this$ = 48
size$ = 56
?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z PROC ; rcVectorBase<int,1>::allocate_and_copy, COMDAT

; 186  : T* rcVectorBase<T, H>::allocate_and_copy(rcSizeType size) {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 187  : 	rcAssert(RC_SIZE_MAX / static_cast<rcSizeType>(sizeof(T)) >= size);

	mov	rax, QWORD PTR ?sRecastAssertFailFunc@@3P6AXPEBD0H@ZEA
	mov	rdi, rdx
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN4@allocate_a
	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rcx
	jle	SHORT $LN4@allocate_a
	mov	r8d, 187				; 000000bbH
	lea	rdx, OFFSET FLAT:??_C@_0GJ@ELNJEFNB@H?3?2Paul?2switchemulator?2Zelda?5To@
	lea	rcx, OFFSET FLAT:??_C@_0DJ@FDICGDBH@RC_SIZE_MAX?5?1?5static_cast?$DMrcSiz@
	call	rax
$LN4@allocate_a:

; 188  : 	T* new_data = static_cast<T*>(rcAlloc(sizeof(T) * size, H));

	lea	rcx, QWORD PTR [rdi*4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.cpp

; 23   : 	return malloc(size);

	call	QWORD PTR __imp_malloc
	mov	r8, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h

; 189  : 	if (new_data) {

	test	rax, rax
	je	SHORT $LN15@allocate_a

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	mov	rdx, QWORD PTR [rbx]

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	r9, QWORD PTR [rbx+16]

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	test	rdx, rdx
	jle	SHORT $LN15@allocate_a

; 190  : 		copy_range(new_data, m_data, m_data + m_size);

	mov	rcx, rax
	sub	r9, rax
	npad	7
$LL16@allocate_a:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN14@allocate_a
	mov	eax, DWORD PTR [r9+rcx]
	mov	DWORD PTR [rcx], eax
$LN14@allocate_a:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL16@allocate_a

; 191  : 	}
; 192  : 	return new_data;

	mov	rax, r8
$LN15@allocate_a:

; 193  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?allocate_and_copy@?$rcVectorBase@H$00@@AEAAPEAH_J@Z ENDP ; rcVectorBase<int,1>::allocate_and_copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?get_new_capacity@?$rcVectorBase@H$00@@AEAA_J_J@Z
_TEXT	SEGMENT
this$ = 8
min_capacity$ = 16
?get_new_capacity@?$rcVectorBase@H$00@@AEAA_J_J@Z PROC	; rcVectorBase<int,1>::get_new_capacity, COMDAT

; 224  : 	rcAssert(min_capacity <= RC_SIZE_MAX);
; 225  : 	if (rcUnlikely(m_cap >= RC_SIZE_MAX / 2))

	mov	rax, QWORD PTR [rcx+8]
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rcx
	jl	SHORT $LN5@get_new_ca

; 226  : 		return RC_SIZE_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 228  : }

	ret	0
$LN5@get_new_ca:

; 227  : 	return 2 * m_cap > min_capacity ? 2 * m_cap : min_capacity;

	add	rax, rax
	cmp	rax, rdx
	cmovg	rdx, rax
	mov	rax, rdx

; 228  : }

	ret	0
?get_new_capacity@?$rcVectorBase@H$00@@AEAA_J_J@Z ENDP	; rcVectorBase<int,1>::get_new_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?construct@?$rcVectorBase@H$00@@CAXPEAH@Z
_TEXT	SEGMENT
p$dead$ = 8
?construct@?$rcVectorBase@H$00@@CAXPEAH@Z PROC		; rcVectorBase<int,1>::construct, COMDAT

; 110  : 	static void construct(T* p) { ::new(rcNewTag(), (void*)p) T; }

	ret	0
?construct@?$rcVectorBase@H$00@@CAXPEAH@Z ENDP		; rcVectorBase<int,1>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\recastnavigation\recast\RecastAlloc.h
;	COMDAT ?copy_range@?$rcVectorBase@H$00@@CAXPEAHPEBH1@Z
_TEXT	SEGMENT
dst$ = 8
begin$ = 16
end$ = 24
?copy_range@?$rcVectorBase@H$00@@CAXPEAHPEBH1@Z PROC	; rcVectorBase<int,1>::copy_range, COMDAT

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	sub	r8, rdx
	sar	r8, 2
	test	r8, r8
	jle	SHORT $LN3@copy_range
	sub	rdx, rcx
	npad	1
$LL4@copy_range:

; 109  : 	static void construct(T* p, const T& v) { ::new(rcNewTag(), (void*)p) T(v); }

	test	rcx, rcx
	je	SHORT $LN2@copy_range
	mov	eax, DWORD PTR [rdx+rcx]
	mov	DWORD PTR [rcx], eax
$LN2@copy_range:

; 293  : 	for (rcSizeType i = 0 ; i < end - begin; i++) {

	add	rcx, 4
	sub	r8, 1
	jne	SHORT $LL4@copy_range
$LN3@copy_range:

; 294  : 		construct(dst + i, begin[i]);
; 295  : 	}
; 296  : }

	ret	0
?copy_range@?$rcVectorBase@H$00@@CAXPEAHPEBH1@Z ENDP	; rcVectorBase<int,1>::copy_range
_TEXT	ENDS
END
