; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?Open@UITools@@3_NA				; UITools::Open
PUBLIC	??_C@_0N@BOJIGJLG@ActorStacker@			; `string'
PUBLIC	??_C@_0CF@HIHBIGIN@Could?5not?5find?5base?5actor?5with?5@ ; `string'
PUBLIC	??_C@_0P@KHDBJKCM@Visible?5actors@		; `string'
PUBLIC	??_C@_06EPLDPNDB@Render@			; `string'
PUBLIC	??_C@_0N@DNFKIBNP@SkyAntiZonau@			; `string'
PUBLIC	??_C@_0BF@PMELGHKF@StartPos?5to?5selected@	; `string'
PUBLIC	??_C@_07BHIPFKL@NavMesh@			; `string'
PUBLIC	??_C@_0BB@KGNBKLMN@Generate?5NavMesh@		; `string'
PUBLIC	??_C@_03LHGHNHCF@Rot@				; `string'
PUBLIC	??_C@_05EINELICJ@Areas@				; `string'
PUBLIC	??_C@_0BB@BEPLMMON@Invisible?5actors@		; `string'
PUBLIC	??_C@_04GDNNPIME@NPCs@				; `string'
PUBLIC	??_C@_0L@CMFCHGAA@Far?5actors@			; `string'
PUBLIC	??_C@_0BD@KNBDJGLP@Save?1Phive?1NavMesh@	; `string'
PUBLIC	??_C@_0CN@NAICAGED@Phive?1NavMesh?1Dungeon136?4Nin_NX@ ; `string'
PUBLIC	??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@ ; `string'
;	COMDAT ??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@
CONST	SEGMENT
??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@ DB 'Save/Phive/NavMesh/'
	DB	'Dungeon', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NAICAGED@Phive?1NavMesh?1Dungeon136?4Nin_NX@
CONST	SEGMENT
??_C@_0CN@NAICAGED@Phive?1NavMesh?1Dungeon136?4Nin_NX@ DB 'Phive/NavMesh/'
	DB	'Dungeon136.Nin_NX_NVN.bphnm.zs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNBDJGLP@Save?1Phive?1NavMesh@
CONST	SEGMENT
??_C@_0BD@KNBDJGLP@Save?1Phive?1NavMesh@ DB 'Save/Phive/NavMesh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMFCHGAA@Far?5actors@
CONST	SEGMENT
??_C@_0L@CMFCHGAA@Far?5actors@ DB 'Far actors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDNNPIME@NPCs@
CONST	SEGMENT
??_C@_04GDNNPIME@NPCs@ DB 'NPCs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BEPLMMON@Invisible?5actors@
CONST	SEGMENT
??_C@_0BB@BEPLMMON@Invisible?5actors@ DB 'Invisible actors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EINELICJ@Areas@
CONST	SEGMENT
??_C@_05EINELICJ@Areas@ DB 'Areas', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHGHNHCF@Rot@
CONST	SEGMENT
??_C@_03LHGHNHCF@Rot@ DB 'Rot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KGNBKLMN@Generate?5NavMesh@
CONST	SEGMENT
??_C@_0BB@KGNBKLMN@Generate?5NavMesh@ DB 'Generate NavMesh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHIPFKL@NavMesh@
CONST	SEGMENT
??_C@_07BHIPFKL@NavMesh@ DB 'NavMesh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PMELGHKF@StartPos?5to?5selected@
CONST	SEGMENT
??_C@_0BF@PMELGHKF@StartPos?5to?5selected@ DB 'StartPos to selected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNFKIBNP@SkyAntiZonau@
CONST	SEGMENT
??_C@_0N@DNFKIBNP@SkyAntiZonau@ DB 'SkyAntiZonau', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPLDPNDB@Render@
CONST	SEGMENT
??_C@_06EPLDPNDB@Render@ DB 'Render', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KHDBJKCM@Visible?5actors@
CONST	SEGMENT
??_C@_0P@KHDBJKCM@Visible?5actors@ DB 'Visible actors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HIHBIGIN@Could?5not?5find?5base?5actor?5with?5@
CONST	SEGMENT
??_C@_0CF@HIHBIGIN@Could?5not?5find?5base?5actor?5with?5@ DB 'Could not f'
	DB	'ind base actor with hash ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOJIGJLG@ActorStacker@
CONST	SEGMENT
??_C@_0N@BOJIGJLG@ActorStacker@ DB 'ActorStacker', 00H	; `string'
?Open@UITools@@3_NA DB 01H				; UITools::Open
PUBLIC	??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData::Node *,unsigned __int64,Actor::PhiveData::RailData::Node *>
PUBLIC	??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >
PUBLIC	??$_Get_unwrapped@PEAUNode@RailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUNode@RailData@PhiveData@Actor@@@Z ; std::_Get_unwrapped<Actor::PhiveData::RailData::Node *>
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Clear_and_reserve_geometric
PUBLIC	??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ; Actor::PhiveData::RailData::Node::operator=
PUBLIC	??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >
PUBLIC	??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> > const >
PUBLIC	??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
PUBLIC	??$_Pocca@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::PhiveData::RailData::Node> >
PUBLIC	??$addressof@$$CBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> > const >
PUBLIC	??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::OwnerData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::OwnerData *>
PUBLIC	??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
PUBLIC	??$_Get_unwrapped@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@Z ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::OwnerData *>
PUBLIC	??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::ReferData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::ReferData *>
PUBLIC	??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
PUBLIC	??$_Get_unwrapped@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@@Z ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::ReferData *>
PUBLIC	??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z ; std::_Copy_n_unchecked4<unsigned __int64 *,unsigned __int64,unsigned __int64 *>
PUBLIC	??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z ; std::_Copy_memmove_n<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z ; std::_Uninitialized_copy_n<unsigned __int64 *,std::allocator<unsigned __int64> >
PUBLIC	??$_Get_unwrapped@PEA_K@std@@YA?A_T$$QEAPEA_K@Z	; std::_Get_unwrapped<unsigned __int64 *>
PUBLIC	??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData *,unsigned __int64,Actor::PhiveData::RailData *>
PUBLIC	??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >
PUBLIC	??$_Get_unwrapped@PEAURailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAURailData@PhiveData@Actor@@@Z ; std::_Get_unwrapped<Actor::PhiveData::RailData *>
PUBLIC	??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z ; std::_Copy_n_unchecked4<Actor::Link *,unsigned __int64,Actor::Link *>
PUBLIC	??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >
PUBLIC	??$_Get_unwrapped@PEAULink@Actor@@@std@@YA?A_T$$QEAPEAULink@Actor@@@Z ; std::_Get_unwrapped<Actor::Link *>
PUBLIC	??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z ; std::_Copy_n_unchecked4<Actor::Rail *,unsigned __int64,Actor::Rail *>
PUBLIC	??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >
PUBLIC	??$_Get_unwrapped@PEAURail@Actor@@@std@@YA?A_T$$QEAPEAURail@Actor@@@Z ; std::_Get_unwrapped<Actor::Rail *>
PUBLIC	??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z ; std::_Copy_n_unchecked4<Actor *,unsigned __int64,Actor *>
PUBLIC	??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z ; std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >
PUBLIC	??$_Get_unwrapped@PEAUActor@@@std@@YA?A_T$$QEAPEAUActor@@@Z ; std::_Get_unwrapped<Actor *>
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@2@$00@2@$00@std@@QEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >,1>,1>::_Get_first
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::clear
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Getcomp
PUBLIC	??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::operator=
PUBLIC	??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::operator=
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Clear_and_reserve_geometric
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Clear_and_reserve_geometric
PUBLIC	?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Clear_and_reserve_geometric
PUBLIC	??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::operator=
PUBLIC	?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Clear_and_reserve_geometric
PUBLIC	?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Clear_and_reserve_geometric
PUBLIC	?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Clear_and_reserve_geometric
PUBLIC	?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z ; std::vector<Actor,std::allocator<Actor> >::_Clear_and_reserve_geometric
PUBLIC	??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ; Actor::PhiveData::ConstraintLinkData::OwnerData::operator=
PUBLIC	??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ; Actor::PhiveData::ConstraintLinkData::ReferData::operator=
PUBLIC	??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ; Actor::PhiveData::RailData::operator=
PUBLIC	??4Link@Actor@@QEAAAEAU01@AEBU01@@Z		; Actor::Link::operator=
PUBLIC	??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z		; Actor::Rail::operator=
PUBLIC	??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > const >
PUBLIC	??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >
PUBLIC	??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> > const >
PUBLIC	??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>
PUBLIC	??$_Pocca@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
PUBLIC	??$addressof@$$CBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> > const >
PUBLIC	??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>
PUBLIC	??$_Pocca@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
PUBLIC	??$addressof@$$CBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> > const >
PUBLIC	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
PUBLIC	??$_Pocca@V?$allocator@_K@std@@@std@@YAXAEAV?$allocator@_K@0@AEBV10@@Z ; std::_Pocca<std::allocator<unsigned __int64> >
PUBLIC	??$addressof@$$CBV?$vector@_KV?$allocator@_K@std@@@std@@@std@@YAPEBV?$vector@_KV?$allocator@_K@std@@@0@AEBV10@@Z ; std::addressof<std::vector<unsigned __int64,std::allocator<unsigned __int64> > const >
PUBLIC	??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Assign_counted_range<Actor::PhiveData::RailData *>
PUBLIC	??$_Pocca@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@URailData@PhiveData@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::PhiveData::RailData> >
PUBLIC	??$addressof@$$CBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> > const >
PUBLIC	??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Assign_counted_range<Actor::Link *>
PUBLIC	??$_Pocca@V?$allocator@ULink@Actor@@@std@@@std@@YAXAEAV?$allocator@ULink@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::Link> >
PUBLIC	??$addressof@$$CBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@@std@@YAPEBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::Link,std::allocator<Actor::Link> > const >
PUBLIC	??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Assign_counted_range<Actor::Rail *>
PUBLIC	??$_Pocca@V?$allocator@URail@Actor@@@std@@@std@@YAXAEAV?$allocator@URail@Actor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor::Rail> >
PUBLIC	??$addressof@$$CBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor::Rail,std::allocator<Actor::Rail> > const >
PUBLIC	??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z ; std::vector<Actor,std::allocator<Actor> >::_Assign_counted_range<Actor *>
PUBLIC	??$_Pocca@V?$allocator@UActor@@@std@@@std@@YAXAEAV?$allocator@UActor@@@0@AEBV10@@Z ; std::_Pocca<std::allocator<Actor> >
PUBLIC	??$addressof@$$CBV?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@@std@@YAPEBV?$vector@UActor@@V?$allocator@UActor@@@std@@@0@AEBV10@@Z ; std::addressof<std::vector<Actor,std::allocator<Actor> > const >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
PUBLIC	??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::operator=
PUBLIC	??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
PUBLIC	??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::operator=
PUBLIC	??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::operator=
PUBLIC	??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator=
PUBLIC	??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::operator=
PUBLIC	??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::Link,std::allocator<Actor::Link> >::operator=
PUBLIC	??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::operator=
PUBLIC	??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::operator=
PUBLIC	??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<Actor,std::allocator<Actor> >::operator=
PUBLIC	??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ; Actor::PhiveData::RopeLinkData::operator=
PUBLIC	??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ; Actor::PhiveData::ConstraintLinkData::operator=
PUBLIC	??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z	; Actor::PhiveData::operator=
PUBLIC	??4Actor@@QEAAAEAU0@AEBU0@@Z			; Actor::operator=
PUBLIC	?DrawToolsWindow@UITools@@YAXXZ			; UITools::DrawToolsWindow
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN28
	DD	imagerel $LN28+111
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z DD imagerel $LN53
	DD	imagerel $LN53+145
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+101
	DD	imagerel $LN67+172
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+172
	DD	imagerel $LN67+262
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+262
	DD	imagerel $LN67+269
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+269
	DD	imagerel $LN67+275
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145
	DD	imagerel $LN145+60
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+60
	DD	imagerel $LN145+292
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+292
	DD	imagerel $LN145+299
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+299
	DD	imagerel $LN145+303
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+303
	DD	imagerel $LN145+442
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+442
	DD	imagerel $LN145+584
	DD	imagerel $chain$6$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD imagerel $LN145+584
	DD	imagerel $LN145+590
	DD	imagerel $chain$8$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN61+23
	DD	imagerel $LN61+485
	DD	imagerel $chain$5$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN61+485
	DD	imagerel $LN61+497
	DD	imagerel $chain$6$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+135
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN27
	DD	imagerel $LN27+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN27+21
	DD	imagerel $LN27+113
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD imagerel $LN27+113
	DD	imagerel $LN27+127
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DD imagerel $LN53
	DD	imagerel $LN53+150
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z DD imagerel $LN16
	DD	imagerel $LN16+50
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+50
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD imagerel $LN31+25
	DD	imagerel $LN31+169
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD imagerel $LN31+169
	DD	imagerel $LN31+183
	DD	imagerel $chain$3$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z DD imagerel $LN52
	DD	imagerel $LN52+129
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD imagerel $LN37
	DD	imagerel $LN37+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD imagerel $LN37+25
	DD	imagerel $LN37+153
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD imagerel $LN37+153
	DD	imagerel $LN37+167
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z DD imagerel $LN57
	DD	imagerel $LN57+178
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD imagerel $LN37
	DD	imagerel $LN37+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD imagerel $LN37+21
	DD	imagerel $LN37+145
	DD	imagerel $chain$1$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD imagerel $LN37+145
	DD	imagerel $LN37+159
	DD	imagerel $chain$2$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z DD imagerel $LN57
	DD	imagerel $LN57+170
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z DD imagerel $LN190
	DD	imagerel $LN190+76
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z DD imagerel $LN711
	DD	imagerel $LN711+135
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+21
	DD	imagerel $LN10+76
	DD	imagerel $chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+76
	DD	imagerel $LN10+90
	DD	imagerel $chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+21
	DD	imagerel $LN12+76
	DD	imagerel $chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+76
	DD	imagerel $LN12+90
	DD	imagerel $chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+100
	DD	imagerel $LN61+173
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+173
	DD	imagerel $LN61+261
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+261
	DD	imagerel $LN61+268
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN61+268
	DD	imagerel $LN61+274
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+101
	DD	imagerel $LN67+173
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+173
	DD	imagerel $LN67+260
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+260
	DD	imagerel $LN67+267
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN67+267
	DD	imagerel $LN67+273
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z DD imagerel $LN42
	DD	imagerel $LN42+188
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68
	DD	imagerel $LN68+32
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68+32
	DD	imagerel $LN68+84
	DD	imagerel $chain$0$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68+84
	DD	imagerel $LN68+153
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68+153
	DD	imagerel $LN68+233
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68+233
	DD	imagerel $LN68+240
	DD	imagerel $chain$4$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN68+240
	DD	imagerel $LN68+246
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+100
	DD	imagerel $LN70+181
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+181
	DD	imagerel $LN70+270
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+270
	DD	imagerel $LN70+277
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+277
	DD	imagerel $LN70+283
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+100
	DD	imagerel $LN70+181
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+181
	DD	imagerel $LN70+267
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+267
	DD	imagerel $LN70+274
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN70+274
	DD	imagerel $LN70+280
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223
	DD	imagerel $LN223+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223+29
	DD	imagerel $LN223+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223+100
	DD	imagerel $LN223+173
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223+173
	DD	imagerel $LN223+261
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223+261
	DD	imagerel $LN223+268
	DD	imagerel $chain$5$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD imagerel $LN223+268
	DD	imagerel $LN223+274
	DD	imagerel $chain$6$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN48+21
	DD	imagerel $LN48+296
	DD	imagerel $chain$0$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN48+296
	DD	imagerel $LN48+400
	DD	imagerel $chain$1$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD imagerel $LN16
	DD	imagerel $LN16+56
	DD	imagerel $unwind$??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD imagerel $LN20
	DD	imagerel $LN20+113
	DD	imagerel $unwind$??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Link@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN26
	DD	imagerel $LN26+108
	DD	imagerel $unwind$??4Link@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN26
	DD	imagerel $LN26+100
	DD	imagerel $unwind$??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN94
	DD	imagerel $LN94+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN94+59
	DD	imagerel $LN94+292
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN94+292
	DD	imagerel $LN94+299
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN94+299
	DD	imagerel $LN94+477
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN94+477
	DD	imagerel $LN94+483
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN142
	DD	imagerel $LN142+300
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN142+300
	DD	imagerel $LN142+557
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD imagerel $LN142+557
	DD	imagerel $LN142+563
	DD	imagerel $chain$1$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD imagerel $LN122
	DD	imagerel $LN122+230
	DD	imagerel $unwind$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD imagerel $LN122+230
	DD	imagerel $LN122+325
	DD	imagerel $chain$0$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD imagerel $LN122+325
	DD	imagerel $LN122+363
	DD	imagerel $chain$2$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD imagerel $LN122+363
	DD	imagerel $LN122+369
	DD	imagerel $chain$3$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD imagerel $LN137
	DD	imagerel $LN137+385
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD imagerel $LN137+385
	DD	imagerel $LN137+511
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD imagerel $LN137+511
	DD	imagerel $LN137+581
	DD	imagerel $chain$1$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD imagerel $LN146
	DD	imagerel $LN146+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD imagerel $LN146+59
	DD	imagerel $LN146+301
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD imagerel $LN146+301
	DD	imagerel $LN146+308
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD imagerel $LN146+308
	DD	imagerel $LN146+591
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD imagerel $LN146+591
	DD	imagerel $LN146+597
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD imagerel $LN169
	DD	imagerel $LN169+309
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD imagerel $LN169+309
	DD	imagerel $LN169+650
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD imagerel $LN169+650
	DD	imagerel $LN169+656
	DD	imagerel $chain$1$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD imagerel $LN344
	DD	imagerel $LN344+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD imagerel $LN344+59
	DD	imagerel $LN344+292
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD imagerel $LN344+292
	DD	imagerel $LN344+299
	DD	imagerel $chain$2$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD imagerel $LN344+299
	DD	imagerel $LN344+501
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD imagerel $LN344+501
	DD	imagerel $LN344+507
	DD	imagerel $chain$4$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+21
	DD	imagerel $LN10+76
	DD	imagerel $chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+76
	DD	imagerel $LN10+90
	DD	imagerel $chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+21
	DD	imagerel $LN10+76
	DD	imagerel $chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN10+76
	DD	imagerel $LN10+90
	DD	imagerel $chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+21
	DD	imagerel $LN12+76
	DD	imagerel $chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+76
	DD	imagerel $LN12+90
	DD	imagerel $chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+45
	DD	imagerel $unwind$??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+45
	DD	imagerel $unwind$??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+21
	DD	imagerel $LN12+76
	DD	imagerel $chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN12+76
	DD	imagerel $LN12+90
	DD	imagerel $chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z DD imagerel ?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z
	DD	imagerel ?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z+39
	DD	imagerel $unwind$?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD imagerel $LN13
	DD	imagerel $LN13+100
	DD	imagerel $unwind$??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD imagerel $LN13
	DD	imagerel $LN13+128
	DD	imagerel $unwind$??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN48
	DD	imagerel $LN48+6
	DD	imagerel $unwind$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN48+6
	DD	imagerel $LN48+22
	DD	imagerel $chain$0$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN48+22
	DD	imagerel $LN48+77
	DD	imagerel $chain$1$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN48+77
	DD	imagerel $LN48+363
	DD	imagerel $chain$2$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD imagerel $LN48+363
	DD	imagerel $LN48+391
	DD	imagerel $chain$3$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Actor@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN53
	DD	imagerel $LN53+24
	DD	imagerel $unwind$??4Actor@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4Actor@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN53+24
	DD	imagerel $LN53+332
	DD	imagerel $chain$1$??4Actor@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4Actor@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN53+332
	DD	imagerel $LN53+531
	DD	imagerel $chain$2$??4Actor@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4Actor@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN53+531
	DD	imagerel $LN53+704
	DD	imagerel $chain$3$??4Actor@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z DD imagerel ??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
	DD	imagerel ??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z+576
	DD	imagerel $unwind$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel $unwind$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel $chain$2$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+883
	DD	imagerel $chain$7$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+883
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1675
	DD	imagerel $chain$12$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1675
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1719
	DD	imagerel $chain$13$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1719
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1743
	DD	imagerel $chain$14$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1743
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+1769
	DD	imagerel $chain$15$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel ?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+80
	DD	imagerel $unwind$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawToolsWindow@UITools@@YAXXZ DD imagerel $LN1334
	DD	imagerel $LN1334+5431
	DD	imagerel $unwind$?DrawToolsWindow@UITools@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA DD imagerel ?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
	DD	imagerel ?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA DD imagerel ?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
	DD	imagerel ?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DrawToolsWindow@UITools@@YAXXZ DB '.'
	DB	0ccH
	DB	00H
	DB	'u', 0eH
	DB	02H
	DB	'`'
	DB	06H
	DB	09H, 01aH
	DB	0aH
	DB	085H, 04H
	DB	08H
	DB	'1', 02H
	DB	06H
	DB	'1', 02H
	DB	00H
	DB	'l'
	DB	0cH
	DB	'N'
	DB	0eH
	DB	099H, 02H
	DB	010H
	DB	'n'
	DB	014H
	DB	0c6H
	DB	016H
	DB	01cH
	DB	014H
	DB	'`'
	DB	018H
	DB	09cH
	DB	01cH
	DB	085H, 04H
	DB	01aH
	DB	091H, 05H
	DB	01eH
	DB	05H, 03H
	DB	01aH
	DB	'u', 02H
	DB	018H
	DB	0bdH, 05H
	DB	00H
	DB	0f1H, 02H
	DB	01aH
	DB	0cH
	DB	06H
	DB	0cH
	DB	01aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DrawToolsWindow@UITools@@YAXXZ DB 01eH
	DB	0aH
	DD	imagerel ??1Result@ZStdFile@@QEAA@XZ
	DB	021H
	DB	04H
	DB	03aH
	DD	imagerel ??1BymlFile@@QEAA@XZ
	DB	081H
	DB	05H
	DB	07aH
	DD	imagerel ??1BymlFile@@QEAA@XZ
	DB	081H
	DB	05H
	DB	03eH
	DD	imagerel ?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
	DB	02cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	025H
	DB	02H
	DD	imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DB	021H
	DB	04H
	DB	042H
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	0e1H
	DB	04H
	DB	03aH
	DD	imagerel ??1Result@ZStdFile@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1PhiveNavMesh@@QEAA@XZ
	DB	01H
	DB	09H
	DB	0aaH
	DD	imagerel ??1PhiveNavMesh@@QEAA@XZ
	DB	01H
	DB	09H
	DB	03cH
	DD	imagerel ??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	072H
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	03eH
	DD	imagerel ?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA
	DB	02cH
	DD	imagerel ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	062H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DrawToolsWindow@UITools@@YAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?DrawToolsWindow@UITools@@YAXXZ
	DD	imagerel $ip2state$?DrawToolsWindow@UITools@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawToolsWindow@UITools@@YAXXZ DD 0113f19H
	DD	086782eH
	DD	087682aH
	DD	01187426H
	DD	01176426H
	DD	01163426H
	DD	01100126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DrawToolsWindow@UITools@@YAXXZ
	DD	0852H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	'J'
	DB	02H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021519H
	DD	03002b206H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 021H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel $unwind$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 021H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel $chain$2$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 021H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+883
	DD	imagerel $chain$7$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 0a4121H
	DD	012d841H
	DD	013c832H
	DD	014b823H
	DD	015a814H
	DD	0187808H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+883
	DD	imagerel $chain$7$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 0a6b21H
	DD	010f86bH
	DD	011e858H
	DD	016983cH
	DD	017881fH
	DD	0196808H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+264
	DD	imagerel $chain$2$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 062121H
	DD	034f421H
	DD	03cd419H
	DD	035e408H
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
	DD	imagerel ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z+93
	DD	imagerel $unwind$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z DD 072419H
	DD	0360116H
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z DB 0eH
	DB	09eH
	DB	00H
	DB	'h'
	DB	02H
	DB	'V'
	DB	04H
	DB	08eH
	DB	06H
	DB	'T'
	DB	04H
	DB	01cH
	DB	02H
	DB	'A', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z DB 06H
	DB	0aH
	DD	imagerel ??1Actor@@QEAA@XZ
	DB	01H
	DB	010H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	034H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z DB 028H
	DD	imagerel $stateUnwindMap$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
	DD	imagerel $ip2state$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z DD 0f3c19H
	DD	078882bH
	DD	0797826H
	DD	07a6822H
	DD	0fb741eH
	DD	0fa641eH
	DD	0f8341eH
	DD	0f6011eH
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
	DD	0772H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4Actor@@QEAAAEAU0@AEBU0@@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+24
	DD	imagerel $unwind$??4Actor@@QEAAAEAU0@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4Actor@@QEAAAEAU0@AEBU0@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN53+24
	DD	imagerel $LN53+332
	DD	imagerel $chain$1$??4Actor@@QEAAAEAU0@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4Actor@@QEAAAEAU0@AEBU0@@Z DD 040e21H
	DD	08e40eH
	DD	075405H
	DD	imagerel $LN53
	DD	imagerel $LN53+24
	DD	imagerel $unwind$??4Actor@@QEAAAEAU0@AEBU0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Actor@@QEAAAEAU0@AEBU0@@Z DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+6
	DD	imagerel $unwind$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD 021H
	DD	imagerel $LN48+6
	DD	imagerel $LN48+22
	DD	imagerel $chain$0$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN48+6
	DD	imagerel $LN48+22
	DD	imagerel $chain$0$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD 020521H
	DD	076405H
	DD	imagerel $LN48
	DD	imagerel $LN48+6
	DD	imagerel $unwind$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN344
	DD	imagerel $LN344+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD 021H
	DD	imagerel $LN344
	DD	imagerel $LN344+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN344
	DD	imagerel $LN344+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD 020521H
	DD	04f405H
	DD	imagerel $LN344
	DD	imagerel $LN344+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z DD 070d01H
	DD	0e009420dH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD 021H
	DD	imagerel $LN169
	DD	imagerel $LN169+309
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD 020521H
	DD	0fc405H
	DD	imagerel $LN169
	DD	imagerel $LN169+309
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z DD 080f01H
	DD	0f00b320fH
	DD	0d007e009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN146
	DD	imagerel $LN146+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD 021H
	DD	imagerel $LN146
	DD	imagerel $LN146+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN146
	DD	imagerel $LN146+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD 020521H
	DD	04c405H
	DD	imagerel $LN146
	DD	imagerel $LN146+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z DD 070d01H
	DD	0f009420dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD 021H
	DD	imagerel $LN137
	DD	imagerel $LN137+385
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD 020521H
	DD	04c405H
	DD	imagerel $LN137
	DD	imagerel $LN137+385
	DD	imagerel $unwind$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z DD 070d01H
	DD	0f009420dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD 021H
	DD	imagerel $LN122
	DD	imagerel $LN122+230
	DD	imagerel $unwind$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD 020021H
	DD	0d6400H
	DD	imagerel $LN122
	DD	imagerel $LN122+230
	DD	imagerel $unwind$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN122
	DD	imagerel $LN122+230
	DD	imagerel $unwind$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 021H
	DD	imagerel $LN142
	DD	imagerel $LN142+300
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 020521H
	DD	0fc405H
	DD	imagerel $LN142
	DD	imagerel $LN142+300
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 080f01H
	DD	0f00b320fH
	DD	0d007e009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN94
	DD	imagerel $LN94+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 021H
	DD	imagerel $LN94
	DD	imagerel $LN94+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 020021H
	DD	04f400H
	DD	imagerel $LN94
	DD	imagerel $LN94+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 020521H
	DD	04f405H
	DD	imagerel $LN94
	DD	imagerel $LN94+59
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z DD 070d01H
	DD	0e009420dH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Link@Actor@@QEAAAEAU01@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD 020521H
	DD	08e405H
	DD	imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0f00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN223
	DD	imagerel $LN223+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04e400H
	DD	0a3400H
	DD	imagerel $LN223
	DD	imagerel $LN223+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN223+29
	DD	imagerel $LN223+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0b6405H
	DD	imagerel $LN223+29
	DD	imagerel $LN223+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	04e417H
	DD	0a3405H
	DD	imagerel $LN223
	DD	imagerel $LN223+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04e400H
	DD	0a3400H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	04e417H
	DD	0a3405H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04e400H
	DD	0a3400H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN70+29
	DD	imagerel $LN70+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	04e417H
	DD	0a3405H
	DD	imagerel $LN70
	DD	imagerel $LN70+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN68
	DD	imagerel $LN68+32
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020021H
	DD	0a3400H
	DD	imagerel $LN68
	DD	imagerel $LN68+32
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN68+32
	DD	imagerel $LN68+84
	DD	imagerel $chain$0$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	045405H
	DD	imagerel $LN68+32
	DD	imagerel $LN68+84
	DD	imagerel $chain$0$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN68
	DD	imagerel $LN68+32
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	046405H
	DD	imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	0b5417H
	DD	0a3405H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	04e400H
	DD	0a3400H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	0b6405H
	DD	imagerel $LN61+29
	DD	imagerel $LN61+100
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	04e417H
	DD	0a3405H
	DD	imagerel $LN61
	DD	imagerel $LN61+29
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+21
	DD	imagerel $unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UActor@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z DB 06H
	DB	0c8H
	DB	02H
	DB	01aH
	DB	04H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@URail@Actor@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z DD 061e19H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD 040e21H
	DD	07740eH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z DD 040a01H
	DD	08540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z DB 06H
	DB	0d6H
	DB	02H
	DB	01cH
	DB	04H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@ULink@Actor@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	036H
	DD	imagerel ?dtor$1@?0???$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z DD 061e19H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z
	DD	042H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD 040e21H
	DD	07740eH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z DD 040a01H
	DD	08540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'F'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD 061721H
	DD	08e417H
	DD	07740eH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+25
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z DD 040a01H
	DD	09540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 04H
	DB	0bcH
	DB	02H
	DB	'F'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 040e21H
	DD	07640eH
	DD	063405H
	DD	imagerel $LN27
	DD	imagerel $LN27+21
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 040a01H
	DD	08540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 0c2921H
	DD	067429H
	DD	04f421H
	DD	05c41cH
	DD	0c6413H
	DD	0b540eH
	DD	0a3405H
	DD	imagerel $LN61
	DD	imagerel $LN61+23
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z DD 030801H
	DD	0e0046208H
	DD	0d002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN145+299
	DD	imagerel $LN145+303
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 020021H
	DD	0f5400H
	DD	imagerel $LN145+299
	DD	imagerel $LN145+303
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 020521H
	DD	0f5405H
	DD	imagerel $LN145+299
	DD	imagerel $LN145+303
	DD	imagerel $chain$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 021H
	DD	imagerel $LN145
	DD	imagerel $LN145+60
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 020021H
	DD	04c400H
	DD	imagerel $LN145
	DD	imagerel $LN145+60
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 020521H
	DD	04c405H
	DD	imagerel $LN145
	DD	imagerel $LN145+60
	DD	imagerel $unwind$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z DD 070e01H
	DD	0f00a420eH
	DD	0d006e008H
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 020521H
	DD	046405H
	DD	imagerel $LN67+30
	DD	imagerel $LN67+101
	DD	imagerel $chain$1$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 041721H
	DD	0b5417H
	DD	0a3405H
	DD	imagerel $LN67
	DD	imagerel $LN67+30
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z DD 030801H
	DD	0e0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z DB 04H
	DB	092H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z DD 061e19H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupExportMod.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
;	COMDAT ?DrawToolsWindow@UITools@@YAXXZ
_TEXT	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?DrawToolsWindow@UITools@@YAXXZ PROC			; UITools::DrawToolsWindow, COMDAT

; 24   : {

$LN1334:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1960]
	sub	rsp, 2176				; 00000880H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	xor	edi, edi
	mov	r15d, edi
	mov	DWORD PTR $T8[rsp], edi

; 25   : 	if (!Open) return;

	cmp	BYTE PTR ?Open@UITools@@3_NA, dil	; UITools::Open
	je	$LN1@DrawToolsW

; 26   : 
; 27   : 	ImGui::Begin("Tools", &Open);

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?Open@UITools@@3_NA	; UITools::Open
	lea	rcx, OFFSET FLAT:??_C@_05OENKALAF@Tools@
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]

; 8007 :     return window->Size;

	movss	xmm0, DWORD PTR [rax+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 29   : 	if (ImGui::Button("Save", ImVec2(ImGui::GetWindowSize().x * 0.5f - ImGui::GetStyle().ItemSpacing.x, 0)))

	movss	xmm6, DWORD PTR __real@3f000000
	mulss	xmm0, xmm6
	subss	xmm0, DWORD PTR [rcx+14628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T14[rsp], xmm0
	xorps	xmm7, xmm7
	mov	DWORD PTR $T14[rsp+4], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T14[rsp]
	lea	rcx, OFFSET FLAT:??_C@_04INACKGJP@Save@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 29   : 	if (ImGui::Button("Save", ImVec2(ImGui::GetWindowSize().x * 0.5f - ImGui::GetStyle().ItemSpacing.x, 0)))

	test	al, al
	je	SHORT $LN9@DrawToolsW
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T55[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T55[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T55[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rdi+4]
	lea	rdx, OFFSET FLAT:??_C@_04INACKGJP@Save@
	lea	rcx, QWORD PTR $T55[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 31   : 		Exporter::Export(Editor::GetWorkingDirFile("Save"), Exporter::Operation::Save);

	lea	rdx, QWORD PTR $T55[rbp-256]
	lea	rcx, QWORD PTR $T51[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	dl, 1
	mov	rcx, rax
	call	?Export@Exporter@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Operation@1@@Z ; Exporter::Export
$LN9@DrawToolsW:

; 32   : 	}
; 33   : 	ImGui::SameLine();

	movss	xmm1, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8006 :     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rdx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rdx+16408]

; 8007 :     return window->Size;

	movss	xmm4, DWORD PTR [rax+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 34   : 	if (ImGui::Button("Export", ImVec2(ImGui::GetWindowSize().x * 0.5f - ImGui::GetStyle().FramePadding.x, 0)))

	mulss	xmm4, xmm6
	subss	xmm4, DWORD PTR [rdx+14612]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T13[rsp], xmm4
	mov	DWORD PTR $T13[rsp+4], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T13[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06BFGAPCKF@Export@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 34   : 	if (ImGui::Button("Export", ImVec2(ImGui::GetWindowSize().x * 0.5f - ImGui::GetStyle().FramePadding.x, 0)))

	test	al, al
	je	SHORT $LN108@DrawToolsW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupExportMod.cpp

; 48   : 	Func = Callback;

	lea	rax, OFFSET FLAT:?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; `UITools::DrawToolsWindow'::`10'::<lambda_1>::<lambda_invoker_cdecl>
	mov	QWORD PTR ?Func@PopupExportMod@@3P6AXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ZEA, rax ; PopupExportMod::Func

; 49   : 	IsOpen = true;

	mov	BYTE PTR ?IsOpen@PopupExportMod@@3_NA, 1 ; PopupExportMod::IsOpen
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rcx, OFFSET FLAT:?Path@PopupExportMod@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; PopupExportMod::Path
	lea	rdx, OFFSET FLAT:?ExportDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::ExportDir
	cmp	rcx, rdx
	je	SHORT $LN108@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR ?ExportDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rdx, QWORD PTR ?ExportDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR ?ExportDir@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN108@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 1465 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]

; 1466 :     if (window->SkipItems)

	cmp	BYTE PTR [rax+240], dil
	jne	SHORT $LN91@DrawToolsW

; 1467 :         return;
; 1468 : 
; 1469 :     // Those flags should eventually be configurable by the user
; 1470 :     // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
; 1471 :     ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
; 1472 :     flags |= ImGuiSeparatorFlags_SpanAllColumns; // NB: this only applies to legacy Columns() api as they relied on Separator() a lot.

	mov	eax, DWORD PTR [rax+492]
	neg	eax
	sbb	ecx, ecx
	add	ecx, 6

; 1473 :     SeparatorEx(flags, 1.0f);

	movss	xmm1, DWORD PTR __real@3f800000
	call	?SeparatorEx@ImGui@@YAXHM@Z		; ImGui::SeparatorEx
	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN91@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 44   : 	if (UIMapView::Focused)

	cmp	BYTE PTR ?Focused@UIMapView@@3_NA, dil	; UIMapView::Focused
	je	$LN24@DrawToolsW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rcx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	r10, QWORD PTR [rcx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6429 :     if (window->SkipItems)

	cmp	BYTE PTR [r10+240], dil
	jne	$LN12@DrawToolsW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 1926 :     inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }

	movsxd	rcx, DWORD PTR [r10+296]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 2049 :     seed = ~seed;

	mov	rax, QWORD PTR [r10+304]
	mov	r9d, DWORD PTR [rax+rcx*4-4]
	not	r9d

; 2050 :     ImU32 crc = seed;

	mov	ebx, r9d

; 2051 :     const unsigned char* data = (const unsigned char*)data_p;
; 2052 :     const ImU32* crc32_lut = GCrc32LookupTable;
; 2053 :     if (data_size != 0)
; 2054 :     {
; 2055 :         while (data_size-- != 0)
; 2056 :         {
; 2057 :             unsigned char c = *data++;
; 2058 :             if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
; 2059 :                 crc = seed;
; 2060 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
; 2061 :         }
; 2062 :     }
; 2063 :     else
; 2064 :     {
; 2065 :         while (unsigned char c = *data++)

	lea	rdx, OFFSET FLAT:??_C@_06EPLDPNDB@Render@+1
	mov	r8b, 82					; 00000052H
	lea	r11, OFFSET FLAT:?GCrc32LookupTable@@3QBIB
$LL131@DrawToolsW:

; 2066 :         {
; 2067 :             if (c == '#' && data[0] == '#' && data[1] == '#')

	cmp	r8b, 35					; 00000023H
	jne	SHORT $LN136@DrawToolsW
	cmp	BYTE PTR [rdx], r8b
	jne	SHORT $LN136@DrawToolsW
	cmp	BYTE PTR [rdx+1], r8b
	cmove	ebx, r9d
$LN136@DrawToolsW:

; 2068 :                 crc = seed;
; 2069 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	ecx, bl
	movzx	eax, r8b
	xor	rcx, rax
	shr	ebx, 8
	xor	ebx, DWORD PTR [r11+rcx*4]

; 2051 :     const unsigned char* data = (const unsigned char*)data_p;
; 2052 :     const ImU32* crc32_lut = GCrc32LookupTable;
; 2053 :     if (data_size != 0)
; 2054 :     {
; 2055 :         while (data_size-- != 0)
; 2056 :         {
; 2057 :             unsigned char c = *data++;
; 2058 :             if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
; 2059 :                 crc = seed;
; 2060 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
; 2061 :         }
; 2062 :     }
; 2063 :     else
; 2064 :     {
; 2065 :         while (unsigned char c = *data++)

	movzx	r8d, BYTE PTR [rdx]
	inc	rdx
	test	r8b, r8b
	jne	SHORT $LL131@DrawToolsW

; 2070 :         }
; 2071 :     }
; 2072 :     return ~crc;

	not	ebx

; 3854 :     ImGuiContext& g = *Ctx;

	mov	rax, QWORD PTR [r10]

; 3855 :     if (g.DebugHookIdInfo == id)

	cmp	DWORD PTR [rax+16480], ebx
	jne	SHORT $LN122@DrawToolsW

; 3856 :         ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);

	lea	r8, OFFSET FLAT:??_C@_06EPLDPNDB@Render@
	mov	edx, 11
	mov	ecx, ebx
	call	?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z	; ImGui::DebugHookIdInfo
$LN122@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 6432 :     return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_06EPLDPNDB@Render@
	lea	edx, QWORD PTR [r9+58]
	mov	ecx, ebx
	call	?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z	; ImGui::TreeNodeBehavior
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 46   : 		if (ImGui::CollapsingHeader("Render", ImGuiTreeNodeFlags_::ImGuiTreeNodeFlags_DefaultOpen))

	test	al, al
	je	$LN12@DrawToolsW

; 47   : 		{
; 48   : 			ImGui::Indent();

	movaps	xmm0, xmm7
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 49   : 			ImGui::Checkbox("Visible actors", &UIMapView::RenderSettings.RenderVisibleActors);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A ; UIMapView::RenderSettings
	lea	rcx, OFFSET FLAT:??_C@_0P@KHDBJKCM@Visible?5actors@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 50   : 			ImGui::Checkbox("Invisible actors", &UIMapView::RenderSettings.RenderInvisibleActors);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1
	lea	rcx, OFFSET FLAT:??_C@_0BB@BEPLMMON@Invisible?5actors@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 51   : 			ImGui::Indent();

	movaps	xmm0, xmm7
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 52   : 			if (!UIMapView::RenderSettings.RenderInvisibleActors) ImGui::BeginDisabled();

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, dil
	jne	SHORT $LN13@DrawToolsW
	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
$LN13@DrawToolsW:

; 53   : 			ImGui::Checkbox("Areas", &UIMapView::RenderSettings.RenderAreas);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+2
	lea	rcx, OFFSET FLAT:??_C@_05EINELICJ@Areas@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 54   : 			if (!UIMapView::RenderSettings.RenderInvisibleActors) ImGui::EndDisabled();

	cmp	BYTE PTR ?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+1, dil
	jne	SHORT $LN14@DrawToolsW
	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled
$LN14@DrawToolsW:

; 55   : 			ImGui::Unindent();

	movaps	xmm0, xmm7
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent

; 56   : 			ImGui::Checkbox("Far actors", &UIMapView::RenderSettings.RenderFarActors);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+3
	lea	rcx, OFFSET FLAT:??_C@_0L@CMFCHGAA@Far?5actors@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 57   : 			ImGui::Checkbox("NPCs", &UIMapView::RenderSettings.RenderNPCs);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+4
	lea	rcx, OFFSET FLAT:??_C@_04GDNNPIME@NPCs@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 58   : 			ImGui::Checkbox("NavMesh", &UIMapView::RenderSettings.RenderNavMesh);

	lea	rdx, OFFSET FLAT:?RenderSettings@UIMapView@@3URenderingSettingsStruct@1@A+6
	lea	rcx, OFFSET FLAT:??_C@_07BHIPFKL@NavMesh@
	call	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z	; ImGui::Checkbox

; 59   : 			ImGui::Unindent();

	movaps	xmm0, xmm7
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent
$LN12@DrawToolsW:

; 60   : 		}
; 61   : 		if (SceneMgr::SceneType == SceneMgr::Type::SmallDungeon && !Editor::Identifier.empty())

	cmp	DWORD PTR ?SceneType@SceneMgr@@3W4Type@1@A, 4 ; SceneMgr::SceneType
	jne	$LN1328@DrawToolsW
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, rdi
	je	$LN1328@DrawToolsW

; 62   : 		{
; 63   : 			if (ImGui::CollapsingHeader("SmallDungeon", ImGuiTreeNodeFlags_::ImGuiTreeNodeFlags_DefaultOpen))

	mov	edx, 32					; 00000020H
	lea	rcx, OFFSET FLAT:??_C@_0N@KMIGGLHL@SmallDungeon@
	call	?CollapsingHeader@ImGui@@YA_NPEBDH@Z	; ImGui::CollapsingHeader
	test	al, al
	je	$LN1328@DrawToolsW

; 64   : 			{
; 65   : 				ImGui::Indent();

	movaps	xmm0, xmm7
	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 66   : 				if (UIOutliner::SelectedActor == nullptr)

	cmp	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, rdi ; UIOutliner::SelectedActor
	jne	SHORT $LN17@DrawToolsW

; 67   : 					ImGui::BeginDisabled();

	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
$LN17@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T12[rsp], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T12[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BF@PMELGHKF@StartPos?5to?5selected@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 68   : 				if (ImGui::Button("StartPos to selected"))

	mov	r14, 9223372036854775807		; 7fffffffffffffffH
	lea	rsi, OFFSET FLAT:?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::Identifier
	test	al, al
	je	$LN960@DrawToolsW
	xor	edx, edx
	mov	r8d, 224				; 000000e0H
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	memset
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T54[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T54[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T54[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 56					; 00000038H
	lea	rdx, OFFSET FLAT:??_C@_0DJ@OLAKHFGA@Banc?1SmallDungeon?1StartPos?1Smal@
	lea	rcx, QWORD PTR $T54[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 70   : 					BymlFile StartPosByml(ZStdFile::Decompress(Editor::GetRomFSFile("Banc/SmallDungeon/StartPos/SmallDungeon.startpos.byml.zs"), ZStdFile::Dictionary::Base).Data);

	mov	r8b, 1
	lea	rdx, QWORD PTR $T54[rbp-256]
	lea	rcx, QWORD PTR $T59[rbp-256]
	call	?GetRomFSFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@_N@Z ; Editor::GetRomFSFile
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR $T61[rbp-256]
	call	?Decompress@ZStdFile@@YA?AUResult@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Dictionary@1@@Z ; ZStdFile::Decompress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rax+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+16], rdi

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rax+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+8], rdi

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rax]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR $T63[rbp-256], rcx
	mov	QWORD PTR $T63[rbp-248], rdx
	mov	QWORD PTR $T63[rbp-240], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 70   : 					BymlFile StartPosByml(ZStdFile::Decompress(Editor::GetRomFSFile("Banc/SmallDungeon/StartPos/SmallDungeon.startpos.byml.zs"), ZStdFile::Dictionary::Base).Data);

	lea	rdx, QWORD PTR $T63[rbp-256]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	??0BymlFile@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; BymlFile::BymlFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T61[rbp-256]
	test	rcx, rcx
	je	SHORT $LN687@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T61[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN705@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN705@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN705@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T61[rbp-256], rdi
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR $T61[rbp-248], xmm0
$LN687@DrawToolsW:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T25[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T25[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T25[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T25[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 72   : 					if (StartPosByml.GetNode("OnElevator")->HasChild("Dungeon" + Editor::Identifier))

	lea	rdx, QWORD PTR $T25[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T50[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r15d, 8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 72   : 					if (StartPosByml.GetNode("OnElevator")->HasChild("Dungeon" + Editor::Identifier))

	lea	rdx, QWORD PTR $T50[rbp-256]
	mov	rcx, rbx
	call	?HasChild@Node@BymlFile@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::HasChild
	test	al, al
	je	$LN19@DrawToolsW
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T24[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T24[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T24[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T24[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 74   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(0)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetX());

	lea	rdx, QWORD PTR $T24[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T65[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 74   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(0)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetX());

	lea	rdx, QWORD PTR $T65[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T40[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T40[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T40[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15-3]
	lea	rdx, OFFSET FLAT:??_C@_05JPPBPLGL@Trans@
	lea	rcx, QWORD PTR $T40[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 74   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(0)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetX());

	lea	rdx, QWORD PTR $T40[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 74   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(0)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetX());

	movss	xmm1, DWORD PTR [rax+52]
	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T23[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T23[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T23[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T23[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 75   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(1)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetY());

	lea	rdx, QWORD PTR $T23[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T49[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 75   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(1)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetY());

	lea	rdx, QWORD PTR $T49[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T39[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T39[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T39[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15-3]
	lea	rdx, OFFSET FLAT:??_C@_05JPPBPLGL@Trans@
	lea	rcx, QWORD PTR $T39[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 75   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(1)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetY());

	lea	rdx, QWORD PTR $T39[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
	add	rcx, 88					; 00000058H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 75   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(1)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetY());

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	movss	xmm1, DWORD PTR [rax+56]
	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T22[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T22[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T22[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T22[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 76   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(2)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetZ());

	lea	rdx, QWORD PTR $T22[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T48[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 76   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(2)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetZ());

	lea	rdx, QWORD PTR $T48[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T38[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T38[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T38[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15-3]
	lea	rdx, OFFSET FLAT:??_C@_05JPPBPLGL@Trans@
	lea	rcx, QWORD PTR $T38[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 76   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(2)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetZ());

	lea	rdx, QWORD PTR $T38[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
	add	rcx, 176				; 000000b0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 76   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Trans")->GetChild(2)->SetValue<float>(UIOutliner::SelectedActor->Translate.GetZ());

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	movss	xmm1, DWORD PTR [rax+60]
	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T21[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T21[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T21[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T21[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 78   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(0)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetX()));

	lea	rdx, QWORD PTR $T21[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T47[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 78   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(0)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetX()));

	lea	rdx, QWORD PTR $T47[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T37[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T37[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T37[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15-5]
	lea	rdx, OFFSET FLAT:??_C@_03LHGHNHCF@Rot@
	lea	rcx, QWORD PTR $T37[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 78   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(0)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetX()));

	lea	rdx, QWORD PTR $T37[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	movss	xmm1, DWORD PTR [rax+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm6, DWORD PTR __real@3c8efa35
	mulss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 78   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(0)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetX()));

	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T20[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T20[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T20[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T20[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 79   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(1)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetY()));

	lea	rdx, QWORD PTR $T20[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T46[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 79   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(1)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetY()));

	lea	rdx, QWORD PTR $T46[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T36[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T36[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T36[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15-5]
	lea	rdx, OFFSET FLAT:??_C@_03LHGHNHCF@Rot@
	lea	rcx, QWORD PTR $T36[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 79   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(1)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetY()));

	lea	rdx, QWORD PTR $T36[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
	add	rcx, 88					; 00000058H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 79   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(1)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetY()));

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	movss	xmm1, DWORD PTR [rax+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 79   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(1)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetY()));

	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T19[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T19[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T19[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r15+2]
	lea	rdx, OFFSET FLAT:??_C@_0L@BHNPBHIE@OnElevator@
	lea	rcx, QWORD PTR $T19[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 80   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(2)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetZ()));

	lea	rdx, QWORD PTR $T19[rsp]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?GetNode@BymlFile@@QEAAPEAVNode@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::GetNode
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	rdx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, r14
	sub	rcx, rdx
	cmp	rcx, 7
	jb	$LN1321@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, rsi
	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	cmovae	rcx, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	mov	QWORD PTR [rsp+48], rdx
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], 7
	lea	r9, OFFSET FLAT:??_C@_07CELLBLHP@Dungeon@
	lea	rcx, QWORD PTR $T45[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	r15d, 2024				; 000007e8H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 80   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(2)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetZ()));

	lea	rdx, QWORD PTR $T45[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
	mov	rbx, rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T35[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T35[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T35[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:??_C@_03LHGHNHCF@Rot@
	lea	rcx, QWORD PTR $T35[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 80   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(2)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetZ()));

	lea	rdx, QWORD PTR $T35[rbp-256]
	mov	rcx, rbx
	call	?GetChild@Node@BymlFile@@QEAAPEAV12@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; BymlFile::Node::GetChild
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+64]
	add	rcx, 176				; 000000b0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 80   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(2)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetZ()));

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	movss	xmm1, DWORD PTR [rax+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm1, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 80   : 						StartPosByml.GetNode("OnElevator")->GetChild("Dungeon" + Editor::Identifier)->GetChild("Rot")->GetChild(2)->SetValue<float>(Util::DegreesToRadians(UIOutliner::SelectedActor->Rotate.GetZ()));

	call	??$SetValue@M@Node@BymlFile@@QEAAXM@Z	; BymlFile::Node::SetValue<float>
$LN19@DrawToolsW:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T18[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T18[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T18[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 31
	lea	rdx, OFFSET FLAT:??_C@_0CA@JKHPMBLD@Save?1Banc?1SmallDungeon?1StartPos@
	lea	rcx, QWORD PTR $T18[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 83   : 					Util::CreateDir(Editor::GetWorkingDirFile("Save/Banc/SmallDungeon/StartPos"));

	lea	rdx, QWORD PTR $T18[rsp]
	lea	rcx, QWORD PTR $T44[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	rcx, rax
	call	?CreateDir@Util@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::CreateDir

; 84   : 					ZStdFile::Compress(StartPosByml.ToBinary(BymlFile::TableGeneration::Auto), ZStdFile::Dictionary::Base).WriteToFile(Editor::GetWorkingDirFile("Save/Banc/SmallDungeon/StartPos/SmallDungeon.startpos.byml.zs"));

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T34[rbp-256]
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?ToBinary@BymlFile@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@W4TableGeneration@1@@Z ; BymlFile::ToBinary
	mov	rsi, rax
	mov	QWORD PTR $T30[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T28[rsp], xmm0
	mov	QWORD PTR $T28[rsp+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 207  : 	return Result;

	or	r15d, 16
	mov	DWORD PTR $T8[rsp], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+8]
	sub	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 174  : 	Result.Data.resize(ZSTD_compressBound(Bytes.size()));

	call	ZSTD_compressBound
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR $T28[rsp+8]
	mov	rcx, r9
	mov	rdx, QWORD PTR $T28[rsp]
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rax, rcx
	jae	SHORT $LN791@DrawToolsW

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	add	rax, rdx
	mov	QWORD PTR $T28[rsp+8], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN792@DrawToolsW
$LN791@DrawToolsW:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN792@DrawToolsW

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR $T28[rsp+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN793@DrawToolsW

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T28[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN792@DrawToolsW
$LN793@DrawToolsW:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR $T28[rsp+8], rbx
$LN792@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 190  : 			CompressionDict = m_CompressDictBase;

	mov	rbx, QWORD PTR ?m_CompressDictBase@@3PEAUZSTD_CDict_s@@EA ; m_CompressDictBase

; 191  : 			break;
; 192  : 		case ZStdFile::Dictionary::Pack:
; 193  : 			CompressionDict = m_CompressDictPack;
; 194  : 			break;
; 195  : 		case ZStdFile::Dictionary::BcettByaml:
; 196  : 			CompressionDict = m_CompressDictBcettByaml;
; 197  : 			break;
; 198  : 		}
; 199  : 
; 200  : 		ZSTD_CCtx* cctx = ZSTD_createCCtx();

	call	ZSTD_createCCtx
	mov	r14, rax

; 201  : 		ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel, 16); //16 = compression level

	mov	edx, 100				; 00000064H
	lea	r8d, QWORD PTR [rdx-84]
	mov	rcx, rax
	call	ZSTD_CCtx_setParameter
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR [rsi]
	mov	rcx, QWORD PTR [rsi+8]
	sub	rcx, r9
	mov	r8, QWORD PTR $T28[rsp+8]
	mov	rdx, QWORD PTR $T28[rsp]
	sub	r8, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 202  : 		const size_t CompSize = ZSTD_compress_usingCDict(cctx, (void*)Result.Data.data(), Result.Data.size(), Bytes.data(), Bytes.size(), CompressionDict);

	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r14
	call	ZSTD_compress_usingCDict
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR $T28[rsp+8]
	mov	rcx, r9
	mov	rdx, QWORD PTR $T28[rsp]
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rax, rcx
	jae	SHORT $LN853@DrawToolsW

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	add	rax, rdx
	mov	QWORD PTR $T28[rsp+8], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN854@DrawToolsW
$LN853@DrawToolsW:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN854@DrawToolsW

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR $T28[rsp+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN855@DrawToolsW

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T28[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN854@DrawToolsW
$LN855@DrawToolsW:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR $T28[rsp+8], rbx
$LN854@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 204  : 		ZSTD_freeCCtx(cctx);

	mov	rcx, r14
	call	ZSTD_freeCCtx
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN880@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN898@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN895@DrawToolsW

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN898@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rdi
$LN880@DrawToolsW:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T17[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T17[rsp+16], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T17[rsp+24], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 61					; 0000003dH
	lea	rdx, OFFSET FLAT:??_C@_0DO@MLFIGNDM@Save?1Banc?1SmallDungeon?1StartPos@
	lea	rcx, QWORD PTR $T17[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 84   : 					ZStdFile::Compress(StartPosByml.ToBinary(BymlFile::TableGeneration::Auto), ZStdFile::Dictionary::Base).WriteToFile(Editor::GetWorkingDirFile("Save/Banc/SmallDungeon/StartPos/SmallDungeon.startpos.byml.zs"));

	lea	rdx, QWORD PTR $T17[rsp]
	lea	rcx, QWORD PTR $T43[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	rdx, rax
	lea	rcx, QWORD PTR $T28[rsp]
	call	?WriteToFile@Result@ZStdFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ZStdFile::Result::WriteToFile
	and	r15d, -17
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T28[rsp]
	test	rcx, rcx
	je	SHORT $LN928@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T28[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN940@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN940@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN895@DrawToolsW:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN940@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN928@DrawToolsW:
	lea	rcx, QWORD PTR StartPosByml$67[rbp-104]
	call	??1?$_Hash@V?$_Umap_traits@VNode@BymlFile@@IV?$_Uhash_compare@VNode@BymlFile@@UNodeHasher@2@UNodeEqual@2@@std@@V?$allocator@U?$pair@$$CBVNode@BymlFile@@I@std@@@4@$0A@@std@@@std@@QEAA@XZ
	lea	rcx, QWORD PTR StartPosByml$67[rbp-168]
	call	??1?$_Hash@V?$_Umap_traits@V?$vector@EV?$allocator@E@std@@@std@@IV?$_Uhash_compare@V?$vector@EV?$allocator@E@std@@@std@@UVectorHasher@BymlFile@@U?$equal_to@V?$vector@EV?$allocator@E@std@@@std@@@2@@2@V?$allocator@U?$pair@$$CBV?$vector@EV?$allocator@E@std@@@std@@I@std@@@2@$0A@@std@@@std@@QEAA@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR StartPosByml$67[rbp-208]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR StartPosByml$67[rbp-232]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AEAAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	lea	rcx, QWORD PTR StartPosByml$67[rbp-256]
	call	?_Tidy@?$vector@VNode@BymlFile@@V?$allocator@VNode@BymlFile@@@std@@@std@@AEAAXXZ ; std::vector<BymlFile::Node,std::allocator<BymlFile::Node> >::_Tidy
$LN960@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 86   : 				if (UIOutliner::SelectedActor == nullptr)

	cmp	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, 0 ; UIOutliner::SelectedActor
	jne	SHORT $LN20@DrawToolsW

; 87   : 					ImGui::EndDisabled();

	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled
$LN20@DrawToolsW:

; 88   : 
; 89   : #ifdef STARLIGHT_SHARED
; 90   : 					ImGui::BeginDisabled();

	call	?BeginDisabled@ImGui@@YAX_N@Z		; ImGui::BeginDisabled
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T11[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T11[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BB@KGNBKLMN@Generate?5NavMesh@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 93   : 				if (ImGui::Button("Generate NavMesh"))

	test	al, al
	je	$LN513@DrawToolsW
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR Vertices$60[rbp-256], xmm1
	mov	QWORD PTR Vertices$60[rbp-240], rdi
	movdqu	XMMWORD PTR Indices$64[rbp-256], xmm1
	mov	QWORD PTR Indices$64[rbp-240], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 137  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	mov	r12, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rsi, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 137  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	cmp	rsi, r12
	je	SHORT $LN3@DrawToolsW
$LL4@DrawToolsW:

; 138  : 					{
; 139  : 						GenereateNavMeshModel(SceneActor, Vertices, Indices);

	lea	r9, QWORD PTR Indices$64[rbp-256]
	lea	r8, QWORD PTR Vertices$60[rbp-256]
	mov	rdx, rsi
	call	??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z ; `UITools::DrawToolsWindow'::`39'::<lambda_2>::operator()

; 140  : 						for (Actor& ChildActor : SceneActor.MergedActorContent)

	mov	r14, QWORD PTR [rsi+440]

; 137  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	mov	rbx, QWORD PTR [rsi+432]

; 140  : 						for (Actor& ChildActor : SceneActor.MergedActorContent)

	cmp	rbx, r14
	je	SHORT $LN2@DrawToolsW
	npad	13
$LL7@DrawToolsW:

; 141  : 						{
; 142  : 							GenereateNavMeshModel(ChildActor, Vertices, Indices);

	lea	r9, QWORD PTR Indices$64[rbp-256]
	lea	r8, QWORD PTR Vertices$60[rbp-256]
	mov	rdx, rbx
	call	??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z ; `UITools::DrawToolsWindow'::`39'::<lambda_2>::operator()

; 140  : 						for (Actor& ChildActor : SceneActor.MergedActorContent)

	add	rbx, 872				; 00000368H
	cmp	rbx, r14
	jne	SHORT $LL7@DrawToolsW
$LN2@DrawToolsW:

; 137  : 					for (Actor& SceneActor : ActorMgr::GetActors())

	add	rsi, 872				; 00000368H
	cmp	rsi, r12
	jne	SHORT $LL4@DrawToolsW
$LN3@DrawToolsW:
	xor	edx, edx
	mov	r8d, 1552				; 00000610H
	lea	rcx, QWORD PTR NavMesh$68[rbp-256]
	call	memset
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T42[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T42[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T42[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 44					; 0000002cH
	lea	rdx, OFFSET FLAT:??_C@_0CN@NAICAGED@Phive?1NavMesh?1Dungeon136?4Nin_NX@
	lea	rcx, QWORD PTR $T42[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 146  : 					PhiveNavMesh NavMesh(ZStdFile::Decompress(Editor::GetRomFSFile("Phive/NavMesh/Dungeon136.Nin_NX_NVN.bphnm.zs", false), ZStdFile::Dictionary::Base).Data);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T42[rbp-256]
	lea	rcx, QWORD PTR $T58[rbp-256]
	call	?GetRomFSFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@_N@Z ; Editor::GetRomFSFile
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR $T33[rbp-256]
	call	?Decompress@ZStdFile@@YA?AUResult@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Dictionary@1@@Z ; ZStdFile::Decompress
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rax+16]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+16], rdi

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rdx, QWORD PTR [rax+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+8], rdi

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rax]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR $T27[rsp], rcx
	mov	QWORD PTR $T27[rsp+8], rdx
	mov	QWORD PTR $T27[rsp+16], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 146  : 					PhiveNavMesh NavMesh(ZStdFile::Decompress(Editor::GetRomFSFile("Phive/NavMesh/Dungeon136.Nin_NX_NVN.bphnm.zs", false), ZStdFile::Dictionary::Base).Data);

	lea	rdx, QWORD PTR $T27[rsp]
	lea	rcx, QWORD PTR NavMesh$68[rbp-256]
	call	??0PhiveNavMesh@@QEAA@V?$vector@EV?$allocator@E@std@@@std@@@Z ; PhiveNavMesh::PhiveNavMesh
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T33[rbp-256]
	test	rcx, rcx
	je	SHORT $LN379@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T33[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN397@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN397@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN397@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR $T33[rbp-256], rdi
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR $T33[rbp-248], xmm0
$LN379@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 147  : 					NavMesh.SetNavMeshModel(Vertices, Indices);

	lea	rax, QWORD PTR $T16[rsp]
	mov	QWORD PTR $T31[rbp-256], rax
	lea	rdx, QWORD PTR Indices$64[rbp-256]
	lea	rcx, QWORD PTR $T16[rsp]
	call	??0?$vector@IV?$allocator@I@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	rbx, rax
	lea	rdx, QWORD PTR Vertices$60[rbp-256]
	lea	rcx, QWORD PTR $T53[rbp-256]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	mov	r8, rbx
	mov	rdx, rax
	lea	rcx, QWORD PTR NavMesh$68[rbp-256]
	call	?SetNavMeshModel@PhiveNavMesh@@QEAAXV?$vector@MV?$allocator@M@std@@@std@@V?$vector@IV?$allocator@I@std@@@3@@Z ; PhiveNavMesh::SetNavMeshModel
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR Data$62[rbp-256], xmm0
	mov	QWORD PTR Data$62[rbp-240], rax

; 148  : 					std::vector<unsigned char> Data = NavMesh.ToBinary();

	lea	rdx, QWORD PTR Data$62[rbp-256]
	lea	rcx, QWORD PTR NavMesh$68[rbp-256]
	call	?ToBinary@PhiveNavMesh@@QEAA?AV?$vector@EV?$allocator@E@std@@@std@@XZ ; PhiveNavMesh::ToBinary
	npad	1
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T41[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T41[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T41[rbp-232], rdi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 18
	lea	rdx, OFFSET FLAT:??_C@_0BD@KNBDJGLP@Save?1Phive?1NavMesh@
	lea	rcx, QWORD PTR $T41[rbp-256]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 149  : 					Util::CreateDir(Editor::GetWorkingDirFile("Save/Phive/NavMesh"));

	lea	rdx, QWORD PTR $T41[rbp-256]
	lea	rcx, QWORD PTR $T57[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	rcx, rax
	call	?CreateDir@Util@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Util::CreateDir

; 150  : 					ZStdFile::Compress(Data, ZStdFile::Dictionary::Base).WriteToFile(Editor::GetWorkingDirFile("Save/Phive/NavMesh/Dungeon" + Editor::Identifier + ".Nin_NX_NVN.bphnm.zs"));

	lea	rdx, QWORD PTR Data$62[rbp-256]
	lea	rcx, QWORD PTR $T52[rbp-256]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@AEBV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	rsi, rax
	mov	QWORD PTR $T29[rbp-256], rax
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T26[rsp], xmm0
	mov	QWORD PTR $T26[rsp+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 207  : 	return Result;

	or	r15d, 2
	mov	DWORD PTR $T8[rsp], r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+8]
	sub	rcx, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 174  : 	Result.Data.resize(ZSTD_compressBound(Bytes.size()));

	call	ZSTD_compressBound
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR $T26[rsp+8]
	mov	rcx, r9
	mov	rdx, QWORD PTR $T26[rsp]
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rax, rcx
	jae	SHORT $LN246@DrawToolsW

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	add	rax, rdx
	mov	QWORD PTR $T26[rsp+8], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN247@DrawToolsW
$LN246@DrawToolsW:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN247@DrawToolsW

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR $T26[rsp+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN248@DrawToolsW

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T26[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN247@DrawToolsW
$LN248@DrawToolsW:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR $T26[rsp+8], rbx
$LN247@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 190  : 			CompressionDict = m_CompressDictBase;

	mov	rbx, QWORD PTR ?m_CompressDictBase@@3PEAUZSTD_CDict_s@@EA ; m_CompressDictBase

; 191  : 			break;
; 192  : 		case ZStdFile::Dictionary::Pack:
; 193  : 			CompressionDict = m_CompressDictPack;
; 194  : 			break;
; 195  : 		case ZStdFile::Dictionary::BcettByaml:
; 196  : 			CompressionDict = m_CompressDictBcettByaml;
; 197  : 			break;
; 198  : 		}
; 199  : 
; 200  : 		ZSTD_CCtx* cctx = ZSTD_createCCtx();

	call	ZSTD_createCCtx
	mov	r14, rax

; 201  : 		ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel, 16); //16 = compression level

	mov	edx, 100				; 00000064H
	lea	r8d, QWORD PTR [rdx-84]
	mov	rcx, rax
	call	ZSTD_CCtx_setParameter
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR [rsi]
	mov	rcx, QWORD PTR [rsi+8]
	sub	rcx, r9
	mov	r8, QWORD PTR $T26[rsp+8]
	mov	rdx, QWORD PTR $T26[rsp]
	sub	r8, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 202  : 		const size_t CompSize = ZSTD_compress_usingCDict(cctx, (void*)Result.Data.data(), Result.Data.size(), Bytes.data(), Bytes.size(), CompressionDict);

	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r14
	call	ZSTD_compress_usingCDict
	mov	r8, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR $T26[rsp+8]
	mov	rcx, r9
	mov	rdx, QWORD PTR $T26[rsp]
	sub	rcx, rdx

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rax, rcx
	jae	SHORT $LN308@DrawToolsW

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	add	rax, rdx
	mov	QWORD PTR $T26[rsp+8], rax

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;
; 1564 :             return;

	jmp	SHORT $LN309@DrawToolsW
$LN308@DrawToolsW:

; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN309@DrawToolsW

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR $T26[rsp+16]
	sub	rax, rdx

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	r8, rax
	jbe	SHORT $LN310@DrawToolsW

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, r8
	lea	rcx, QWORD PTR $T26[rsp]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1571 :                 return;

	jmp	SHORT $LN309@DrawToolsW
$LN310@DrawToolsW:

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	r8, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [r8+r9]

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, r9
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	QWORD PTR $T26[rsp+8], rbx
$LN309@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\ZStdFile.cpp

; 204  : 		ZSTD_freeCCtx(cctx);

	mov	rcx, r14
	call	ZSTD_freeCCtx
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN335@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN353@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN639@DrawToolsW

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN353@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], rdi

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rdi

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rdi
$LN335@DrawToolsW:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4915 :     const auto _Right_size = _Right.size();

	mov	r13, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rcx
	sub	rax, r13
	cmp	rax, 26
	jb	$LN1331@DrawToolsW

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16
	lea	r12, OFFSET FLAT:?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; Editor::Identifier
	cmovae	r12, QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rsp], xmm0
	xorps	xmm1, xmm1

; 2293 :     size_type _Mysize = 0; // current length of string

	movdqu	XMMWORD PTR $T15[rsp+16], xmm1

; 2787 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

	lea	r14, QWORD PTR [r13+26]

; 2788 :         size_type _New_capacity = _BUF_SIZE - 1;

	mov	esi, 15

; 2789 :         auto& _My_data          = _Mypair._Myval2;
; 2790 :         _Elem* _Ptr             = _My_data._Bx._Buf;

	lea	rbx, QWORD PTR $T15[rsp]

; 2791 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2792 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2793 : 
; 2794 :         if (_New_capacity < _New_size) {

	cmp	r14, rsi
	jbe	SHORT $LN165@DrawToolsW

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rsi, r14
	or	rsi, 15
	cmp	rsi, rcx

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN188@DrawToolsW

; 4716 :             return _Max;

	mov	rsi, rcx
	jmp	SHORT $LN187@DrawToolsW
$LN188@DrawToolsW:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, 22
	cmp	rsi, rax
	cmovb	rsi, rax
$LN187@DrawToolsW:

; 2796 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

	mov	rcx, rsi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN197@DrawToolsW

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN1332@DrawToolsW

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN639@DrawToolsW

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN195@DrawToolsW
$LN197@DrawToolsW:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN198@DrawToolsW

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN195@DrawToolsW
$LN198@DrawToolsW:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	mov	rbx, rdi
$LN195@DrawToolsW:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2798 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

	mov	QWORD PTR $T15[rsp], rbx
$LN165@DrawToolsW:

; 2799 : 
; 2800 :             _Start_element_lifetimes(_Ptr, _New_capacity + 1);
; 2801 :         }
; 2802 : 
; 2803 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR $T15[rsp+16], r14

; 2804 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rsp+24], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR ??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@
	movups	XMMWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR ??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@+16
	movsd	QWORD PTR [rbx+16], xmm0
	movzx	eax, WORD PTR ??_C@_0BL@GNBFNKIE@Save?1Phive?1NavMesh?1Dungeon@+24
	mov	WORD PTR [rbx+24], ax

; 2806 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

	lea	rcx, QWORD PTR [rbx+26]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, r13
	mov	rdx, r12
	call	memcpy

; 2807 :         _Traits::assign(_Ptr[_New_size], _Elem());

	mov	BYTE PTR [rbx+r14], 0

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

	or	r15d, 1
	mov	DWORD PTR $T8[rsp], r15d

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T15[rsp+16]
	mov	rdx, QWORD PTR $T15[rsp+24]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 20
	jb	SHORT $LN450@DrawToolsW

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+20]
	mov	QWORD PTR $T15[rsp+16], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T15[rsp]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rbx, QWORD PTR $T15[rsp]

; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8d, 20
	lea	rdx, OFFSET FLAT:??_C@_0BF@EGONCGKD@?4Nin_NX_NVN?4bphnm?4zs@
	mov	rcx, rbx
	call	memmove

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+20], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T15[rsp]
	jmp	SHORT $LN449@DrawToolsW
$LN450@DrawToolsW:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 20
	lea	r9, OFFSET FLAT:??_C@_0BF@EGONCGKD@?4Nin_NX_NVN?4bphnm?4zs@
	mov	edx, 20
	lea	rcx, QWORD PTR $T15[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN449@DrawToolsW:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T32[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T32[rbp-240], rdi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T32[rbp-232], rdi

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T32[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T32[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], rdi
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	r15d, 4
	mov	DWORD PTR $T8[rsp], r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 150  : 					ZStdFile::Compress(Data, ZStdFile::Dictionary::Base).WriteToFile(Editor::GetWorkingDirFile("Save/Phive/NavMesh/Dungeon" + Editor::Identifier + ".Nin_NX_NVN.bphnm.zs"));

	lea	rdx, QWORD PTR $T32[rbp-256]
	lea	rcx, QWORD PTR $T56[rbp-256]
	call	?GetWorkingDirFile@Editor@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z ; Editor::GetWorkingDirFile
	mov	rdx, rax
	lea	rcx, QWORD PTR $T26[rsp]
	call	?WriteToFile@Result@ZStdFile@@QEAAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; ZStdFile::Result::WriteToFile
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T15[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN630@DrawToolsW

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T15[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN642@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN642@DrawToolsW
$LN639@DrawToolsW:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN642@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN630@DrawToolsW:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T15[rsp+16], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;
; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T15[rsp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T26[rsp]
	test	rcx, rcx
	je	SHORT $LN600@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR $T26[rsp+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN612@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN612@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN612@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN600@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 151  : 					SceneMgr::NavMeshModel = SceneMgr::LoadNavMeshBfres(NavMesh);

	lea	rdx, QWORD PTR NavMesh$68[rbp-256]
	lea	rcx, QWORD PTR $T66[rbp-256]
	call	?LoadNavMeshBfres@SceneMgr@@YA?AVBfresFile@@AEAVPhiveNavMesh@@@Z ; SceneMgr::LoadNavMeshBfres
	mov	rdx, rax
	call	??4BfresFile@@QEAAAEAV0@$$QEAV0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T66[rbp-176]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR $T66[rbp-208]
	call	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AEAAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
	lea	rcx, QWORD PTR $T66[rbp-232]
	call	?_Tidy@?$vector@USkeletonBone@BfresFile@@V?$allocator@USkeletonBone@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::SkeletonBone,std::allocator<BfresFile::SkeletonBone> >::_Tidy
	lea	rcx, QWORD PTR $T66[rbp-256]
	call	?_Tidy@?$vector@UModel@BfresFile@@V?$allocator@UModel@BfresFile@@@std@@@std@@AEAAXXZ ; std::vector<BfresFile::Model,std::allocator<BfresFile::Model> >::_Tidy
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Data$62[rbp-256]
	test	rcx, rcx
	je	SHORT $LN565@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Data$62[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN583@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN583@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN583@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	mov	QWORD PTR Data$62[rbp-256], rdi
	xorps	xmm0, xmm0

; 2050 :             _Mylast  = nullptr;

	movdqu	XMMWORD PTR Data$62[rbp-248], xmm0
$LN565@DrawToolsW:
	lea	rcx, QWORD PTR NavMesh$68[rbp+920]
	call	??1?$hkRootLevelContainer__NamedVariant@UhkaiClusterGraph@PhiveNavMesh@@$2U?$StringLiteral@$0BB@@2@3D0GI@@0GL@@0GB@@0GJ@@0ED@@0GM@@0HF@@0HD@@0HE@@0GF@@0HC@@0EH@@0HC@@0GB@@0HA@@0GI@@0A@@@@@PhiveNavMesh@@QEAA@XZ
	lea	rcx, QWORD PTR NavMesh$68[rbp-56]
	call	??1?$hkRootLevelContainer__NamedVariant@UhkaiNavMesh@PhiveNavMesh@@$2U?$StringLiteral@$0M@@2@3D0GI@@0GL@@0GB@@0GJ@@0EO@@0GB@@0HG@@0EN@@0GF@@0HD@@0GI@@0A@@@@@PhiveNavMesh@@QEAA@XZ
	lea	rcx, QWORD PTR NavMesh$68[rbp-256]
	call	??1PhiveWrapper@@QEAA@XZ
	npad	1

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Indices$64[rbp-256]
	test	rcx, rcx
	je	SHORT $LN533@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR Indices$64[rbp-240]
	sub	rax, rcx
	sar	rax, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN551@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN551@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN551@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR Indices$64[rbp-256], xmm0

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR Indices$64[rbp-240], rdi
$LN533@DrawToolsW:

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR Vertices$60[rbp-256]
	test	rcx, rcx
	je	SHORT $LN513@DrawToolsW

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR Vertices$60[rbp-240]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN525@DrawToolsW

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN525@DrawToolsW
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN525@DrawToolsW:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN513@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 155  : 				ImGui::EndDisabled();

	call	?EndDisabled@ImGui@@YAXXZ		; ImGui::EndDisabled

; 156  : #endif // STARLIGHT_SHARED
; 157  : 
; 158  : 				ImGui::Unindent();

	movaps	xmm0, xmm7
	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent
$LN1328@DrawToolsW:

; 159  : 			}
; 160  : 		}
; 161  : 		if (Editor::Identifier.length() > 0)

	cmp	QWORD PTR ?Identifier@Editor@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
	jbe	$LN24@DrawToolsW
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T10[rsp], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T10[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0N@HAJMNOBJ@Stack?5actors@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 163  : 			if (ImGui::Button("Stack actors"))

	test	al, al
	je	SHORT $LN23@DrawToolsW

; 164  : 			{
; 165  : 				PopupStackActors::Open([](uint64_t SrcActor, float OffX, float OffY, float OffZ, uint16_t Count) {

	mov	rax, QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA ; UIOutliner::SelectedActor
	test	rax, rax
	je	SHORT $LN27@DrawToolsW
	mov	rdi, QWORD PTR [rax+40]
$LN27@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\PopupStackActors.cpp

; 55   : 	Func = Callback;

	lea	rax, OFFSET FLAT:?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::<lambda_invoker_cdecl>
	mov	QWORD PTR ?Func@PopupStackActors@@3P6AX_KMMMG@ZEA, rax ; PopupStackActors::Func

; 56   : 	SrcActor = Src;

	mov	QWORD PTR ?SrcActor@PopupStackActors@@3_KA, rdi ; PopupStackActors::SrcActor

; 57   : 
; 58   : 	IsOpen = true;

	mov	BYTE PTR ?IsOpen@PopupStackActors@@3_NA, 1 ; PopupStackActors::IsOpen
$LN23@DrawToolsW:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 8007 :     return window->Size;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16408]
	movss	xmm0, DWORD PTR [rax+88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 197  : 			if (ImGui::Button("AINB actor links", ImVec2(ImGui::GetWindowSize().x - ImGui::GetStyle().FramePadding.x, 0)))

	subss	xmm0, DWORD PTR [rcx+14612]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T9[rsp], xmm0
	mov	DWORD PTR $T9[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 723  :     return ButtonEx(label, size_arg, ImGuiButtonFlags_None);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T9[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BB@HMNIADBB@AINB?5actor?5links@
	call	?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z ; ImGui::ButtonEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 197  : 			if (ImGui::Button("AINB actor links", ImVec2(ImGui::GetWindowSize().x - ImGui::GetStyle().FramePadding.x, 0)))

	test	al, al
	je	SHORT $LN24@DrawToolsW

; 198  : 			{
; 199  : 				PopupEditorAINBActorLinks::Open();

	mov	BYTE PTR ?IsOpen@PopupEditorAINBActorLinks@@3_NA, 1 ; PopupEditorAINBActorLinks::IsOpen
$LN24@DrawToolsW:

; 200  : 			}
; 201  : 		}
; 202  : 	}
; 203  : 
; 204  : 	ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
$LN1@DrawToolsW:

; 205  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+2176]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1332@DrawToolsW:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN1321@DrawToolsW:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1331@DrawToolsW:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1329@DrawToolsW:
?DrawToolsWindow@UITools@@YAXXZ ENDP			; UITools::DrawToolsWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$4@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$4
	lea	rcx, QWORD PTR $T61[rdx]
	jmp	??1Result@ZStdFile@@QEAA@XZ
?dtor$4@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$6@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$6
	lea	rcx, QWORD PTR StartPosByml$67[rdx]
	jmp	??1BymlFile@@QEAA@XZ
?dtor$6@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$83
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T8[rbp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN776@dtor$83
	and	DWORD PTR $T8[rbp], -17
	lea	rcx, QWORD PTR $T28[rbp]
	call	??1Result@ZStdFile@@QEAA@XZ
$LN776@dtor$83:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$83@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$83
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$82@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$82
	mov	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$82@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$82
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$33@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$33
	lea	rcx, QWORD PTR Vertices$60[rdx]
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$33@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$34@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$34
	lea	rcx, QWORD PTR Indices$64[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$34@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$37@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$37
	lea	rcx, QWORD PTR $T33[rdx]
	jmp	??1Result@ZStdFile@@QEAA@XZ
?dtor$37@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$39@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$39
	lea	rcx, QWORD PTR NavMesh$68[rdx]
	jmp	??1PhiveNavMesh@@QEAA@XZ
?dtor$39@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$40@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$40
	mov	rcx, QWORD PTR $T31[rdx]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QEAA@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
?dtor$40@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$42@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$42
	lea	rcx, QWORD PTR Data$62[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$42@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$57
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T8[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN231@dtor$57
	and	DWORD PTR $T8[rbp], -3
	lea	rcx, QWORD PTR $T26[rbp]
	call	??1Result@ZStdFile@@QEAA@XZ
$LN231@dtor$57:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$57@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$56@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$56
	mov	rcx, QWORD PTR $T29[rdx]
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
?dtor$56@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$56
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 72
$T16 = 72
$T17 = 72
$T18 = 72
$T19 = 72
$T20 = 72
$T21 = 72
$T22 = 72
$T23 = 72
$T24 = 72
$T25 = 72
$T26 = 104
$T27 = 104
$T28 = 104
$T29 = 128
$T30 = 128
$T31 = 128
$T32 = 136
$T33 = 136
$T34 = 136
$T35 = 136
$T36 = 136
$T37 = 136
$T38 = 136
$T39 = 136
$T40 = 136
$T41 = 168
$T42 = 168
$T43 = 168
$T44 = 168
$T45 = 168
$T46 = 168
$T47 = 168
$T48 = 168
$T49 = 168
$T50 = 168
$T51 = 168
$T52 = 200
$T53 = 200
$T54 = 200
$T55 = 200
$T56 = 232
$T57 = 232
$T58 = 232
$T59 = 232
Vertices$60 = 264
$T61 = 264
Data$62 = 288
$T63 = 288
Indices$64 = 312
$T65 = 312
$T66 = 352
StartPosByml$67 = 352
NavMesh$68 = 576
__$ArrayPad$ = 2128
?dtor$47@?0??DrawToolsWindow@UITools@@YAXXZ@4HA PROC	; `UITools::DrawToolsWindow'::`1'::dtor$47
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??DrawToolsWindow@UITools@@YAXXZ@4HA ENDP	; `UITools::DrawToolsWindow'::`1'::dtor$47
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
;	COMDAT ?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
Path$GSCopy$ = 72
__$ArrayPad$ = 80
Path$ = 112
?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; `UITools::DrawToolsWindow'::`10'::<lambda_1>::<lambda_invoker_cdecl>, COMDAT

; 39   : 			});

	push	rbx
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 36   : 		PopupExportMod::Open([](std::string Path)

	mov	QWORD PTR Path$GSCopy$[rsp], rcx

; 37   : 			{
; 38   : 				Exporter::Export(Path, Exporter::Operation::Export);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	xor	edx, edx
	mov	rcx, rax
	call	?Export@Exporter@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Operation@1@@Z ; Exporter::Export
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 39   : 			});

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; `UITools::DrawToolsWindow'::`10'::<lambda_1>::<lambda_invoker_cdecl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
Path$GSCopy$ = 72
__$ArrayPad$ = 80
Path$ = 112
?dtor$0@?0??<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; ``UITools::DrawToolsWindow'::`10'::<lambda_1>::<lambda_invoker_cdecl>'::`1'::dtor$0
	mov	rcx, QWORD PTR Path$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??<lambda_invoker_cdecl>@<lambda_1>@?9??DrawToolsWindow@UITools@@YAXXZ@SA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; ``UITools::DrawToolsWindow'::`10'::<lambda_1>::<lambda_invoker_cdecl>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
;	COMDAT ??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z
_TEXT	SEGMENT
SubModelIndex$1$ = 32
$T2 = 36
$T3 = 40
$T4 = 44
$T5 = 48
$T6 = 52
$T7 = 56
$T8 = 60
$T9 = 64
$T10 = 68
$T11 = 72
$T12 = 76
SceneActor$GSCopy$1$ = 80
Indices$GSCopy$1$ = 88
$T13 = 96
$T14 = 96
$T15 = 96
$T16 = 96
$T17 = 160
Vertex$18 = 160
$T19 = 160
$T20 = 160
$T21 = 160
$T22 = 160
GLMModel$ = 176
__$ArrayPad$ = 240
this$dead$ = 480
SceneActor$ = 488
Vertices$ = 496
Indices$ = 504
??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z PROC ; `UITools::DrawToolsWindow'::`39'::<lambda_2>::operator(), COMDAT

; 99   : 						{

	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	lea	rbp, QWORD PTR [rsp-176]
	sub	rsp, 432				; 000001b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 100  : 							if (SceneActor.Model->IsDefaultModel() || !SceneActor.Bakeable || SceneActor.Gyml.find("SkyAntiZonau") != std::string::npos)

	mov	r12, QWORD PTR [rdx+424]
	mov	rsi, r9
	mov	QWORD PTR Indices$GSCopy$1$[rsp], r9
	mov	rbx, r8
	mov	rdi, rdx
	mov	QWORD PTR SceneActor$GSCopy$1$[rsp], rdx
	cmp	BYTE PTR [r12+72], 0
	jne	$LN12@operator
	cmp	BYTE PTR [rdx+120], 0
	je	$LN12@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+32], 16

; 4357 :         return static_cast<size_type>(_Traits_find<_Traits>(

	mov	rax, QWORD PTR [rdx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 100  : 							if (SceneActor.Model->IsDefaultModel() || !SceneActor.Bakeable || SceneActor.Gyml.find("SkyAntiZonau") != std::string::npos)

	mov	QWORD PTR [rsp+424], r14
	lea	r14, QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN213@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN213@operator:
	mov	QWORD PTR [rsp+480], r13
	mov	QWORD PTR [rsp+416], r15

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	rax, 12
	jb	SHORT $LN523@operator

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	r15, QWORD PTR [rax+r14]

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 83					; 00000053H

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r15-11]

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, r14

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	sub	r8, r14

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN523@operator
	mov	r13, 6514866352861834067		; 5a69746e41796b53H
	npad	5
$LL220@operator:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	cmp	QWORD PTR [rax], r13
	jne	SHORT $LN522@operator
	cmp	DWORD PTR [rax+8], 1969319535		; 75616e6fH
	je	SHORT $LN344@operator
$LN522@operator:

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rax

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [r15-11]
	sub	r8, rax

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	rcx, rax
	mov	edx, 83					; 00000053H
	call	memchr

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL220@operator
	jmp	SHORT $LN523@operator
$LN344@operator:

; 597  :             return static_cast<size_t>(-1);
; 598  :         }
; 599  : 
; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rax, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 100  : 							if (SceneActor.Model->IsDefaultModel() || !SceneActor.Bakeable || SceneActor.Gyml.find("SkyAntiZonau") != std::string::npos)

	cmp	rax, -1
	jne	$LN541@operator
$LN523@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	lea	r8, QWORD PTR $T22[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	lea	rdx, QWORD PTR GLMModel$[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	lea	rcx, QWORD PTR $T16[rsp]
	movaps	XMMWORD PTR [rsp+400], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r13, QWORD PTR [rax]
	movaps	XMMWORD PTR [rsp+368], xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm0, DWORD PTR [rdi+52]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR [rsp+352], xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T22[rbp-256], xmm0
	movss	xmm0, DWORD PTR [rdi+60]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm1, DWORD PTR [rdi+56]
	movaps	XMMWORD PTR [rsp+272], xmm14
	movss	DWORD PTR $T22[rbp-248], xmm0
	movss	DWORD PTR $T22[rbp-252], xmm1
	movaps	XMMWORD PTR [rsp+256], xmm15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm2, DWORD PTR [rdi+84]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	r9, QWORD PTR $T21[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm6, DWORD PTR __real@3c8efa35
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	rdx, QWORD PTR GLMModel$[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	lea	rcx, QWORD PTR $T15[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T21[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T21[rbp-248], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 107  : 							GLMModel = glm::translate(GLMModel, glm::vec3(SceneActor.Translate.GetX(), SceneActor.Translate.GetY(), SceneActor.Translate.GetZ()));

	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	movss	xmm2, DWORD PTR [rdi+80]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 110  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	r9, QWORD PTR $T20[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 110  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	lea	rdx, QWORD PTR GLMModel$[rbp-256]
	lea	rcx, QWORD PTR $T14[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T20[rbp-256], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 55   : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T20[rbp-252], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 109  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetZ()), glm::vec3(0.0, 0.0f, 1.0));

	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 110  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 30   : 	return this->m_Data[0];

	movss	xmm2, DWORD PTR [rdi+76]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 111  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	r9, QWORD PTR $T19[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\func_trigonometric.inl

; 13   : 		return degrees * static_cast<genType>(0.01745329251994329576923690768489);

	mulss	xmm2, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 111  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	lea	rdx, QWORD PTR GLMModel$[rbp-256]
	lea	rcx, QWORD PTR $T13[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T19[rbp-256], 1065353216	; 3f800000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 110  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T19[rbp-248], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 110  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetY()), glm::vec3(0.0f, 1.0, 0.0));

	movups	xmm1, XMMWORD PTR [rax+16]
	movaps	XMMWORD PTR GLMModel$[rbp-256], xmm0
	movups	xmm0, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-240], xmm1
	movups	xmm1, XMMWORD PTR [rax+48]
	movaps	XMMWORD PTR GLMModel$[rbp-224], xmm0
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm1

; 111  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	call	??$rotate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@MAEBU?$vec@$02M$0A@@0@@Z ; glm::rotate<float,0>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm14, DWORD PTR [rdi+64]
	movss	xmm15, DWORD PTR [rdi+68]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 111  : 							GLMModel = glm::rotate(GLMModel, glm::radians(SceneActor.Rotate.GetX()), glm::vec3(1.0, 0.0f, 0.0));

	movups	xmm0, XMMWORD PTR [rax+48]
	movups	xmm1, XMMWORD PTR [rax]
	movups	xmm2, XMMWORD PTR [rax+16]
	movups	xmm3, XMMWORD PTR [rax+32]
	movaps	XMMWORD PTR GLMModel$[rbp-208], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm4, DWORD PTR [rdi+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm8, xmm14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm9, xmm14
	shufps	xmm0, xmm1, 85				; 00000055H

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm6, xmm14

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	mulss	xmm8, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 115  : 							for (uint32_t SubModelIndex = 0; SubModelIndex < LODModel->Faces.size(); SubModelIndex++)

	xor	r10d, r10d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rax, 3
	mov	r11, -6148914691236517205		; aaaaaaaaaaaaaaabH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm1

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	mulss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 115  : 							for (uint32_t SubModelIndex = 0; SubModelIndex < LODModel->Faces.size(); SubModelIndex++)

	mov	DWORD PTR SubModelIndex$1$[rsp], r10d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm0, xmm1, 170				; 000000aaH
	mulss	xmm9, xmm0

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm0, xmm15
	mulss	xmm0, xmm2

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	shufps	xmm1, xmm1, 255				; 000000ffH
	mulss	xmm14, xmm1
	movaps	xmm1, xmm15

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movss	DWORD PTR $T5[rsp], xmm0

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 85				; 00000055H
	mulss	xmm1, xmm0
	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 170				; 000000aaH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	imul	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movss	DWORD PTR $T6[rsp], xmm1
	movaps	xmm1, xmm15
	mulss	xmm1, xmm0

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movaps	xmm0, xmm4
	mulss	xmm0, xmm3

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movss	DWORD PTR $T7[rsp], xmm1
	movaps	xmm1, xmm4
	shufps	xmm2, xmm2, 255				; 000000ffH

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movss	DWORD PTR $T8[rsp], xmm0

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movaps	xmm0, xmm3
	shufps	xmm0, xmm3, 85				; 00000055H
	mulss	xmm1, xmm0
	movaps	xmm0, xmm3
	shufps	xmm0, xmm3, 170				; 000000aaH
	shufps	xmm3, xmm3, 255				; 000000ffH
	movss	DWORD PTR $T9[rsp], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, xmm0
	mulss	xmm4, xmm3

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	movss	DWORD PTR $T2[rsp], xmm6

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movss	DWORD PTR $T10[rsp], xmm1
	movss	DWORD PTR $T3[rsp], xmm8
	movss	DWORD PTR $T4[rsp], xmm9
	movss	DWORD PTR $T11[rsp], xmm4
	mulss	xmm15, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 115  : 							for (uint32_t SubModelIndex = 0; SubModelIndex < LODModel->Faces.size(); SubModelIndex++)

	test	rax, rax
	je	$LN546@operator
	movaps	XMMWORD PTR [rsp+384], xmm7
	xor	r9d, r9d
	movaps	XMMWORD PTR [rsp+336], xmm10
	movss	xmm10, DWORD PTR GLMModel$[rbp-196]
	movaps	XMMWORD PTR [rsp+320], xmm11
	movss	xmm11, DWORD PTR GLMModel$[rbp-200]
	movaps	XMMWORD PTR [rsp+304], xmm12
	movss	xmm12, DWORD PTR GLMModel$[rbp-204]
	movaps	XMMWORD PTR [rsp+288], xmm13
	movss	xmm13, DWORD PTR GLMModel$[rbp-208]
	npad	6
$LL4@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 117  : 								uint32_t IndexOffset = Vertices.size() / 3;

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	xor	r15d, r15d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 117  : 								uint32_t IndexOffset = Vertices.size() / 3;

	mul	rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdi+424]
	lea	rdi, QWORD PTR [r9+r9*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 117  : 								uint32_t IndexOffset = Vertices.size() / 3;

	mov	r12, rdx
	shr	r12, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR [r8+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+rdi*8+8]
	sub	rcx, QWORD PTR [rax+rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	mul	rcx
	shr	rdx, 1
	je	$LN6@operator
	mov	rsi, QWORD PTR SceneActor$GSCopy$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 156  : 		: x(scalar), y(scalar), z(scalar), w(scalar)

	xor	r14d, r14d
$LL7@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm2, xmm8
	movss	xmm8, DWORD PTR $T9[rsp]
	movaps	xmm3, xmm9
	movss	xmm9, DWORD PTR $T10[rsp]
	movaps	xmm1, xmm6
	movss	xmm6, DWORD PTR $T7[rsp]
	movaps	xmm4, xmm14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+rdi*8]

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_mat4x4.inl

; 561  : 		typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);

	movss	xmm0, DWORD PTR [rcx+r14]

; 562  : 		typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);

	movss	xmm5, DWORD PTR [rcx+r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Libraries\include\glm\detail\type_vec4.inl

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	movss	xmm7, DWORD PTR [rcx+r14+8]

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	mulss	xmm2, xmm0
	mulss	xmm4, xmm0
	mulss	xmm3, xmm0
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR $T5[rsp]
	mulss	xmm0, xmm5
	mulss	xmm6, xmm5

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm0, xmm1

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movss	xmm1, DWORD PTR $T6[rsp]
	mulss	xmm1, xmm5

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm6, xmm3

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	mulss	xmm8, xmm7

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm1, xmm2

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movaps	xmm3, xmm15
	mulss	xmm3, xmm5

; 13   : 			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

	addss	xmm8, xmm12

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movss	xmm5, DWORD PTR $T8[rsp]
	mulss	xmm5, xmm7

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm3, xmm4

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	movss	xmm4, DWORD PTR $T11[rsp]
	mulss	xmm9, xmm7

; 13   : 			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

	addss	xmm5, xmm13

; 31   : 			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

	mulss	xmm4, xmm7

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm8, xmm1

; 13   : 			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

	addss	xmm9, xmm11
	addss	xmm4, xmm10

; 161  : 		: x(_x), y(_y), z(_z), w(_w)

	addss	xmm5, xmm0
	addss	xmm9, xmm6
	addss	xmm4, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 125  : 									Vertex = GLMModel * Vertex;

	movaps	xmm2, xmm5
	shufps	xmm2, xmm2, 225				; 000000e1H
	movss	xmm2, xmm8
	shufps	xmm2, xmm2, 198				; 000000c6H
	movss	xmm2, xmm9
	shufps	xmm2, xmm2, 39				; 00000027H
	movss	xmm2, xmm4
	shufps	xmm2, xmm2, 57				; 00000039H
	movaps	XMMWORD PTR $T17[rbp-256], xmm2
	movdqa	XMMWORD PTR Vertex$18[rbp-256], xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN40@operator

; 806  :         ++_Mylast;

	lea	rax, QWORD PTR [rdx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	movss	DWORD PTR [rdx], xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rbx+8], rax

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN39@operator
$LN40@operator:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Vertex$18[rbp-256]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
$LN39@operator:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN183@operator

; 806  :         ++_Mylast;

	lea	rax, QWORD PTR [rdx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	movss	DWORD PTR [rdx], xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rbx+8], rax

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN182@operator
$LN183@operator:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Vertex$18[rbp-252]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
$LN182@operator:

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rbx+8]
	cmp	rdx, QWORD PTR [rbx+16]
	je	SHORT $LN196@operator

; 806  :         ++_Mylast;

	lea	rax, QWORD PTR [rdx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	movss	DWORD PTR [rdx], xmm9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 806  :         ++_Mylast;

	mov	QWORD PTR [rbx+8], rax

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@operator
$LN196@operator:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR Vertex$18[rbp-248]
	mov	rcx, rbx
	call	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
$LN5@operator:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi+424]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	mov	r11, -6148914691236517205		; aaaaaaaaaaaaaaabH
	movss	xmm6, DWORD PTR $T2[rsp]
	inc	r15
	movss	xmm8, DWORD PTR $T3[rsp]
	add	r14, 12
	movss	xmm9, DWORD PTR $T4[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR [r8+24]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+rdi*8+8]
	sub	rcx, QWORD PTR [rax+rdi*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	mov	rax, r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	rcx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 118  : 								for (size_t i = 0; i < SceneActor.Model->GetModels()[0].Vertices[SubModelIndex].size() / 3; i++)

	mul	rcx
	shr	rdx, 1
	cmp	r15, rdx
	jb	$LL7@operator
	mov	rsi, QWORD PTR Indices$GSCopy$1$[rsp]
	mov	r10d, DWORD PTR SubModelIndex$1$[rsp]
$LN6@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 130  : 								for (size_t i = 0; i < LODModel->Faces[SubModelIndex].size(); i++)

	xor	r14d, r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+rdi*8+8]
	sub	rax, QWORD PTR [rcx+rdi*8]
	sar	rax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 130  : 								for (size_t i = 0; i < LODModel->Faces[SubModelIndex].size(); i++)

	test	rax, rax
	je	SHORT $LN2@operator
$LL10@operator:

; 132  : 									Indices.push_back(LODModel->Faces[SubModelIndex][i] + IndexOffset);

	mov	rax, QWORD PTR [rcx+rdi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rsi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 132  : 									Indices.push_back(LODModel->Faces[SubModelIndex][i] + IndexOffset);

	mov	eax, DWORD PTR [rax+r14*4]
	add	eax, r12d
	mov	DWORD PTR $T12[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	cmp	rdx, QWORD PTR [rsi+16]
	je	SHORT $LN23@operator

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 806  :         ++_Mylast;

	add	QWORD PTR [rsi+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN8@operator
$LN23@operator:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T12[rsp]
	mov	rcx, rsi
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN8@operator:

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 130  : 								for (size_t i = 0; i < LODModel->Faces[SubModelIndex].size(); i++)

	inc	r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+rdi*8+8]
	sub	rax, QWORD PTR [rcx+rdi*8]
	sar	rax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 130  : 								for (size_t i = 0; i < LODModel->Faces[SubModelIndex].size(); i++)

	cmp	r14, rax
	jb	SHORT $LL10@operator
	mov	r10d, DWORD PTR SubModelIndex$1$[rsp]
	mov	r11, -6148914691236517205		; aaaaaaaaaaaaaaabH
$LN2@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 115  : 							for (uint32_t SubModelIndex = 0; SubModelIndex < LODModel->Faces.size(); SubModelIndex++)

	inc	r10d
	mov	rdi, QWORD PTR SceneActor$GSCopy$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rax, rcx
	sar	rax, 3
	imul	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 115  : 							for (uint32_t SubModelIndex = 0; SubModelIndex < LODModel->Faces.size(); SubModelIndex++)

	mov	r9d, r10d
	mov	DWORD PTR SubModelIndex$1$[rsp], r10d
	cmp	r9, rax
	jb	$LL4@operator
	movaps	xmm13, XMMWORD PTR [rsp+288]
	movaps	xmm12, XMMWORD PTR [rsp+304]
	movaps	xmm11, XMMWORD PTR [rsp+320]
	movaps	xmm10, XMMWORD PTR [rsp+336]
	movaps	xmm7, XMMWORD PTR [rsp+384]
$LN546@operator:
	movaps	xmm14, XMMWORD PTR [rsp+272]
	movaps	xmm9, XMMWORD PTR [rsp+352]
	movaps	xmm8, XMMWORD PTR [rsp+368]
	movaps	xmm6, XMMWORD PTR [rsp+400]
	movaps	xmm15, XMMWORD PTR [rsp+256]
$LN541@operator:
	mov	r13, QWORD PTR [rsp+480]
	mov	r15, QWORD PTR [rsp+416]
	mov	r14, QWORD PTR [rsp+424]
$LN12@operator:

; 133  : 								}
; 134  : 							}
; 135  : 						};

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 432				; 000001b0H
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
??R<lambda_2>@?CH@??DrawToolsWindow@UITools@@YAXXZ@QEBA@AEAUActor@@AEAV?$vector@MV?$allocator@M@std@@@std@@AEAV?$vector@IV?$allocator@I@std@@@5@@Z ENDP ; `UITools::DrawToolsWindow'::`39'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
;	COMDAT ??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 80
$T4 = 112
$T5 = 144
BaseActor$ = 1024
__$ArrayPad$ = 1904
this$dead$ = 1984
SrcActor$ = 1992
OffX$ = 2000
OffY$ = 2008
OffZ$ = 2016
Count$ = 2024
??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z PROC ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::operator(), COMDAT

; 165  : 				PopupStackActors::Open([](uint64_t SrcActor, float OffX, float OffY, float OffZ, uint16_t Count) {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	lea	rbp, QWORD PTR [rax-1720]
	sub	rsp, 1968				; 000007b0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	movaps	xmm7, xmm3
	movaps	xmm8, xmm2
	mov	rdi, rdx
	xor	ebx, ebx

; 166  : 
; 167  : 					Actor BaseActor;

	lea	rcx, QWORD PTR BaseActor$[rbp-256]
	call	??0Actor@@QEAA@XZ
	npad	1

; 168  : 
; 169  : 					for (Actor& Act : ActorMgr::GetActors())

	mov	rdx, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A
	mov	rax, QWORD PTR ?Actors@ActorMgr@@3V?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@A+8
	cmp	rdx, rax
	je	SHORT $LN3@operator
$LL4@operator:

; 170  : 					{
; 171  : 						if (Act.Hash == SrcActor)

	cmp	QWORD PTR [rdx+40], rdi
	je	SHORT $LN104@operator

; 168  : 
; 169  : 					for (Actor& Act : ActorMgr::GetActors())

	add	rdx, 872				; 00000368H
	cmp	rdx, rax
	jne	SHORT $LL4@operator

; 170  : 					{
; 171  : 						if (Act.Hash == SrcActor)

	jmp	SHORT $LN3@operator
$LN104@operator:

; 172  : 						{
; 173  : 							BaseActor = Act;

	lea	rcx, QWORD PTR BaseActor$[rbp-256]
	call	??4Actor@@QEAAAEAU0@AEBU0@@Z
$LN3@operator:

; 174  : 							break;
; 175  : 						}
; 176  : 					}
; 177  : 
; 178  : 					if (BaseActor.Hash == 0)

	cmp	QWORD PTR BaseActor$[rbp-216], 0
	jne	$LN9@operator

; 180  : 						Logger::Error("ActorStacker", "Could not find base actor with hash " + std::to_string(SrcActor));

	lea	rsi, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rsi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T4[rsp]
	call	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@_K@Z ; std::to_string
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3537 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r9d, 36					; 00000024H
	lea	r8, OFFSET FLAT:??_C@_0CF@HIHBIGIN@Could?5not?5find?5base?5actor?5with?5@
	mov	rcx, rax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T2[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T2[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T2[rsp+24], rbx

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T2[rsp], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T2[rsp+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 180  : 						Logger::Error("ActorStacker", "Could not find base actor with hash " + std::to_string(SrcActor));

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T3[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T3[rsp+16], rbx

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T3[rsp+24], rbx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 12
	lea	rdx, OFFSET FLAT:??_C@_0N@BOJIGJLG@ActorStacker@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 180  : 						Logger::Error("ActorStacker", "Could not find base actor with hash " + std::to_string(SrcActor));

	mov	rdx, rsi
	lea	rcx, QWORD PTR $T3[rsp]
	call	?Error@Logger@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; Logger::Error
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T4[rbp-232]
	cmp	rdx, 16
	jb	$LN6@operator

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN95@operator

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN95@operator
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN95@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	jmp	$LN6@operator
$LN9@operator:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 184  : 					for (uint16_t i = 0; i < Count; i++)

	movzx	edi, WORD PTR Count$[rbp-256]
	cmp	bx, di
	jae	SHORT $LN6@operator
	movss	xmm6, DWORD PTR OffZ$[rbp-256]
	npad	7
$LL7@operator:

; 185  : 					{
; 186  : 						Actor& NewActor = ActorMgr::AddActor(BaseActor);

	lea	rdx, QWORD PTR BaseActor$[rbp-256]
	lea	rcx, QWORD PTR $T5[rbp-256]
	call	??0Actor@@QEAA@AEBU0@@Z
	mov	rcx, rax
	call	?AddActor@ActorMgr@@YAAEAUActor@@U2@_N@Z ; ActorMgr::AddActor

; 187  : 						NewActor.Translate.SetX(BaseActor.Translate.GetX() + OffX * (i + 1));

	movzx	ecx, bx
	inc	ecx
	movd	xmm2, ecx
	cvtdq2ps xmm2, xmm2
	movaps	xmm0, xmm2
	mulss	xmm0, xmm8
	addss	xmm0, DWORD PTR BaseActor$[rbp-204]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\Vector3F.cpp

; 15   : 	this->m_Data[0] = x;

	movss	DWORD PTR [rax+52], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp

; 188  : 						NewActor.Translate.SetY(BaseActor.Translate.GetY() + OffY * (i + 1));

	movaps	xmm1, xmm2
	mulss	xmm1, xmm7
	addss	xmm1, DWORD PTR BaseActor$[rbp-200]
	movss	DWORD PTR [rax+56], xmm1

; 189  : 						NewActor.Translate.SetZ(BaseActor.Translate.GetZ() + OffZ * (i + 1));

	mulss	xmm2, xmm6
	addss	xmm2, DWORD PTR BaseActor$[rbp-196]
	movss	DWORD PTR [rax+60], xmm2

; 190  : 
; 191  : 						UIOutliner::SelectedActor = &NewActor;

	mov	QWORD PTR ?SelectedActor@UIOutliner@@3PEAUActor@@EA, rax ; UIOutliner::SelectedActor

; 184  : 					for (uint16_t i = 0; i < Count; i++)

	inc	bx
	cmp	bx, di
	jb	SHORT $LL7@operator
$LN6@operator:

; 192  : 					}
; 193  : 
; 194  : 					}, UIOutliner::SelectedActor == nullptr ? 0 : UIOutliner::SelectedActor->Hash);

	lea	rcx, QWORD PTR BaseActor$[rbp-256]
	call	??1Actor@@QEAA@XZ
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1968]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN116@operator:
??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z ENDP ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 80
$T4 = 112
$T5 = 144
BaseActor$ = 1024
__$ArrayPad$ = 1904
this$dead$ = 1984
SrcActor$ = 1992
OffX$ = 2000
OffY$ = 2008
OffZ$ = 2016
Count$ = 2024
?dtor$0@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA PROC ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$0
	lea	rcx, QWORD PTR BaseActor$[rdx]
	jmp	??1Actor@@QEAA@XZ
?dtor$0@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA ENDP ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 80
$T4 = 112
$T5 = 144
BaseActor$ = 1024
__$ArrayPad$ = 1904
this$dead$ = 1984
SrcActor$ = 1992
OffX$ = 2000
OffY$ = 2008
OffZ$ = 2016
Count$ = 2024
?dtor$1@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA PROC ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$1
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA ENDP ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 80
$T4 = 112
$T5 = 144
BaseActor$ = 1024
__$ArrayPad$ = 1904
this$dead$ = 1984
SrcActor$ = 1992
OffX$ = 2000
OffY$ = 2008
OffZ$ = 2016
Count$ = 2024
?dtor$2@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA PROC ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$2
	mov	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0???R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z@4HA ENDP ; ``UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4Actor@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Actor@@QEAAAEAU0@AEBU0@@Z PROC			; Actor::operator=, COMDAT
$LN53:
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rsi, rdx
	mov	DWORD PTR [rcx], eax
	mov	rdi, rcx
	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	mov	QWORD PTR [rsp+56], rbp
	add	rdx, 8
	mov	QWORD PTR [rsp+64], r14
	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	mov	rax, QWORD PTR [rsi+40]
	lea	rdx, QWORD PTR [rsi+88]
	mov	QWORD PTR [rdi+40], rax
	lea	rcx, QWORD PTR [rdi+88]
	mov	eax, DWORD PTR [rsi+48]
	mov	DWORD PTR [rdi+48], eax
	movsd	xmm0, QWORD PTR [rsi+52]
	movsd	QWORD PTR [rdi+52], xmm0
	mov	eax, DWORD PTR [rsi+60]
	mov	DWORD PTR [rdi+60], eax
	movsd	xmm0, QWORD PTR [rsi+64]
	movsd	QWORD PTR [rdi+64], xmm0
	mov	eax, DWORD PTR [rsi+72]
	mov	DWORD PTR [rdi+72], eax
	movsd	xmm0, QWORD PTR [rsi+76]
	movsd	QWORD PTR [rdi+76], xmm0
	mov	eax, DWORD PTR [rsi+84]
	mov	DWORD PTR [rdi+84], eax

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:
	movzx	eax, BYTE PTR [rsi+120]
	lea	r8, QWORD PTR [rsi+136]
	mov	BYTE PTR [rdi+120], al
	lea	rcx, QWORD PTR [rdi+136]
	movzx	eax, BYTE PTR [rsi+121]
	mov	BYTE PTR [rdi+121], al
	movzx	eax, BYTE PTR [rsi+122]
	mov	BYTE PTR [rdi+122], al
	mov	eax, DWORD PTR [rsi+124]
	mov	DWORD PTR [rdi+124], eax
	mov	eax, DWORD PTR [rsi+128]
	mov	DWORD PTR [rdi+128], eax
	movzx	eax, BYTE PTR [rsi+132]
	mov	BYTE PTR [rdi+132], al
	movzx	eax, BYTE PTR [rsi+133]
	mov	BYTE PTR [rdi+133], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN19@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rax
	call	??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Assign_counted_range<Actor::Link *>
$LN19@operator:
	lea	r8, QWORD PTR [rsi+160]
	lea	rcx, QWORD PTR [rdi+160]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN22@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Assign_counted_range<Actor::Rail *>
$LN22@operator:
	lea	rbp, QWORD PTR [rsi+184]
	mov	QWORD PTR [rsp+48], rbx
	lea	r14, QWORD PTR [rdi+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rbp
	je	SHORT $LN27@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [r14]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r14
	mov	rcx, r14
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r14

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [r14+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN27@operator:
	lea	rdx, QWORD PTR [rsi+200]
	lea	rcx, QWORD PTR [rdi+200]
	call	??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
	lea	rbp, QWORD PTR [rsi+408]
	lea	r14, QWORD PTR [rdi+408]

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rbp
	je	SHORT $LN34@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [r14]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r14
	mov	rcx, r14
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r14

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [r14+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::_Copy<0>
$LN34@operator:
	mov	rax, QWORD PTR [rsi+424]
	lea	r8, QWORD PTR [rsi+432]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	mov	r14, QWORD PTR [rsp+64]
	lea	rcx, QWORD PTR [rdi+432]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+424], rax
	cmp	rcx, r8
	je	SHORT $LN39@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -6430974998173972123		; a6c0964fda6c0965H
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z ; std::vector<Actor,std::allocator<Actor> >::_Assign_counted_range<Actor *>
$LN39@operator:
	lea	rdx, QWORD PTR [rsi+456]
	lea	rcx, QWORD PTR [rdi+456]
	call	??4BymlFile@@QEAAAEAV0@AEBV0@@Z
	mov	rax, QWORD PTR [rsi+680]
	lea	rdx, QWORD PTR [rsi+696]
	mov	QWORD PTR [rdi+680], rax
	lea	rcx, QWORD PTR [rdi+696]
	movzx	eax, BYTE PTR [rsi+688]
	mov	BYTE PTR [rdi+688], al
	call	??4UMii@@QEAAAEAV0@AEBV0@@Z
	movzx	eax, BYTE PTR [rsi+848]
	mov	BYTE PTR [rdi+848], al
	mov	eax, DWORD PTR [rsi+852]
	mov	DWORD PTR [rdi+852], eax
	mov	eax, DWORD PTR [rsi+856]
	mov	DWORD PTR [rdi+856], eax
	mov	eax, DWORD PTR [rsi+860]
	mov	DWORD PTR [rdi+860], eax
	mov	eax, DWORD PTR [rsi+864]
	mov	rsi, QWORD PTR [rsp+72]
	mov	DWORD PTR [rdi+864], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Actor@@QEAAAEAU0@AEBU0@@Z ENDP			; Actor::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z PROC		; Actor::PhiveData::operator=, COMDAT
$LN48:
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	mov	QWORD PTR [rsp+56], rsi
	mov	rsi, rdx
	mov	rdi, rcx
	cmp	rcx, rdx
	je	SHORT $LN5@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
	mov	rbx, QWORD PTR [rsp+48]
$LN5@operator:
	mov	rax, QWORD PTR [rsi+16]
	lea	r8, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdi+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN12@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -8116567392432202711		; 8f5c28f5c28f5c29H
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>
$LN12@operator:
	lea	r8, QWORD PTR [rsi+48]
	lea	rcx, QWORD PTR [rdi+48]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN15@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>
$LN15@operator:
	mov	rax, QWORD PTR [rsi+72]
	lea	r8, QWORD PTR [rsi+80]
	lea	rcx, QWORD PTR [rdi+80]
	mov	QWORD PTR [rdi+72], rax

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN20@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN20@operator:
	lea	r8, QWORD PTR [rsi+104]
	lea	rcx, QWORD PTR [rdi+104]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN23@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN23@operator:
	mov	rax, QWORD PTR [rsi+128]
	lea	r8, QWORD PTR [rsi+136]
	lea	rcx, QWORD PTR [rdi+136]
	mov	QWORD PTR [rdi+128], rax

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN28@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN28@operator:
	lea	r8, QWORD PTR [rsi+160]
	lea	rcx, QWORD PTR [rdi+160]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN31@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN31@operator:
	lea	r8, QWORD PTR [rsi+184]

; 1483 :         if (this == _STD addressof(_Right)) {

	mov	rsi, QWORD PTR [rsp+56]
	lea	rcx, QWORD PTR [rdi+184]
	cmp	rcx, r8
	je	SHORT $LN37@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 6
	call	??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Assign_counted_range<Actor::PhiveData::RailData *>
$LN37@operator:
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4PhiveData@Actor@@QEAAAEAU01@AEBU01@@Z ENDP		; Actor::PhiveData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z PROC ; Actor::PhiveData::ConstraintLinkData::operator=, COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	lea	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	add	rcx, 8
	mov	rdi, rdx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN3@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -8116567392432202711		; 8f5c28f5c28f5c29H
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>
$LN3@operator:
	lea	r8, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR [rbx+32]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN9@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>
$LN9@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4ConstraintLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ENDP ; Actor::PhiveData::ConstraintLinkData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z PROC ; Actor::PhiveData::RopeLinkData::operator=, COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	lea	r8, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	add	rcx, 8
	mov	rdi, rdx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN3@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN3@operator:
	lea	r8, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR [rbx+32]

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN9@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN9@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4RopeLinkData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ENDP ; Actor::PhiveData::RopeLinkData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UITools.cpp
;	COMDAT ?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z
_TEXT	SEGMENT
SrcActor$ = 64
OffX$ = 72
OffY$ = 80
OffZ$ = 88
Count$ = 96
?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z PROC ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::<lambda_invoker_cdecl>, COMDAT

; 194  : 					}, UIOutliner::SelectedActor == nullptr ? 0 : UIOutliner::SelectedActor->Hash);

	sub	rsp, 56					; 00000038H
	movzx	eax, WORD PTR Count$[rsp]
	mov	rdx, rcx
	mov	WORD PTR [rsp+40], ax
	movss	DWORD PTR [rsp+32], xmm3
	movaps	xmm3, xmm2
	movaps	xmm2, xmm1
	call	??R<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@QEBA@_KMMMG@Z ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::operator()
	add	rsp, 56					; 00000038H
	ret	0
?<lambda_invoker_cdecl>@<lambda_3>@?DF@??DrawToolsWindow@UITools@@YAXXZ@SA@_KMMMG@Z ENDP ; `UITools::DrawToolsWindow'::`53'::<lambda_3>::<lambda_invoker_cdecl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor,std::allocator<Actor> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -6430974998173972123		; a6c0964fda6c0965H
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z ; std::vector<Actor,std::allocator<Actor> >::_Assign_counted_range<Actor *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor,std::allocator<Actor> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::operator=, COMDAT

; 161  :     map& operator=(const map& _Right) {

$LN12:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN8@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::_Copy<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 163  :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN8@operator:

; 164  :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Assign_counted_range<Actor::Rail *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::Link,std::allocator<Actor::Link> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rax
	call	??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Assign_counted_range<Actor::Link *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::Link,std::allocator<Actor::Link> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 6
	call	??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Assign_counted_range<Actor::PhiveData::RailData *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	call	??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@_KV?$allocator@_K@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -3689348814741910323		; cccccccccccccccdH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -8116567392432202711		; 8f5c28f5c28f5c29H
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 3
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=, COMDAT

; 161  :     map& operator=(const map& _Right) {

$LN12:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN8@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 163  :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN8@operator:

; 164  :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::operator=, COMDAT

; 1090 :     _Tree& operator=(const _Tree& _Right) {

$LN10:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN7@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::_Copy<0>

; 1121 : 
; 1122 :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN7@operator:

; 1123 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=, COMDAT

; 1090 :     _Tree& operator=(const _Tree& _Right) {

$LN10:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN7@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>

; 1121 : 
; 1122 :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN7@operator:

; 1123 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@@std@@YAPEBV?$vector@UActor@@V?$allocator@UActor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@@std@@YAPEBV?$vector@UActor@@V?$allocator@UActor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor,std::allocator<Actor> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@@std@@YAPEBV?$vector@UActor@@V?$allocator@UActor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor,std::allocator<Actor> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UActor@@@std@@@std@@YAXAEAV?$allocator@UActor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UActor@@@std@@@std@@YAXAEAV?$allocator@UActor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UActor@@@std@@@std@@YAXAEAV?$allocator@UActor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z PROC ; std::vector<Actor,std::allocator<Actor> >::_Assign_counted_range<Actor *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN344:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r12, -6430974998173972123		; a6c0964fda6c0965H
	sub	rcx, rbx
	mov	rsi, r8
	sar	rcx, 3
	mov	rdi, rdx
	imul	rcx, r12

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r15

; 1658 :         if (_Newsize > max_size()) {

	mov	r15, 21154523020309118			; 004b27ed3604b27eH
	cmp	r8, r15
	ja	$LN342@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r15, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r15, r8
	cmovb	r15, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
	mov	rcx, rbx
	call	??1Actor@@QEAA@XZ
	add	rbx, 872				; 00000368H
	cmp	rbx, rbp
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rax, QWORD PTR [r14+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 872				; 00000368H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r15
	call	?allocate@?$allocator@UActor@@@std@@QEAAPEAUActor@@_K@Z ; std::allocator<Actor>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	r8, r15, 872				; 00000368H
	mov	QWORD PTR [r14+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rcx, rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax
	call	??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z ; std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN45@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rbp, r8
	sub	rbp, rbx
	sar	rbp, 3
	imul	rbp, r12

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	rsi, rbp
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	npad	9
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4Actor@@QEAAAEAU0@AEBU0@@Z
	mov	r8, QWORD PTR [r14+8]
	add	rbx, 872				; 00000368H
	add	rdi, 872				; 00000368H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rsi, rbp
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z ; std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rbp, rsi, 872				; 00000368H
	add	rbp, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN84@Assign_cou
$LL85@Assign_cou:

; 4573 :         *_Dest = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4Actor@@QEAAAEAU0@AEBU0@@Z
	add	rbx, 872				; 00000368H
	add	rdi, 872				; 00000368H
	sub	rsi, 1
	jne	SHORT $LL85@Assign_cou
$LN84@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN89@Assign_cou
	npad	2
$LL90@Assign_cou:
	mov	rcx, rbx
	call	??1Actor@@QEAA@XZ
	add	rbx, 872				; 00000368H
	cmp	rbx, rdi
	jne	SHORT $LL90@Assign_cou
$LN89@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN342@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@CAXXZ ; std::vector<Actor,std::allocator<Actor> >::_Xlength
	int	3
$LN340@Assign_cou:
??$_Assign_counted_range@PEAUActor@@@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAXPEAUActor@@_K@Z ENDP ; std::vector<Actor,std::allocator<Actor> >::_Assign_counted_range<Actor *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::Rail,std::allocator<Actor::Rail> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::Rail,std::allocator<Actor::Rail> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@URail@Actor@@@std@@@std@@YAXAEAV?$allocator@URail@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@URail@Actor@@@std@@@std@@YAXAEAV?$allocator@URail@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::Rail> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@URail@Actor@@@std@@@std@@YAXAEAV?$allocator@URail@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::Rail> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z PROC ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Assign_counted_range<Actor::Rail *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN169:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r13, -8198552921648689607		; 8e38e38e38e38e39H
	sub	rcx, rbx
	mov	r14, r8
	sar	rcx, 3
	mov	r15, rdx
	imul	rcx, r13

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 256204778801521550			; 038e38e38e38e38eH
	cmp	r8, rsi
	ja	$LN167@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, rsi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, r8
	cmovb	rsi, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN22@Assign_cou
	npad	6
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rdi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbp]
	mov	rax, QWORD PTR [rbp+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN57@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN54@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN57@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbp], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbp+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbp+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@URail@Actor@@@std@@QEAAPEAURail@Actor@@_K@Z ; std::allocator<Actor::Rail>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rbp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [rsi+rsi*8]
	mov	QWORD PTR [rbp+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r14
	mov	rcx, r15

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r9, QWORD PTR [rax+r8*8]

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rbp+16], r9

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, rbp
	call	??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >
	mov	QWORD PTR [rbp+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN54@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+120], r12
	mov	r12, r8
	sub	r12, rbx
	sar	r12, 3
	imul	r12, r13

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, r12
	jbe	$LN6@Assign_cou

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	lea	rsi, QWORD PTR [rbx+40]
	lea	rdi, QWORD PTR [rdx+32]
	npad	2
$LL4@Assign_cou:
	mov	rax, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-24]
	lea	rcx, QWORD PTR [rsi-32]
	mov	QWORD PTR [rbx], rax
	cmp	rcx, rdx
	je	SHORT $LN66@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN70@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN70@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi-8]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN66@Assign_cou:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi+8]
	cmp	rsi, rdx
	je	SHORT $LN2@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN78@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN78@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+24]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	r8, QWORD PTR [rbp+8]
	add	rbx, 72					; 00000048H
	add	rsi, 72					; 00000048H
	add	r15, 72					; 00000048H
	add	rdi, 72					; 00000048H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, r12
	mov	r9, rbp
	mov	rdx, r14
	mov	rcx, r15
	call	??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >
	mov	QWORD PTR [rbp+8], rax

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {

	jmp	$LN164@Assign_cou
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r14+r14*8]
	lea	r13, QWORD PTR [rbx+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN84@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rbx+40]
	lea	rdi, QWORD PTR [rdx+32]
	npad	4
$LL85@Assign_cou:
	mov	rax, QWORD PTR [rdi-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-24]
	lea	rcx, QWORD PTR [rsi-32]
	mov	QWORD PTR [rbx], rax
	cmp	rcx, rdx
	je	SHORT $LN89@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN93@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN93@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi-8]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN89@Assign_cou:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi+8]
	cmp	rsi, rdx
	je	SHORT $LN83@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN101@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN101@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+24]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN83@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 72					; 00000048H
	add	rsi, 72					; 00000048H
	add	rdi, 72					; 00000048H
	sub	r14, 1
	jne	SHORT $LL85@Assign_cou
$LN84@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r13, rdi
	je	SHORT $LN107@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	lea	rbx, QWORD PTR [r13+8]
$LL108@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, rdi
	jne	SHORT $LL108@Assign_cou
$LN107@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbp+8], r13
$LN164@Assign_cou:
	mov	r12, QWORD PTR [rsp+120]

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN167@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Xlength
	int	3
$LN165@Assign_cou:
??$_Assign_counted_range@PEAURail@Actor@@@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAXPEAURail@Actor@@_K@Z ENDP ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Assign_counted_range<Actor::Rail *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@@std@@YAPEBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@@std@@YAPEBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::Link,std::allocator<Actor::Link> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@@std@@YAPEBV?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::Link,std::allocator<Actor::Link> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@ULink@Actor@@@std@@@std@@YAXAEAV?$allocator@ULink@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@ULink@Actor@@@std@@@std@@YAXAEAV?$allocator@ULink@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::Link> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@ULink@Actor@@@std@@@std@@YAXAEAV?$allocator@ULink@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::Link> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z PROC ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Assign_counted_range<Actor::Link *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN146:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r15, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	rbp, -3689348814741910323		; cccccccccccccccdH
	sub	rcx, rbx
	mov	r14, r8
	sar	rcx, 4
	mov	rdi, rdx
	imul	rcx, rbp

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r12

; 1658 :         if (_Newsize > max_size()) {

	mov	r12, 230584300921369395			; 0333333333333333H
	cmp	r8, r12
	ja	$LN144@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r12
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r12, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r12, r8
	cmovb	r12, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+48]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+16]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 80					; 00000050H
	cmp	rbx, rsi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r15]
	mov	rax, QWORD PTR [r15+16]
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN57@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN54@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN57@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r15], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r12
	call	?allocate@?$allocator@ULink@Actor@@@std@@QEAAPEAULink@Actor@@_K@Z ; std::allocator<Actor::Link>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r15], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [r12+r12*4]
	shl	r8, 4

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r15

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax
	mov	QWORD PTR [r15+8], rax
	mov	QWORD PTR [r15+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r14
	mov	r8, rax
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >
	mov	r12, QWORD PTR [rsp+32]
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN54@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r15+8]
	mov	rsi, r8
	sub	rsi, rbx
	sar	rsi, 4
	imul	rsi, rbp

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, rsi
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4Link@Actor@@QEAAAEAU01@AEBU01@@Z
	mov	r8, QWORD PTR [r15+8]
	add	rbx, 80					; 00000050H
	add	rdi, 80					; 00000050H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, rsi
	mov	r9, r15
	mov	rdx, r14
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [r14+r14*4]
	shl	rbp, 4
	add	rbp, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN66@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rbx+16]
	add	rdi, 40					; 00000028H
	npad	10
$LL67@Assign_cou:
	mov	rax, QWORD PTR [rdi-40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-24]
	mov	QWORD PTR [rbx], rax
	mov	rax, QWORD PTR [rdi-32]
	mov	QWORD PTR [rsi-8], rax
	cmp	rsi, rdx
	je	SHORT $LN71@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN75@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN75@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi-8]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN71@Assign_cou:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [rsi+32]
	cmp	rcx, rdx
	je	SHORT $LN65@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN83@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN83@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN65@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 80					; 00000050H
	add	rsi, 80					; 00000050H
	add	rdi, 80					; 00000050H
	sub	r14, 1
	jne	SHORT $LL67@Assign_cou
$LN66@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN89@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	lea	rbx, QWORD PTR [rbp+16]
	npad	4
$LL90@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 80					; 00000050H
	lea	rax, QWORD PTR [rbx-16]
	cmp	rax, rdi
	jne	SHORT $LL90@Assign_cou
$LN89@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r15+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN144@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Xlength
	int	3
$LN142@Assign_cou:
??$_Assign_counted_range@PEAULink@Actor@@@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAXPEAULink@Actor@@_K@Z ENDP ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Assign_counted_range<Actor::Link *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@URailData@PhiveData@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@URailData@PhiveData@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::PhiveData::RailData> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@URailData@PhiveData@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::PhiveData::RailData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z PROC ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Assign_counted_range<Actor::PhiveData::RailData *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN137:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	r14, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	rbp, r8
	sub	rcx, rbx
	mov	rdi, rdx
	sar	rcx, 6

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 288230376151711743			; 03ffffffffffffffH
	cmp	r8, rsi
	ja	$LN135@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, rsi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, r8
	cmovb	rsi, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r15, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, r15
	je	SHORT $LN22@Assign_cou
	npad	6
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXXZ ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, r15
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r14]
	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN56@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN53@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN56@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@URailData@PhiveData@Actor@@@std@@QEAAPEAURailData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::RailData>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rsi, 6

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rsi, rax
	mov	QWORD PTR [r14+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, rbp

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], rsi

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN53@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rsi, r8
	sub	rsi, rbx
	sar	rsi, 6

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	rbp, rsi
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	npad	9
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rdi
	mov	rcx, rbx
	call	??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
	mov	r8, QWORD PTR [r14+8]
	add	rbx, 64					; 00000040H
	add	rdi, 64					; 00000040H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rbp, rsi
	mov	r9, r14
	mov	rdx, rbp
	mov	rcx, rdi
	call	??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >
	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	mov	r15, rbp
	shl	r15, 6
	add	r15, rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rbp, rbp
	je	$LN65@Assign_cou
	mov	QWORD PTR [rsp+32], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rbx+32]
	mov	r12, -6148914691236517205		; aaaaaaaaaaaaaaabH
	add	rdi, 48					; 00000030H
	npad	8
$LL66@Assign_cou:
	movzx	eax, BYTE PTR [rdi-48]

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-40]
	lea	rcx, QWORD PTR [rsi-24]
	mov	BYTE PTR [rbx], al
	cmp	rcx, rdx
	je	SHORT $LN70@Assign_cou

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdi-32]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, r12
	call	??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
$LN70@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rdi-16]
	cmp	rsi, rdx
	je	SHORT $LN64@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+8], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN77@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN77@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN64@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 64					; 00000040H
	add	rsi, 64					; 00000040H
	add	rdi, 64					; 00000040H
	sub	rbp, 1
	jne	SHORT $LL66@Assign_cou
	mov	r12, QWORD PTR [rsp+32]
$LN65@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r15, rdi
	je	SHORT $LN83@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	lea	rbx, QWORD PTR [r15+8]
	npad	4
$LL84@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+24]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXXZ ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, rdi
	jne	SHORT $LL84@Assign_cou
$LN83@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], r15

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN135@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Xlength
	int	3
$LN133@Assign_cou:
??$_Assign_counted_range@PEAURailData@PhiveData@Actor@@@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAURailData@PhiveData@Actor@@_K@Z ENDP ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Assign_counted_range<Actor::PhiveData::RailData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@_KV?$allocator@_K@std@@@std@@@std@@YAPEBV?$vector@_KV?$allocator@_K@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@_KV?$allocator@_K@std@@@std@@@std@@YAPEBV?$vector@_KV?$allocator@_K@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<unsigned __int64,std::allocator<unsigned __int64> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@_KV?$allocator@_K@std@@@std@@@std@@YAPEBV?$vector@_KV?$allocator@_K@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<unsigned __int64,std::allocator<unsigned __int64> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@_K@std@@@std@@YAXAEAV?$allocator@_K@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@_K@std@@@std@@YAXAEAV?$allocator@_K@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<unsigned __int64> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@_K@std@@@std@@YAXAEAV?$allocator@_K@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN122:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, rdx
	mov	r14, rcx

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
	sar	rdx, 3

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rdx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rbx, 2305843009213693951		; 1fffffffffffffffH
	cmp	r8, rbx
	ja	$LN120@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rdx
	mov	rax, rbx
	shr	r8, 1
	sub	rax, r8
	cmp	rdx, rax
	ja	SHORT $LN17@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [r8+rdx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rbp
	cmovb	rbx, rbp
$LN17@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN13@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN34@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN37@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r14], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r14+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r14+16], rax
$LN13@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@_K@std@@QEAAPEA_K_K@Z ; std::allocator<unsigned __int64>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r14], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [r14+8], rax
	mov	rdi, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rax+rbx*8]
	mov	QWORD PTR [r14+16], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rax
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN34@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+104], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1407 :         if (_Newsize > _Oldsize) {

	mov	rdx, r15
	mov	rsi, QWORD PTR [r14+8]
	sub	rsi, rcx
	sar	rsi, 3
	cmp	rbp, rsi
	jbe	SHORT $LN6@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rsi*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1416 :                     _Copied = true;

	mov	rdi, QWORD PTR [r14+8]
	lea	rdx, QWORD PTR [rbx+r15]

; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rbp, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
	mov	rsi, QWORD PTR [rsp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	QWORD PTR [r14+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	r8, QWORD PTR [r8*8]
	lea	rbx, QWORD PTR [rcx+r8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
	mov	rsi, QWORD PTR [rsp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r14+8], rbx

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN120@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength
	int	3
$LN118@Assign_cou:
??$_Assign_counted_range@PEA_K@?$vector@_KV?$allocator@_K@std@@@std@@AEAAXPEA_K_K@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Assign_counted_range<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN142:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r13, -3689348814741910323		; cccccccccccccccdH
	sub	rcx, rbx
	mov	r14, r8
	sar	rcx, 3
	mov	r15, rdx
	imul	rcx, r13

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou

; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 461168601842738790			; 0666666666666666H
	cmp	r8, rsi
	ja	$LN140@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, rsi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, r8
	cmovb	rsi, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdi, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rdi
	je	SHORT $LN22@Assign_cou
	npad	6
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbp]
	mov	rax, QWORD PTR [rbp+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbp], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbp+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbp+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@QEAAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rbp], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r8, QWORD PTR [rsi+rsi*4]
	mov	QWORD PTR [rbp+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r14
	mov	rcx, r15

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	r9, QWORD PTR [rax+r8*8]

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rbp+16], r9

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, rbp
	call	??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
	mov	QWORD PTR [rbp+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN51@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rbp+8]
	mov	QWORD PTR [rsp+120], r12
	mov	r12, r8
	sub	r12, rbx
	sar	r12, 3
	imul	r12, r13

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, r12
	jbe	SHORT $LN6@Assign_cou

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	lea	rsi, QWORD PTR [rbx+8]
	lea	rdi, QWORD PTR [rdx+8]
$LL4@Assign_cou:
	mov	rax, QWORD PTR [r15]
	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rdi
	je	SHORT $LN2@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN67@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN67@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+16]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	r8, QWORD PTR [rbp+8]
	add	rbx, 40					; 00000028H
	add	rsi, 40					; 00000028H
	add	r15, 40					; 00000028H
	add	rdi, 40					; 00000028H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, r12
	mov	r9, rbp
	mov	rdx, r14
	mov	rcx, r15
	call	??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
	mov	QWORD PTR [rbp+8], rax

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {

	jmp	SHORT $LN137@Assign_cou
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [r14+r14*4]
	lea	r12, QWORD PTR [rbx+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN73@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rbx+8]
	lea	rdi, QWORD PTR [rdx+8]
	npad	6
$LL74@Assign_cou:
	mov	rax, QWORD PTR [rdi-8]
	mov	QWORD PTR [rbx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rdi
	je	SHORT $LN72@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rdi

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN82@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdi]
$LN82@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdi+16]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN72@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 40					; 00000028H
	add	rsi, 40					; 00000028H
	add	rdi, 40					; 00000028H
	sub	r14, 1
	jne	SHORT $LL74@Assign_cou
$LN73@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [rbp+8]
	mov	rbx, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	r12, rdi
	je	SHORT $LN88@Assign_cou
$LL89@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rdi
	jne	SHORT $LL89@Assign_cou
$LN88@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbp+8], r12
$LN137@Assign_cou:
	mov	r12, QWORD PTR [rsp+120]

; 1440 :         }
; 1441 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN140@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Xlength
	int	3
$LN138@Assign_cou:
??$_Assign_counted_range@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::ReferData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN94:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r12, -8116567392432202711		; 8f5c28f5c28f5c29H
	sub	rcx, rbx
	mov	r14, r8
	sar	rcx, 3
	mov	rsi, rdx
	imul	rcx, r12

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r15

; 1658 :         if (_Newsize > max_size()) {

	mov	r15, 92233720368547758			; 0147ae147ae147aeH
	cmp	r8, r15
	ja	$LN92@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r15
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r15, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r15, r8
	cmovb	r15, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN22@Assign_cou
	npad	3
$LL23@Assign_cou:
	mov	rcx, rbx
	call	??1OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAA@XZ
	add	rbx, 200				; 000000c8H
	cmp	rbx, rbp
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rcx
	sar	rax, 3
	imul	rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 200				; 000000c8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r15
	call	?allocate@?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@QEAAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, rdi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	r8, r15, 200				; 000000c8H
	mov	QWORD PTR [rdi+8], rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdx, r14

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	r8, rax

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rcx, rsi

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], r8

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax
	call	??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN45@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rdi+8]
	mov	rbp, r8
	sub	rbp, rbx
	sar	rbp, 3
	imul	rbp, r12

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, rbp
	jbe	SHORT $LN6@Assign_cou

; 1408 :             bool _Copied = false;
; 1409 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1410 : #if _HAS_CXX20
; 1411 :                 if (!_STD is_constant_evaluated())
; 1412 : #endif // _HAS_CXX20
; 1413 :                 {
; 1414 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
; 1415 :                     _First += _Oldsize;
; 1416 :                     _Copied = true;
; 1417 :                 }
; 1418 :             }
; 1419 : 
; 1420 :             if (!_Copied) {
; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rbx, r8
	je	SHORT $LN3@Assign_cou
	npad	9
$LL4@Assign_cou:

; 1422 :                     *_Mid = *_First;

	mov	rdx, rsi
	mov	rcx, rbx
	call	??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
	mov	r8, QWORD PTR [rdi+8]
	add	rbx, 200				; 000000c8H
	add	rsi, 200				; 000000c8H
	cmp	rbx, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, rbp
	mov	r9, rdi
	mov	rdx, r14
	mov	rcx, rsi
	call	??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
	mov	QWORD PTR [rdi+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1432 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1433 :             }
; 1434 :         } else {
; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	imul	rbp, r14, 200				; 000000c8H

; 1436 :             _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);

	mov	r8, rbx
	mov	rdx, r14
	mov	rcx, rsi
	add	rbp, rbx
	call	??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::OwnerData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::OwnerData *>

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rsi
	je	SHORT $LN57@Assign_cou
$LL58@Assign_cou:
	mov	rcx, rbx
	call	??1OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAA@XZ
	add	rbx, 200				; 000000c8H
	cmp	rbx, rsi
	jne	SHORT $LL58@Assign_cou
$LN57@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [rdi+8], rbp

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN92@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Xlength
	int	3
$LN90@Assign_cou:
??$_Assign_counted_range@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Assign_counted_range<Actor::PhiveData::ConstraintLinkData::OwnerData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@@2@$0A@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,Actor::DynamicData,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData> >,0> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UDynamicData@Actor@@@std@@PEAX@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,Actor::DynamicData>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z PROC		; Actor::Rail::operator=, COMDAT
$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rdi, rdx
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	add	rcx, 8
	add	rdx, 8

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	lea	rdx, QWORD PTR [rdi+40]
	lea	rcx, QWORD PTR [rbx+40]

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN19@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN19@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Rail@Actor@@QEAAAEAU01@AEBU01@@Z ENDP		; Actor::Rail::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4Link@Actor@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Link@Actor@@QEAAAEAU01@AEBU01@@Z PROC		; Actor::Link::operator=, COMDAT
$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rdi, rdx
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx
	mov	rax, QWORD PTR [rdx+8]
	add	rdx, 16
	mov	QWORD PTR [rcx+8], rax
	add	rcx, 16

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	lea	rdx, QWORD PTR [rdi+48]
	lea	rcx, QWORD PTR [rbx+48]

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN19@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN19@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Link@Actor@@QEAAAEAU01@AEBU01@@Z ENDP		; Actor::Link::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z PROC ; Actor::PhiveData::RailData::operator=, COMDAT
$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	movzx	eax, BYTE PTR [rdx]
	lea	r8, QWORD PTR [rdx+8]
	mov	BYTE PTR [rcx], al
	mov	rbx, rcx
	add	rcx, 8
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN3@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [r8]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	r8, QWORD PTR [r8+8]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
$LN3@operator:
	lea	rdx, QWORD PTR [rdi+32]
	lea	rcx, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN14@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN10@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN14@operator:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4RailData@PhiveData@Actor@@QEAAAEAU012@AEBU012@@Z ENDP ; Actor::PhiveData::RailData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z PROC ; Actor::PhiveData::ConstraintLinkData::ReferData::operator=, COMDAT
$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rdx]
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	add	rdx, 8
	add	rcx, 8

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4ReferData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ENDP ; Actor::PhiveData::ConstraintLinkData::ReferData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 64
__that$ = 72
??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z PROC ; Actor::PhiveData::ConstraintLinkData::OwnerData::operator=, COMDAT
$LN48:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 1091 :         if (this == _STD addressof(_Right)) {

	xor	r15d, r15d
	mov	QWORD PTR [rsp+64], r14
	mov	rsi, rdx
	mov	rdi, rcx
	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [rcx]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN5@operator:
	lea	rbp, QWORD PTR [rsi+16]
	lea	r14, QWORD PTR [rdi+16]

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rbp
	je	SHORT $LN12@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [r14]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r14
	mov	rcx, r14
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r14

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [r14+8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN12@operator:
	movups	xmm0, XMMWORD PTR [rsi+32]
	lea	rbp, QWORD PTR [rsi+56]
	lea	r14, QWORD PTR [rdi+56]
	movups	XMMWORD PTR [rdi+32], xmm0
	movsd	xmm1, QWORD PTR [rsi+48]
	movsd	QWORD PTR [rdi+48], xmm1

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	r14, rbp
	je	SHORT $LN19@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [r14]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r14
	mov	rcx, r14
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r14

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [r14+8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Copy<0>
$LN19@operator:
	movups	xmm0, XMMWORD PTR [rsi+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	mov	r14, QWORD PTR [rsp+64]
	lea	rdx, QWORD PTR [rsi+152]
	lea	rcx, QWORD PTR [rdi+152]
	movups	XMMWORD PTR [rdi+72], xmm0
	movups	xmm1, XMMWORD PTR [rsi+88]
	movups	XMMWORD PTR [rdi+88], xmm1
	movups	xmm0, XMMWORD PTR [rsi+104]
	movups	XMMWORD PTR [rdi+104], xmm0
	mov	rax, QWORD PTR [rsi+120]
	mov	QWORD PTR [rdi+120], rax
	movups	xmm0, XMMWORD PTR [rsi+128]
	movups	XMMWORD PTR [rdi+128], xmm0
	movsd	xmm1, QWORD PTR [rsi+144]
	movsd	QWORD PTR [rdi+144], xmm1
	cmp	rcx, rdx
	je	SHORT $LN24@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN28@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN28@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN24@operator:
	lea	rbp, QWORD PTR [rsi+184]
	lea	rsi, QWORD PTR [rdi+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rbp
	je	SHORT $LN39@operator

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [rsi]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rsi
	mov	rcx, rsi
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rsi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rsi+8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN39@operator:
	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
??4OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ENDP ; Actor::PhiveData::ConstraintLinkData::OwnerData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor,std::allocator<Actor> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN223:
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rbp, 21154523020309118			; 004b27ed3604b27eH
	mov	rdi, rcx
	cmp	rdx, rbp
	ja	$LN221@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbp

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+32], r14
	sar	rcx, 3
	mov	r14, -6430974998173972123		; a6c0964fda6c0965H
	imul	rcx, r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbp, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbp, rdx
	cmovb	rbp, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+88], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
	mov	rcx, rbx
	call	??1Actor@@QEAA@XZ
	add	rbx, 872				; 00000368H
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 872				; 00000368H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN201@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN198@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN201@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbp
	call	?allocate@?$allocator@UActor@@@std@@QEAAPEAUActor@@_K@Z ; std::allocator<Actor>::allocate
	mov	rbx, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rcx, rbp, 872				; 00000368H
	mov	QWORD PTR [rdi+8], rax
	add	rcx, rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
$LN198@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN221@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@CAXXZ ; std::vector<Actor,std::allocator<Actor> >::_Xlength
	int	3
$LN219@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UActor@@V?$allocator@UActor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor,std::allocator<Actor> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN70:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 256204778801521550			; 038e38e38e38e38eH
	mov	rdi, rcx
	cmp	rdx, rsi
	ja	$LN68@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rsi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+32], r14
	sar	rcx, 3
	mov	r14, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, rdx
	cmovb	rsi, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+88], rbp

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+40]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 72					; 00000048H
	cmp	rbx, rbp
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rbp, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*8]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@URail@Actor@@@std@@QEAAPEAURail@Actor@@_K@Z ; std::allocator<Actor::Rail>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rsi*8]
	mov	r14, QWORD PTR [rsp+32]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rdi+16], rax

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN45@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN68@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Xlength
	int	3
$LN66@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@URail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::Rail,std::allocator<Actor::Rail> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN70:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rsi, 230584300921369395			; 0333333333333333H
	mov	rdi, rcx
	cmp	rdx, rsi
	ja	$LN68@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rsi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+32], r14
	sar	rcx, 4
	mov	r14, -3689348814741910323		; cccccccccccccccdH
	imul	rcx, r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rsi, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rsi, rdx
	cmovb	rsi, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+88], rbp

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+48]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	lea	rcx, QWORD PTR [rbx+16]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 80					; 00000050H
	cmp	rbx, rbp
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rbp, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 4
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN48@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN45@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN48@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rsi
	call	?allocate@?$allocator@ULink@Actor@@@std@@QEAAPEAULink@Actor@@_K@Z ; std::allocator<Actor::Link>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rsi*4]
	mov	r14, QWORD PTR [rsp+32]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN45@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN68@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Xlength
	int	3
$LN66@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@ULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::Link,std::allocator<Actor::Link> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN68:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rdi, 288230376151711743			; 03ffffffffffffffH
	mov	r8, rdx
	mov	rsi, rcx
	cmp	rdx, rdi
	ja	$LN66@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	sar	rcx, 6

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, r8
	cmovb	rdi, r8
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rbp

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rbp, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rbp
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 767  :         _Tidy();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXXZ ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 64					; 00000040H
	cmp	rbx, rbp
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rbp, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -64				; ffffffffffffffc0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN47@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN44@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN47@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rsi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rdi
	call	?allocate@?$allocator@URailData@PhiveData@Actor@@@std@@QEAAPEAURailData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::RailData>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rdi, 6
	add	rdi, rax
	mov	QWORD PTR [rsi+8], rax
	mov	QWORD PTR [rsi+16], rdi

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
$LN44@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN66@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Xlength
	int	3
$LN64@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@URailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::PhiveData::RailData,std::allocator<Actor::PhiveData::RailData> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::operator=, COMDAT

; 1482 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r8, rdx
	mov	rbx, rcx

; 1483 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN5@operator

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r8, QWORD PTR [r8+8]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rdx]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, rax
	call	??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
$LN5@operator:

; 1499 : 
; 1500 :         return *this;
; 1501 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN42:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rdi, 2305843009213693951		; 1fffffffffffffffH
	mov	r8, rdx
	mov	rbx, rcx
	cmp	rdx, rdi
	ja	$LN40@Clear_and_

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx]

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rdi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	sar	rdx, 3

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, rdx
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [r9+rdx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rdi, r8
	cmovb	rdi, r8
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN3@Clear_and_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rdi
	call	?allocate@?$allocator@_K@std@@QEAAPEA_K_K@Z ; std::allocator<unsigned __int64>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rbx], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rbx+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rdi*8]
	mov	QWORD PTR [rbx+16], rax

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN24@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN40@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength
	int	3
$LN38@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@_KV?$allocator@_K@std@@@std@@AEAAX_K@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN67:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	r14, 461168601842738790			; 0666666666666666H
	mov	rdi, rcx
	cmp	rdx, r14
	ja	$LN65@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+88], rbp
	sar	rcx, 3
	mov	rbp, -3689348814741910323		; cccccccccccccccdH
	imul	rcx, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rdx
	cmovb	r14, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx+8]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 40					; 00000028H
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*4]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN42@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN45@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@QEAAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+r14*4]
	mov	rbp, QWORD PTR [rsp+88]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rdi+16], rax

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
$LN42@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN65@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Xlength
	int	3
$LN63@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::ReferData,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN61:
	push	rbp
	push	rdi
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	rbp, 92233720368547758			; 0147ae147ae147aeH
	mov	rdi, rcx
	cmp	rdx, rbp
	ja	$LN59@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbp

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+32], r14
	sar	rcx, 3
	mov	r14, -8116567392432202711		; 8f5c28f5c28f5c29H
	imul	rcx, r14

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbp, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbp, rdx
	cmovb	rbp, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+88], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
	mov	rcx, rbx
	call	??1OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAA@XZ
	add	rbx, 200				; 000000c8H
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 3
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rdx, rax, 200				; 000000c8H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN39@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN36@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN39@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, rbp
	call	?allocate@?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@QEAAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData>::allocate
	mov	rbx, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+32]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	imul	rcx, rbp, 200				; 000000c8H
	mov	QWORD PTR [rdi+8], rax
	add	rcx, rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rbp
	ret	0
$LN36@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN59@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Xlength
	int	3
$LN57@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::PhiveData::ConstraintLinkData::OwnerData,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::operator=, COMDAT

; 161  :     map& operator=(const map& _Right) {

$LN12:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN8@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Copy<0>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 163  :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN8@operator:

; 164  :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::operator=, COMDAT

; 1090 :     _Tree& operator=(const _Tree& _Right) {

$LN10:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 1091 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN7@operator
	mov	QWORD PTR [rsp+48], rbx

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rdi

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rdi+8], 0

; 1092 :             return *this;
; 1093 :         }
; 1094 : 
; 1095 :         auto& _Al       = _Getal();
; 1096 :         auto& _Right_al = _Right._Getal();
; 1097 :         if constexpr (_Choose_pocca_v<_Alnode>) {
; 1098 :             if (_Al != _Right_al) {
; 1099 :                 clear();
; 1100 :                 const auto _Scary = _Get_scary();
; 1101 :                 _Scary->_Orphan_all();
; 1102 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
; 1103 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
; 1104 :                 _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
; 1105 :                 auto _Right_al_non_const = _Right_al;
; 1106 :                 auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
; 1107 :                 _Node::_Freenode0(_Al, _Scary->_Myhead);
; 1108 :                 _Pocca(_Al, _Right_al);
; 1109 :                 _Scary->_Myhead = _Newhead;
; 1110 :                 _Proxy._Bind(_Alproxy, _Scary);
; 1111 :                 _Getcomp() = _Right._Getcomp();
; 1112 :                 _Copy<_Strategy::_Copy>(_Right);
; 1113 :                 return *this;
; 1114 :             }
; 1115 :         }
; 1116 : 
; 1117 :         clear();
; 1118 :         _Getcomp() = _Right._Getcomp();
; 1119 :         _Pocca(_Al, _Right_al);
; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Copy<0>

; 1121 : 
; 1122 :         return *this;

	mov	rbx, QWORD PTR [rsp+48]
$LN7@operator:

; 1123 :     }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Getcomp, COMDAT

; 1953 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1954 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::clear, COMDAT

; 1354 :     void clear() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1355 :         const auto _Scary = _Get_scary();
; 1356 :         _Scary->_Orphan_ptr(nullptr);
; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rbx, QWORD PTR [rcx]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rcx
	mov	rdi, rcx
	mov	r8, QWORD PTR [rbx+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rbx+8], rbx

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rbx], rbx

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rbx+16], rbx

; 1362 :         _Scary->_Mysize = 0;
; 1363 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+8], 0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@2@$00@2@$00@std@@QEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@2@$00@2@$00@std@@QEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >,1>,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@2@$00@2@$00@std@@QEAAAEAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUActor@@@std@@YA?A_T$$QEAPEAUActor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUActor@@@std@@YA?A_T$$QEAPEAUActor@@@Z PROC ; std::_Get_unwrapped<Actor *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUActor@@@std@@YA?A_T$$QEAPEAUActor@@@Z ENDP ; std::_Get_unwrapped<Actor *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN711:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN708@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0Actor@@QEAA@AEBU0@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 872				; 00000368H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 872				; 00000368H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN708@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UActor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor> >::~_Uninitialized_backout_al<std::allocator<Actor> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUActor@@V?$allocator@UActor@@@std@@@std@@YAPEAUActor@@PEAU1@_K0AEAV?$allocator@UActor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor *,std::allocator<Actor> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor *,unsigned __int64,Actor *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN190:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN186@Copy_n_unc
	sub	rsi, rbx
$LL4@Copy_n_unc:

; 4573 :         *_Dest = *_First;

	lea	rdx, QWORD PTR [rsi+rbx]
	mov	rcx, rbx
	call	??4Actor@@QEAAAEAU0@AEBU0@@Z
	add	rbx, 872				; 00000368H
	sub	rdi, 1
	jne	SHORT $LL4@Copy_n_unc
$LN186@Copy_n_unc:

; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAUActor@@_KPEAU1@@std@@YAPEAUActor@@PEAU1@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor *,unsigned __int64,Actor *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAURail@Actor@@@std@@YA?A_T$$QEAPEAURail@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAURail@Actor@@@std@@YA?A_T$$QEAPEAURail@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::Rail *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAURail@Actor@@@std@@YA?A_T$$QEAPEAURail@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::Rail *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN57:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN54@Uninitiali

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	rbx, QWORD PTR [rcx+40]
	npad	12
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rax, QWORD PTR [rbx-40]
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+8]
	lea	rdx, QWORD PTR [rbx-32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+40]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 72					; 00000048H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 72					; 00000048H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN54@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@URail@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::Rail> >::~_Uninitialized_backout_al<std::allocator<Actor::Rail> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$1@?0???$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 8
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Uninitialized_copy_n@PEAURail@Actor@@V?$allocator@URail@Actor@@@std@@@std@@YAPEAURail@Actor@@PEAU12@_K0AEAV?$allocator@URail@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::Rail *,std::allocator<Actor::Rail> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::Rail *,unsigned __int64,Actor::Rail *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN37:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN28@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rsp+56], rdi
	lea	rdi, QWORD PTR [r8+40]
	npad	9
$LL4@Copy_n_unc:
	mov	rax, QWORD PTR [rbx-32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-24]
	lea	rcx, QWORD PTR [rdi-32]
	mov	QWORD PTR [rsi], rax
	cmp	rcx, rdx
	je	SHORT $LN8@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-8]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@Copy_n_unc:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx+8]
	cmp	rdi, rdx
	je	SHORT $LN2@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN20@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+24]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rsi, 72					; 00000048H
	add	rbx, 72					; 00000048H
	add	rdi, 72					; 00000048H
	sub	rbp, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN28@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAURail@Actor@@_KPEAU12@@std@@YAPEAURail@Actor@@PEAU12@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::Rail *,unsigned __int64,Actor::Rail *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAULink@Actor@@@std@@YA?A_T$$QEAPEAULink@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAULink@Actor@@@std@@YA?A_T$$QEAPEAULink@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::Link *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAULink@Actor@@@std@@YA?A_T$$QEAPEAULink@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::Link *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN57:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN54@Uninitiali

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	lea	rbx, QWORD PTR [rcx+16]
	npad	12
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], rdi
	mov	rax, QWORD PTR [rbx-16]
	mov	QWORD PTR [rdi], rax
	mov	rax, QWORD PTR [rbx-8]
	mov	QWORD PTR [rdi+8], rax
	lea	rcx, QWORD PTR [rdi+16]
	mov	rdx, rbx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR [rdi+48]
	lea	rdx, QWORD PTR [rbx+32]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 80					; 00000050H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 80					; 00000050H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN54@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@ULink@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::Link> >::~_Uninitialized_backout_al<std::allocator<Actor::Link> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Backout$ = 40
__$ArrayPad$ = 64
_First$ = 96
_Count$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$1@?0???$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T1[rdx]
	add	rcx, 16
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0???$_Uninitialized_copy_n@PEAULink@Actor@@V?$allocator@ULink@Actor@@@std@@@std@@YAPEAULink@Actor@@PEAU12@_K0AEAV?$allocator@ULink@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::Link *,std::allocator<Actor::Link> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::Link *,unsigned __int64,Actor::Link *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN37:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	$LN28@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rsp+56], rdi
	lea	rdi, QWORD PTR [r8+16]
	npad	5
$LL4@Copy_n_unc:
	mov	rax, QWORD PTR [rbx-40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-24]
	mov	QWORD PTR [rsi], rax
	mov	rax, QWORD PTR [rbx-32]
	mov	QWORD PTR [rdi-8], rax
	cmp	rdi, rdx
	je	SHORT $LN8@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx-8]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN8@Copy_n_unc:

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rdi+32]
	cmp	rcx, rdx
	je	SHORT $LN2@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+32], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN20@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rsi, 80					; 00000050H
	add	rdi, 80					; 00000050H
	add	rbx, 80					; 00000050H
	sub	rbp, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN28@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAULink@Actor@@_KPEAU12@@std@@YAPEAULink@Actor@@PEAU12@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::Link *,unsigned __int64,Actor::Link *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAURailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAURailData@PhiveData@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAURailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAURailData@PhiveData@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::PhiveData::RailData *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAURailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAURailData@PhiveData@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::PhiveData::RailData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN52:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN49@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0RailData@PhiveData@Actor@@QEAA@AEBU012@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 64					; 00000040H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 64					; 00000040H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN49@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::PhiveData::RailData> >::~_Uninitialized_backout_al<std::allocator<Actor::PhiveData::RailData> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAURailData@PhiveData@Actor@@V?$allocator@URailData@PhiveData@Actor@@@std@@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0AEAV?$allocator@URailData@PhiveData@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::PhiveData::RailData *,std::allocator<Actor::PhiveData::RailData> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData *,unsigned __int64,Actor::PhiveData::RailData *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN31:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	$LN23@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rsp+56], rdi
	lea	rdi, QWORD PTR [r8+32]
	mov	QWORD PTR [rsp+64], r14
	mov	r14, -6148914691236517205		; aaaaaaaaaaaaaaabH
	npad	6
$LL4@Copy_n_unc:
	movzx	eax, BYTE PTR [rbx-48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1483 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-40]
	lea	rcx, QWORD PTR [rdi-24]
	mov	BYTE PTR [rsi], al
	cmp	rcx, rdx
	je	SHORT $LN8@Copy_n_unc

; 1484 :             return *this;
; 1485 :         }
; 1486 : 
; 1487 :         auto& _Al       = _Getal();
; 1488 :         auto& _Right_al = _Right._Getal();
; 1489 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1490 :             if (_Al != _Right_al) {
; 1491 :                 _Tidy();
; 1492 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1493 :             }
; 1494 :         }
; 1495 : 
; 1496 :         _Pocca(_Al, _Right_al);
; 1497 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1498 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rbx-32]
	sub	r8, rdx
	sar	r8, 4
	imul	r8, r14
	call	??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
$LN8@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rbx-16]
	cmp	rdi, rdx
	je	SHORT $LN2@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+8], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN15@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN15@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rsi, 64					; 00000040H
	add	rbx, 64					; 00000040H
	add	rdi, 64					; 00000040H
	sub	rbp, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	r14, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN23@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Copy_n_unchecked4@PEAURailData@PhiveData@Actor@@_KPEAU123@@std@@YAPEAURailData@PhiveData@Actor@@PEAU123@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData *,unsigned __int64,Actor::PhiveData::RailData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEA_K@std@@YA?A_T$$QEAPEA_K@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEA_K@std@@YA?A_T$$QEAPEA_K@Z PROC	; std::_Get_unwrapped<unsigned __int64 *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEA_K@std@@YA?A_T$$QEAPEA_K@Z ENDP	; std::_Get_unwrapped<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z PROC ; std::_Uninitialized_copy_n<unsigned __int64 *,std::allocator<unsigned __int64> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN25:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1881 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEA_KV?$allocator@_K@std@@@std@@YAPEA_KPEA_K_K0AEAV?$allocator@_K@0@@Z ENDP ; std::_Uninitialized_copy_n<unsigned __int64 *,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z PROC ; std::_Copy_memmove_n<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 4543 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4545 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4546 :         return _Result;
; 4547 :     } else { // _Result is unused so the compiler can optimize it away
; 4548 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4549 :     }
; 4550 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEA_KPEA_K@std@@YAPEA_KPEA_K_K0@Z ENDP ; std::_Copy_memmove_n<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z PROC ; std::_Copy_n_unchecked4<unsigned __int64 *,unsigned __int64,unsigned __int64 *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4544 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*8]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4557 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4558 :     // note: has callers outside the copy family
; 4559 : #ifdef __cpp_lib_concepts
; 4560 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4561 : #endif // __cpp_lib_concepts
; 4562 : 
; 4563 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4564 : #if _HAS_CXX20
; 4565 :         if (!_STD is_constant_evaluated())
; 4566 : #endif // _HAS_CXX20
; 4567 :         {
; 4568 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4569 :         }
; 4570 :     }
; 4571 : 
; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEA_K_KPEA_K@std@@YAPEA_KPEA_K_K0@Z ENDP ; std::_Copy_n_unchecked4<unsigned __int64 *,unsigned __int64,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::ReferData *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::ReferData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN53:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN50@Uninitiali
	npad	13
$LL4@Uninitiali:
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rdi], rcx
	lea	rcx, QWORD PTR [rdi+8]
	lea	rdx, QWORD PTR [rbx+8]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1803 :         ++_Last;

	add	rdi, 40					; 00000028H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	lea	rbx, QWORD PTR [rbx+40]
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN50@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >::~_Uninitialized_backout_al<std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UReferData@ConstraintLinkData@PhiveData@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::ReferData *,std::allocator<Actor::PhiveData::ConstraintLinkData::ReferData> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::ReferData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::ReferData *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN27:
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbp, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN20@Copy_n_unc
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+56], rsi
	lea	rsi, QWORD PTR [r8+8]
	npad	9
$LL4@Copy_n_unc:
	mov	rax, QWORD PTR [rbx-8]
	mov	QWORD PTR [rdi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rsi, rbx
	je	SHORT $LN2@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rsi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rdi, 40					; 00000028H
	add	rbx, 40					; 00000028H
	add	rsi, 40					; 00000028H
	sub	rbp, 1
	jne	SHORT $LL4@Copy_n_unc
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN20@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAUReferData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUReferData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::ReferData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::ReferData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::OwnerData *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::PhiveData::ConstraintLinkData::OwnerData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN41@Uninitiali
$LL4@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	mov	rcx, rdi
	call	??0OwnerData@ConstraintLinkData@PhiveData@Actor@@QEAA@AEBU0123@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	rdi, 200				; 000000c8H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 200				; 000000c8H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN41@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >::~_Uninitialized_backout_al<std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@V?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@std@@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UOwnerData@ConstraintLinkData@PhiveData@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::PhiveData::ConstraintLinkData::OwnerData *,std::allocator<Actor::PhiveData::ConstraintLinkData::OwnerData> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z
_TEXT	SEGMENT
_First$ = 80
_Count$ = 88
_Dest$ = 96
??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::OwnerData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::OwnerData *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN61:
	push	r13
	push	r14
	sub	rsp, 56					; 00000038H
	mov	r14, r8
	mov	r13, rdx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	$LN50@Copy_n_unc
	mov	QWORD PTR [rsp+80], rbx
	lea	rbx, QWORD PTR [r8+16]
	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+96], rsi
	lea	rsi, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+32], r15
	xor	r15d, r15d
	mov	QWORD PTR [rsp+48], rdi
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	lea	rbp, QWORD PTR [rsi-16]
	cmp	r14, rbp
	je	SHORT $LN49@Copy_n_unc

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rdi, QWORD PTR [r14]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r14
	mov	rcx, r14
	mov	r8, QWORD PTR [rdi+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rdi+8], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rbp

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rdi], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r14

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rdi+16], rdi

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rbx-8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN49@Copy_n_unc:

; 1091 :         if (this == _STD addressof(_Right)) {

	mov	rbp, rbx
	cmp	rbx, rsi
	je	SHORT $LN17@Copy_n_unc

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rdi, QWORD PTR [rbx]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, rbx
	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rdi+8], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, rsi

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rdi], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, rbx

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rdi+16], rdi

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rbx+8], r15

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN17@Copy_n_unc:
	movups	xmm0, XMMWORD PTR [rsi+16]

; 1091 :         if (this == _STD addressof(_Right)) {

	lea	r12, QWORD PTR [rsi+40]
	lea	r15, QWORD PTR [rbx+40]
	movups	XMMWORD PTR [rbx+16], xmm0
	movsd	xmm1, QWORD PTR [rsi+32]
	movsd	QWORD PTR [rbx+32], xmm1
	cmp	r15, r12
	je	SHORT $LN48@Copy_n_unc

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rdi, QWORD PTR [r15]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r15
	mov	rcx, r15
	mov	r8, QWORD PTR [rdi+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rdi+8], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, r12

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rdi], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r15

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rdi+16], rdi

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rbp+48], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> >::_Copy<0>
$LN48@Copy_n_unc:
	movups	xmm0, XMMWORD PTR [rsi+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	lea	rdx, QWORD PTR [rsi+136]
	lea	rcx, QWORD PTR [rbx+136]
	movups	XMMWORD PTR [rbx+56], xmm0
	movups	xmm1, XMMWORD PTR [rsi+72]
	movups	XMMWORD PTR [rbx+72], xmm1
	movups	xmm0, XMMWORD PTR [rsi+88]
	movups	XMMWORD PTR [rbx+88], xmm0
	mov	rax, QWORD PTR [rsi+104]
	mov	QWORD PTR [rbx+104], rax
	movups	xmm0, XMMWORD PTR [rsi+112]
	movups	XMMWORD PTR [rbx+112], xmm0
	movsd	xmm1, QWORD PTR [rsi+128]
	movsd	QWORD PTR [rbx+128], xmm1
	cmp	rcx, rdx
	je	SHORT $LN29@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rsi+160], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN33@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN33@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rsi+152]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN29@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1091 :         if (this == _STD addressof(_Right)) {

	lea	r12, QWORD PTR [rsi+168]
	lea	r15, QWORD PTR [rbx+168]
	cmp	r15, r12
	je	SHORT $LN2@Copy_n_unc

; 1357 :         auto _Head = _Scary->_Myhead;

	mov	rdi, QWORD PTR [r15]

; 1358 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	rdx, r15
	mov	rcx, r15
	mov	r8, QWORD PTR [rdi+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 1359 :         _Head->_Parent  = _Head;

	mov	QWORD PTR [rdi+8], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rdx, r12

; 1360 :         _Head->_Left    = _Head;

	mov	QWORD PTR [rdi], rdi

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	mov	rcx, r15

; 1361 :         _Head->_Right   = _Head;

	mov	QWORD PTR [rdi+16], rdi

; 1362 :         _Scary->_Mysize = 0;

	mov	QWORD PTR [rbp+176], 0

; 1120 :         _Copy<_Strategy::_Copy>(_Right);

	call	??$_Copy@$0A@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IEAAXAEBV01@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Copy<0>
$LN2@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	r14, 200				; 000000c8H
	add	rbx, 200				; 000000c8H
	add	rsi, 200				; 000000c8H
	mov	r15d, 0
	sub	r13, 1
	jne	$LL4@Copy_n_unc
	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
$LN50@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rax, r14
	add	rsp, 56					; 00000038H
	pop	r14
	pop	r13
	ret	0
??$_Copy_n_unchecked4@PEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUOwnerData@ConstraintLinkData@PhiveData@Actor@@PEAU1234@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::PhiveData::ConstraintLinkData::OwnerData *,unsigned __int64,Actor::PhiveData::ConstraintLinkData::OwnerData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@@std@@YAPEBV?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<Actor::PhiveData::RailData::Node> >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAXAEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<Actor::PhiveData::RailData::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z
_TEXT	SEGMENT
this$ = 96
_First$ = 104
_Newsize$ = 112
??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z PROC ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>, COMDAT

; 1381 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN145:
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 1382 :         // assign elements from counted range _First + [0, _Newsize)
; 1383 :         auto& _Al         = _Getal();
; 1384 :         auto& _My_data    = _Mypair._Myval2;
; 1385 :         pointer& _Myfirst = _My_data._Myfirst;
; 1386 :         pointer& _Mylast  = _My_data._Mylast;
; 1387 :         pointer& _Myend   = _My_data._Myend;
; 1388 : 
; 1389 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1390 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1391 : 
; 1392 :         _My_data._Orphan_all();
; 1393 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	r15, rcx
	mov	rcx, QWORD PTR [rcx+16]
	mov	r13, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rcx, rdi
	mov	r14, r8
	sar	rcx, 4
	mov	rbx, rdx
	imul	rcx, r13

; 1394 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rcx
	jbe	$LN5@Assign_cou
	mov	QWORD PTR [rsp+32], r12

; 1658 :         if (_Newsize > max_size()) {

	mov	r12, 384307168202282325			; 0555555555555555H
	cmp	r8, r12
	ja	$LN143@Assign_cou

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	rax, r12
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	SHORT $LN16@Assign_cou

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r12, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r12, r8
	cmovb	r12, r8
$LN16@Assign_cou:

; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rdi, rdi
	je	SHORT $LN12@Assign_cou

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [r15+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rsi
	je	SHORT $LN22@Assign_cou
	npad	2
$LL23@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rdi
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rdi, 48					; 00000030H
	cmp	rdi, rsi
	jne	SHORT $LL23@Assign_cou
$LN22@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [r15]
	mov	rax, QWORD PTR [r15+16]
	sub	rax, rcx
	sar	rax, 4
	imul	rax, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Assign_cou

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Assign_cou

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Assign_cou:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [r15], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [r15+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [r15+16], rax
$LN12@Assign_cou:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r12
	call	?allocate@?$allocator@UNode@RailData@PhiveData@Actor@@@std@@QEAAPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::RailData::Node>::allocate

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [r15], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r12+r12*2]
	shl	rcx, 4

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r9, r15

; 1992 :         _Myend             = _Newvec + _Newcapacity;

	add	rcx, rax
	mov	QWORD PTR [r15+8], rax
	mov	QWORD PTR [r15+16], rcx

; 1395 :             _Clear_and_reserve_geometric(_Newsize);
; 1396 :             if constexpr (_Nothrow_construct) {
; 1397 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1398 :                 _ASAN_VECTOR_CREATE;
; 1399 :             } else {
; 1400 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1401 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, rax
	mov	rcx, rbx
	mov	rdx, r14
	call	??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >
	mov	r12, QWORD PTR [rsp+32]
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN51@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1406 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r15+8]
	mov	QWORD PTR [rsp+120], rbp
	mov	rbp, r8
	sub	rbp, rdi
	sar	rbp, 4
	imul	rbp, r13

; 1407 :         if (_Newsize > _Oldsize) {

	cmp	r14, rbp
	jbe	SHORT $LN6@Assign_cou

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rdi, r8
	je	SHORT $LN3@Assign_cou
	lea	rsi, QWORD PTR [rdi+32]
$LL4@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN120@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN67@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN67@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN120@Assign_cou:
	movsd	xmm0, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1421 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	add	rdi, 48					; 00000030H
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rbx+40]
	add	rbx, 48					; 00000030H
	mov	DWORD PTR [rsi+8], eax
	add	rsi, 48					; 00000030H
	mov	r8, QWORD PTR [r15+8]
	cmp	rdi, r8
	jne	SHORT $LL4@Assign_cou
$LN3@Assign_cou:

; 1422 :                     *_Mid = *_First;
; 1423 :                 }
; 1424 :             }
; 1425 : 
; 1426 :             if constexpr (_Nothrow_construct) {
; 1427 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1428 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1429 :             } else {
; 1430 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1431 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	r14, rbp
	mov	r9, r15
	mov	rdx, r14
	mov	rcx, rbx
	call	??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >
	mov	rbp, QWORD PTR [rsp+120]
	mov	QWORD PTR [r15+8], rax

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@Assign_cou:

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbp, QWORD PTR [r14+r14*2]
	shl	rbp, 4
	add	rbp, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	r14, r14
	je	SHORT $LN73@Assign_cou
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1435 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rsi, QWORD PTR [rdi+32]
	npad	2
$LL74@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN121@Assign_cou

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN82@Assign_cou

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN82@Assign_cou:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN121@Assign_cou:
	movsd	xmm0, QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rdi, 48					; 00000030H
	movsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rbx+40]
	add	rbx, 48					; 00000030H
	mov	DWORD PTR [rsi+8], eax
	add	rsi, 48					; 00000030H
	sub	r14, 1
	jne	SHORT $LL74@Assign_cou
$LN73@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1437 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdi, QWORD PTR [r15+8]
	mov	rbx, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbp, rdi
	je	SHORT $LN88@Assign_cou
	npad	5
$LL89@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 48					; 00000030H
	cmp	rbx, rdi
	jne	SHORT $LL89@Assign_cou
$LN88@Assign_cou:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1439 :             _Mylast = _Newlast;

	mov	QWORD PTR [r15+8], rbp
	mov	rbp, QWORD PTR [rsp+120]

; 1440 :         }
; 1441 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN143@Assign_cou:

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Xlength
	int	3
$LN141@Assign_cou:
??$_Assign_counted_range@PEAUNode@RailData@PhiveData@Actor@@@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAXPEAUNode@RailData@PhiveData@Actor@@_K@Z ENDP ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Assign_counted_range<Actor::PhiveData::RailData::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> > const >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@$$CBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@std@@@std@@YAPEBV?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@@2@$0A@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node>,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> > >,0> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >, COMDAT

; 1060 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1061 :         _Left = _Right;
; 1062 :     }
; 1063 : }

	ret	0
??$_Pocca@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@std@@@std@@YAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$variant@IH_K_JM_NNV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VNode@BymlFile@@@2@@std@@PEAX@std@@@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::variant<unsigned int,int,unsigned __int64,__int64,float,bool,double,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,BymlFile::Node> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z PROC ; Actor::PhiveData::RailData::Node::operator=, COMDAT
$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN3@operator

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN7@operator:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN3@operator:
	movsd	xmm0, QWORD PTR [rbx+32]
	movsd	QWORD PTR [rdi+32], xmm0
	mov	eax, DWORD PTR [rbx+40]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi+40], eax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Node@RailData@PhiveData@Actor@@QEAAAEAU0123@AEBU0123@@Z ENDP ; Actor::PhiveData::RailData::Node::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Clear_and_reserve_geometric, COMDAT

; 1646 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN67:
	push	rdi
	push	r14
	sub	rsp, 40					; 00000028H

; 1647 :         auto& _Al         = _Getal();
; 1648 :         auto& _My_data    = _Mypair._Myval2;
; 1649 :         pointer& _Myfirst = _My_data._Myfirst;
; 1650 :         pointer& _Mylast  = _My_data._Mylast;
; 1651 :         pointer& _Myend   = _My_data._Myend;
; 1652 : 
; 1653 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1654 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1655 :         _Check_all_orphaned();
; 1656 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1657 : 
; 1658 :         if (_Newsize > max_size()) {

	mov	r14, 384307168202282325			; 0555555555555555H
	mov	rdi, rcx
	cmp	rdx, r14
	ja	$LN65@Clear_and_
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rbx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rbx
	mov	QWORD PTR [rsp+88], rbp
	sar	rcx, 4
	mov	rbp, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	rcx, rbp

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, rcx
	shr	r8, 1
	sub	rax, r8
	cmp	rcx, rax
	ja	SHORT $LN7@Clear_and_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r14, QWORD PTR [r8+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	r14, rdx
	cmovb	r14, rdx
$LN7@Clear_and_:

; 1660 :         }
; 1661 : 
; 1662 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1663 : 
; 1664 :         if (_Myfirst) { // destroy and deallocate old array

	test	rbx, rbx
	je	SHORT $LN3@Clear_and_
	mov	QWORD PTR [rsp+32], rsi

; 1665 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rsi, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	cmp	rbx, rsi
	je	SHORT $LN13@Clear_and_
$LL14@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

	add	rbx, 48					; 00000030H
	cmp	rbx, rsi
	jne	SHORT $LL14@Clear_and_
$LN13@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1667 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 4
	imul	rax, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@Clear_and_

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN42@Clear_and_

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN45@Clear_and_:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1669 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1670 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1671 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1989 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	rdx, r14
	call	?allocate@?$allocator@UNode@RailData@PhiveData@Actor@@@std@@QEAAPEAUNode@RailData@PhiveData@Actor@@_K@Z ; std::allocator<Actor::PhiveData::RailData::Node>::allocate
	mov	rbx, QWORD PTR [rsp+80]

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+r14*2]
	mov	rbp, QWORD PTR [rsp+88]

; 1990 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1991 :         _Mylast            = _Newvec;
; 1992 :         _Myend             = _Newvec + _Newcapacity;

	shl	rcx, 4
	add	rcx, rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rcx

; 1672 :         }
; 1673 : 
; 1674 :         _Buy_raw(_Newcapacity);
; 1675 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rdi
	ret	0
$LN42@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN65@Clear_and_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1659 :             _Xlength();

	call	?_Xlength@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@CAXXZ ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Xlength
	int	3
$LN63@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@UNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<Actor::PhiveData::RailData::Node,std::allocator<Actor::PhiveData::RailData::Node> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAUNode@RailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUNode@RailData@PhiveData@Actor@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAUNode@RailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUNode@RailData@PhiveData@Actor@@@Z PROC ; std::_Get_unwrapped<Actor::PhiveData::RailData::Node *>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@PEAUNode@RailData@PhiveData@Actor@@@std@@YA?A_T$$QEAPEAUNode@RailData@PhiveData@Actor@@@Z ENDP ; std::_Get_unwrapped<Actor::PhiveData::RailData::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z PROC ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >, COMDAT

; 1864 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN53:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN50@Uninitiali
$LL4@Uninitiali:
	mov	rdx, rbx
	mov	rcx, rdi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	movsd	xmm0, QWORD PTR [rbx+32]
	movsd	QWORD PTR [rdi+32], xmm0
	mov	ecx, DWORD PTR [rbx+40]
	mov	DWORD PTR [rdi+40], ecx

; 1803 :         ++_Last;

	add	rdi, 48					; 00000030H
	mov	QWORD PTR _Backout$[rsp+8], rdi

; 1865 :     // copy _First + [0, _Count) to raw _Dest, using _Al
; 1866 :     // note: only called internally from elsewhere in the STL
; 1867 :     using _Ptrval = typename _Alloc::value_type*;
; 1868 : 
; 1869 :     auto _UFirst = _Get_unwrapped(_STD move(_First));
; 1870 : 
; 1871 :     constexpr bool _Can_memmove =
; 1872 :         conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1873 :             _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;
; 1874 : 
; 1875 :     if constexpr (_Can_memmove) {
; 1876 : #if _HAS_CXX20
; 1877 :         if (!_STD is_constant_evaluated())
; 1878 : #endif // _HAS_CXX20
; 1879 :         {
; 1880 :             _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
; 1881 :             _Dest += _Count;
; 1882 :             return _Dest;
; 1883 :         }
; 1884 :     }
; 1885 : 
; 1886 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1887 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	add	rbx, 48					; 00000030H
	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN50@Uninitiali:

; 1888 :         _Backout._Emplace_back(*_UFirst);
; 1889 :     }
; 1890 : 
; 1891 :     return _Backout._Release();
; 1892 : }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z ENDP ; std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<Actor::PhiveData::RailData::Node> >::~_Uninitialized_backout_al<std::allocator<Actor::PhiveData::RailData::Node> >
?dtor$0@?0???$_Uninitialized_copy_n@PEAUNode@RailData@PhiveData@Actor@@V?$allocator@UNode@RailData@PhiveData@Actor@@@std@@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0AEAV?$allocator@UNode@RailData@PhiveData@Actor@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<Actor::PhiveData::RailData::Node *,std::allocator<Actor::PhiveData::RailData::Node> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z PROC ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData::Node *,unsigned __int64,Actor::PhiveData::RailData::Node *>, COMDAT

; 4556 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN21@Copy_n_unc
	npad	3
$LL4@Copy_n_unc:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

	cmp	rdi, rbx
	je	SHORT $LN20@Copy_n_unc

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@Copy_n_unc

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rbx]
$LN12@Copy_n_unc:

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN20@Copy_n_unc:
	movsd	xmm0, QWORD PTR [rbx+32]
	movsd	QWORD PTR [rdi+32], xmm0
	mov	eax, DWORD PTR [rbx+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4572 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rbx, 48					; 00000030H
	mov	DWORD PTR [rdi+40], eax
	add	rdi, 48					; 00000030H
	sub	rsi, 1
	jne	SHORT $LL4@Copy_n_unc
$LN21@Copy_n_unc:

; 4573 :         *_Dest = *_First;
; 4574 :     }
; 4575 : 
; 4576 :     return _Dest;
; 4577 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAUNode@RailData@PhiveData@Actor@@_KPEAU1234@@std@@YAPEAUNode@RailData@PhiveData@Actor@@PEAU1234@_K0@Z ENDP ; std::_Copy_n_unchecked4<Actor::PhiveData::RailData::Node *,unsigned __int64,Actor::PhiveData::RailData::Node *>
_TEXT	ENDS
END
