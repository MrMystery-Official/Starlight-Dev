; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	?in_place@std@@3Uin_place_t@1@B			; std::in_place
PUBLIC	?nullopt@std@@3Unullopt_t@1@B			; std::nullopt
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	??2@YAPEAX_KAEBUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	__std_reverse_trivially_swappable_8:PROC
;	COMDAT ?nullopt@std@@3Unullopt_t@1@B
CONST	SEGMENT
?nullopt@std@@3Unullopt_t@1@B	ORG $+1			; std::nullopt
CONST	ENDS
;	COMDAT ?in_place@std@@3Uin_place_t@1@B
CONST	SEGMENT
?in_place@std@@3Uin_place_t@1@B	ORG $+1			; std::in_place
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
PUBLIC	??$construct_at@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@$0A@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@AEAPEAU123@@Z ; std::construct_at<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &,0>
PUBLIC	??$addressof@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z ; std::addressof<bvh::TopDownBuildTask::WorkItem *>
PUBLIC	??$reverse@PEA_K@std@@YAXQEA_K0@Z		; std::reverse<unsigned __int64 *>
PUBLIC	??$_Copy_backward_memmove@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ; std::_Copy_backward_memmove<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$forward@$$T@std@@YA$$QEA$$TAEA$$T@Z		; std::forward<std::nullptr_t>
PUBLIC	?_Release@?$_Uninitialized_backout@PEA_K@std@@QEAAPEA_KXZ ; std::_Uninitialized_backout<unsigned __int64 *>::_Release
PUBLIC	??$?0V<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$cross@M@1@YA?AU01@AEBU01@0@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::cross<float>'::`2'::<lambda_1>,0>
PUBLIC	??$_Construct_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::_Construct_in_place<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &>
PUBLIC	??$forward@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z ; std::forward<bvh::TopDownBuildTask::WorkItem * &>
PUBLIC	??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z		; std::rotate<unsigned __int64 *>
PUBLIC	??$_Move_backward_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ; std::_Move_backward_unchecked<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z ; std::_Uninitialized_move_unchecked<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$advance@PEA_K_J@std@@YAXAEAPEA_K_J@Z		; std::advance<unsigned __int64 *,__int64>
PUBLIC	??$forward@AEA_J@std@@YAAEA_JAEA_J@Z		; std::forward<__int64 &>
PUBLIC	??$?0$$TH$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEA$$T$$QEAH@Z ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><std::nullptr_t,int,0>
PUBLIC	??$?0PEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEAPEA_KAEA_J@Z ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 *,__int64 &,0>
PUBLIC	??$min@_J@std@@YAAEB_JAEB_J0@Z			; std::min<__int64>
PUBLIC	??$construct_at@UNode@?$Bvh@M@bvh@@U123@$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@$$QEAU123@@Z ; std::construct_at<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node,0>
PUBLIC	??$construct_at@U?$Triangle@M$00$0A@@bvh@@U12@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU12@@Z ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0>,0>
PUBLIC	??$forward@PEAU?$Vector@M$02@bvh@@@std@@YA$$QEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z ; std::forward<bvh::Vector<float,3> *>
PUBLIC	??$forward@PEAU?$BoundingBox@M@bvh@@@std@@YA$$QEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z ; std::forward<bvh::BoundingBox<float> *>
PUBLIC	??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K0@Z ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>
PUBLIC	?set@?$VectorSetter@$02M$02@bvh@@SAXAEAU?$Vector@M$02@2@@Z ; bvh::VectorSetter<3,float,3>::set
PUBLIC	??0<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ; `bvh::cross<float>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ; `bvh::cross<float>'::`2'::<lambda_1>::operator()
PUBLIC	??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z	; bvh::cross<float>
PUBLIC	??$exchange@PEAU?$BoundingBox@M@bvh@@$$T@std@@YAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<bvh::BoundingBox<float> *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$Vector@M$02@bvh@@$$T@std@@YAPEAU?$Vector@M$02@bvh@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<bvh::Vector<float,3> *,std::nullptr_t>
PUBLIC	??$_Destroy_range@PEA_KPEA_K@std@@YAXPEA_KQEA_K@Z ; std::_Destroy_range<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$to_address@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z ; std::to_address<bvh::TopDownBuildTask::WorkItem *>
PUBLIC	??$forward@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAPEAU123@@Z ; std::forward<bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Emplace_back@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Emplace_back<bvh::TopDownBuildTask::WorkItem * &>
PUBLIC	??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z ; std::_Copy_memmove<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$?0AEBQEA_K_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEBQEA_K$$QEA_J@Z ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * const &,__int64,0>
PUBLIC	??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z ; std::_Buffered_rotate_unchecked<unsigned __int64 *>
PUBLIC	??$next@PEA_K@std@@YAPEA_KPEA_K_J@Z		; std::next<unsigned __int64 *>
PUBLIC	??$?0AEAPEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEAPEA_KAEA_J@Z ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * &,__int64 &,0>
PUBLIC	??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ; std::_Move_unchecked<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Emplace_back@_K@?$_Uninitialized_backout@PEA_K@std@@QEAAX$$QEA_K@Z ; std::_Uninitialized_backout<unsigned __int64 *>::_Emplace_back<unsigned __int64>
PUBLIC	??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z ; std::_Get_temporary_buffer<unsigned __int64>
PUBLIC	??$_Temporary_buffer_size@_J@std@@YA_J_J@Z	; std::_Temporary_buffer_size<__int64>
PUBLIC	??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEAU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEAU123@@Z ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &,0>
PUBLIC	??$construct_at@UNode@?$Bvh@M@bvh@@$$V$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z ; std::construct_at<bvh::Bvh<float>::Node,0>
PUBLIC	??$construct@UNode@?$Bvh@M@bvh@@U123@@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@$$QEAU345@@Z ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node>
PUBLIC	??$forward@UNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z ; std::forward<bvh::Bvh<float>::Node>
PUBLIC	??$to_address@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z ; std::to_address<bvh::Bvh<float>::Node>
PUBLIC	??$forward@AEAPEAU?$Vector@M$02@bvh@@@std@@YAAEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z ; std::forward<bvh::Vector<float,3> * &>
PUBLIC	??$forward@AEAPEAU?$BoundingBox@M@bvh@@@std@@YAAEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z ; std::forward<bvh::BoundingBox<float> * &>
PUBLIC	??$construct@U?$Triangle@M$00$0A@@bvh@@U12@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0> >
PUBLIC	??$forward@U?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z ; std::forward<bvh::Triangle<float,1,0> >
PUBLIC	??$to_address@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@@Z ; std::to_address<bvh::Triangle<float,1,0> >
PUBLIC	??$set@$$V@?$VectorSetter@$01M$02@bvh@@SAXAEAU?$Vector@M$02@1@M@Z ; bvh::VectorSetter<2,float,3>::set<>
PUBLIC	??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@1@$$QEAPEAU?$Vector@M$02@bvh@@@Z ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *>
PUBLIC	??$forward@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@0@AEAU10@@Z ; std::forward<std::default_delete<bvh::Vector<float,3> [0]> >
PUBLIC	??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@1@$$QEAPEAU?$BoundingBox@M@bvh@@@Z ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *>
PUBLIC	??$forward@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@0@AEAU10@@Z ; std::forward<std::default_delete<bvh::BoundingBox<float> [0]> >
PUBLIC	??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z ; bvh::Triangle<float,1,0>::Triangle<float,1,0>
PUBLIC	?get_deleter@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get_deleter
PUBLIC	?release@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAPEAU?$BoundingBox@M@bvh@@XZ ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::release
PUBLIC	?get_deleter@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get_deleter
PUBLIC	?release@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAPEAU?$Vector@M$02@bvh@@XZ ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::release
PUBLIC	??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K@Z ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>
PUBLIC	??1?$_Uninitialized_backout@PEA_K@std@@QEAA@XZ	; std::_Uninitialized_backout<unsigned __int64 *>::~_Uninitialized_backout<unsigned __int64 *>
PUBLIC	??0?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??1?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::~_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	?_Release@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Release
PUBLIC	??$_Return_temporary_buffer@_K@std@@YAXQEA_K@Z	; std::_Return_temporary_buffer<unsigned __int64>
PUBLIC	??$_To_address@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_To_address<bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z ; std::_Zero_range<bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Seek_wrapped@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@$$QEAPEAPEAU123@@Z ; std::_Seek_wrapped<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z ; std::_Uninitialized_copy_unchecked<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Adl_verify_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::_Adl_verify_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEBU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEBU123@@Z ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &,0>
PUBLIC	??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
PUBLIC	??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z ; std::_Optimistic_temporary_buffer<unsigned __int64>::_Optimistic_temporary_buffer<unsigned __int64><__int64>
PUBLIC	??$distance@PEA_K@std@@YA_JPEA_K0@Z		; std::distance<unsigned __int64 *>
PUBLIC	??$construct@UWorkItem@TopDownBuildTask@bvh@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEAU345@@Z ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$construct_at@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@$$QEAH1AEA_K1@Z ; std::construct_at<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int,0>
PUBLIC	??$forward@AEAPEAE@std@@YAAEAPEAEAEAPEAE@Z	; std::forward<unsigned char * &>
PUBLIC	??$forward@AEAPEAI@std@@YAAEAPEAIAEAPEAI@Z	; std::forward<unsigned int * &>
PUBLIC	??$forward@AEAPEAM@std@@YAAEAPEAMAEAPEAM@Z	; std::forward<float * &>
PUBLIC	??$forward@AEAPEAUNode@?$Bvh@M@bvh@@@std@@YAAEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z ; std::forward<bvh::Bvh<float>::Node * &>
PUBLIC	??$construct@UNode@?$Bvh@M@bvh@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@@Z ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node>
PUBLIC	??$_Emplace_back@UNode@?$Bvh@M@bvh@@@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX$$QEAUNode@?$Bvh@M@bvh@@@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<bvh::Bvh<float>::Node>
PUBLIC	??$_To_address@PEAUNode@?$Bvh@M@bvh@@@std@@YA?A_PAEBQEAUNode@?$Bvh@M@bvh@@@Z ; std::_To_address<bvh::Bvh<float>::Node *>
PUBLIC	??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z ; std::_Copy_memmove<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>
PUBLIC	??$_Unfancy@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@@Z ; std::_Unfancy<bvh::Bvh<float>::Node>
PUBLIC	??$move@AEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z ; std::move<bvh::Bvh<float>::Node &>
PUBLIC	??$?0AEAPEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$Vector@M$02@bvh@@@Z ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><bvh::Vector<float,3> * &>
PUBLIC	??$?0AEAPEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$BoundingBox@M@bvh@@@Z ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><bvh::BoundingBox<float> * &>
PUBLIC	??$_Emplace_back@U?$Triangle@M$00$0A@@bvh@@@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX$$QEAU?$Triangle@M$00$0A@@bvh@@@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back<bvh::Triangle<float,1,0> >
PUBLIC	??$_To_address@PEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_PAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z ; std::_To_address<bvh::Triangle<float,1,0> *>
PUBLIC	??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z ; std::_Copy_memmove<bvh::Triangle<float,1,0> *,bvh::Triangle<float,1,0> *>
PUBLIC	??$move@AEAU?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z ; std::move<bvh::Triangle<float,1,0> &>
PUBLIC	??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3>,0>
PUBLIC	??$set@M@?$VectorSetter@$00M$02@bvh@@SAXAEAU?$Vector@M$02@1@MM@Z ; bvh::VectorSetter<1,float,3>::set<float>
PUBLIC	??$forward@AEAPEA_K@std@@YAAEAPEA_KAEAPEA_K@Z	; std::forward<unsigned __int64 * &>
PUBLIC	??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><std::default_delete<bvh::Vector<float,3> [0]>,0>
PUBLIC	??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><std::default_delete<bvh::BoundingBox<float> [0]>,0>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@PEAU?$Triangle@M$00$0A@@bvh@@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::~_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Release
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ ; std::_Optimistic_temporary_buffer<unsigned __int64>::~_Optimistic_temporary_buffer<unsigned __int64>
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2
PUBLIC	??$_Get_size_of_n@$0M@@std@@YA_K_K@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Destroy_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z ; std::_Destroy_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z ; std::_Uninitialized_value_construct_n_unchecked1<bvh::TopDownBuildTask::WorkItem * *,unsigned __int64>
PUBLIC	??$_Get_unwrapped_n@AEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@std@@YA?A_TAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@Z ; std::_Get_unwrapped_n<bvh::TopDownBuildTask::WorkItem * * &,__int64>
PUBLIC	??$_Idl_distance@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::_Idl_distance<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Get_unwrapped@AEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_TAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_Get_unwrapped<bvh::TopDownBuildTask::WorkItem * * const &>
PUBLIC	??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z ; std::uninitialized_copy<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Fill_zero_memset@PEAM@std@@YAXPEAM_K@Z	; std::_Fill_zero_memset<float *>
PUBLIC	??$_Is_all_bits_zero@M@std@@YA_NAEBM@Z		; std::_Is_all_bits_zero<float>
PUBLIC	??$?0AEAM_K$0A@@?$pair@M_K@std@@QEAA@AEAM$$QEA_K@Z ; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float &,unsigned __int64,0>
PUBLIC	??$?0V<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?GM$02@1@YA?AU01@AEBU01@0@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator-<float,3>'::`2'::<lambda_1>,0>
PUBLIC	??$construct@UWorkItem@TopDownBuildTask@bvh@@AEBU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEBU345@@Z ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &>
PUBLIC	??$forward@AEBUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEBUWorkItem@TopDownBuildTask@bvh@@AEBU123@@Z ; std::forward<bvh::TopDownBuildTask::WorkItem const &>
PUBLIC	??$destroy_at@UWorkItem@TopDownBuildTask@bvh@@@std@@YAXQEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::destroy_at<bvh::TopDownBuildTask::WorkItem>
PUBLIC	??$?0V<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$max@M$02@1@YA?AU01@AEBU01@0@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::max<float,3>'::`2'::<lambda_1>,0>
PUBLIC	??$max@M@std@@YAAEBMAEBM0@Z			; std::max<float>
PUBLIC	??$?0V<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$min@M$02@1@YA?AU01@AEBU01@0@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::min<float,3>'::`2'::<lambda_1>,0>
PUBLIC	??$min@M@std@@YAAEBMAEBM0@Z			; std::min<float>
PUBLIC	??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??$?0AEAUWorkItem@TopDownBuildTask@bvh@@AEAU012@$0A@@?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@QEAA@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem><bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &,0>
PUBLIC	??$_Seek_wrapped@PEA_KPEA_K@std@@YAXAEAPEA_K$$QEAPEA_K@Z ; std::_Seek_wrapped<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ; std::_Stable_partition_unchecked<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$forward@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z ; std::forward<bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$move@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z ; std::move<bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$construct@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@$$QEAH2AEA_K2@Z ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int>
PUBLIC	??$move@AEAPEIA_K@std@@YA$$QEAPEIA_KAEAPEIA_K@Z	; std::move<unsigned __int64 * __restrict &>
PUBLIC	??$move@AEAPEIAI@std@@YA$$QEAPEIAIAEAPEIAI@Z	; std::move<unsigned int * __restrict &>
PUBLIC	??$_Fill_zero_memset@PEA_K@std@@YAXPEA_K_K@Z	; std::_Fill_zero_memset<unsigned __int64 *>
PUBLIC	??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z		; std::_Is_all_bits_zero<int>
PUBLIC	??$_Adl_verify_range@PEA_KPEA_K@std@@YAXAEBQEA_K0@Z ; std::_Adl_verify_range<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$?0AEAPEAE@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAE@Z ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1><unsigned char * &>
PUBLIC	??$?0AEAPEAI@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAI@Z ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1><unsigned int * &>
PUBLIC	??$?0AEAPEAM@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAM@Z ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Compressed_pair<std::default_delete<float [0]>,float *,1><float * &>
PUBLIC	??$?0AEAPEAUNode@?$Bvh@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAUNode@?$Bvh@M@bvh@@@Z ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1><bvh::Bvh<float>::Node * &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ; std::_Uninitialized_move<bvh::Bvh<float>::Node *,std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??$_Get_unwrapped@AEBQEAUNode@?$Bvh@M@bvh@@@std@@YA?A_TAEBQEAUNode@?$Bvh@M@bvh@@@Z ; std::_Get_unwrapped<bvh::Bvh<float>::Node * const &>
PUBLIC	??$?0V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@$0A@@?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@1@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@@Z ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > ><std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >,0>
PUBLIC	??$?0PEAU?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@PEAU?$Vector@M$02@bvh@@@Z ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><bvh::Vector<float,3> *,std::default_delete<bvh::Vector<float,3> [0]>,0,0>
PUBLIC	??$?0PEAU?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@PEAU?$BoundingBox@M@bvh@@@Z ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><bvh::BoundingBox<float> *,std::default_delete<bvh::BoundingBox<float> [0]>,0,0>
PUBLIC	??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z ; std::_Uninitialized_move<bvh::Triangle<float,1,0> *,std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	??$_Get_unwrapped@AEBQEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_TAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z ; std::_Get_unwrapped<bvh::Triangle<float,1,0> * const &>
PUBLIC	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
PUBLIC	??$_Unfancy@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z ; std::_Unfancy<bvh::Triangle<float,1,0> >
PUBLIC	??$set@MM@?$VectorSetter@$0A@M$02@bvh@@SAXAEAU?$Vector@M$02@1@MMM@Z ; bvh::VectorSetter<0,float,3>::set<float,float>
PUBLIC	??$?0AEAPEA_K@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEA_K@Z ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><unsigned __int64 * &>
PUBLIC	??$exchange@PEA_KAEAPEA_K@std@@YAPEA_KAEAPEA_K0@Z ; std::exchange<unsigned __int64 *,unsigned __int64 * &>
PUBLIC	??$exchange@PEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@0@Z ; std::exchange<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node * &>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SA_KAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@@Z ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size
PUBLIC	?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SA_KAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::max_size
PUBLIC	?capacity@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::capacity
PUBLIC	?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SA_KAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@@Z ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::max_size
PUBLIC	?capacity@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::capacity
PUBLIC	?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal
PUBLIC	?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocate
PUBLIC	?max_size@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_KXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size
PUBLIC	?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Xlen
PUBLIC	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--
PUBLIC	?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z ; std::allocator<bvh::Triangle<float,1,0> >::allocate
PUBLIC	?max_size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::max_size
PUBLIC	?_Calculate_growth@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBA_K_K@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Change_array
PUBLIC	?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAXPEAU?$Triangle@M$00$0A@@bvh@@0@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Orphan_range
PUBLIC	?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z ; std::allocator<bvh::Bvh<float>::Node>::allocate
PUBLIC	?max_size@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::max_size
PUBLIC	?_Calculate_growth@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBA_K_K@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Change_array
PUBLIC	?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Xlength
PUBLIC	??0?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocator<bvh::TopDownBuildTask::WorkItem>
PUBLIC	?allocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocate
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >
PUBLIC	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
PUBLIC	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::~_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2
PUBLIC	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z		; std::fill<float *,float>
PUBLIC	??$make_pair@AEAM_K@std@@YA?AU?$pair@M_K@0@AEAM$$QEA_K@Z ; std::make_pair<float &,unsigned __int64>
PUBLIC	??$?0MAEA_K$0A@@?$pair@M_K@std@@QEAA@$$QEAMAEA_K@Z ; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64 &,0>
PUBLIC	??0<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ; `bvh::operator-<float,3>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ; `bvh::operator-<float,3>'::`2'::<lambda_1>::operator()
PUBLIC	??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z	; bvh::operator-<float,3>
PUBLIC	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
PUBLIC	??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem const &>
PUBLIC	??$destroy@UWorkItem@TopDownBuildTask@bvh@@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::destroy<bvh::TopDownBuildTask::WorkItem>
PUBLIC	??$_Unfancy@UWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@PEAU123@@Z ; std::_Unfancy<bvh::TopDownBuildTask::WorkItem>
PUBLIC	??$_Destroy_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::_Destroy_in_place<bvh::TopDownBuildTask::WorkItem *>
PUBLIC	??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocator<bvh::TopDownBuildTask::WorkItem *><bvh::TopDownBuildTask::WorkItem>
PUBLIC	??$addressof@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z ; std::addressof<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ; `bvh::max<float,3>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ; `bvh::max<float,3>'::`2'::<lambda_1>::operator()
PUBLIC	??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ; bvh::max<float,3>
PUBLIC	??0<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ; `bvh::min<float,3>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ; `bvh::min<float,3>'::`2'::<lambda_1>::operator()
PUBLIC	??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ; bvh::min<float,3>
PUBLIC	??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>
PUBLIC	??$forward@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YA$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z ; std::forward<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??$make_optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@std@@YA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@@Z ; std::make_optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>
PUBLIC	??$make_pair@AEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@std@@YA?AU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::make_pair<bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$_Pass_fn@V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ; std::_Pass_fn<`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
PUBLIC	??$_Get_unwrapped@AEAPEA_K@std@@YA?A_TAEAPEA_K@Z ; std::_Get_unwrapped<unsigned __int64 * &>
PUBLIC	??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ; std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
PUBLIC	??$?4U?$pair@M_K@std@@$0A@@?$pair@M_K@std@@QEAAAEAU01@$$QEAU01@@Z ; std::pair<float,unsigned __int64>::operator=<std::pair<float,unsigned __int64>,0>
PUBLIC	??$?0M_K$0A@@?$pair@M_K@std@@QEAA@XZ		; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64,0>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1><>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><bvh::TopDownBuildTask::WorkItem>
PUBLIC	??$_Prev_iter@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@0@V10@@Z ; std::_Prev_iter<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > > >
PUBLIC	??$?0V<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?DM$02@1@YA?AU01@AEBU01@M@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator*<float,3>'::`2'::<lambda_1>,0>
PUBLIC	??$?0V<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?HM$02@1@YA?AU01@AEBU01@0@Z@@Z ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator+<float,3>'::`2'::<lambda_1>,0>
PUBLIC	??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>
PUBLIC	??$swap@UWorkItem@TopDownBuildTask@bvh@@$0A@@std@@YAXAEAUWorkItem@TopDownBuildTask@bvh@@0@Z ; std::swap<bvh::TopDownBuildTask::WorkItem,0>
PUBLIC	??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<int,int,unsigned __int64 &,int>
PUBLIC	??$forward@$$QEAH@std@@YA$$QEAHAEAH@Z		; std::forward<int &&>
PUBLIC	??$swap@PEIA_K$0A@@std@@YAXAEAPEIA_K0@Z		; std::swap<unsigned __int64 * __restrict,0>
PUBLIC	??$swap@PEIAI$0A@@std@@YAXAEAPEIAI0@Z		; std::swap<unsigned int * __restrict,0>
PUBLIC	??$fill@PEA_KH@std@@YAXQEA_K0AEBH@Z		; std::fill<unsigned __int64 *,int>
PUBLIC	??$?0PEAEU?$default_delete@$$BY0A@E@std@@$0A@$0A@@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@PEAE@Z ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> ><unsigned char *,std::default_delete<unsigned char [0]>,0,0>
PUBLIC	??$?0PEAIU?$default_delete@$$BY0A@I@std@@$0A@$0A@@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@PEAI@Z ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> ><unsigned int *,std::default_delete<unsigned int [0]>,0,0>
PUBLIC	??$?0PEAMU?$default_delete@$$BY0A@M@std@@$0A@$0A@@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@PEAM@Z ; std::unique_ptr<float [0],std::default_delete<float [0]> >::unique_ptr<float [0],std::default_delete<float [0]> ><float *,std::default_delete<float [0]>,0,0>
PUBLIC	??$?0PEAUNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@@Z ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> ><bvh::Bvh<float>::Node *,std::default_delete<bvh::Bvh<float>::Node [0]>,0,0>
PUBLIC	??$forward@PEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z ; std::forward<bvh::Bvh<float>::Node *>
PUBLIC	??$forward@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z ; std::forward<std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
PUBLIC	??$forward@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z ; std::forward<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > >
PUBLIC	??$make_pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@@Z ; std::make_pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
PUBLIC	??$move@AEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > &>
PUBLIC	??$move@AEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z ; std::move<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > &>
PUBLIC	??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z ; std::make_unique<bvh::Vector<float,3> [0],0>
PUBLIC	??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z ; std::make_unique<bvh::BoundingBox<float> [0],0>
PUBLIC	??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
PUBLIC	??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back_with_unused_capacity<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
PUBLIC	??$set@MMM@?$Vector@M$02@bvh@@QEAAXMMM@Z	; bvh::Vector<float,3>::set<float,float,float>
PUBLIC	??$?0PEA_KU?$default_delete@$$BY0A@_K@std@@$0A@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@PEA_K@Z ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><unsigned __int64 *,std::default_delete<unsigned __int64 [0]>,0,0>
PUBLIC	??$move@AEAU?$default_delete@$$BY0A@_K@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@_K@0@AEAU10@@Z ; std::move<std::default_delete<unsigned __int64 [0]> &>
PUBLIC	??$reset@PEA_K$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAXPEA_K@Z ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::reset<unsigned __int64 *,0>
PUBLIC	??$addressof@V?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> > >
PUBLIC	??$move@AEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@0@AEAU10@@Z ; std::move<std::default_delete<bvh::Bvh<float>::Node [0]> &>
PUBLIC	??$reset@PEAUNode@?$Bvh@M@bvh@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXPEAUNode@?$Bvh@M@bvh@@@Z ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::reset<bvh::Bvh<float>::Node *,0>
PUBLIC	??$addressof@V?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@AEAV10@@Z ; std::addressof<std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> > >
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
PUBLIC	??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Getblock
PUBLIC	?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data
PUBLIC	??0?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@XZ ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>
PUBLIC	??A?$Vector@M$02@bvh@@QEAAAEAM_K@Z		; bvh::Vector<float,3>::operator[]
PUBLIC	?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ ; bvh::BoundingBox<float>::diagonal
PUBLIC	?half_area@?$BoundingBox@M@bvh@@QEBAMXZ		; bvh::BoundingBox<float>::half_area
PUBLIC	??A?$array@PEIAM$02@std@@QEAAAEAPEIAM_K@Z	; std::array<float * __restrict,3>::operator[]
PUBLIC	??BBoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@3@XZ ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator bvh::BoundingBox<float>
PUBLIC	?deallocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ; std::allocator<bvh::TopDownBuildTask::WorkItem>::deallocate
PUBLIC	?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::deallocate
PUBLIC	?_Getblock@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBA_K_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getblock
PUBLIC	?_Map@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Map
PUBLIC	?_Mapsize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mapsize
PUBLIC	?_Myoff@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Myoff
PUBLIC	?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize
PUBLIC	?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEB_KXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEBUWorkItem@TopDownBuildTask@bvh@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
PUBLIC	??A?$array@PEIA_K$02@std@@QEAAAEAPEIA_K_K@Z	; std::array<unsigned __int64 * __restrict,3>::operator[]
PUBLIC	??0?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@XZ ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Unullopt_t@1@@Z ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??0?$Vector@M$02@bvh@@QEAA@M@Z			; bvh::Vector<float,3>::Vector<float,3>
PUBLIC	??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@@Z ; bvh::BoundingBox<float>::BoundingBox<float>
PUBLIC	??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@0@Z ; bvh::BoundingBox<float>::BoundingBox<float>
PUBLIC	?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z ; bvh::BoundingBox<float>::extend
PUBLIC	?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ	; bvh::BoundingBox<float>::largest_axis
PUBLIC	?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split
PUBLIC	?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ; bvh::Triangle<float,1,0>::p1
PUBLIC	?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ; bvh::Triangle<float,1,0>::p2
PUBLIC	?to_bounding_box@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@4@XZ ; bvh::Bvh<float>::Node::BoundingBoxProxy::to_bounding_box
PUBLIC	?half_area@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBAMXZ ; bvh::Bvh<float>::Node::BoundingBoxProxy::half_area
PUBLIC	?_Unchecked_end@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@2@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Unchecked_end
PUBLIC	?empty@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_NXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::empty
PUBLIC	?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::push_back
PUBLIC	?pop_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::pop_back
PUBLIC	?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Tidy
PUBLIC	?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal
PUBLIC	?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*
PUBLIC	?__autoclassinit2@<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@QEAAX_K@Z ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::__autoclassinit2
PUBLIC	?release@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAPEA_KXZ ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::release
PUBLIC	?release@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::release
PUBLIC	??C?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@XZ ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator->
PUBLIC	??B?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEBA_NXZ ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator bool
PUBLIC	?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z ; bvh::BoundingBox<float>::extend
PUBLIC	?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ		; bvh::BoundingBox<float>::empty
PUBLIC	??0<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEAA@PEAV23@@Z ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::<lambda_2>
PUBLIC	??R<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@_K@Z ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::operator()
PUBLIC	??R<lambda_1>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@AEAUNode@?$Bvh@M@3@_K2@Z ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_1>::operator()
PUBLIC	?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::build
PUBLIC	??0?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAA@XZ ; std::allocator<bvh::Triangle<float,1,0> >::allocator<bvh::Triangle<float,1,0> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >
PUBLIC	?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ ; bvh::Triangle<float,1,0>::bounding_box
PUBLIC	?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ; bvh::Triangle<float,1,0>::center
PUBLIC	??A?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAAEAU?$BoundingBox@M@bvh@@_K@Z ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::operator[]
PUBLIC	??A?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAAEAU?$Vector@M$02@bvh@@_K@Z ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::operator[]
PUBLIC	??0?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAA@XZ	; std::allocator<bvh::Bvh<float>::Node>::allocator<bvh::Bvh<float>::Node>
PUBLIC	?_Orphan_range@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAXPEAUNode@?$Bvh@M@bvh@@0@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Orphan_range
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@00@Z ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >
PUBLIC	??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >
PUBLIC	??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >
PUBLIC	?back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::back
PUBLIC	?_Orphan_all@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Orphan_all
PUBLIC	?empty@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBA_NXZ ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::empty
PUBLIC	?top@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::top
PUBLIC	?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::push
PUBLIC	?pop@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXXZ ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::pop
PUBLIC	?__autoclassinit2@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAX_K@Z ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::__autoclassinit2
PUBLIC	??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::~stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAX_K@Z ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAX_K@Z ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::__autoclassinit2
PUBLIC	??$_Destroy_range@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAXPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z ; std::_Destroy_range<std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	??$_Destroy_range@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAXPEAUNode@?$Bvh@M@bvh@@QEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ; std::_Destroy_range<std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??$?RM$0A@@?$default_delete@$$BY0A@M@std@@QEBAXPEAM@Z ; std::default_delete<float [0]>::operator()<float,0>
PUBLIC	??$?RI$0A@@?$default_delete@$$BY0A@I@std@@QEBAXPEAI@Z ; std::default_delete<unsigned int [0]>::operator()<unsigned int,0>
PUBLIC	??$?RE$0A@@?$default_delete@$$BY0A@E@std@@QEBAXPEAE@Z ; std::default_delete<unsigned char [0]>::operator()<unsigned char,0>
PUBLIC	??$?R_K$0A@@?$default_delete@$$BY0A@_K@std@@QEBAXPEA_K@Z ; std::default_delete<unsigned __int64 [0]>::operator()<unsigned __int64,0>
PUBLIC	??$?RUNode@?$Bvh@M@bvh@@$0A@@?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@QEBAXPEAUNode@?$Bvh@M@bvh@@@Z ; std::default_delete<bvh::Bvh<float>::Node [0]>::operator()<bvh::Bvh<float>::Node,0>
PUBLIC	??0<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEAA@0AEBM@Z ; `bvh::operator*<float,3>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEBA@_K@Z ; `bvh::operator*<float,3>'::`2'::<lambda_1>::operator()
PUBLIC	??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z	; bvh::operator*<float,3>
PUBLIC	??0<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ; `bvh::operator+<float,3>'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??R<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ; `bvh::operator+<float,3>'::`2'::<lambda_1>::operator()
PUBLIC	??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z	; bvh::operator+<float,3>
PUBLIC	??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<int,int,unsigned __int64 &,int>
PUBLIC	??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<int,int,unsigned __int64 &,int>
PUBLIC	??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >
PUBLIC	??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>
PUBLIC	??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z ; bvh::RadixSort<10>::sort_in_parallel<unsigned int,unsigned __int64>
PUBLIC	??$make_key@M$0A@@?$RadixSort@$09@bvh@@SAIM@Z	; bvh::RadixSort<10>::make_key<float,0>
PUBLIC	??$swap@PEA_K$0A@@std@@YAXAEAPEA_K0@Z		; std::swap<unsigned __int64 *,0>
PUBLIC	??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z ; std::make_unique<unsigned char [0],0>
PUBLIC	??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z ; std::make_unique<unsigned int [0],0>
PUBLIC	??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z ; std::make_unique<float [0],0>
PUBLIC	??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z ; std::make_unique<bvh::Bvh<float>::Node [0],0>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1><>
PUBLIC	??$_Unfancy_maybe_null@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z ; std::_Unfancy_maybe_null<bvh::Triangle<float,1,0> >
PUBLIC	??$?RU?$BoundingBox@M@bvh@@$0A@@?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@QEBAXPEAU?$BoundingBox@M@bvh@@@Z ; std::default_delete<bvh::BoundingBox<float> [0]>::operator()<bvh::BoundingBox<float>,0>
PUBLIC	??$?RU?$Vector@M$02@bvh@@$0A@@?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@QEBAXPEAU?$Vector@M$02@bvh@@@Z ; std::default_delete<bvh::Vector<float,3> [0]>::operator()<bvh::Vector<float,3>,0>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><>
PUBLIC	??$?0V?$allocator@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@$$QEAPEAUNode@?$Bvh@M@bvh@@22@Z ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><std::allocator<bvh::Bvh<float>::Node>,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>
PUBLIC	??$exchange@PEAUNode@?$Bvh@M@bvh@@$$T@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@$$QEA$$T@Z ; std::exchange<bvh::Bvh<float>::Node *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z ; std::move<std::allocator<bvh::Bvh<float>::Node> &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize<std::_Value_init_tag>
PUBLIC	??$get@$00V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z ; std::get<1,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
PUBLIC	??$get@$0A@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z ; std::get<0,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
PUBLIC	??$<move>@AEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@@@YA$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@AEAU01@@Z ; <move><std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > > &>
PUBLIC	??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z ; bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>
PUBLIC	??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_one_at_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
PUBLIC	??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z ; bvh::compute_bounding_boxes_union<float>
PUBLIC	??$forward@U?$Vector@M$02@bvh@@@std@@YA$$QEAU?$Vector@M$02@bvh@@AEAU12@@Z ; std::forward<bvh::Vector<float,3> >
PUBLIC	??$?0M@?$Vector@M$02@bvh@@QEAA@MMM@Z		; bvh::Vector<float,3>::Vector<float,3><float>
PUBLIC	??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z ; std::make_unique<unsigned __int64 [0],0>
PUBLIC	??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator=<std::default_delete<unsigned __int64 [0]>,0>
PUBLIC	??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator=<std::default_delete<bvh::Bvh<float>::Node [0]>,0>
PUBLIC	??$as@IM@bvh@@YAIM@Z				; bvh::as<unsigned int,float>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first
PUBLIC	??A?$array@PEA_K$02@std@@QEBAAEBQEA_K_K@Z	; std::array<unsigned __int64 *,3>::operator[]
PUBLIC	?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z ; std::allocator<bvh::Triangle<float,1,0> >::deallocate
PUBLIC	?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal
PUBLIC	?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z ; std::allocator<bvh::Bvh<float>::Node>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAAAEAU?$default_delete@$$BY0A@M@2@XZ ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAAAEAU?$default_delete@$$BY0A@I@2@XZ ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAAAEAU?$default_delete@$$BY0A@E@2@XZ ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Get_first
PUBLIC	??A?$array@PEAM$02@std@@QEBAAEBQEAM_K@Z		; std::array<float *,3>::operator[]
PUBLIC	??0BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAA@AEAU123@@Z ; bvh::Bvh<float>::Node::BoundingBoxProxy::BoundingBoxProxy
PUBLIC	?get@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAPEA_KXZ ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::get
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAAAEAU?$default_delete@$$BY0A@_K@2@XZ ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@2@XZ ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Get_first
PUBLIC	??A?$array@PEA_K$02@std@@QEAAAEAPEA_K_K@Z	; std::array<unsigned __int64 *,3>::operator[]
PUBLIC	??A?$Vector@M$02@bvh@@QEBAM_K@Z			; bvh::Vector<float,3>::operator[]
PUBLIC	??0?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAV?$SweepSahBuilder@U?$Bvh@M@bvh@@@1@PEBU?$BoundingBox@M@1@PEBU?$Vector@M$02@1@AEBV?$array@PEA_K$02@std@@AEBV?$array@PEAM$02@6@PEAE@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::SweepSahBuildTask<bvh::Bvh<float> >
PUBLIC	?bounding_box_proxy@Node@?$Bvh@M@bvh@@QEAA?AUBoundingBoxProxy@123@XZ ; bvh::Bvh<float>::Node::bounding_box_proxy
PUBLIC	?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Tidy
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Get_first
PUBLIC	?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Tidy
PUBLIC	?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal
PUBLIC	??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ ; std::unique_ptr<float [0],std::default_delete<float [0]> >::~unique_ptr<float [0],std::default_delete<float [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEBAPEAMXZ ; std::unique_ptr<float [0],std::default_delete<float [0]> >::get
PUBLIC	??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::~unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEBAPEAIXZ ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::get
PUBLIC	??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::~unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEBAPEAEXZ ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::get
PUBLIC	??4BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAAAEAU0123@AEBU?$BoundingBox@M@3@@Z ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator=
PUBLIC	?__autoclassinit2@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAAX_K@Z ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAAX_K@Z ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAAX_K@Z ; std::unique_ptr<float [0],std::default_delete<float [0]> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAX_K@Z ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::__autoclassinit2
PUBLIC	??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::~unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >
PUBLIC	??A?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAAEA_K_K@Z ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator[]
PUBLIC	??1?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::~unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >
PUBLIC	??A?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBAAEAUNode@?$Bvh@M@bvh@@_K@Z ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator[]
PUBLIC	??1?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@IEAA@XZ ; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::~SahBasedAlgorithm<bvh::Bvh<float> >
PUBLIC	??0?$RadixSort@$09@bvh@@QEAA@XZ			; bvh::RadixSort<10>::RadixSort<10>
PUBLIC	??0?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ ; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::SahBasedAlgorithm<bvh::Bvh<float> >
PUBLIC	??0TopDownBuilder@bvh@@QEAA@XZ			; bvh::TopDownBuilder::TopDownBuilder
PUBLIC	??0?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAU?$Bvh@M@1@@Z ; bvh::SweepSahBuilder<bvh::Bvh<float> >::SweepSahBuilder<bvh::Bvh<float> >
PUBLIC	?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z ; bvh::SweepSahBuilder<bvh::Bvh<float> >::build
PUBLIC	?is_leaf@Node@?$Bvh@M@bvh@@QEBA_NXZ		; bvh::Bvh<float>::Node::is_leaf
PUBLIC	??0?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::~vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >
PUBLIC	?data@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::data
PUBLIC	?size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::size
PUBLIC	??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::~unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAPEAU?$BoundingBox@M@bvh@@XZ ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get
PUBLIC	??1?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@XZ ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::~unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >
PUBLIC	?get@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAPEAU?$Vector@M$02@bvh@@XZ ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get
PUBLIC	??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::~vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
PUBLIC	?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::resize
PUBLIC	??A?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAUNode@?$Bvh@M@bvh@@_K@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::operator[]
PUBLIC	?__autoclassinit2@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2
PUBLIC	?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ ; BVHBuilder::GetBVHNodes
PUBLIC	??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::~pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
PUBLIC	?__autoclassinit2@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2
PUBLIC	??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::emplace_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
PUBLIC	?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z	; BVHBuilder::BuildBVHForMesh
PUBLIC	?__autoclassinit2@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z ; bvh::SweepSahBuilder<bvh::Bvh<float> >::__autoclassinit2
PUBLIC	??1?$RadixSort@$09@bvh@@QEAA@XZ			; bvh::RadixSort<10>::~RadixSort<10>
PUBLIC	??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ ; bvh::SweepSahBuilder<bvh::Bvh<float> >::~SweepSahBuilder<bvh::Bvh<float> >
PUBLIC	??1?$Bvh@M@bvh@@QEAA@XZ				; bvh::Bvh<float>::~Bvh<float>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><>
PUBLIC	??$?0U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><std::default_delete<unsigned __int64 [0]>,0>
PUBLIC	??1TopDownBuilder@bvh@@IEAA@XZ			; bvh::TopDownBuilder::~TopDownBuilder
PUBLIC	?work_size@WorkItem@TopDownBuildTask@bvh@@QEBA_KXZ ; bvh::TopDownBuildTask::WorkItem::work_size
PUBLIC	??0WorkItem@TopDownBuildTask@bvh@@QEAA@_K000@Z	; bvh::TopDownBuildTask::WorkItem::WorkItem
PUBLIC	??0_Nontrivial_dummy_type@std@@QEAA@XZ		; std::_Nontrivial_dummy_type::_Nontrivial_dummy_type
PUBLIC	?assert_in_parallel@bvh@@YAXXZ			; bvh::assert_in_parallel
PUBLIC	?get_thread_id@bvh@@YA_KXZ			; bvh::get_thread_id
PUBLIC	?get_thread_count@bvh@@YA_KXZ			; bvh::get_thread_count
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A		; BVHBuilder::mBVH
?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A DB 018H DUP (?)	; BVHBuilder::mBVH
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z DD imagerel $LN45
	DD	imagerel $LN45+95
	DD	imagerel $unwind$??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z DD imagerel $LN21
	DD	imagerel $LN21+48
	DD	imagerel $unwind$??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD imagerel $LN28
	DD	imagerel $LN28+145
	DD	imagerel $unwind$??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD imagerel $LN151
	DD	imagerel $LN151+76
	DD	imagerel $unwind$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD imagerel $LN151+76
	DD	imagerel $LN151+175
	DD	imagerel $chain$1$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD imagerel $LN151+175
	DD	imagerel $LN151+251
	DD	imagerel $chain$3$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD imagerel $LN151+251
	DD	imagerel $LN151+326
	DD	imagerel $chain$5$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z DD imagerel $LN23
	DD	imagerel $LN23+122
	DD	imagerel $unwind$??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z DD imagerel $LN93
	DD	imagerel $LN93+354
	DD	imagerel $unwind$??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z DD imagerel $LN21
	DD	imagerel $LN21+48
	DD	imagerel $unwind$??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD imagerel $LN229
	DD	imagerel $LN229+207
	DD	imagerel $unwind$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD imagerel $LN229+207
	DD	imagerel $LN229+753
	DD	imagerel $chain$2$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD imagerel $LN229+753
	DD	imagerel $LN229+781
	DD	imagerel $chain$3$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z DD imagerel $LN35
	DD	imagerel $LN35+176
	DD	imagerel $unwind$??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z DD imagerel $LN95
	DD	imagerel $LN95+354
	DD	imagerel $unwind$??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0M@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0M@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z DD imagerel $LN25
	DD	imagerel $LN25+48
	DD	imagerel $unwind$??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+37
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DD imagerel $LN67
	DD	imagerel $LN67+361
	DD	imagerel $unwind$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN46
	DD	imagerel $LN46+140
	DD	imagerel $unwind$??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z DD imagerel $LN27
	DD	imagerel $LN27+82
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z DD imagerel $LN97
	DD	imagerel $LN97+347
	DD	imagerel $unwind$??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+112
	DD	imagerel $unwind$?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+174
	DD	imagerel $unwind$?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+108
	DD	imagerel $unwind$?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z DD imagerel $LN30
	DD	imagerel $LN30+142
	DD	imagerel $unwind$?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189
	DD	imagerel $LN189+74
	DD	imagerel $unwind$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189+74
	DD	imagerel $LN189+194
	DD	imagerel $chain$1$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189+194
	DD	imagerel $LN189+375
	DD	imagerel $chain$4$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189+375
	DD	imagerel $LN189+446
	DD	imagerel $chain$5$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189+446
	DD	imagerel $LN189+459
	DD	imagerel $chain$7$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD imagerel $LN189+459
	DD	imagerel $LN189+465
	DD	imagerel $chain$8$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD imagerel $LN27
	DD	imagerel $LN27+94
	DD	imagerel $unwind$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD imagerel $LN27+94
	DD	imagerel $LN27+137
	DD	imagerel $chain$0$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD imagerel $LN27+137
	DD	imagerel $LN27+164
	DD	imagerel $chain$1$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD imagerel $LN24
	DD	imagerel $LN24+66
	DD	imagerel $unwind$??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN46
	DD	imagerel $LN46+140
	DD	imagerel $unwind$??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD imagerel $LN26
	DD	imagerel $LN26+67
	DD	imagerel $unwind$??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD imagerel $LN26
	DD	imagerel $LN26+67
	DD	imagerel $unwind$??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DD imagerel $LN71
	DD	imagerel $LN71+361
	DD	imagerel $unwind$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN44
	DD	imagerel $LN44+39
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN69
	DD	imagerel $LN69+172
	DD	imagerel $unwind$??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN72
	DD	imagerel $LN72+172
	DD	imagerel $unwind$??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z DD imagerel $LN285
	DD	imagerel $LN285+854
	DD	imagerel $unwind$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z DD imagerel $LN48
	DD	imagerel $LN48+187
	DD	imagerel $unwind$??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+64
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN134
	DD	imagerel $LN134+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN134+33
	DD	imagerel $LN134+337
	DD	imagerel $chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN134+337
	DD	imagerel $LN134+344
	DD	imagerel $chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN134+344
	DD	imagerel $LN134+350
	DD	imagerel $chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN134+350
	DD	imagerel $LN134+356
	DD	imagerel $chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD imagerel $LN163
	DD	imagerel $LN163+118
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD imagerel $LN163+118
	DD	imagerel $LN163+496
	DD	imagerel $chain$2$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD imagerel $LN163+496
	DD	imagerel $LN163+503
	DD	imagerel $chain$4$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD imagerel $LN163+503
	DD	imagerel $LN163+509
	DD	imagerel $chain$5$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD imagerel $LN163+509
	DD	imagerel $LN163+515
	DD	imagerel $chain$6$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD imagerel $LN26
	DD	imagerel $LN26+65
	DD	imagerel $unwind$?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?half_area@?$BoundingBox@M@bvh@@QEBAMXZ DD imagerel $LN38
	DD	imagerel $LN38+67
	DD	imagerel $unwind$?half_area@?$BoundingBox@M@bvh@@QEBAMXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$Vector@M$02@bvh@@QEAA@M@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$??0?$Vector@M$02@bvh@@QEAA@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z DD imagerel $LN51
	DD	imagerel $LN51+120
	DD	imagerel $unwind$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ DD imagerel $LN38
	DD	imagerel $LN38+120
	DD	imagerel $unwind$?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z DD imagerel $LN240
	DD	imagerel $LN240+885
	DD	imagerel $unwind$?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD imagerel $LN26
	DD	imagerel $LN26+65
	DD	imagerel $unwind$?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD imagerel $LN26
	DD	imagerel $LN26+61
	DD	imagerel $unwind$?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN49
	DD	imagerel $LN49+140
	DD	imagerel $unwind$?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD imagerel $LN77
	DD	imagerel $LN77+43
	DD	imagerel $unwind$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD imagerel $LN77+43
	DD	imagerel $LN77+121
	DD	imagerel $chain$0$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD imagerel $LN77+121
	DD	imagerel $LN77+179
	DD	imagerel $chain$1$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z DD imagerel $LN51
	DD	imagerel $LN51+121
	DD	imagerel $unwind$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ DD imagerel $LN15
	DD	imagerel $LN15+137
	DD	imagerel $unwind$?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467
	DD	imagerel $LN467+109
	DD	imagerel $unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+109
	DD	imagerel $LN467+140
	DD	imagerel $chain$2$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+140
	DD	imagerel $LN467+469
	DD	imagerel $chain$3$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+469
	DD	imagerel $LN467+1542
	DD	imagerel $chain$4$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+1542
	DD	imagerel $LN467+1572
	DD	imagerel $chain$5$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+1572
	DD	imagerel $LN467+1590
	DD	imagerel $chain$6$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD imagerel $LN467+1590
	DD	imagerel $LN467+1607
	DD	imagerel $chain$7$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ DD imagerel $LN149
	DD	imagerel $LN149+303
	DD	imagerel $unwind$?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD imagerel $LN112
	DD	imagerel $LN112+219
	DD	imagerel $unwind$?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN53
	DD	imagerel $LN53+66
	DD	imagerel $unwind$??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN128
	DD	imagerel $LN128+52
	DD	imagerel $unwind$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN128+52
	DD	imagerel $LN128+137
	DD	imagerel $chain$0$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN128+137
	DD	imagerel $LN128+207
	DD	imagerel $chain$1$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD imagerel $LN52
	DD	imagerel $LN52+140
	DD	imagerel $unwind$?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z DD imagerel $LN22
	DD	imagerel $LN22+59
	DD	imagerel $unwind$??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD imagerel $LN24
	DD	imagerel $LN24+62
	DD	imagerel $unwind$??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z DD imagerel $LN71
	DD	imagerel $LN71+219
	DD	imagerel $unwind$??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z DD imagerel $LN74
	DD	imagerel $LN74+219
	DD	imagerel $unwind$??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ DD imagerel $LN57
	DD	imagerel $LN57+66
	DD	imagerel $unwind$??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z DD imagerel $LN287
	DD	imagerel $LN287+895
	DD	imagerel $unwind$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z DD imagerel $LN128
	DD	imagerel $LN128+595
	DD	imagerel $unwind$??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+72
	DD	imagerel $unwind$??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN10
	DD	imagerel $LN10+100
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z DD imagerel $LN335
	DD	imagerel $LN335+1135
	DD	imagerel $unwind$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z DD imagerel $LN7
	DD	imagerel $LN7+63
	DD	imagerel $unwind$??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z DD imagerel $LN75
	DD	imagerel $LN75+298
	DD	imagerel $unwind$??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+91
	DD	imagerel $unwind$??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN23
	DD	imagerel $LN23+49
	DD	imagerel $unwind$??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+67
	DD	imagerel $unwind$?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z DD imagerel $LN23
	DD	imagerel $LN23+66
	DD	imagerel $unwind$?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+114
	DD	imagerel $unwind$?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+92
	DD	imagerel $unwind$?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z DD imagerel $LN341
	DD	imagerel $LN341+1507
	DD	imagerel $unwind$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+114
	DD	imagerel $unwind$??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+92
	DD	imagerel $unwind$??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+100
	DD	imagerel $unwind$?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ DD imagerel $LN56
	DD	imagerel $LN56+157
	DD	imagerel $unwind$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA DD imagerel ?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+47
	DD	imagerel $unwind$??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z DD imagerel $LN9
	DD	imagerel $LN9+63
	DD	imagerel $unwind$??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z DD imagerel $LN169
	DD	imagerel $LN169+761
	DD	imagerel $unwind$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Bvh@M@bvh@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+47
	DD	imagerel $unwind$??1?$Bvh@M@bvh@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FmBVH@BVHBuilder@@YAXXZ DD imagerel ??__FmBVH@BVHBuilder@@YAXXZ
	DD	imagerel ??__FmBVH@BVHBuilder@@YAXXZ+47
	DD	imagerel $unwind$??__FmBVH@BVHBuilder@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FmBVH@BVHBuilder@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Bvh@M@bvh@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z DB 08H
	DB	0b9H, 04H
	DB	02H
	DB	0f2H
	DB	04H
	DB	09aH
	DB	06H
	DB	'Q', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ
	DB	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z DB 028H
	DD	imagerel $stateUnwindMap$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z
	DD	imagerel $ip2state$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z DD 0113a19H
	DD	0c882cH
	DD	0d7827H
	DD	0e6823H
	DD	023e41fH
	DD	022741fH
	DD	021641fH
	DD	020341fH
	DD	01e011fH
	DD	05014H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ DB 02H
	DB	080H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ DB 028H
	DD	imagerel $stateUnwindMap$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ
	DD	imagerel $ip2state$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ DD 040a11H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z DB 0eH
	DB	0e4H
	DB	00H
	DB	0e9H, 02H
	DB	02H
	DB	'l'
	DB	04H
	DB	'^'
	DB	06H
	DB	'@'
	DB	08H
	DB	081H, 0fH
	DB	06H
	DB	'X'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z DB 08H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ
	DB	01H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ
	DB	021H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ
	DB	061H
	DB	05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z
	DD	imagerel $ip2state$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z DD 0d3219H
	DD	0377424H
	DD	0366424H
	DD	0353424H
	DD	02e0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z
	DD	0162H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z DD 061e19H
	DD	010640fH
	DD	0f340fH
	DD	0700bb20fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z DB 06H
	DB	05H, 02H
	DB	00H
	DB	'V'
	DB	02H
	DB	0e9H, 0dH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ
	DB	0e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z
	DD	imagerel $ip2state$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z DD 01b5b19H
	DD	08d84dH
	DD	09c845H
	DD	0ab83dH
	DD	0ba835H
	DD	0c9830H
	DD	0d882bH
	DD	0e7826H
	DD	0f6822H
	DD	029641eH
	DD	027341eH
	DD	020011eH
	DD	0e011f013H
	DD	0700dc00fH
	DD	0500cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z DD 091101H
	DD	0f00da211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z DB 08H
	DB	0ccH
	DB	00H
	DB	'\'
	DB	02H
	DB	0b1H, 08H
	DB	00H
	DB	'x'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z DB 028H
	DD	imagerel $stateUnwindMap$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z
	DD	imagerel $ip2state$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z DD 0f3519H
	DD	0157827H
	DD	0166823H
	DD	037641fH
	DD	036341fH
	DD	02e011fH
	DD	0e011f013H
	DD	0700dc00fH
	DD	0500cH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z
	DD	0142H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN128
	DD	imagerel $LN128+52
	DD	imagerel $unwind$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD 020521H
	DD	077405H
	DD	imagerel $LN128
	DD	imagerel $LN128+52
	DD	imagerel $unwind$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD 052801H
	DD	028828H
	DD	03781dH
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ DD 0e6201H
	DD	02b862H
	DD	03a84cH
	DD	049842H
	DD	058839H
	DD	067831H
	DD	076828H
	DD	011010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 021H
	DD	imagerel $LN467
	DD	imagerel $LN467+109
	DD	imagerel $unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 060021H
	DD	022e400H
	DD	023c400H
	DD	02d6400H
	DD	imagerel $LN467
	DD	imagerel $LN467+109
	DD	imagerel $unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 021H
	DD	imagerel $LN467
	DD	imagerel $LN467+109
	DD	imagerel $unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 021H
	DD	imagerel $LN467+109
	DD	imagerel $LN467+140
	DD	imagerel $chain$2$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 020521H
	DD	0106805H
	DD	imagerel $LN467+109
	DD	imagerel $LN467+140
	DD	imagerel $chain$2$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 061c21H
	DD	022e41cH
	DD	023c40bH
	DD	02d6404H
	DD	imagerel $LN467
	DD	imagerel $LN467+109
	DD	imagerel $unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z DD 072319H
	DD	0240115H
	DD	0d008f00aH
	DD	030057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+43
	DD	imagerel $unwind$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD 020521H
	DD	073405H
	DD	imagerel $LN77
	DD	imagerel $LN77+43
	DD	imagerel $unwind$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z DD 0f3319H
	DD	097825H
	DD	0a6821H
	DD	021341dH
	DD	016011dH
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Vector@M$02@bvh@@QEAA@M@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?half_area@?$BoundingBox@M@bvh@@QEBAMXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD 060021H
	DD	087400H
	DD	095400H
	DD	0123400H
	DD	imagerel $LN163
	DD	imagerel $LN163+118
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD 021H
	DD	imagerel $LN163
	DD	imagerel $LN163+118
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD 060021H
	DD	087400H
	DD	095400H
	DD	0123400H
	DD	imagerel $LN163
	DD	imagerel $LN163+118
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD 062021H
	DD	087420H
	DD	095418H
	DD	0123408H
	DD	imagerel $LN163
	DD	imagerel $LN163+118
	DD	imagerel $unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z DD 060e01H
	DD	0f00a920eH
	DD	0d006e008H
	DD	06002c004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060021H
	DD	047400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN134
	DD	imagerel $LN134+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN134
	DD	imagerel $LN134+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 060021H
	DD	047400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN134
	DD	imagerel $LN134+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 063121H
	DD	047431H
	DD	0b540dH
	DD	0a3405H
	DD	imagerel $LN134
	DD	imagerel $LN134+33
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 030801H
	DD	0e0044208H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z DB 08H
	DB	0a6H
	DB	00H
	DB	'\'
	DB	02H
	DB	'u', 08H
	DB	00H
	DB	'Z'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z
	DD	imagerel $ip2state$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z DD 092619H
	DD	0323418H
	DD	02a0118H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z
	DD	0142H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 06H
	DB	'&'
	DB	00H
	DB	'%', 04H
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
	DD	imagerel $ip2state$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DD 092d19H
	DD	0215541bH
	DD	0214341bH
	DD	020e011bH
	DD	0700ce00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
	DD	01062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+94
	DD	imagerel $unwind$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD 020521H
	DD	047405H
	DD	imagerel $LN27
	DD	imagerel $LN27+94
	DD	imagerel $unwind$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$fill@PEAMM@std@@YAXQEAM0AEBM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN189
	DD	imagerel $LN189+74
	DD	imagerel $unwind$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 040021H
	DD	05e400H
	DD	06c400H
	DD	imagerel $LN189
	DD	imagerel $LN189+74
	DD	imagerel $unwind$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN189+74
	DD	imagerel $LN189+194
	DD	imagerel $chain$1$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 060f21H
	DD	04f40fH
	DD	0c740aH
	DD	0b3405H
	DD	imagerel $LN189+74
	DD	imagerel $LN189+194
	DD	imagerel $chain$1$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 041821H
	DD	05e418H
	DD	06c405H
	DD	imagerel $LN189
	DD	imagerel $LN189+74
	DD	imagerel $unwind$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z DD 030701H
	DD	060036207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z DD 076b01H
	DD	02886bH
	DD	037853H
	DD	046839H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 06H
	DB	'&'
	DB	00H
	DB	'%', 04H
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ
	DB	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
	DD	imagerel $ip2state$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z DD 092d19H
	DD	0215541bH
	DD	0214341bH
	DD	020e011bH
	DD	0700ce00eH
	DD	0600bH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
	DD	01062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0M@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z DD 076601H
	DD	028866H
	DD	037856H
	DD	04683cH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD 021H
	DD	imagerel $LN229
	DD	imagerel $LN229+207
	DD	imagerel $unwind$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD 062021H
	DD	010d420H
	DD	011c415H
	DD	01b5408H
	DD	imagerel $LN229
	DD	imagerel $LN229+207
	DD	imagerel $unwind$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z DD 071e19H
	DD	012010fH
	DD	0e006f008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z DD 076601H
	DD	028866H
	DD	037856H
	DD	04683cH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD 020021H
	DD	0d3400H
	DD	imagerel $LN151
	DD	imagerel $LN151+76
	DD	imagerel $unwind$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD 020021H
	DD	0d3400H
	DD	imagerel $LN151
	DD	imagerel $LN151+76
	DD	imagerel $unwind$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD 041421H
	DD	047414H
	DD	0d3405H
	DD	imagerel $LN151
	DD	imagerel $LN151+76
	DD	imagerel $unwind$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z DD 052701H
	DD	027827H
	DD	036815H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z DD 040801H
	DD	070043208H
	DD	030026003H
?mBVH$initializer$@BVHBuilder@@3P6AXXZEA DQ FLAT:??__FmBVH@BVHBuilder@@YAXXZ ; BVHBuilder::mBVH$initializer$
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Mycont_$ = 16
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1186 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx

; 1187 : 
; 1188 :     const _Container_base12* _Mycont       = nullptr;
; 1189 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	QWORD PTR [rcx+8], 0
	ret	0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1195 : 
; 1196 :     _Container_base12(const _Container_base12&)            = delete;
; 1197 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1198 : 
; 1199 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1200 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1201 : 
; 1202 :     template <class _Alloc>
; 1203 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1204 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1205 :         _Construct_in_place(*_New_proxy, this);
; 1206 :         _Myproxy            = _New_proxy;
; 1207 :         _New_proxy->_Mycont = this;
; 1208 :     }
; 1209 : 
; 1210 :     template <class _Alloc>
; 1211 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1212 :         // pre: no iterators refer to the existing proxy
; 1213 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1214 :         _Construct_in_place(*_New_proxy, this);
; 1215 :         _New_proxy->_Mycont = this;
; 1216 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1217 :     }
; 1218 : 
; 1219 :     _Container_proxy* _Myproxy = nullptr;

	mov	QWORD PTR [rcx], 0
	mov	rax, rcx
	ret	0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1377 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1378 : #if _HAS_CXX20
; 1379 :     if (_STD is_constant_evaluated()) {
; 1380 :         _Orphan_all_unlocked_v3();
; 1381 :     } else
; 1382 : #endif // _HAS_CXX20
; 1383 :     {
; 1384 :         _Orphan_all_locked_v3();
; 1385 :     }
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : }

	ret	0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\platform.hpp
;	COMDAT ?get_thread_count@bvh@@YA_KXZ
_TEXT	SEGMENT
?get_thread_count@bvh@@YA_KXZ PROC			; bvh::get_thread_count, COMDAT

; 38   : inline constexpr size_t get_thread_count() { return 1; }

	mov	eax, 1
	ret	0
?get_thread_count@bvh@@YA_KXZ ENDP			; bvh::get_thread_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\platform.hpp
;	COMDAT ?get_thread_id@bvh@@YA_KXZ
_TEXT	SEGMENT
?get_thread_id@bvh@@YA_KXZ PROC				; bvh::get_thread_id, COMDAT

; 39   : inline constexpr size_t get_thread_id()    { return 0; }

	xor	eax, eax
	ret	0
?get_thread_id@bvh@@YA_KXZ ENDP				; bvh::get_thread_id
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\platform.hpp
;	COMDAT ?assert_in_parallel@bvh@@YAXXZ
_TEXT	SEGMENT
?assert_in_parallel@bvh@@YAXXZ PROC			; bvh::assert_in_parallel, COMDAT

; 41   : inline void assert_in_parallel() {}

	ret	0
?assert_in_parallel@bvh@@YAXXZ ENDP			; bvh::assert_in_parallel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??0_Nontrivial_dummy_type@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Nontrivial_dummy_type@std@@QEAA@XZ PROC		; std::_Nontrivial_dummy_type::_Nontrivial_dummy_type, COMDAT

; 59   :         // This default constructor is user-provided to avoid zero-initialization when objects are value-initialized.
; 60   :     }

	mov	rax, rcx
	ret	0
??0_Nontrivial_dummy_type@std@@QEAA@XZ ENDP		; std::_Nontrivial_dummy_type::_Nontrivial_dummy_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
;	COMDAT ??0WorkItem@TopDownBuildTask@bvh@@QEAA@_K000@Z
_TEXT	SEGMENT
this$ = 8
node_index$ = 16
begin$ = 24
end$ = 32
depth$ = 40
??0WorkItem@TopDownBuildTask@bvh@@QEAA@_K000@Z PROC	; bvh::TopDownBuildTask::WorkItem::WorkItem, COMDAT

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	rax, QWORD PTR depth$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 21   :         {}

	mov	rax, rcx
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0WorkItem@TopDownBuildTask@bvh@@QEAA@_K000@Z ENDP	; bvh::TopDownBuildTask::WorkItem::WorkItem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
;	COMDAT ?work_size@WorkItem@TopDownBuildTask@bvh@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?work_size@WorkItem@TopDownBuildTask@bvh@@QEBA_KXZ PROC	; bvh::TopDownBuildTask::WorkItem::work_size, COMDAT

; 23   :         size_t work_size() const { return end - begin; }

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	ret	0
?work_size@WorkItem@TopDownBuildTask@bvh@@QEBA_KXZ ENDP	; bvh::TopDownBuildTask::WorkItem::work_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
;	COMDAT ??1TopDownBuilder@bvh@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1TopDownBuilder@bvh@@IEAA@XZ PROC			; bvh::TopDownBuilder::~TopDownBuilder, COMDAT

; 44   :     ~TopDownBuilder() {}

	ret	0
??1TopDownBuilder@bvh@@IEAA@XZ ENDP			; bvh::TopDownBuilder::~TopDownBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><std::default_delete<unsigned __int64 [0]>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3347 :     constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><std::default_delete<unsigned __int64 [0]>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], 0
	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ??__FmBVH@BVHBuilder@@YAXXZ
text$di	SEGMENT
??__FmBVH@BVHBuilder@@YAXXZ PROC			; BVHBuilder::`dynamic atexit destructor for 'mBVH'', COMDAT

; 11   : Bvh BVHBuilder::mBVH;

	lea	rcx, OFFSET FLAT:??__FmBVH@BVHBuilder@@YAXXZ ; BVHBuilder::`dynamic atexit destructor for 'mBVH''
	jmp	atexit
??__FmBVH@BVHBuilder@@YAXXZ ENDP			; BVHBuilder::`dynamic atexit destructor for 'mBVH''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??__FmBVH@BVHBuilder@@YAXXZ
text$yd	SEGMENT
??__FmBVH@BVHBuilder@@YAXXZ PROC			; BVHBuilder::`dynamic atexit destructor for 'mBVH'', COMDAT
	sub	rsp, 40					; 00000028H

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+8
	test	rcx, rcx
	je	SHORT $LN11@dynamic

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN11@dynamic:

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A
	test	rcx, rcx
	je	SHORT $LN18@dynamic
	add	rsp, 40					; 00000028H

; 3194 :         delete[] _Ptr;

	jmp	??_V@YAXPEAX@Z				; operator delete[]
$LN18@dynamic:
	add	rsp, 40					; 00000028H
	ret	0
??__FmBVH@BVHBuilder@@YAXXZ ENDP			; BVHBuilder::`dynamic atexit destructor for 'mBVH''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$Bvh@M@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$Bvh@M@bvh@@QEAA@XZ PROC				; bvh::Bvh<float>::~Bvh<float>, COMDAT
$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Bvh

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN8@Bvh:

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN15@Bvh
	add	rsp, 32					; 00000020H
	pop	rbx

; 3194 :         delete[] _Ptr;

	jmp	??_V@YAXPEAX@Z				; operator delete[]
$LN15@Bvh:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$Bvh@M@bvh@@QEAA@XZ ENDP				; bvh::Bvh<float>::~Bvh<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ PROC	; bvh::SweepSahBuilder<bvh::Bvh<float> >::~SweepSahBuilder<bvh::Bvh<float> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+32]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]
	ret	0
??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ ENDP	; bvh::SweepSahBuilder<bvh::Bvh<float> >::~SweepSahBuilder<bvh::Bvh<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$RadixSort@$09@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$RadixSort@$09@bvh@@QEAA@XZ PROC			; bvh::RadixSort<10>::~RadixSort<10>, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]
	ret	0
??1?$RadixSort@$09@bvh@@QEAA@XZ ENDP			; bvh::RadixSort<10>::~RadixSort<10>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z PROC ; bvh::SweepSahBuilder<bvh::Bvh<float> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	mov	QWORD PTR [rcx+48], rax
	ret	0
?__autoclassinit2@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z ENDP ; bvh::SweepSahBuilder<bvh::Bvh<float> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z
_TEXT	SEGMENT
$T1 = 48
triangles$ = 64
$S1$ = 88
$T2 = 88
globalBBox$ = 104
$T3 = 104
builder$ = 128
__$ArrayPad$ = 184
verts$ = 256
indices$ = 264
icount$ = 272
?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z PROC	; BVHBuilder::BuildBVHForMesh, COMDAT

; 48   : {

$LN169:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r14
	push	rbp
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 240				; 000000f0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-153], rax
	mov	rbx, rdx
	mov	rsi, rcx
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR triangles$[rbp-153], xmm1
	xor	edi, edi
	mov	r9d, edi
	mov	QWORD PTR triangles$[rbp-137], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 51   :     for (int i = 0; i < icount / 3; i++) {

	mov	eax, 1431655766				; 55555556H
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	movsxd	r14, edx
	mov	r10, QWORD PTR triangles$[rbp-145]
	test	edx, edx
	jle	$LN3@BuildBVHFo
	add	rbx, 8
	npad	13
$LL4@BuildBVHFo:

; 52   :         int i1 = (int)indices[i * 3];

	mov	eax, DWORD PTR [rbx-8]

; 53   :         int i2 = (int)indices[i * 3 + 1];

	mov	edx, DWORD PTR [rbx-4]

; 54   :         int i3 = (int)indices[i * 3 + 2];

	mov	r8d, DWORD PTR [rbx]

; 55   :         float v1x = verts[i1 * 3];

	lea	eax, DWORD PTR [rax+rax*2]
	movsxd	rcx, eax
	movss	xmm6, DWORD PTR [rsi+rcx*4]

; 56   :         float v1y = verts[i1 * 3 + 1];

	movss	xmm7, DWORD PTR [rsi+rcx*4+4]

; 57   :         float v1z = verts[i1 * 3 + 2];

	movss	xmm8, DWORD PTR [rsi+rcx*4+8]

; 58   :         float v2x = verts[i2 * 3];

	lea	eax, DWORD PTR [rdx+rdx*2]
	movsxd	rcx, eax
	movss	xmm3, DWORD PTR [rsi+rcx*4]

; 59   :         float v2y = verts[i2 * 3 + 1];

	movss	xmm4, DWORD PTR [rsi+rcx*4+4]

; 60   :         float v2z = verts[i2 * 3 + 2];

	movss	xmm5, DWORD PTR [rsi+rcx*4+8]

; 61   :         float v3x = verts[i3 * 3];

	lea	eax, DWORD PTR [r8+r8*2]
	movsxd	rcx, eax
	movss	xmm0, DWORD PTR [rsi+rcx*4]

; 62   :         float v3y = verts[i3 * 3 + 1];

	movss	xmm1, DWORD PTR [rsi+rcx*4+4]

; 63   :         float v3z = verts[i3 * 3 + 2];

	movss	xmm2, DWORD PTR [rsi+rcx*4+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	DWORD PTR $T1[rbp-153], xmm0
	movss	DWORD PTR $T1[rbp-149], xmm1

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR $T1[rbp-145], xmm2

; 22   :         v[I] = s;

	movss	DWORD PTR $T3[rbp-153], xmm3
	movss	DWORD PTR $T3[rbp-149], xmm4

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR $T3[rbp-145], xmm5

; 22   :         v[I] = s;

	movss	DWORD PTR $T2[rbp-153], xmm6
	movss	DWORD PTR $T2[rbp-149], xmm7

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR $T2[rbp-145], xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	lea	rax, QWORD PTR $T1[rbp-153]
	lea	r8, QWORD PTR $T2[rbp-153]
	mov	rdx, r10
	mov	QWORD PTR [rsp+32], rax
	cmp	r10, r9
	lea	r9, QWORD PTR $T3[rbp-153]
	je	SHORT $LN119@BuildBVHFo

; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	call	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	mov	r10, QWORD PTR triangles$[rbp-145]
	add	r10, 48					; 00000030H
	mov	QWORD PTR triangles$[rbp-145], r10

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@BuildBVHFo
$LN119@BuildBVHFo:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	rcx, QWORD PTR triangles$[rbp-153]
	call	??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
	mov	r10, QWORD PTR triangles$[rbp-145]
$LN2@BuildBVHFo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 51   :     for (int i = 0; i < icount / 3; i++) {

	add	rbx, 12
	sub	r14, 1
	je	SHORT $LN3@BuildBVHFo
	mov	r9, QWORD PTR triangles$[rbp-137]
	jmp	$LL4@BuildBVHFo
$LN3@BuildBVHFo:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR builder$[rbp-153], xmm0
	movups	XMMWORD PTR builder$[rbp-137], xmm0
	mov	QWORD PTR builder$[rbp-153], 1024	; 00000400H
	mov	QWORD PTR builder$[rbp-145], 64		; 00000040H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 41   :     {}

	mov	DWORD PTR builder$[rbp-129], 1065353216	; 3f800000H
	xorps	xmm1, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	movdqu	XMMWORD PTR builder$[rbp-121], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 40   :         : bvh(bvh)

	lea	rax, OFFSET FLAT:?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A ; BVHBuilder::mBVH
	mov	QWORD PTR builder$[rbp-105], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 73   :     builder.max_leaf_size = 1;

	mov	QWORD PTR builder$[rbp-137], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR triangles$[rbp-153]
	sub	r10, rdx
	sar	r10, 4
	mov	r14, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	r10, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 74   :     auto [bboxes, centers] = bvh::compute_bounding_boxes_and_centers(triangles.data(), triangles.size());

	mov	r8, r10
	lea	rcx, QWORD PTR $S1$[rbp-153]
	call	??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z ; bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r8, QWORD PTR triangles$[rbp-145]
	sub	r8, QWORD PTR triangles$[rbp-153]
	sar	r8, 4
	imul	r8, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 75   :     auto globalBBox = bvh::compute_bounding_boxes_union(bboxes.get(), triangles.size());

	mov	rbx, QWORD PTR $S1$[rbp-153]
	mov	rdx, rbx
	lea	rcx, QWORD PTR globalBBox$[rbp-153]
	call	??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z ; bvh::compute_bounding_boxes_union<float>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR triangles$[rbp-145]
	sub	rax, QWORD PTR triangles$[rbp-153]
	sar	rax, 4
	imul	rax, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 76   :     builder.build(globalBBox, bboxes.get(), centers.get(), triangles.size());

	mov	QWORD PTR [rsp+32], rax
	mov	rsi, QWORD PTR $S1$[rbp-145]
	mov	r9, rsi
	mov	r8, rbx
	lea	rdx, QWORD PTR globalBBox$[rbp-153]
	lea	rcx, QWORD PTR builder$[rbp-153]
	call	?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z ; bvh::SweepSahBuilder<bvh::Bvh<float> >::build

; 77   : 
; 78   :     for (int i = 0; i < mBVH.node_count; i++) {

	mov	rcx, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+16
	test	rcx, rcx
	je	SHORT $LN6@BuildBVHFo
	mov	rdx, rdi
	npad	8
$LL7@BuildBVHFo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	r8, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 30   :         bool is_leaf() const { return primitive_count != 0; }

	cmp	DWORD PTR [rdx+r8+24], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 79   :         if (mBVH.nodes[i].is_leaf()) {

	je	SHORT $LN5@BuildBVHFo

; 80   :             mBVH.nodes[i].first_child_or_primitive = mBVH.primitive_indices[mBVH.nodes[i].first_child_or_primitive];

	mov	ecx, DWORD PTR [rdx+r8+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 80   :             mBVH.nodes[i].first_child_or_primitive = mBVH.primitive_indices[mBVH.nodes[i].first_child_or_primitive];

	mov	eax, DWORD PTR [rax+rcx*8]
	mov	DWORD PTR [rdx+r8+28], eax
	mov	rcx, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+16
$LN5@BuildBVHFo:

; 77   : 
; 78   :     for (int i = 0; i < mBVH.node_count; i++) {

	inc	edi
	add	rdx, 32					; 00000020H
	movsxd	rax, edi
	cmp	rax, rcx
	jb	SHORT $LL7@BuildBVHFo
$LN6@BuildBVHFo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3428 :         if (_Mypair._Myval2) {

	test	rsi, rsi
	je	SHORT $LN25@BuildBVHFo

; 3194 :         delete[] _Ptr;

	mov	rcx, rsi
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN25@BuildBVHFo:

; 3428 :         if (_Mypair._Myval2) {

	test	rbx, rbx
	je	SHORT $LN32@BuildBVHFo

; 3194 :         delete[] _Ptr;

	mov	rcx, rbx
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
$LN32@BuildBVHFo:

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR builder$[rbp-121]
	test	rcx, rcx
	je	SHORT $LN45@BuildBVHFo

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
$LN45@BuildBVHFo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR triangles$[rbp-153]
	test	rcx, rcx
	je	SHORT $LN56@BuildBVHFo

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR triangles$[rbp-137]
	sub	rax, rcx
	sar	rax, 4
	imul	rax, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN68@BuildBVHFo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN68@BuildBVHFo
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN68@BuildBVHFo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN56@BuildBVHFo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 84   :     return true;

	mov	al, 1

; 85   : 
; 86   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-153]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	r14, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN166@BuildBVHFo:
?BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z ENDP	; BVHBuilder::BuildBVHForMesh
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
triangles$ = 64
$S1$ = 88
$T2 = 88
globalBBox$ = 104
$T3 = 104
builder$ = 128
__$ArrayPad$ = 184
verts$ = 256
indices$ = 264
icount$ = 272
?dtor$0@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA PROC ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$0
	lea	rcx, QWORD PTR triangles$[rdx]
	jmp	??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::~vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >
?dtor$0@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA ENDP ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
triangles$ = 64
$S1$ = 88
$T2 = 88
globalBBox$ = 104
$T3 = 104
builder$ = 128
__$ArrayPad$ = 184
verts$ = 256
indices$ = 264
icount$ = 272
?dtor$1@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA PROC ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$1
	lea	rcx, QWORD PTR builder$[rdx]
	jmp	??1?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ
?dtor$1@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA ENDP ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
triangles$ = 64
$S1$ = 88
$T2 = 88
globalBBox$ = 104
$T3 = 104
builder$ = 128
__$ArrayPad$ = 184
verts$ = 256
indices$ = 264
icount$ = 272
?dtor$2@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA PROC ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$2
	lea	rcx, QWORD PTR $S1$[rdx]
	jmp	??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ
?dtor$2@?0??BuildBVHForMesh@BVHBuilder@@YA_NPEBMPEBIH@Z@4HA ENDP ; `BVHBuilder::BuildBVHForMesh'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z
_TEXT	SEGMENT
this$ = 64
<_Val_0>$ = 72
<_Val_1>$ = 80
<_Val_2>$ = 88
??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::emplace_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >, COMDAT

; 862  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

$LN9:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	QWORD PTR [rsp+32], r9
	mov	rdx, QWORD PTR [rcx+8]
	mov	r9, r8

; 862  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	r10, rcx

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	r8, rax
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@emplace_ba

; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	call	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r10+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [r10+8], rcx

; 863  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 864  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);
; 865  : #if _HAS_CXX17
; 866  :         return _Result;
; 867  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 868  :         (void) _Result;
; 869  : #endif // _HAS_CXX17
; 870  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN4@emplace_ba:

; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 863  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 864  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);
; 865  : #if _HAS_CXX17
; 866  :         return _Result;
; 867  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 868  :         (void) _Result;
; 869  : #endif // _HAS_CXX17
; 870  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$emplace_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA?A_T$$QEAU?$Vector@M$02@bvh@@00@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::emplace_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ PROC ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::~pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >, COMDAT
$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@pair

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN8@pair:

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN15@pair
	add	rsp, 32					; 00000020H
	pop	rbx

; 3194 :         delete[] _Ptr;

	jmp	??_V@YAXPEAX@Z				; operator delete[]
$LN15@pair:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@XZ ENDP ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::~pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ
_TEXT	SEGMENT
$T2 = 32
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ PROC ; BVHBuilder::GetBVHNodes, COMDAT

; 99   : {

$LN56:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	edi, edi
	mov	DWORD PTR $T2[rsp], edi
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 106  :     return Result;

	mov	DWORD PTR $T2[rsp], 1

; 100  :     std::vector<Bvh::Node> Result;
; 101  :     Result.resize(mBVH.node_count);

	mov	rax, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1567 :         if (_Newsize > _Oldsize) { // append

	test	rax, rax
	je	SHORT $LN52@GetBVHNode

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rdx, rax
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>
	mov	rax, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+16
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

; 102  :     for (int i = 0; i < mBVH.node_count; i++)

	test	rax, rax
	je	SHORT $LN52@GetBVHNode
	mov	edx, edi
	npad	13
$LL4@GetBVHNode:

; 103  :     {
; 104  :         Result[i] = mBVH.nodes[i];

	mov	rax, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A
	movups	xmm0, XMMWORD PTR [rdx+rax]
	movups	xmm1, XMMWORD PTR [rdx+rax+16]
	mov	rcx, QWORD PTR [rbx]
	movups	XMMWORD PTR [rcx+rdx], xmm0
	movups	XMMWORD PTR [rcx+rdx+16], xmm1

; 102  :     for (int i = 0; i < mBVH.node_count; i++)

	inc	edi
	lea	rdx, QWORD PTR [rdx+32]
	movsxd	rcx, edi
	cmp	rcx, QWORD PTR ?mBVH@BVHBuilder@@3U?$Bvh@M@bvh@@A+16
	jb	SHORT $LL4@GetBVHNode
$LN52@GetBVHNode:

; 107  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
	int	3
?GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ ENDP ; BVHBuilder::GetBVHNodes
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA PROC ; `BVHBuilder::GetBVHNodes'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T2[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@dtor$0
	and	DWORD PTR $T2[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::~vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
$LN7@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??GetBVHNodes@BVHBuilder@@YA?AV?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@XZ@4HA ENDP ; `BVHBuilder::GetBVHNodes'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??A?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAUNode@?$Bvh@M@bvh@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAUNode@?$Bvh@M@bvh@@_K@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::operator[], COMDAT

; 1883 :         auto& _My_data = _Mypair._Myval2;
; 1884 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1885 :         _STL_VERIFY(
; 1886 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1887 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1888 : 
; 1889 :         return _My_data._Myfirst[_Pos];

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1890 :     }

	ret	0
??A?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAUNode@?$Bvh@M@bvh@@_K@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::resize, COMDAT

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]

; 1590 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rbx, rcx

; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 5

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN4@resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdx, 5
	add	rdx, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbx+8], rdx

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@resize:

; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN5@resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, r8
	sar	rax, 5

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN6@resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rbx

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<bvh::Bvh<float>::Node> >
	mov	QWORD PTR [rbx+8], rax
$LN5@resize:

; 1591 :         // trim or append value-initialized elements, provide strong guarantee
; 1592 :         _Resize(_Newsize, _Value_init_tag{});
; 1593 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?resize@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::~vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::~vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 701  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 702  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 703  :     }

	ret	0
??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAPEAU?$Vector@M$02@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAPEAU?$Vector@M$02@bvh@@XZ PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAPEAU?$Vector@M$02@bvh@@XZ ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::~unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::~unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAPEAU?$BoundingBox@M@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAPEAU?$BoundingBox@M@bvh@@XZ PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAPEAU?$BoundingBox@M@bvh@@XZ ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::~unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::~unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::size, COMDAT

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 4
	imul	rax, rcx

; 1870 :     }

	ret	0
?size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?data@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::data, COMDAT

; 1787 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

	mov	rax, QWORD PTR [rcx]

; 1788 :     }

	ret	0
?data@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::~vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 766  :     _CONSTEXPR20 ~vector() noexcept {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 772  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@vector:
??1?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::~vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 611  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 612  :     }

	mov	rax, rcx
	ret	0
??0?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ?is_leaf@Node@?$Bvh@M@bvh@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?is_leaf@Node@?$Bvh@M@bvh@@QEBA_NXZ PROC		; bvh::Bvh<float>::Node::is_leaf, COMDAT

; 30   :         bool is_leaf() const { return primitive_count != 0; }

	cmp	DWORD PTR [rcx+24], 0
	setne	al
	ret	0
?is_leaf@Node@?$Bvh@M@bvh@@QEBA_NXZ ENDP		; bvh::Bvh<float>::Node::is_leaf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z
_TEXT	SEGMENT
tv2513 = 48
$T1 = 48
$T2 = 56
$T3 = 56
axis$1$ = 64
$T4 = 64
unsorted_references$1$ = 72
unsorted_keys$1$ = 80
tv2488 = 88
tv2490 = 96
tv2493 = 104
this$GSCopy$1$ = 112
centers$1$ = 120
$T5 = 128
$T6 = 136
bboxes$1$ = 144
$T7 = 152
costs$$sroa$164$1$ = 160
costs$$sroa$163$1$ = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
primitive_count$GSCopy$ = 208
sorted_references$ = 216
first_task$12 = 240
reference_data$ = 320
cost_data$ = 328
key_data$ = 336
mark_data$ = 344
__$ArrayPad$ = 352
this$ = 416
global_bbox$ = 424
bboxes$ = 432
centers$ = 440
primitive_count$ = 448
?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z PROC ; bvh::SweepSahBuilder<bvh::Bvh<float> >::build, COMDAT

; 48   :     {

$LN341:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-112]
	sub	rsp, 368				; 00000170H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	QWORD PTR centers$1$[rsp], r9
	mov	QWORD PTR bboxes$1$[rbp-256], r8
	mov	r14, rdx
	mov	r13, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	mov	r15, QWORD PTR primitive_count$[rbp-256]
	mov	QWORD PTR primitive_count$GSCopy$[rbp-256], r15
	lea	rsi, QWORD PTR [r15+r15]

; 52   :         bvh.nodes = std::make_unique<typename Bvh::Node[]>(2 * primitive_count + 1);

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 32					; 00000020H
	mul	rcx
	mov	rbx, rax
	mov	r12, -1
	cmovo	rbx, r12
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdi, rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 52   :         bvh.nodes = std::make_unique<typename Bvh::Node[]>(2 * primitive_count + 1);

	mov	rax, QWORD PTR [r13+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3381 :         if (this != _STD addressof(_Right)) {

	lea	rcx, QWORD PTR $T9[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN209@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rax]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rcx, rcx
	je	SHORT $LN216@build

; 3428 :         if (_Mypair._Myval2) {

	jmp	SHORT $LN336@build
$LN209@build:

; 3194 :         delete[] _Ptr;

	mov	rcx, rdi
$LN336@build:

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN216@build:
	mov	eax, 8
	mul	r15
	mov	rbx, rax
	cmovo	rbx, r12
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdi, rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 53   :         bvh.primitive_indices = std::make_unique<size_t[]>(primitive_count);

	mov	rcx, QWORD PTR [r13+48]
	add	rcx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3381 :         if (this != _STD addressof(_Right)) {

	lea	rax, QWORD PTR $T10[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN246@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rax, rax
	je	SHORT $LN169@build

; 3194 :         delete[] _Ptr;

	mov	rcx, rax

; 3428 :         if (_Mypair._Myval2) {

	jmp	SHORT $LN337@build
$LN246@build:

; 3194 :         delete[] _Ptr;

	mov	rcx, rdi
$LN337@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 55   :         auto reference_data = std::make_unique<size_t[]>(primitive_count * 3);

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN169@build:
	lea	rdi, QWORD PTR [r15+r15*2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 8
	mul	rdi
	mov	rbx, rax
	cmovo	rbx, r12
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r12, rax
	mov	QWORD PTR $T6[rbp-256], rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR reference_data$[rbp-256], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 4
	mul	rdi
	mov	rbx, rax
	mov	r12, -1
	cmovo	rbx, r12
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdi, rax
	mov	QWORD PTR $T7[rbp-256], rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR cost_data$[rbp-256], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 4
	mul	rsi
	mov	rbx, rax
	cmovo	rbx, r12
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rsi, rax
	mov	QWORD PTR $T5[rbp-256], rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR key_data$[rbp-256], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rcx, r15
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rbx, rax
	mov	QWORD PTR $T8[rbp-256], rax
	mov	r8, r15
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR mark_data$[rbp-256], rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 62   :             cost_data.get() + primitive_count,

	lea	rax, QWORD PTR [rdi+r15*4]
	mov	QWORD PTR costs$$sroa$164$1$[rbp-256], rax
	lea	rax, QWORD PTR [r15*8]

; 63   :             cost_data.get() + 2 * primitive_count

	add	rax, rdi
	mov	QWORD PTR costs$$sroa$163$1$[rbp-256], rax

; 64   :         };
; 65   : 
; 66   :         std::array<size_t*, 3> sorted_references;
; 67   :         size_t* unsorted_references = bvh.primitive_indices.get();

	mov	rcx, QWORD PTR [r13+48]
	mov	r12, QWORD PTR [rcx+8]

; 68   :         Key* sorted_keys = key_data.get();
; 69   :         Key* unsorted_keys = key_data.get() + primitive_count;

	mov	rax, rsi
	lea	rax, QWORD PTR [rax+r15*4]
	mov	QWORD PTR unsorted_keys$1$[rsp], rax

; 70   : 
; 71   :         bvh.node_count = 1;

	mov	QWORD PTR [rcx+16], 1

; 72   :         bvh.nodes[0].bounding_box_proxy() = global_bbox;

	mov	rax, QWORD PTR [r13+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 38   :                 : node(node)

	mov	rax, QWORD PTR [rax]

; 42   :                 node.bounds[0] = bbox.min[0];

	mov	ecx, DWORD PTR [r14]
	mov	DWORD PTR [rax], ecx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm0, DWORD PTR [r14+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 43   :                 node.bounds[1] = bbox.max[0];

	movss	DWORD PTR [rax+4], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm1, DWORD PTR [r14+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 44   :                 node.bounds[2] = bbox.min[1];

	movss	DWORD PTR [rax+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm0, DWORD PTR [r14+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 45   :                 node.bounds[3] = bbox.max[1];

	movss	DWORD PTR [rax+12], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm1, DWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 46   :                 node.bounds[4] = bbox.min[2];

	movss	DWORD PTR [rax+16], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm0, DWORD PTR [r14+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 47   :                 node.bounds[5] = bbox.max[2];

	movss	DWORD PTR [rax+20], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 77   :             for (int axis = 0; axis < 3; ++axis) {

	xor	eax, eax
	mov	DWORD PTR axis$1$[rsp], eax
	lea	rdi, QWORD PTR [r13+32]
	xor	r10d, r10d
	mov	DWORD PTR tv2513[rsp], r10d

; 55   :         auto reference_data = std::make_unique<size_t[]>(primitive_count * 3);

	lea	r14, QWORD PTR sorted_references$[rbp-256]
	mov	QWORD PTR tv2493[rsp], r14
	mov	r11, QWORD PTR centers$1$[rsp]
	mov	QWORD PTR tv2490[rsp], r11
	mov	r9, QWORD PTR $T6[rbp-256]
	mov	QWORD PTR tv2488[rsp], r9
	npad	11
$LL4@build:

; 78   :                 #pragma omp single
; 79   :                 {
; 80   :                     sorted_references[axis] = unsorted_references;

	mov	rcx, r12
	mov	QWORD PTR [r14], r12

; 81   :                     unsorted_references = reference_data.get() + axis * primitive_count;

	mov	QWORD PTR unsorted_references$1$[rsp], r9
	mov	rdx, r12
	mov	QWORD PTR $T2[rsp], rcx

; 83   :                     if (axis != 0 && sorted_references[axis] == bvh.primitive_indices.get())

	test	eax, eax
	je	SHORT $LN161@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [r13+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 83   :                     if (axis != 0 && sorted_references[axis] == bvh.primitive_indices.get())

	mov	QWORD PTR $T2[rsp], rcx
	cmp	r12, QWORD PTR [rax+8]
	jne	SHORT $LN161@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	QWORD PTR unsorted_references$1$[rsp], rcx

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR [r14], r9

; 101  :     _Right   = _STD move(_Tmp);

	mov	rdx, r9
	mov	QWORD PTR $T2[rsp], rdx
$LN161@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 91   :                 for (size_t i = 0; i < primitive_count; ++i) {

	xor	r12d, r12d
	mov	ecx, r12d
	test	r15, r15
	je	SHORT $LN6@build
	mov	r8, r11
$LL7@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 94   :         return (y & mask ? static_cast<U>(-static_cast<I>(y)) ^ mask : y) ^ mask;

	mov	eax, DWORD PTR [r8]
	test	eax, eax
	jns	SHORT $LN20@build
	neg	eax
	btc	eax, 31
$LN20@build:
	btc	eax, 31
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 92   :                     sorted_keys[i] = radix_sort.make_key(centers[i][axis]);

	mov	DWORD PTR [rsi+rcx*4], eax

; 93   :                     sorted_references[axis][i] = i;

	mov	QWORD PTR [rdx], rcx

; 91   :                 for (size_t i = 0; i < primitive_count; ++i) {

	inc	rcx
	add	r8, 12
	add	rdx, 8
	cmp	rcx, r15
	jb	SHORT $LL7@build
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR $T2[rsp], rax
$LN6@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 40   :             if (per_thread_data_size < data_size) {

	cmp	QWORD PTR [rdi+8], 2048			; 00000800H
	jae	SHORT $LN47@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	ecx, 16384				; 00004000H
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rbx, rax
	xor	edx, edx
	mov	r8d, 16384				; 00004000H
	mov	rcx, rax
	call	memset

; 3381 :         if (this != _STD addressof(_Right)) {

	lea	rax, QWORD PTR $T11[rbp-256]
	cmp	rdi, rax
	je	SHORT $LN74@build
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rdi]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rcx, rcx
	je	SHORT $LN81@build

; 3428 :         if (_Mypair._Myval2) {

	jmp	SHORT $LN338@build
$LN74@build:

; 3194 :         delete[] _Ptr;

	mov	rcx, rbx
$LN338@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 42   :                 per_thread_data_size = data_size;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN81@build:
	mov	QWORD PTR [rdi+8], 2048			; 00000800H
	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR $T2[rsp], rax
	mov	r10d, r12d
$LN47@build:

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	mov	r14, r12
	jmp	SHORT $LN31@build
$LL335@build:
	xor	r12d, r12d
$LN31@build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rbx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 48   :             std::fill(buckets, buckets + bucket_count, 0);

	lea	rcx, QWORD PTR [rbx+8192]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5038 :         auto _UFirst      = _Get_unwrapped(_First);

	mov	rax, rbx

; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	test	r10d, r10d

; 5048 :                 if (_Is_all_bits_zero(_Val)) {

	jne	SHORT $LN90@build

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	xor	edx, edx
	mov	r8d, 8192				; 00002000H
	mov	rcx, rbx
	call	memset

; 5050 :                     return;

	jmp	SHORT $LN87@build
$LN90@build:

; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rcx
	je	SHORT $LN87@build
	npad	4
$LL88@build:

; 5056 :             *_UFirst = _Val;

	mov	QWORD PTR [rax], r12

; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 8
	cmp	rax, rcx
	jne	SHORT $LL88@build
$LN87@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 51   :             for (size_t i = 0; i < count; ++i)

	mov	rdx, r12
	test	r15, r15
	je	SHORT $LN33@build
	npad	12
$LL34@build:

; 52   :                 buckets[(keys[i] >> bit) & mask]++;

	mov	eax, DWORD PTR [rsi+rdx*4]
	mov	rcx, r14
	shr	rax, cl
	and	eax, 1023				; 000003ffH
	inc	QWORD PTR [rbx+rax*8]

; 51   :             for (size_t i = 0; i < count; ++i)

	inc	rdx
	cmp	rdx, r15
	jb	SHORT $LL34@build
$LN33@build:

; 53   : 
; 54   :             #pragma omp for
; 55   :             for (size_t i = 0; i < bucket_count; i++) {

	mov	rdx, r12
	npad	3
$LL37@build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 60   :                     sum += per_thread_buckets[j * bucket_count + i];

	mov	rcx, QWORD PTR [rax+rdx]

; 61   :                     per_thread_buckets[j * bucket_count + i] = old_sum;

	mov	QWORD PTR [rax+rdx], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 63   :                 per_thread_buckets[thread_count * bucket_count + i] = sum;

	mov	QWORD PTR [rax+rdx+8192], rcx

; 53   : 
; 54   :             #pragma omp for
; 55   :             for (size_t i = 0; i < bucket_count; i++) {

	add	rdx, 8
	cmp	rdx, 8192				; 00002000H
	jb	SHORT $LL37@build

; 64   :             }
; 65   : 
; 66   :             for (size_t i = 0, sum = 0; i < bucket_count; ++i) {

	mov	r9, r12
	lea	r8, QWORD PTR [rbx+8]
	mov	r11d, 8200				; 00002008H
	sub	r11, rbx
	mov	r12d, 8208				; 00002010H
	sub	r12, rbx
	mov	r13d, 8184				; 00001ff8H
	sub	r13, rbx
	mov	r10d, 256				; 00000100H
	npad	5
$LL43@build:

; 67   :                 size_t old_sum = sum;

	mov	rcx, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	lea	rdx, QWORD PTR [r8+r13]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	mov	rax, QWORD PTR [rdi]
	add	r9, QWORD PTR [rax+rdx]

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8-8], rcx

; 67   :                 size_t old_sum = sum;

	mov	rcx, r9

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	mov	rax, QWORD PTR [rdi]
	add	r9, QWORD PTR [rax+rdx+8]

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8], rcx

; 67   :                 size_t old_sum = sum;

	mov	rcx, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rdi]
	add	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	add	r9, QWORD PTR [rax+r8]

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8+8], rcx

; 67   :                 size_t old_sum = sum;

	mov	rcx, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rdi]
	add	rax, r12
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	add	r9, QWORD PTR [rax+r8]

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8+16], rcx
	lea	r8, QWORD PTR [r8+32]

; 64   :             }
; 65   : 
; 66   :             for (size_t i = 0, sum = 0; i < bucket_count; ++i) {

	sub	r10, 1
	jne	SHORT $LL43@build

; 70   :             }
; 71   : 
; 72   :             #pragma omp for schedule(static)
; 73   :             for (size_t i = 0; i < count; ++i) {

	xor	r8d, r8d
	mov	r10, QWORD PTR $T2[rsp]
	mov	r11, QWORD PTR unsorted_references$1$[rsp]
	mov	r12, QWORD PTR unsorted_keys$1$[rsp]
	test	r15, r15
	je	SHORT $LN45@build

; 76   :                 values_copy[j] = values[i];

	mov	r9, r10
	npad	10
$LL46@build:

; 74   :                 size_t j = buckets[(keys[i] >> bit) & mask]++;

	mov	edx, DWORD PTR [rsi+r8*4]
	mov	rcx, r14
	shr	rdx, cl
	and	edx, 1023				; 000003ffH
	mov	rcx, QWORD PTR [rbx+rdx*8]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbx+rdx*8], rax

; 75   :                 keys_copy[j]   = keys[i];

	mov	eax, DWORD PTR [rsi+r8*4]
	mov	DWORD PTR [r12+rcx*4], eax

; 76   :                 values_copy[j] = values[i];

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r11+rcx*8], rax

; 70   :             }
; 71   : 
; 72   :             #pragma omp for schedule(static)
; 73   :             for (size_t i = 0; i < count; ++i) {

	inc	r8
	lea	r9, QWORD PTR [r9+8]
	cmp	r8, r15
	jb	SHORT $LL46@build
$LN45@build:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	QWORD PTR unsorted_keys$1$[rsp], rsi

; 101  :     _Right   = _STD move(_Tmp);

	mov	rsi, r12

; 100  :     _Left    = _STD move(_Right);

	mov	r12, r10
	mov	QWORD PTR unsorted_references$1$[rsp], r10

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR $T2[rsp], r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	add	r14, 10
	cmp	r14, 32					; 00000020H
	mov	r10d, DWORD PTR tv2513[rsp]
	jb	$LL335@build
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 77   :             for (int axis = 0; axis < 3; ++axis) {

	mov	r14, QWORD PTR tv2493[rsp]
	mov	QWORD PTR [r14], r11
	mov	eax, DWORD PTR axis$1$[rsp]
	inc	eax
	mov	DWORD PTR axis$1$[rsp], eax
	mov	r9, QWORD PTR tv2488[rsp]
	lea	rcx, QWORD PTR [r15*8]
	add	r9, rcx
	mov	QWORD PTR tv2488[rsp], r9
	mov	r11, QWORD PTR tv2490[rsp]
	add	r11, 4
	mov	QWORD PTR tv2490[rsp], r11
	add	r14, 8
	mov	QWORD PTR tv2493[rsp], r14
	cmp	eax, 3
	mov	r13, QWORD PTR this$GSCopy$1$[rsp]
	jl	$LL4@build

; 159  :         : builder(builder)

	mov	rcx, r13
	mov	QWORD PTR first_task$12[rbp-256], rcx

; 160  :         , bboxes(bboxes)

	mov	rax, QWORD PTR bboxes$1$[rbp-256]
	mov	QWORD PTR first_task$12[rbp-248], rax

; 161  :         , centers(centers)

	mov	rax, QWORD PTR centers$1$[rsp]
	mov	QWORD PTR first_task$12[rbp-240], rax
	mov	rax, QWORD PTR sorted_references$[rbp-256]
	mov	QWORD PTR first_task$12[rbp-232], rax
	mov	rax, QWORD PTR sorted_references$[rbp-248]
	mov	QWORD PTR first_task$12[rbp-224], rax
	mov	rax, QWORD PTR sorted_references$[rbp-240]
	mov	QWORD PTR first_task$12[rbp-216], rax
	mov	rbx, QWORD PTR $T7[rbp-256]
	mov	QWORD PTR first_task$12[rbp-208], rbx
	mov	rax, QWORD PTR costs$$sroa$164$1$[rbp-256]
	mov	QWORD PTR first_task$12[rbp-200], rax
	mov	rax, QWORD PTR costs$$sroa$163$1$[rbp-256]
	mov	QWORD PTR first_task$12[rbp-192], rax

; 162  :         , references { references[0], references[1], references[2] }
; 163  :         , costs { costs[0], costs[1], costs[2] }
; 164  :         , marks(marks)

	mov	rdi, QWORD PTR $T8[rbp-256]
	mov	QWORD PTR first_task$12[rbp-184], rdi

; 94   :                 }
; 95   : 
; 96   :                 radix_sort.sort_in_parallel(
; 97   :                     sorted_keys,
; 98   :                     unsorted_keys,
; 99   :                     sorted_references[axis],
; 100  :                     unsorted_references,
; 101  :                     primitive_count,
; 102  :                     sizeof(Scalar) * CHAR_BIT);
; 103  :             }
; 104  : 
; 105  :             #pragma omp single
; 106  :             {
; 107  :                 BuildTask first_task(*this, bboxes, centers, sorted_references, costs, mark_data.get());
; 108  :                 run_task(first_task, 0, 0, primitive_count, 0);

	mov	DWORD PTR $T4[rsp], r10d
	mov	DWORD PTR $T1[rsp], r10d
	mov	DWORD PTR $T3[rsp], r10d
	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR primitive_count$GSCopy$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T1[rsp]
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR first_task$12[rbp-256]
	call	??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3194 :         delete[] _Ptr;

	mov	rcx, rdi
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
	mov	rcx, QWORD PTR $T5[rbp-256]
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
	mov	rcx, rbx
	call	??_V@YAXPEAX@Z				; operator delete[]
	npad	1
	mov	rcx, QWORD PTR $T6[rbp-256]
	call	??_V@YAXPEAX@Z				; operator delete[]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 111  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z ENDP ; bvh::SweepSahBuilder<bvh::Bvh<float> >::build
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2513 = 48
$T1 = 48
$T2 = 56
$T3 = 56
axis$1$ = 64
$T4 = 64
unsorted_references$1$ = 72
unsorted_keys$1$ = 80
tv2488 = 88
tv2490 = 96
tv2493 = 104
this$GSCopy$1$ = 112
centers$1$ = 120
$T5 = 128
$T6 = 136
bboxes$1$ = 144
$T7 = 152
costs$$sroa$164$1$ = 160
costs$$sroa$163$1$ = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
primitive_count$GSCopy$ = 208
sorted_references$ = 216
first_task$12 = 240
reference_data$ = 320
cost_data$ = 328
key_data$ = 336
mark_data$ = 344
__$ArrayPad$ = 352
this$ = 416
global_bbox$ = 424
bboxes$ = 432
centers$ = 440
primitive_count$ = 448
?dtor$2@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA PROC ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$2
	lea	rcx, QWORD PTR reference_data$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::~unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >
?dtor$2@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA ENDP ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2513 = 48
$T1 = 48
$T2 = 56
$T3 = 56
axis$1$ = 64
$T4 = 64
unsorted_references$1$ = 72
unsorted_keys$1$ = 80
tv2488 = 88
tv2490 = 96
tv2493 = 104
this$GSCopy$1$ = 112
centers$1$ = 120
$T5 = 128
$T6 = 136
bboxes$1$ = 144
$T7 = 152
costs$$sroa$164$1$ = 160
costs$$sroa$163$1$ = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
primitive_count$GSCopy$ = 208
sorted_references$ = 216
first_task$12 = 240
reference_data$ = 320
cost_data$ = 328
key_data$ = 336
mark_data$ = 344
__$ArrayPad$ = 352
this$ = 416
global_bbox$ = 424
bboxes$ = 432
centers$ = 440
primitive_count$ = 448
?dtor$3@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA PROC ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$3
	lea	rcx, QWORD PTR cost_data$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ ; std::unique_ptr<float [0],std::default_delete<float [0]> >::~unique_ptr<float [0],std::default_delete<float [0]> >
?dtor$3@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA ENDP ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2513 = 48
$T1 = 48
$T2 = 56
$T3 = 56
axis$1$ = 64
$T4 = 64
unsorted_references$1$ = 72
unsorted_keys$1$ = 80
tv2488 = 88
tv2490 = 96
tv2493 = 104
this$GSCopy$1$ = 112
centers$1$ = 120
$T5 = 128
$T6 = 136
bboxes$1$ = 144
$T7 = 152
costs$$sroa$164$1$ = 160
costs$$sroa$163$1$ = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
primitive_count$GSCopy$ = 208
sorted_references$ = 216
first_task$12 = 240
reference_data$ = 320
cost_data$ = 328
key_data$ = 336
mark_data$ = 344
__$ArrayPad$ = 352
this$ = 416
global_bbox$ = 424
bboxes$ = 432
centers$ = 440
primitive_count$ = 448
?dtor$4@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA PROC ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$4
	lea	rcx, QWORD PTR key_data$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::~unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >
?dtor$4@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA ENDP ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
tv2513 = 48
$T1 = 48
$T2 = 56
$T3 = 56
axis$1$ = 64
$T4 = 64
unsorted_references$1$ = 72
unsorted_keys$1$ = 80
tv2488 = 88
tv2490 = 96
tv2493 = 104
this$GSCopy$1$ = 112
centers$1$ = 120
$T5 = 128
$T6 = 136
bboxes$1$ = 144
$T7 = 152
costs$$sroa$164$1$ = 160
costs$$sroa$163$1$ = 168
$T8 = 176
$T9 = 184
$T10 = 192
$T11 = 200
primitive_count$GSCopy$ = 208
sorted_references$ = 216
first_task$12 = 240
reference_data$ = 320
cost_data$ = 328
key_data$ = 336
mark_data$ = 344
__$ArrayPad$ = 352
this$ = 416
global_bbox$ = 424
bboxes$ = 432
centers$ = 440
primitive_count$ = 448
?dtor$5@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA PROC ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$5
	lea	rcx, QWORD PTR mark_data$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::~unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >
?dtor$5@?0??build@?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAAXAEBU?$BoundingBox@M@2@PEBU32@PEBU?$Vector@M$02@2@_K@Z@4HA ENDP ; `bvh::SweepSahBuilder<bvh::Bvh<float> >::build'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ??0?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAU?$Bvh@M@1@@Z
_TEXT	SEGMENT
this$ = 8
bvh$ = 16
??0?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAU?$Bvh@M@1@@Z PROC ; bvh::SweepSahBuilder<bvh::Bvh<float> >::SweepSahBuilder<bvh::Bvh<float> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], 1024			; 00000400H
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 41   :     {}

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 64			; 00000040H
	mov	QWORD PTR [rcx+16], 16
	mov	DWORD PTR [rcx+24], 1065353216		; 3f800000H
	mov	QWORD PTR [rcx+48], rdx
	ret	0
??0?$SweepSahBuilder@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAU?$Bvh@M@1@@Z ENDP ; bvh::SweepSahBuilder<bvh::Bvh<float> >::SweepSahBuilder<bvh::Bvh<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0TopDownBuilder@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0TopDownBuilder@bvh@@QEAA@XZ PROC			; bvh::TopDownBuilder::TopDownBuilder, COMDAT
	mov	QWORD PTR [rcx], 1024			; 00000400H
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 64			; 00000040H
	mov	QWORD PTR [rcx+16], 16
	ret	0
??0TopDownBuilder@bvh@@QEAA@XZ ENDP			; bvh::TopDownBuilder::TopDownBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ PROC	; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::SahBasedAlgorithm<bvh::Bvh<float> >, COMDAT
	mov	DWORD PTR [rcx], 1065353216		; 3f800000H
	mov	rax, rcx
	ret	0
??0?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@QEAA@XZ ENDP	; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::SahBasedAlgorithm<bvh::Bvh<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$RadixSort@$09@bvh@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$RadixSort@$09@bvh@@QEAA@XZ PROC			; bvh::RadixSort<10>::RadixSort<10>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$RadixSort@$09@bvh@@QEAA@XZ ENDP			; bvh::RadixSort<10>::RadixSort<10>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sah_based_algorithm.hpp
;	COMDAT ??1?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@IEAA@XZ PROC	; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::~SahBasedAlgorithm<bvh::Bvh<float> >, COMDAT

; 19   :     ~SahBasedAlgorithm() {}

	ret	0
??1?$SahBasedAlgorithm@U?$Bvh@M@bvh@@@bvh@@IEAA@XZ ENDP	; bvh::SahBasedAlgorithm<bvh::Bvh<float> >::~SahBasedAlgorithm<bvh::Bvh<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??A?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBAAEAUNode@?$Bvh@M@bvh@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Idx$ = 16
??A?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBAAEAUNode@?$Bvh@M@bvh@@_K@Z PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator[], COMDAT

; 3442 :         return _Mypair._Myval2[_Idx];

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 3443 :     }

	ret	0
??A?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBAAEAUNode@?$Bvh@M@bvh@@_K@Z ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::~unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::~unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??A?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAAEA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Idx$ = 16
??A?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAAEA_K_K@Z PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator[], COMDAT

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]

; 3443 :     }

	ret	0
??A?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAAEA_K_K@Z ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::~unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::~unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<float [0],std::default_delete<float [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<float [0],std::default_delete<float [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z PROC ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	ret	0
?__autoclassinit2@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAAX_K@Z ENDP ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ??4BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAAAEAU0123@AEBU?$BoundingBox@M@3@@Z
_TEXT	SEGMENT
this$ = 8
bbox$ = 16
??4BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAAAEAU0123@AEBU?$BoundingBox@M@3@@Z PROC ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator=, COMDAT

; 42   :                 node.bounds[0] = bbox.min[0];

	mov	eax, DWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	DWORD PTR [r8], eax

; 43   :                 node.bounds[1] = bbox.max[0];

	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [r8+4], eax

; 44   :                 node.bounds[2] = bbox.min[1];

	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8+8], eax

; 45   :                 node.bounds[3] = bbox.max[1];

	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [r8+12], eax

; 46   :                 node.bounds[4] = bbox.min[2];

	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [r8+16], eax

; 47   :                 node.bounds[5] = bbox.max[2];

	mov	eax, DWORD PTR [rdx+20]
	mov	DWORD PTR [r8+20], eax

; 48   :                 return *this;

	mov	rax, rcx

; 49   :             }

	ret	0
??4BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAAAEAU0123@AEBU?$BoundingBox@M@3@@Z ENDP ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEBAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEBAPEAEXZ PROC ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEBAPEAEXZ ENDP ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::~unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::~unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEBAPEAIXZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEBAPEAIXZ PROC ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEBAPEAIXZ ENDP ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::~unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::~unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEBAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEBAPEAMXZ PROC ; std::unique_ptr<float [0],std::default_delete<float [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEBAPEAMXZ ENDP ; std::unique_ptr<float [0],std::default_delete<float [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ PROC ; std::unique_ptr<float [0],std::default_delete<float [0]> >::~unique_ptr<float [0],std::default_delete<float [0]> >, COMDAT

; 3428 :         if (_Mypair._Myval2) {

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	jne	??_V@YAXPEAX@Z				; operator delete[]

; 3429 :             _Mypair._Get_first()(_Mypair._Myval2);
; 3430 :         }
; 3431 :     }

	ret	0
??1?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@XZ ENDP ; std::unique_ptr<float [0],std::default_delete<float [0]> >::~unique_ptr<float [0],std::default_delete<float [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXXZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Tidy, COMDAT

; 2035 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2036 :         auto& _Al         = _Getal();
; 2037 :         auto& _My_data    = _Mypair._Myval2;
; 2038 :         pointer& _Myfirst = _My_data._Myfirst;
; 2039 :         pointer& _Mylast  = _My_data._Mylast;
; 2040 :         pointer& _Myend   = _My_data._Myend;
; 2041 : 
; 2042 :         _My_data._Orphan_all();
; 2043 : 
; 2044 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2046 :             _ASAN_VECTOR_REMOVE;
; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2050 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2051 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2053 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Tidy:
?_Tidy@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXXZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ?bounding_box_proxy@Node@?$Bvh@M@bvh@@QEAA?AUBoundingBoxProxy@123@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?bounding_box_proxy@Node@?$Bvh@M@bvh@@QEAA?AUBoundingBoxProxy@123@XZ PROC ; bvh::Bvh<float>::Node::bounding_box_proxy, COMDAT

; 38   :                 : node(node)

	mov	QWORD PTR [rdx], rcx

; 73   :             return BoundingBoxProxy(*this);

	mov	rax, rdx

; 74   :         }

	ret	0
?bounding_box_proxy@Node@?$Bvh@M@bvh@@QEAA?AUBoundingBoxProxy@123@XZ ENDP ; bvh::Bvh<float>::Node::bounding_box_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ??0?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAV?$SweepSahBuilder@U?$Bvh@M@bvh@@@1@PEBU?$BoundingBox@M@1@PEBU?$Vector@M$02@1@AEBV?$array@PEA_K$02@std@@AEBV?$array@PEAM$02@6@PEAE@Z
_TEXT	SEGMENT
this$ = 8
builder$ = 16
bboxes$ = 24
centers$ = 32
references$ = 40
costs$ = 48
marks$ = 56
??0?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAV?$SweepSahBuilder@U?$Bvh@M@bvh@@@1@PEBU?$BoundingBox@M@1@PEBU?$Vector@M$02@1@AEBV?$array@PEA_K$02@std@@AEBV?$array@PEAM$02@6@PEAE@Z PROC ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::SweepSahBuildTask<bvh::Bvh<float> >, COMDAT

; 159  :         : builder(builder)

	mov	QWORD PTR [rcx], rdx

; 160  :         , bboxes(bboxes)
; 161  :         , centers(centers)

	mov	rdx, QWORD PTR references$[rsp]
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+24], rax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+32], rax
	mov	rax, QWORD PTR [rdx+16]
	mov	rdx, QWORD PTR costs$[rsp]
	mov	QWORD PTR [rcx+40], rax
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+48], rax
	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+56], rax
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+64], rax

; 162  :         , references { references[0], references[1], references[2] }
; 163  :         , costs { costs[0], costs[1], costs[2] }
; 164  :         , marks(marks)

	mov	rax, QWORD PTR marks$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 165  :     {}

	mov	rax, rcx
	ret	0
??0?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA@AEAV?$SweepSahBuilder@U?$Bvh@M@bvh@@@1@PEBU?$BoundingBox@M@1@PEBU?$Vector@M$02@1@AEBV?$array@PEA_K$02@std@@AEBV?$array@PEAM$02@6@PEAE@Z ENDP ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::SweepSahBuildTask<bvh::Bvh<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??A?$Vector@M$02@bvh@@QEBAM_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$Vector@M$02@bvh@@QEBAM_K@Z PROC			; bvh::Vector<float,3>::operator[], COMDAT

; 89   :     bvh_always_inline Scalar  operator [] (size_t i) const { return values[i]; }

	movss	xmm0, DWORD PTR [rcx+rdx*4]
	ret	0
??A?$Vector@M$02@bvh@@QEBAM_K@Z ENDP			; bvh::Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\array
;	COMDAT ??A?$array@PEA_K$02@std@@QEAAAEAPEA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$array@PEA_K$02@std@@QEAAAEAPEA_K_K@Z PROC		; std::array<unsigned __int64 *,3>::operator[], COMDAT

; 533  : #if _CONTAINER_DEBUG_LEVEL > 0
; 534  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 535  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 536  : 
; 537  :         return _Elems[_Pos];

	lea	rax, QWORD PTR [rcx+rdx*8]

; 538  :     }

	ret	0
??A?$array@PEA_K$02@std@@QEAAAEAPEA_K_K@Z ENDP		; std::array<unsigned __int64 *,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAAAEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAAAEAU?$default_delete@$$BY0A@_K@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAAAEAU?$default_delete@$$BY0A@_K@2@XZ PROC ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAAAEAU?$default_delete@$$BY0A@_K@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAPEA_KXZ
_TEXT	SEGMENT
this$ = 8
?get@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAPEA_KXZ PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::get, COMDAT

; 3446 :         return _Mypair._Myval2;

	mov	rax, QWORD PTR [rcx]

; 3447 :     }

	ret	0
?get@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEBAPEA_KXZ ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ??0BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAA@AEAU123@@Z
_TEXT	SEGMENT
this$ = 8
node$ = 16
??0BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAA@AEAU123@@Z PROC ; bvh::Bvh<float>::Node::BoundingBoxProxy::BoundingBoxProxy, COMDAT

; 38   :                 : node(node)

	mov	QWORD PTR [rcx], rdx

; 39   :             {}

	mov	rax, rcx
	ret	0
??0BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEAA@AEAU123@@Z ENDP ; bvh::Bvh<float>::Node::BoundingBoxProxy::BoundingBoxProxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\array
;	COMDAT ??A?$array@PEAM$02@std@@QEBAAEBQEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$array@PEAM$02@std@@QEBAAEBQEAM_K@Z PROC		; std::array<float *,3>::operator[], COMDAT

; 542  : #if _CONTAINER_DEBUG_LEVEL > 0
; 543  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 544  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 545  : 
; 546  :         return _Elems[_Pos];

	lea	rax, QWORD PTR [rcx+rdx*8]

; 547  :     }

	ret	0
??A?$array@PEAM$02@std@@QEBAAEBQEAM_K@Z ENDP		; std::array<float *,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAAAEAU?$default_delete@$$BY0A@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAAAEAU?$default_delete@$$BY0A@E@2@XZ PROC ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAAAEAU?$default_delete@$$BY0A@E@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAAAEAU?$default_delete@$$BY0A@I@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAAAEAU?$default_delete@$$BY0A@I@2@XZ PROC ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAAAEAU?$default_delete@$$BY0A@I@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAAAEAU?$default_delete@$$BY0A@M@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAAAEAU?$default_delete@$$BY0A@M@2@XZ PROC ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAAAEAU?$default_delete@$$BY0A@M@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z PROC ; std::allocator<bvh::Bvh<float>::Node>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 5
	mov	rax, rdx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAXQEAUNode@?$Bvh@M@bvh@@_K@Z ENDP ; std::allocator<bvh::Bvh<float>::Node>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal, COMDAT

; 2181 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2182 :     }

	ret	0
?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z PROC ; std::allocator<bvh::Triangle<float,1,0> >::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K@Z ENDP ; std::allocator<bvh::Triangle<float,1,0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\array
;	COMDAT ??A?$array@PEA_K$02@std@@QEBAAEBQEA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$array@PEA_K$02@std@@QEBAAEBQEA_K_K@Z PROC		; std::array<unsigned __int64 *,3>::operator[], COMDAT

; 542  : #if _CONTAINER_DEBUG_LEVEL > 0
; 543  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 544  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 545  : 
; 546  :         return _Elems[_Pos];

	lea	rax, QWORD PTR [rcx+rdx*8]

; 547  :     }

	ret	0
??A?$array@PEA_K$02@std@@QEBAAEBQEA_K_K@Z ENDP		; std::array<unsigned __int64 *,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], 0
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
;	COMDAT ??$as@IM@bvh@@YAIM@Z
_TEXT	SEGMENT
from$ = 8
??$as@IM@bvh@@YAIM@Z PROC				; bvh::as<unsigned int,float>, COMDAT

; 20   : To as(From from) {

	movss	DWORD PTR [rsp+8], xmm0

; 21   :     static_assert(sizeof(To) == sizeof(From));
; 22   :     To to;
; 23   :     std::memcpy(&to, &from, sizeof(from));
; 24   :     return to;

	mov	eax, DWORD PTR from$[rsp]

; 25   : }

	ret	0
??$as@IM@bvh@@YAIM@Z ENDP				; bvh::as<unsigned int,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator=<std::default_delete<bvh::Bvh<float>::Node [0]>,0>, COMDAT

; 3380 :     _CONSTEXPR23 unique_ptr& operator=(unique_ptr&& _Right) noexcept {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3381 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN18@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rcx, rcx
	je	SHORT $LN18@operator

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN18@operator:

; 3382 :             reset(_Right.release());
; 3383 :             _Mypair._Get_first() = _STD move(_Right._Mypair._Get_first());
; 3384 :         }
; 3385 : 
; 3386 :         return *this;
; 3387 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?4U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::operator=<std::default_delete<bvh::Bvh<float>::Node [0]>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator=<std::default_delete<unsigned __int64 [0]>,0>, COMDAT

; 3380 :     _CONSTEXPR23 unique_ptr& operator=(unique_ptr&& _Right) noexcept {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3381 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN18@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rcx, rcx
	je	SHORT $LN18@operator

; 3194 :         delete[] _Ptr;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN18@operator:

; 3382 :             reset(_Right.release());
; 3383 :             _Mypair._Get_first() = _STD move(_Right._Mypair._Get_first());
; 3384 :         }
; 3385 : 
; 3386 :         return *this;
; 3387 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?4U?$default_delete@$$BY0A@_K@std@@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::operator=<std::default_delete<unsigned __int64 [0]>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z PROC ; std::make_unique<unsigned __int64 [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 8
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@_K$0A@@std@@YA?AV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@_K@Z ENDP ; std::make_unique<unsigned __int64 [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0M@?$Vector@M$02@bvh@@QEAA@MMM@Z
_TEXT	SEGMENT
this$ = 8
first$ = 16
second$ = 24
<args_0>$ = 32
??$?0M@?$Vector@M$02@bvh@@QEAA@MMM@Z PROC		; bvh::Vector<float,3>::Vector<float,3><float>, COMDAT

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx], xmm1

; 47   :         set(first, second, args...);
; 48   :     }

	mov	rax, rcx

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx+4], xmm2

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR [rcx+8], xmm3

; 47   :         set(first, second, args...);
; 48   :     }

	ret	0
??$?0M@?$Vector@M$02@bvh@@QEAA@MMM@Z ENDP		; bvh::Vector<float,3>::Vector<float,3><float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$Vector@M$02@bvh@@@std@@YA$$QEAU?$Vector@M$02@bvh@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$Vector@M$02@bvh@@@std@@YA$$QEAU?$Vector@M$02@bvh@@AEAU12@@Z PROC ; std::forward<bvh::Vector<float,3> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$Vector@M$02@bvh@@@std@@YA$$QEAU?$Vector@M$02@bvh@@AEAU12@@Z ENDP ; std::forward<bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
;	COMDAT ??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
s$ = 72
s$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 112
bboxes$ = 120
count$ = 128
??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z PROC ; bvh::compute_bounding_boxes_union<float>, COMDAT

; 163  : BoundingBox<Scalar> compute_bounding_boxes_union(const BoundingBox<Scalar>* bboxes, size_t count) {

$LN75:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 163  : BoundingBox<Scalar> compute_bounding_boxes_union(const BoundingBox<Scalar>* bboxes, size_t count) {

	mov	rdi, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 163  : BoundingBox<Scalar> compute_bounding_boxes_union(const BoundingBox<Scalar>* bboxes, size_t count) {

	mov	rbx, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T2[rsp+12]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], 2139095039		; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T1[rsp+12]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR $T1[rsp+8]
	movsd	QWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR $T2[rsp]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR $T2[rsp+8]
	movsd	QWORD PTR [rbx+12], xmm0
	mov	DWORD PTR [rbx+20], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 171  :     for (size_t i = 0; i < count; ++i)

	test	rsi, rsi
	je	$LN70@compute_bo
	npad	5
$LL4@compute_bo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rdi]
	movss	xmm2, DWORD PTR [rdi+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 171  :     for (size_t i = 0; i < count; ++i)

	lea	rdi, QWORD PTR [rdi+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm1, QWORD PTR [rbx]
	minss	xmm3, xmm1
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR [rdi-16]
	shufps	xmm0, xmm0, 85				; 00000055H
	minss	xmm2, xmm0
	minss	xmm1, DWORD PTR [rbx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rbx], xmm0
	movss	DWORD PTR [rbx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm1, QWORD PTR [rbx+12]
	movsd	xmm3, QWORD PTR [rdi-12]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [rdi-8]
	maxss	xmm3, xmm1
	movss	xmm1, DWORD PTR [rdi-4]
	shufps	xmm0, xmm0, 85				; 00000055H
	maxss	xmm2, xmm0
	maxss	xmm1, DWORD PTR [rbx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rbx+12], xmm0
	movss	DWORD PTR [rbx+20], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 171  :     for (size_t i = 0; i < count; ++i)

	sub	rsi, 1
	jne	SHORT $LL4@compute_bo
$LN70@compute_bo:

; 172  :         bbox.extend(bboxes[i]);
; 173  : 
; 174  :     return bbox;
; 175  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
??$compute_bounding_boxes_union@M@bvh@@YA?AU?$BoundingBox@M@0@PEBU10@_K@Z ENDP ; bvh::compute_bounding_boxes_union<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z
_TEXT	SEGMENT
this$ = 64
<_Val_0>$ = 72
<_Val_1>$ = 80
<_Val_2>$ = 88
??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_one_at_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >, COMDAT

; 776  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN7:
	sub	rsp, 56					; 00000038H
	mov	rax, rdx

; 777  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 778  :         auto& _My_data   = _Mypair._Myval2;
; 779  :         pointer& _Mylast = _My_data._Mylast;
; 780  : 
; 781  :         if (_Mylast != _My_data._Myend) {

	mov	QWORD PTR [rsp+32], r9
	mov	rdx, QWORD PTR [rcx+8]
	mov	r9, r8
	mov	r10, rcx
	mov	r8, rax
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	call	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r10+8]

; 806  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+48]
	mov	QWORD PTR [r10+8], rcx

; 786  :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@Emplace_on:

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 786  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_one_at_back@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_one_at_back<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp
;	COMDAT ??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z
_TEXT	SEGMENT
$T2 = 32
$T3 = 32
$T4 = 36
$T5 = 40
$T6 = 44
$T7 = 48
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 88
$T16 = 112
__$ReturnUdt$GSCopy$ = 112
$T17 = 112
bounding_boxes$ = 112
__$ArrayPad$ = 120
__$ReturnUdt$ = 304
primitives$ = 312
primitive_count$ = 320
??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z PROC ; bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>, COMDAT

; 148  : compute_bounding_boxes_and_centers(const Primitive* primitives, size_t primitive_count) {

$LN335:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 256				; 00000100H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-201], rax
	mov	r14, r8
	mov	r12, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-201], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 24
	mul	r8
	mov	rbx, rax
	mov	r15, -1
	cmovo	rbx, r15
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rsi, rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR bounding_boxes$[rbp-201], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 12
	mul	r14
	mov	rbx, rax
	cmovo	rbx, r15
	mov	rcx, rbx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r15, rax
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	memset
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 153  :     for (size_t i = 0; i < primitive_count; ++i) {

	test	r14, r14
	je	$LN3@compute_bo

; 148  : compute_bounding_boxes_and_centers(const Primitive* primitives, size_t primitive_count) {

	mov	rdx, r15
	mov	rcx, rsi
	movss	xmm13, DWORD PTR __real@3eaaaaab
	npad	7
$LL4@compute_bo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm0, QWORD PTR [r12]
	movsd	xmm1, QWORD PTR [r12+12]
	movaps	xmm2, xmm0
	subss	xmm2, xmm1
	movaps	xmm3, xmm0
	shufps	xmm3, xmm3, 85				; 00000055H
	movsd	QWORD PTR $T14[rsp], xmm0
	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm3, xmm0
	movss	xmm1, DWORD PTR [r12+8]
	subss	xmm1, DWORD PTR [r12+20]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [r12]
	movss	DWORD PTR $T4[rsp], xmm2
	movsd	QWORD PTR $T13[rsp], xmm0
	movss	DWORD PTR $T5[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T4[rsp]
	lea	r8, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm0, xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm12, DWORD PTR [rax]
	movss	DWORD PTR $T4[rsp], xmm3
	movss	xmm0, DWORD PTR $T13[rsp+4]
	movss	DWORD PTR $T5[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T4[rsp]
	lea	r8, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm0, xmm3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm11, DWORD PTR [rax]
	movss	DWORD PTR $T4[rsp], xmm1
	movss	xmm0, DWORD PTR [r12+8]
	movss	DWORD PTR $T5[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T4[rsp]
	lea	r8, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm9, DWORD PTR [rax]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [r12]
	movss	DWORD PTR $T6[rsp], xmm2
	movsd	QWORD PTR $T12[rsp], xmm0
	movss	DWORD PTR $T7[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T6[rsp]
	lea	r8, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm2, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm10, DWORD PTR [rax]
	movss	DWORD PTR $T6[rsp], xmm3
	movss	xmm0, DWORD PTR $T12[rsp+4]
	movss	DWORD PTR $T7[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T6[rsp]
	lea	r8, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm3, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm8, DWORD PTR [rax]
	movss	DWORD PTR $T6[rsp], xmm1
	movss	xmm0, DWORD PTR [r12+8]
	movss	DWORD PTR $T7[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T6[rsp]
	lea	r8, QWORD PTR $T7[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm7, DWORD PTR [rax]

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm1, QWORD PTR [r12]
	movsd	xmm0, QWORD PTR [r12+24]
	movaps	xmm5, xmm1
	addss	xmm5, xmm0
	movaps	xmm6, xmm0
	shufps	xmm6, xmm6, 85				; 00000055H
	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	movsd	QWORD PTR $T11[rsp], xmm1
	addss	xmm6, xmm0
	movss	xmm4, DWORD PTR [r12+8]
	addss	xmm4, DWORD PTR [r12+32]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	DWORD PTR $T3[rsp], xmm5
	movss	DWORD PTR $T17[rbp-201], xmm12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T17[rbp-201]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm12, xmm5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm3, DWORD PTR [rax]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	DWORD PTR $T3[rsp], xmm6
	movss	DWORD PTR $T17[rbp-201], xmm11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T17[rbp-201]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm11, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm2, DWORD PTR [rax]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	DWORD PTR $T3[rsp], xmm4
	movss	DWORD PTR $T17[rbp-201], xmm9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	lea	rax, QWORD PTR $T3[rsp]
	lea	r8, QWORD PTR $T17[rbp-201]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	comiss	xmm9, xmm4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm1, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 30   :         min = bvh::min(min, v);

	unpcklps xmm3, xmm2
	movss	DWORD PTR $T15[rbp-193], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	DWORD PTR $T16[rbp-201], xmm5
	movss	DWORD PTR $T2[rsp], xmm10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T16[rbp-201]
	lea	r8, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm5, xmm10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm0, DWORD PTR [rax]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	DWORD PTR $T16[rbp-201], xmm6
	movss	DWORD PTR $T2[rsp], xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T16[rbp-201]
	lea	r8, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm2, DWORD PTR [rax]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	DWORD PTR $T16[rbp-201], xmm4
	movss	DWORD PTR $T2[rsp], xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	lea	rax, QWORD PTR $T16[rbp-201]
	lea	r8, QWORD PTR $T2[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	comiss	xmm4, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmovbe	rax, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm1, DWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 31   :         max = bvh::max(max, v);

	unpcklps xmm0, xmm2
	movsd	QWORD PTR $T15[rbp-189], xmm0
	movss	DWORD PTR $T15[rbp-181], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 154  :         bounding_boxes[i] = primitives[i].bounding_box();

	movups	xmm0, XMMWORD PTR $T15[rbp-201]
	movsd	xmm0, xmm3
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR $T15[rbp-185]
	movsd	QWORD PTR [rcx+16], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm1, QWORD PTR [r12]
	movsd	xmm0, QWORD PTR [r12+24]
	movaps	xmm7, xmm1
	addss	xmm7, xmm0
	movaps	xmm6, xmm0
	shufps	xmm6, xmm6, 85				; 00000055H
	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	movsd	QWORD PTR $T9[rsp], xmm1
	addss	xmm6, xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR [r12+12]
	movaps	xmm2, xmm0
	subss	xmm2, xmm1
	movaps	xmm3, xmm0
	shufps	xmm3, xmm3, 85				; 00000055H
	movsd	QWORD PTR $T8[rsp], xmm0
	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm3, xmm0

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm0, QWORD PTR [r12]
	movaps	xmm5, xmm0
	addss	xmm5, xmm2
	movaps	xmm4, xmm0
	shufps	xmm4, xmm4, 85				; 00000055H
	movsd	QWORD PTR $T10[rsp], xmm0
	addss	xmm4, xmm3
	addss	xmm5, xmm7
	addss	xmm4, xmm6

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	mulss	xmm5, xmm13
	mulss	xmm4, xmm13

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm3, DWORD PTR [r12+8]
	subss	xmm3, DWORD PTR [r12+20]

; 53   :             values[i] = f(i);

	addss	xmm3, DWORD PTR [r12+8]

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm2, DWORD PTR [r12+8]
	addss	xmm2, DWORD PTR [r12+32]

; 53   :             values[i] = f(i);

	addss	xmm3, xmm2
	mulss	xmm3, xmm13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 155  :         centers[i]        = primitives[i].center();

	movaps	xmm0, xmm5
	unpcklps xmm0, xmm4
	movsd	QWORD PTR [rdx], xmm0
	movss	DWORD PTR [rdx+8], xmm3

; 153  :     for (size_t i = 0; i < primitive_count; ++i) {

	add	rcx, 24
	add	r12, 48					; 00000030H
	add	rdx, 12
	sub	r14, 1
	jne	$LL4@compute_bo
$LN3@compute_bo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rdi], rsi
	mov	QWORD PTR [rdi+8], r15
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\utilities.hpp

; 158  :     return std::make_pair(std::move(bounding_boxes), std::move(centers));

	mov	rax, rdi

; 159  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-201]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+256]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
??$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z ENDP ; bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T3 = 32
$T4 = 36
$T5 = 40
$T6 = 44
$T7 = 48
$T8 = 56
$T9 = 56
$T10 = 56
$T11 = 56
$T12 = 56
$T13 = 56
$T14 = 56
$T15 = 88
$T16 = 112
__$ReturnUdt$GSCopy$ = 112
$T17 = 112
bounding_boxes$ = 112
__$ArrayPad$ = 120
__$ReturnUdt$ = 304
primitives$ = 312
primitive_count$ = 320
?dtor$0@?0???$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z@4HA PROC ; `bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>'::`1'::dtor$0
	lea	rcx, QWORD PTR bounding_boxes$[rdx]
	jmp	??1?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@XZ ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::~unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >
?dtor$0@?0???$compute_bounding_boxes_and_centers@U?$Triangle@M$00$0A@@bvh@@M@bvh@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@PEBU?$Triangle@M$00$0A@@0@_K@Z@4HA ENDP ; `bvh::compute_bounding_boxes_and_centers<bvh::Triangle<float,1,0>,float>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\predefined C++ types (compiler internal)
;	COMDAT ??$<move>@AEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@@@YA$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@AEAU01@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$<move>@AEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@@@YA$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@AEAU01@@Z PROC ; <move><std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > > &>, COMDAT

	mov	rax, rcx

	ret	0
??$<move>@AEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@@@YA$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@AEAU01@@Z ENDP ; <move><std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$0A@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$0A@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z PROC ; std::get<0,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >, COMDAT

; 708  :     // get rvalue reference to element at _Idx in pair _Pr
; 709  :     if constexpr (_Idx == 0) {
; 710  :         return _STD forward<_Ty1>(_Pr.first);

	mov	rax, rcx

; 711  :     } else {
; 712  :         return _STD forward<_Ty2>(_Pr.second);
; 713  :     }
; 714  : }

	ret	0
??$get@$0A@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z ENDP ; std::get<0,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$get@$00V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z
_TEXT	SEGMENT
_Pr$ = 8
??$get@$00V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z PROC ; std::get<1,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >, COMDAT

; 708  :     // get rvalue reference to element at _Idx in pair _Pr
; 709  :     if constexpr (_Idx == 0) {
; 710  :         return _STD forward<_Ty1>(_Pr.first);
; 711  :     } else {
; 712  :         return _STD forward<_Ty2>(_Pr.second);

	lea	rax, QWORD PTR [rcx+8]

; 713  :     }
; 714  : }

	ret	0
??$get@$00V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@$$QEAU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@@Z ENDP ; std::get<1,std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize<std::_Value_init_tag>, COMDAT

; 1551 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1552 :         // trim or append elements, provide strong guarantee
; 1553 :         auto& _Al           = _Getal();
; 1554 :         auto& _My_data      = _Mypair._Myval2;
; 1555 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1556 :         pointer& _Mylast    = _My_data._Mylast;
; 1557 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r9, QWORD PTR [rcx+8]
	mov	rbx, rcx
	mov	r8, QWORD PTR [rcx]
	mov	rcx, r9
	sub	rcx, r8
	sar	rcx, 5

; 1558 :         if (_Newsize < _Oldsize) { // trim

	cmp	rdx, rcx
	jae	SHORT $LN2@Resize

; 1559 :             const pointer _Newlast = _Myfirst + _Newsize;

	shl	rdx, 5
	add	rdx, r8

; 1560 :             _Orphan_range(_Newlast, _Mylast);
; 1561 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1562 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1563 :             _Mylast = _Newlast;

	mov	QWORD PTR [rbx+8], rdx

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Resize:

; 1564 :             return;
; 1565 :         }
; 1566 : 
; 1567 :         if (_Newsize > _Oldsize) { // append

	jbe	SHORT $LN3@Resize

; 1568 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, r8
	sar	rax, 5

; 1569 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rdx, rax
	jbe	SHORT $LN4@Resize

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rbx

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx

; 1570 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:

; 1571 :                 return;
; 1572 :             }
; 1573 : 
; 1574 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1575 :             const pointer _Oldlast = _Mylast;
; 1576 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1577 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1578 :             } else {
; 1579 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1580 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	sub	rdx, rcx
	mov	rcx, r9
	call	??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<bvh::Bvh<float>::Node> >
	mov	QWORD PTR [rbx+8], rax
$LN3@Resize:

; 1581 :             }
; 1582 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1583 :             _Orphan_range(_Oldlast, _Oldlast);
; 1584 :         }
; 1585 : 
; 1586 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1587 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z PROC ; std::move<std::allocator<bvh::Bvh<float>::Node> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<bvh::Bvh<float>::Node> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUNode@?$Bvh@M@bvh@@$$T@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUNode@?$Bvh@M@bvh@@$$T@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@$$QEA$$T@Z PROC ; std::exchange<bvh::Bvh<float>::Node *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUNode@?$Bvh@M@bvh@@$$T@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@$$QEA$$T@Z ENDP ; std::exchange<bvh::Bvh<float>::Node *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0V?$allocator@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@$$QEAPEAUNode@?$Bvh@M@bvh@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@$$QEAPEAUNode@?$Bvh@M@bvh@@22@Z PROC ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><std::allocator<bvh::Bvh<float>::Node>,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@PEAU234@PEAU234@@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@$$QEAPEAUNode@?$Bvh@M@bvh@@22@Z ENDP ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><std::allocator<bvh::Bvh<float>::Node>,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RU?$Vector@M$02@bvh@@$0A@@?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@QEBAXPEAU?$Vector@M$02@bvh@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RU?$Vector@M$02@bvh@@$0A@@?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@QEBAXPEAU?$Vector@M$02@bvh@@@Z PROC ; std::default_delete<bvh::Vector<float,3> [0]>::operator()<bvh::Vector<float,3>,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RU?$Vector@M$02@bvh@@$0A@@?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@QEBAXPEAU?$Vector@M$02@bvh@@@Z ENDP ; std::default_delete<bvh::Vector<float,3> [0]>::operator()<bvh::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RU?$BoundingBox@M@bvh@@$0A@@?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@QEBAXPEAU?$BoundingBox@M@bvh@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RU?$BoundingBox@M@bvh@@$0A@@?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@QEBAXPEAU?$BoundingBox@M@bvh@@@Z PROC ; std::default_delete<bvh::BoundingBox<float> [0]>::operator()<bvh::BoundingBox<float>,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RU?$BoundingBox@M@bvh@@$0A@@?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@QEBAXPEAU?$BoundingBox@M@bvh@@@Z ENDP ; std::default_delete<bvh::BoundingBox<float> [0]>::operator()<bvh::BoundingBox<float>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Unfancy_maybe_null@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z PROC ; std::_Unfancy_maybe_null<bvh::Triangle<float,1,0> >, COMDAT

; 434  :     return _Ptr;

	mov	rax, rcx

; 435  : }

	ret	0
??$_Unfancy_maybe_null@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z ENDP ; std::_Unfancy_maybe_null<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1><>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z PROC ; std::make_unique<bvh::Bvh<float>::Node [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 32					; 00000020H
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@UNode@?$Bvh@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@_K@Z ENDP ; std::make_unique<bvh::Bvh<float>::Node [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z PROC ; std::make_unique<float [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 4
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@M$0A@@std@@YA?AV?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@0@_K@Z ENDP ; std::make_unique<float [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z PROC ; std::make_unique<unsigned int [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 4
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@I$0A@@std@@YA?AV?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@0@_K@Z ENDP ; std::make_unique<unsigned int [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z PROC ; std::make_unique<unsigned char [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rcx, rdx
	mov	rdi, rdx
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@E$0A@@std@@YA?AV?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@0@_K@Z ENDP ; std::make_unique<unsigned char [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEA_K$0A@@std@@YAXAEAPEA_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEA_K$0A@@std@@YAXAEAPEA_K0@Z PROC		; std::swap<unsigned __int64 *,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEA_K$0A@@std@@YAXAEAPEA_K0@Z ENDP		; std::swap<unsigned __int64 *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
;	COMDAT ??$make_key@M$0A@@?$RadixSort@$09@bvh@@SAIM@Z
_TEXT	SEGMENT
x$ = 8
??$make_key@M$0A@@?$RadixSort@$09@bvh@@SAIM@Z PROC	; bvh::RadixSort<10>::make_key<float,0>, COMDAT

; 90   :         using U = typename SizedIntegerType<sizeof(T) * CHAR_BIT>::Unsigned;
; 91   :         using I = typename SizedIntegerType<sizeof(T) * CHAR_BIT>::Signed;
; 92   :         auto mask = U(1) << (sizeof(T) * CHAR_BIT - 1);
; 93   :         auto y = as<U>(x);
; 94   :         return (y & mask ? static_cast<U>(-static_cast<I>(y)) ^ mask : y) ^ mask;

	movd	eax, xmm0
	test	eax, eax
	jns	SHORT $LN3@make_key
	neg	eax
	btc	eax, 31
$LN3@make_key:
	btc	eax, 31

; 95   :     }

	ret	0
??$make_key@M$0A@@?$RadixSort@$09@bvh@@SAIM@Z ENDP	; bvh::RadixSort<10>::make_key<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp
;	COMDAT ??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z
_TEXT	SEGMENT
tv1502 = 32
values_copy$GSCopy$1$ = 40
values$GSCopy$1$ = 48
this$GSCopy$1$ = 56
$T1 = 64
this$ = 160
keys$ = 168
keys_copy$ = 176
values$ = 184
values_copy$ = 192
count$ = 200
bit_count$dead$ = 208
??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z PROC ; bvh::RadixSort<10>::sort_in_parallel<unsigned int,unsigned __int64>, COMDAT

; 27   :     {

$LN128:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR values_copy$[rsp]
	xor	r15d, r15d

; 28   :         bvh::assert_in_parallel();
; 29   : 
; 30   :         static constexpr size_t bucket_count = 1 << bits_per_iteration;
; 31   :         static constexpr Key mask = (Key(1) << bits_per_iteration) - 1;
; 32   : 
; 33   :         size_t thread_count = bvh::get_thread_count();
; 34   :         size_t thread_id    = bvh::get_thread_id();
; 35   : 
; 36   :         // Allocate temporary storage
; 37   :         #pragma omp single
; 38   :         {
; 39   :             size_t data_size = (thread_count + 1) * bucket_count;
; 40   :             if (per_thread_data_size < data_size) {

	cmp	QWORD PTR [rcx+8], 2048			; 00000800H
	mov	r13, r8
	mov	QWORD PTR values$GSCopy$1$[rsp], r9
	mov	rsi, rdx
	mov	rdi, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	mov	QWORD PTR values_copy$GSCopy$1$[rsp], rax
	jae	SHORT $LN20@sort_in_pa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	ecx, 16384				; 00004000H
	call	??_U@YAPEAX_K@Z				; operator new[]
	xor	edx, edx
	mov	r8d, 16384				; 00004000H
	mov	rcx, rax
	mov	rbx, rax
	call	memset

; 3381 :         if (this != _STD addressof(_Right)) {

	lea	rax, QWORD PTR $T1[rsp]
	cmp	rdi, rax
	je	SHORT $LN47@sort_in_pa
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rdi]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rcx, rcx
	je	SHORT $LN54@sort_in_pa

; 3428 :         if (_Mypair._Myval2) {

	jmp	SHORT $LN125@sort_in_pa
$LN47@sort_in_pa:

; 3194 :         delete[] _Ptr;

	mov	rcx, rbx
$LN125@sort_in_pa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 42   :                 per_thread_data_size = data_size;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN54@sort_in_pa:
	mov	QWORD PTR [rdi+8], 2048			; 00000800H
$LN20@sort_in_pa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5026 :         constexpr _Ty _Zero{};

	mov	r14, QWORD PTR count$[rsp]
	mov	edx, r15d
	sub	edx, r15d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	mov	rbp, r15
	mov	DWORD PTR tv1502[rsp], edx
	npad	9
$LL4@sort_in_pa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rbx, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5038 :         auto _UFirst      = _Get_unwrapped(_First);

	mov	rax, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 48   :             std::fill(buckets, buckets + bucket_count, 0);

	lea	rcx, QWORD PTR [rbx+8192]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	test	edx, edx

; 5048 :                 if (_Is_all_bits_zero(_Val)) {

	jne	SHORT $LN63@sort_in_pa

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	mov	r8d, 8192				; 00002000H
	mov	rcx, rbx
	call	memset

; 5050 :                     return;

	jmp	SHORT $LN60@sort_in_pa
$LN63@sort_in_pa:

; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rbx, rcx
	je	SHORT $LN60@sort_in_pa
	npad	10
$LL61@sort_in_pa:

; 5056 :             *_UFirst = _Val;

	mov	QWORD PTR [rax], r15
	add	rax, 8
	cmp	rax, rcx
	jne	SHORT $LL61@sort_in_pa
$LN60@sort_in_pa:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 51   :             for (size_t i = 0; i < count; ++i)

	mov	r8, r15
	test	r14, r14
	je	SHORT $LN6@sort_in_pa
	npad	12
$LL7@sort_in_pa:

; 52   :                 buckets[(keys[i] >> bit) & mask]++;

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rbp
	mov	edx, DWORD PTR [rax+r8*4]
	inc	r8
	shr	rdx, cl
	and	edx, 1023				; 000003ffH
	inc	QWORD PTR [rbx+rdx*8]
	cmp	r8, r14
	jb	SHORT $LL7@sort_in_pa
$LN6@sort_in_pa:

; 53   : 
; 54   :             #pragma omp for
; 55   :             for (size_t i = 0; i < bucket_count; i++) {

	mov	rax, r15
$LL10@sort_in_pa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rcx, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 60   :                     sum += per_thread_buckets[j * bucket_count + i];

	mov	rdx, QWORD PTR [rcx+rax]

; 61   :                     per_thread_buckets[j * bucket_count + i] = old_sum;

	mov	QWORD PTR [rcx+rax], r15

; 62   :                 }
; 63   :                 per_thread_buckets[thread_count * bucket_count + i] = sum;

	mov	rcx, QWORD PTR [rdi]
	mov	QWORD PTR [rcx+rax+8192], rdx
	add	rax, 8
	cmp	rax, 8192				; 00002000H
	jb	SHORT $LL10@sort_in_pa

; 64   :             }
; 65   : 
; 66   :             for (size_t i = 0, sum = 0; i < bucket_count; ++i) {

	mov	r9, r15
	lea	r8, QWORD PTR [rbx+8]
	mov	r10d, 8200				; 00002008H
	mov	r11d, 8208				; 00002010H
	sub	r10, rbx
	sub	r11, rbx
	mov	r15d, 8184				; 00001ff8H
	mov	r12d, 256				; 00000100H
	sub	r15, rbx
	npad	4
$LL16@sort_in_pa:

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	mov	rax, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	lea	rdx, QWORD PTR [r15+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 67   :                 size_t old_sum = sum;

	mov	rcx, r9

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	add	r9, QWORD PTR [rdx+rax]

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8-8], rcx
	mov	rcx, r9
	mov	rax, QWORD PTR [rdi]
	add	r9, QWORD PTR [rdx+rax+8]
	add	QWORD PTR [r8], rcx
	mov	rdx, r9
	mov	rax, QWORD PTR [rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	lea	rcx, QWORD PTR [r10+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 68   :                 sum += per_thread_buckets[thread_count * bucket_count + i];

	add	r9, QWORD PTR [rcx+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	lea	rcx, QWORD PTR [r11+r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 69   :                 buckets[i] += old_sum;

	add	QWORD PTR [r8+8], rdx
	lea	r8, QWORD PTR [r8+32]
	mov	rax, QWORD PTR [rdi]
	mov	rdx, r9
	add	r9, QWORD PTR [rcx+rax]
	add	QWORD PTR [r8-16], rdx
	sub	r12, 1
	jne	SHORT $LL16@sort_in_pa

; 70   :             }
; 71   : 
; 72   :             #pragma omp for schedule(static)
; 73   :             for (size_t i = 0; i < count; ++i) {

	xor	r15d, r15d
	mov	r9d, r15d
	test	r14, r14
	je	SHORT $LN18@sort_in_pa
	mov	r10, QWORD PTR values$GSCopy$1$[rsp]
	mov	rdi, QWORD PTR values_copy$GSCopy$1$[rsp]
$LL19@sort_in_pa:

; 74   :                 size_t j = buckets[(keys[i] >> bit) & mask]++;

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rbp
	mov	edx, DWORD PTR [rax+r9*4]
	shr	rdx, cl
	and	edx, 1023				; 000003ffH
	mov	r8, QWORD PTR [rbx+rdx*8]
	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rbx+rdx*8], rax

; 75   :                 keys_copy[j]   = keys[i];

	mov	rax, QWORD PTR [rsi]
	mov	rcx, QWORD PTR [r13]
	mov	eax, DWORD PTR [rax+r9*4]
	mov	DWORD PTR [rcx+r8*4], eax

; 76   :                 values_copy[j] = values[i];

	mov	rax, QWORD PTR [r10]
	mov	rcx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rax+r9*8]
	inc	r9
	mov	QWORD PTR [rcx+r8*8], rax
	cmp	r9, r14
	jb	SHORT $LL19@sort_in_pa
	mov	rdi, QWORD PTR this$GSCopy$1$[rsp]
$LN18@sort_in_pa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rsi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	add	rbp, 10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR [r13]
	mov	rdx, QWORD PTR values_copy$GSCopy$1$[rsp]

; 100  :     _Left    = _STD move(_Right);

	mov	r9, QWORD PTR values$GSCopy$1$[rsp]
	mov	QWORD PTR [r13], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rsi], rcx

; 99   :     _Ty _Tmp = _STD move(_Left);

	mov	rcx, QWORD PTR [rdx]

; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rdx], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	mov	edx, DWORD PTR tv1502[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [r9], rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\radix_sort.hpp

; 46   :         for (size_t bit = 0; bit < bit_count; bit += BitsPerIteration) {

	cmp	rbp, 32					; 00000020H
	jb	$LL4@sort_in_pa

; 77   :             }
; 78   : 
; 79   :             #pragma omp single
; 80   :             {
; 81   :                 std::swap(keys_copy, keys);
; 82   :                 std::swap(values_copy, values);
; 83   :             }
; 84   :         }
; 85   :     }

	add	rsp, 88					; 00000058H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??$sort_in_parallel@I_K@?$RadixSort@$09@bvh@@QEAAXAEAPEIAI0AEAPEIA_K1_K2@Z ENDP ; bvh::RadixSort<10>::sort_in_parallel<unsigned int,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
;	COMDAT ??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z
_TEXT	SEGMENT
$T1 = 32
first_item$2 = 48
stack$ = 80
more_work$3 = 128
work_item$4 = 208
new_task$5 = 240
__$ArrayPad$ = 320
this$ = 416
task$ = 424
<args_0>$ = 432
<args_1>$ = 440
<args_2>$ = 448
<args_3>$ = 456
??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z PROC ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>, COMDAT

; 47   :     void run_task(BuildTask& task, Args&&... args) {

$LN287:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-112]
	sub	rsp, 368				; 00000170H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, r9
	mov	r14, r8
	mov	rbx, rdx
	mov	r15, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR stack$[rsp+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	movdqu	XMMWORD PTR stack$[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	xor	r12d, r12d
	mov	QWORD PTR stack$[rsp+16], r12
	mov	QWORD PTR stack$[rsp+24], r12
	mov	QWORD PTR stack$[rsp+32], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r12+16]
	call	??2@YAPEAX_K@Z				; operator new

; 1206 :         _Myproxy            = _New_proxy;

	mov	QWORD PTR [rax+8], r12
	mov	QWORD PTR stack$[rsp], rax

; 1207 :         _New_proxy->_Mycont = this;

	lea	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rcx, QWORD PTR stack$[rsp+32]
	lea	rax, QWORD PTR [rcx+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN208@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	rcx, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN208@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	add	rcx, rax

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	r9, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [r9+rdi], 0
	jne	SHORT $LN209@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	r9, QWORD PTR stack$[rsp+8]
$LN209@run_task:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [r9+rdi]
	mov	rax, QWORD PTR <args_3>$[rbp-256]
	movsxd	r8, DWORD PTR [rax]
	mov	rax, QWORD PTR <args_2>$[rbp-256]
	mov	rdx, QWORD PTR [rax]
	movsxd	rcx, DWORD PTR [rsi]
	movsxd	rax, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [r9], rax
	mov	QWORD PTR [r9+8], rcx
	mov	QWORD PTR [r9+16], rdx
	mov	QWORD PTR [r9+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	add	r8, 1
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 51   :         while (!stack.empty()) {

	je	$LN3@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	lea	rax, QWORD PTR stack$[rsp]
	mov	QWORD PTR $T1[rsp], rax
$LL2@run_task:

; 955  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

	mov	rcx, QWORD PTR stack$[rsp+24]
	dec	rcx

; 67   :         --_Myoff;

	add	rcx, r8

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR [rax+16]
	dec	rdx
	and	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 99   :         return c.back();

	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR [rax+rdx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 52   :             auto work_item = stack.top();

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR work_item$4[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR work_item$4[rbp-240], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1208 :         if (--_Mysize() == 0) {

	sub	r8, 1
	mov	QWORD PTR stack$[rsp+32], r8
	jne	SHORT $LN39@run_task

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR stack$[rsp+24], r12
$LN39@run_task:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 56   :             auto more_work = task.build(work_item);

	lea	r8, QWORD PTR work_item$4[rbp-256]
	lea	rdx, QWORD PTR more_work$3[rbp-256]
	mov	rcx, rbx
	call	?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::build

; 57   :             if (more_work) {

	cmp	BYTE PTR more_work$3[rbp-192], 0
	je	$LN284@run_task

; 23   :         size_t work_size() const { return end - begin; }

	mov	rcx, QWORD PTR more_work$3[rbp-208]
	sub	rcx, QWORD PTR more_work$3[rbp-216]
	mov	rax, QWORD PTR more_work$3[rbp-240]
	sub	rax, QWORD PTR more_work$3[rbp-248]

; 58   :                 if (more_work->first.work_size() > more_work->second.work_size())

	cmp	rax, rcx
	jbe	SHORT $LN283@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movaps	xmm2, XMMWORD PTR more_work$3[rbp-256]
	movaps	xmm3, XMMWORD PTR more_work$3[rbp-240]

; 100  :     _Left    = _STD move(_Right);

	movaps	xmm0, XMMWORD PTR more_work$3[rbp-224]
	movaps	XMMWORD PTR more_work$3[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR more_work$3[rbp-208]
	movaps	XMMWORD PTR more_work$3[rbp-240], xmm1

; 101  :     _Right   = _STD move(_Tmp);

	movaps	XMMWORD PTR more_work$3[rbp-224], xmm2
	movaps	XMMWORD PTR more_work$3[rbp-208], xmm3
$LN283@run_task:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rcx, QWORD PTR stack$[rsp+32]
	lea	rax, QWORD PTR [rcx+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN54@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	rcx, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN54@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax
	add	rcx, rax

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [rax+rdi], 0
	jne	SHORT $LN55@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR stack$[rsp+8]
$LN55@run_task:

; 1157 :         }
; 1158 : 
; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rax+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movaps	xmm0, XMMWORD PTR more_work$3[rbp-224]
	movups	XMMWORD PTR [rax], xmm0
	movaps	xmm1, XMMWORD PTR more_work$3[rbp-208]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	inc	r8
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 62   :                 auto first_item = more_work->first;

	movaps	xmm6, XMMWORD PTR more_work$3[rbp-256]
	movups	XMMWORD PTR first_item$2[rsp], xmm6
	movaps	xmm7, XMMWORD PTR more_work$3[rbp-240]
	movups	XMMWORD PTR first_item$2[rsp+16], xmm7

; 23   :         size_t work_size() const { return end - begin; }

	movq	rcx, xmm7
	movdqa	xmm0, xmm6
	psrldq	xmm0, 8
	movq	rax, xmm0
	sub	rcx, rax

; 63   :                 if (first_item.work_size() > task_spawn_threshold) {

	cmp	rcx, QWORD PTR [r15]
	jbe	$LN6@run_task

; 64   :                     BuildTask new_task(task);

	movaps	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR new_task$5[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR [rbx+16]
	movaps	XMMWORD PTR new_task$5[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR [rbx+32]
	movaps	XMMWORD PTR new_task$5[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR [rbx+48]
	movaps	XMMWORD PTR new_task$5[rbp-208], xmm1
	movaps	xmm0, XMMWORD PTR [rbx+64]
	movaps	XMMWORD PTR new_task$5[rbp-192], xmm0

; 65   :                     #pragma omp task firstprivate(new_task, first_item)
; 66   :                     { run_task(new_task, first_item); }

	lea	r8, QWORD PTR first_item$2[rsp]
	lea	rdx, QWORD PTR new_task$5[rbp-256]
	mov	rcx, r15
	call	??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>
$LN284@run_task:

; 51   :         while (!stack.empty()) {

	mov	r8, QWORD PTR stack$[rsp+32]
$LN145@run_task:
	test	r8, r8
	jne	$LL2@run_task
$LN3@run_task:
	lea	rcx, QWORD PTR stack$[rsp]
	call	??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >

; 67   :                 } else {
; 68   :                     stack.push(first_item);
; 69   :                 }
; 70   :             }
; 71   :         }
; 72   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+368]
	mov	rbx, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN6@run_task:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	lea	rax, QWORD PTR [r8+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN107@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	r8, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN107@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax
	lea	rcx, QWORD PTR [r8+rax]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [rax+rdi], 0
	jne	SHORT $LN108@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR stack$[rsp+8]
$LN108@run_task:

; 1157 :         }
; 1158 : 
; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rax+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm6
	movups	XMMWORD PTR [rax+16], xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	inc	r8
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 57   :             if (more_work) {

	jmp	$LN145@run_task
	int	3
??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z ENDP ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
first_item$2 = 48
stack$ = 80
more_work$3 = 128
work_item$4 = 208
new_task$5 = 240
__$ArrayPad$ = 320
this$ = 416
task$ = 424
<args_0>$ = 432
<args_1>$ = 440
<args_2>$ = 448
<args_3>$ = 456
?dtor$0@?0???$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z@4HA PROC ; `bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>'::`1'::dtor$0
	lea	rcx, QWORD PTR stack$[rdx]
	jmp	??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@HHAEA_KH@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@$$QEAH1AEA_K1@Z@4HA ENDP ; `bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,int,int,unsigned __int64 &,int>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >, COMDAT

; 38   :     stack() = default;

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 38   :     stack() = default;

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	mov	QWORD PTR [rcx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
	mov	QWORD PTR [rcx+24], rdi
	mov	QWORD PTR [rcx+32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+16]
	call	??2@YAPEAX_K@Z				; operator new

; 1206 :         _Myproxy            = _New_proxy;

	mov	QWORD PTR [rax+8], rdi
	mov	QWORD PTR [rbx], rax

; 1207 :         _New_proxy->_Mycont = this;

	mov	QWORD PTR [rax], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 38   :     stack() = default;

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
<_Val_1>$ = 64
<_Val_2>$ = 72
<_Val_3>$ = 80
??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<int,int,unsigned __int64 &,int>, COMDAT

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

$LN74:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

	mov	rsi, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

	mov	rbp, r8
	mov	r14, rdx
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN6@emplace

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN6@emplace:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rax, QWORD PTR [rbx+16]
	dec	rax
	and	QWORD PTR [rbx+24], rax

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rcx, QWORD PTR [rbx+32]
	add	rcx, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rax

; 1155 :         if (_Map()[_Block] == nullptr) {

	mov	rax, QWORD PTR [rbx+8]
	lea	rdi, QWORD PTR [rcx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN7@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN7@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 132  :     }

	mov	rbp, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [rdi+rax]
	mov	rax, QWORD PTR <_Val_3>$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 132  :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsxd	r8, DWORD PTR [rax]
	movsxd	rax, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [r9+8], rcx
	mov	QWORD PTR [r9+16], rdx
	mov	QWORD PTR [r9], rax
	mov	QWORD PTR [r9+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rdx, QWORD PTR [rbx+24]
	dec	rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 128  :         return c.emplace_back(_STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	add	rdx, rcx
	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 132  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rcx
	and	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 128  :         return c.emplace_back(_STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rax+rdx*8]

; 132  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$emplace@HHAEA_KH@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<int,int,unsigned __int64 &,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
<_Val_1>$ = 64
<_Val_2>$ = 72
<_Val_3>$ = 80
??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<int,int,unsigned __int64 &,int>, COMDAT

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

$LN71:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	rsi, r9

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	rbp, r8
	mov	r14, rdx
	mov	rbx, rcx

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN4@emplace_ba

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN4@emplace_ba:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rcx, QWORD PTR [rbx+16]
	dec	rcx
	and	QWORD PTR [rbx+24], rcx

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rax, QWORD PTR [rbx+32]
	add	rax, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rax, rcx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rax*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN5@emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN5@emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 863  :     }

	mov	rbp, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [rdi+rax]
	mov	rax, QWORD PTR <_Val_3>$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 863  :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsxd	r8, DWORD PTR [rax]
	movsxd	rax, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [r9+16], rdx
	mov	QWORD PTR [r9], rax
	mov	QWORD PTR [r9+8], rcx
	mov	QWORD PTR [r9+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rbx+24]

; 1162 :         ++_Mysize();

	mov	rdx, QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rax
	mov	rcx, QWORD PTR [rbx+16]
	add	rdx, rax

; 857  :         _Orphan_all();
; 858  :         _Emplace_back_internal(_STD forward<_Valty>(_Val)...);
; 859  : 
; 860  : #if _HAS_CXX17
; 861  :         return back();

	mov	rax, QWORD PTR [rbx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rcx

; 863  :     }

	mov	rbx, QWORD PTR [rsp+48]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rdx, rcx

; 857  :         _Orphan_all();
; 858  :         _Emplace_back_internal(_STD forward<_Valty>(_Val)...);
; 859  : 
; 860  : #if _HAS_CXX17
; 861  :         return back();

	mov	rax, QWORD PTR [rax+rdx*8]

; 863  :     }

	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$emplace_back@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_T$$QEAH0AEA_K0@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<int,int,unsigned __int64 &,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z PROC	; bvh::operator+<float,3>, COMDAT

; 94   : Vector<Scalar, N> operator + (const Vector<Scalar, N>& a, const Vector<Scalar, N>& b) {

$LN24:
	sub	rsp, 40					; 00000028H

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm2, QWORD PTR [r8]
	mov	rax, rcx
	movsd	xmm0, QWORD PTR [rdx]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	addss	xmm0, xmm2
	addss	xmm1, DWORD PTR [rdx+4]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm1, DWORD PTR [r8+8]
	addss	xmm1, DWORD PTR [rdx+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+8], xmm1

; 96   : }

	add	rsp, 40					; 00000028H
	ret	0
??$?HM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ENDP	; bvh::operator+<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z PROC ; `bvh::operator+<float,3>'::`2'::<lambda_1>::operator(), COMDAT

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm0, DWORD PTR [rcx+rdx*4+12]
	addss	xmm0, DWORD PTR [rcx+rdx*4]
	ret	0
??R<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ENDP ; `bvh::operator+<float,3>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__b$ = 24
??0<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z PROC ; `bvh::operator+<float,3>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ENDP ; `bvh::operator+<float,3>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 32
a$ = 40
s$ = 48
??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z PROC	; bvh::operator*<float,3>, COMDAT

; 124  : Vector<Scalar, N> operator * (const Vector<Scalar, N>& a, Scalar s) {

$LN22:
	sub	rsp, 24

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	movsd	xmm3, QWORD PTR [rdx]

; 124  : Vector<Scalar, N> operator * (const Vector<Scalar, N>& a, Scalar s) {

	mov	rax, rcx

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	mov	ecx, DWORD PTR [rdx+8]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	movaps	xmm1, xmm3
	shufps	xmm1, xmm1, 85				; 00000055H
	mulss	xmm1, xmm2

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rax], xmm0

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	movd	xmm0, ecx
	mulss	xmm0, xmm2

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rax+4], xmm1
	movss	DWORD PTR [rax+8], xmm0

; 126  : }

	add	rsp, 24
	ret	0
??$?DM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@M@Z ENDP	; bvh::operator*<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEBA@_K@Z PROC ; `bvh::operator*<float,3>'::`2'::<lambda_1>::operator(), COMDAT

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	movss	xmm0, DWORD PTR [rcx+rdx*4]
	mulss	xmm0, DWORD PTR [rcx+12]
	ret	0
??R<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEBA@_K@Z ENDP ; `bvh::operator*<float,3>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEAA@0AEBM@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__s$ = 24
??0<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEAA@0AEBM@Z PROC ; `bvh::operator*<float,3>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx+12], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@QEAA@0AEBM@Z ENDP ; `bvh::operator*<float,3>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RUNode@?$Bvh@M@bvh@@$0A@@?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@QEBAXPEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RUNode@?$Bvh@M@bvh@@$0A@@?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@QEBAXPEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::default_delete<bvh::Bvh<float>::Node [0]>::operator()<bvh::Bvh<float>::Node,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RUNode@?$Bvh@M@bvh@@$0A@@?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@QEBAXPEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::default_delete<bvh::Bvh<float>::Node [0]>::operator()<bvh::Bvh<float>::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?R_K$0A@@?$default_delete@$$BY0A@_K@std@@QEBAXPEA_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?R_K$0A@@?$default_delete@$$BY0A@_K@std@@QEBAXPEA_K@Z PROC ; std::default_delete<unsigned __int64 [0]>::operator()<unsigned __int64,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?R_K$0A@@?$default_delete@$$BY0A@_K@std@@QEBAXPEA_K@Z ENDP ; std::default_delete<unsigned __int64 [0]>::operator()<unsigned __int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RE$0A@@?$default_delete@$$BY0A@E@std@@QEBAXPEAE@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RE$0A@@?$default_delete@$$BY0A@E@std@@QEBAXPEAE@Z PROC ; std::default_delete<unsigned char [0]>::operator()<unsigned char,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RE$0A@@?$default_delete@$$BY0A@E@std@@QEBAXPEAE@Z ENDP ; std::default_delete<unsigned char [0]>::operator()<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RI$0A@@?$default_delete@$$BY0A@I@std@@QEBAXPEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RI$0A@@?$default_delete@$$BY0A@I@std@@QEBAXPEAI@Z PROC ; std::default_delete<unsigned int [0]>::operator()<unsigned int,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RI$0A@@?$default_delete@$$BY0A@I@std@@QEBAXPEAI@Z ENDP ; std::default_delete<unsigned int [0]>::operator()<unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?RM$0A@@?$default_delete@$$BY0A@M@std@@QEBAXPEAM@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
??$?RM$0A@@?$default_delete@$$BY0A@M@std@@QEBAXPEAM@Z PROC ; std::default_delete<float [0]>::operator()<float,0>, COMDAT

; 3193 :         static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
; 3194 :         delete[] _Ptr;

	mov	rcx, rdx
	jmp	??_V@YAXPEAX@Z				; operator delete[]
??$?RM$0A@@?$default_delete@$$BY0A@M@std@@QEBAXPEAM@Z ENDP ; std::default_delete<float [0]>::operator()<float,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAXPEAUNode@?$Bvh@M@bvh@@QEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAXPEAUNode@?$Bvh@M@bvh@@QEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z PROC ; std::_Destroy_range<std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAXPEAUNode@?$Bvh@M@bvh@@QEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAXPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAXPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z PROC ; std::_Destroy_range<std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 1083 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1084 :     using _Ty = typename _Alloc::value_type;
; 1085 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1086 :         for (; _First != _Last; ++_First) {
; 1087 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1088 :         }
; 1089 :     }
; 1090 : }

	ret	0
??$_Destroy_range@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAXPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::~stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >, COMDAT
	jmp	??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >
??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::~stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	mov	QWORD PTR [rcx+32], rax
	ret	0
?__autoclassinit2@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ?pop@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXXZ PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::pop, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1208 :         if (--_Mysize() == 0) {

	sub	QWORD PTR [rcx+32], 1
	jne	SHORT $LN4@pop

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR [rcx+24], 0
$LN4@pop:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 136  :     }

	ret	0
?pop@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::push, COMDAT

; 106  :     void push(const value_type& _Val) {

$LN52:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 106  :     void push(const value_type& _Val) {

	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 106  :     void push(const value_type& _Val) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN6@push

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN6@push:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rax, QWORD PTR [rbx+16]
	dec	rax
	and	QWORD PTR [rbx+24], rax

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rcx, QWORD PTR [rbx+32]
	add	rcx, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rax

; 1155 :         if (_Map()[_Block] == nullptr) {

	mov	rax, QWORD PTR [rbx+8]
	lea	rdi, QWORD PTR [rcx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN7@push
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN7@push:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 108  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 108  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ?top@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?top@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::top, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rdx, QWORD PTR [rcx+32]
	mov	r8, QWORD PTR [rcx+24]
	dec	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 99   :         return c.back();

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	add	r8, rdx
	mov	rdx, QWORD PTR [rcx+16]
	dec	rdx
	and	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 99   :         return c.back();

	mov	rax, QWORD PTR [rax+r8*8]

; 100  :     }

	ret	0
?top@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ?empty@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBA_NXZ PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::empty, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1045 :         return _Mysize() == 0;

	cmp	QWORD PTR [rcx+32], 0
	sete	al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 92   :     }

	ret	0
?empty@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBA_NXZ ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Orphan_all@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Orphan_all, COMDAT

; 1633 :         _Get_data()._Orphan_all();
; 1634 :     }

	ret	0
?_Orphan_all@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::back, COMDAT

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rdx, QWORD PTR [rcx+32]
	mov	r8, QWORD PTR [rcx+24]
	dec	rdx

; 1101 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1102 :         _STL_VERIFY(!empty(), "back() called on empty deque");
; 1103 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1104 : 
; 1105 :         return *_Prev_iter(_Unchecked_end());

	mov	rax, QWORD PTR [rcx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	add	r8, rdx
	mov	rdx, QWORD PTR [rcx+16]
	dec	rdx
	and	r8, rdx

; 1101 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1102 :         _STL_VERIFY(!empty(), "back() called on empty deque");
; 1103 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1104 : 
; 1105 :         return *_Prev_iter(_Unchecked_end());

	mov	rax, QWORD PTR [rax+r8*8]

; 1106 :     }

	ret	0
?back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 904  :     ~deque() noexcept {

$LN128:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 1045 :         return _Mysize() == 0;

	mov	rax, QWORD PTR [rcx+32]
	xor	esi, esi

; 904  :     ~deque() noexcept {

	mov	rbx, rcx

; 1045 :         return _Mysize() == 0;

	test	rax, rax

; 1588 :         while (!empty()) {

	je	SHORT $LN116@deque
	npad	8
$LL4@deque:

; 1208 :         if (--_Mysize() == 0) {

	sub	rax, 1
	mov	QWORD PTR [rcx+32], rax
	jne	SHORT $LL4@deque

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR [rcx+24], rsi
$LN116@deque:

; 1592 :         if (_Map() != nullptr) {

	cmp	QWORD PTR [rcx+8], rsi
	je	SHORT $LN115@deque
	mov	QWORD PTR [rsp+56], rdi

; 1593 :             for (size_type _Block = _Mapsize(); _Block > 0;) { // free storage for a block and destroy pointer

	mov	rdi, QWORD PTR [rcx+16]
	test	rdi, rdi
	je	SHORT $LN7@deque
	npad	14
$LL6@deque:

; 1594 :                 if (_Map()[--_Block]) { // free block

	mov	rax, QWORD PTR [rbx+8]
	dec	rdi
	mov	rcx, QWORD PTR [rax+rdi*8]
	test	rcx, rcx
	je	SHORT $LN45@deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN45@deque:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1593 :             for (size_type _Block = _Mapsize(); _Block > 0;) { // free storage for a block and destroy pointer

	test	rdi, rdi
	jne	SHORT $LL6@deque
$LN7@deque:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR [rbx+16]
	mov	rcx, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rsp+56]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@deque

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN34@deque

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN37@deque:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN115@deque:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rbx], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1603 :         _Mapsize() = 0;

	mov	QWORD PTR [rbx+16], rsi

; 1604 :         _Map()     = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 908  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN34@deque:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN125@deque:
??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 614  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

$LN53:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 614  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	mov	QWORD PTR [rcx], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
	mov	QWORD PTR [rcx+24], rdi
	mov	QWORD PTR [rcx+32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rdi+16]
	call	??2@YAPEAX_K@Z				; operator new

; 1206 :         _Myproxy            = _New_proxy;

	mov	QWORD PTR [rax+8], rdi
	mov	QWORD PTR [rbx], rax

; 1207 :         _New_proxy->_Mycont = this;

	mov	QWORD PTR [rax], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 616  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@00@Z PROC ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAXPEAUNode@?$Bvh@M@bvh@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAXPEAUNode@?$Bvh@M@bvh@@0@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAXPEAUNode@?$Bvh@M@bvh@@0@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAA@XZ PROC	; std::allocator<bvh::Bvh<float>::Node>::allocator<bvh::Bvh<float>::Node>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAA@XZ ENDP	; std::allocator<bvh::Bvh<float>::Node>::allocator<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??A?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAAEAU?$Vector@M$02@bvh@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Idx$ = 16
??A?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAAEAU?$Vector@M$02@bvh@@_K@Z PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::operator[], COMDAT

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*4]

; 3443 :     }

	ret	0
??A?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEBAAEAU?$Vector@M$02@bvh@@_K@Z ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??A?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAAEAU?$BoundingBox@M@bvh@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Idx$ = 16
??A?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAAEAU?$BoundingBox@M@bvh@@_K@Z PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::operator[], COMDAT

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]

; 3443 :     }

	ret	0
??A?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEBAAEAU?$BoundingBox@M@bvh@@_K@Z ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
;	COMDAT ?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ PROC ; bvh::Triangle<float,1,0>::center, COMDAT

; 50   :     Vector3<Scalar> center() const {

$LN112:
	sub	rsp, 72					; 00000048H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	mov	r10d, DWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 51   :         return (p0 + p1() + p2()) * (Scalar(1.0) / Scalar(3.0));

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm4, QWORD PTR [rcx+12]

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	mov	r9d, DWORD PTR [rcx+32]

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	mov	r8d, DWORD PTR [rcx+20]
	movaps	XMMWORD PTR [rsp+48], xmm7

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm7, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rsp+32], xmm8
	movsd	xmm8, QWORD PTR [rcx]

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm2, xmm8

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movaps	xmm0, xmm8

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm1, xmm2

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	addss	xmm0, xmm7

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm3, xmm2
	subss	xmm1, xmm4
	shufps	xmm3, xmm3, 85				; 00000055H

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	addss	xmm1, xmm2
	addss	xmm1, xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm4
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm3, xmm0

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 52   :     }

	movaps	xmm8, XMMWORD PTR [rsp+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	shufps	xmm0, xmm0, 85				; 00000055H

; 53   :             values[i] = f(i);

	mulss	xmm1, DWORD PTR __real@3eaaaaab
	movss	DWORD PTR [rdx], xmm1
	movaps	xmm1, xmm2

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movaps	xmm2, xmm7

; 53   :             values[i] = f(i);

	shufps	xmm1, xmm1, 85				; 00000055H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 52   :     }

	movaps	xmm7, XMMWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	addss	xmm3, xmm1

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	shufps	xmm2, xmm2, 85				; 00000055H
	addss	xmm2, xmm0

; 53   :             values[i] = f(i);

	movd	xmm1, r10d

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm0, r8d

; 53   :             values[i] = f(i);

	addss	xmm3, xmm2

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movd	xmm2, r9d

; 53   :             values[i] = f(i);

	mulss	xmm3, DWORD PTR __real@3eaaaaab
	movss	DWORD PTR [rdx+4], xmm3

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm3, r10d
	subss	xmm3, xmm0

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movd	xmm0, r10d
	addss	xmm2, xmm0

; 53   :             values[i] = f(i);

	addss	xmm3, xmm1
	addss	xmm3, xmm2
	mulss	xmm3, DWORD PTR __real@3eaaaaab
	movss	DWORD PTR [rdx+8], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 52   :     }

	add	rsp, 72					; 00000048H
	ret	0
?center@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ENDP ; bvh::Triangle<float,1,0>::center
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
;	COMDAT ?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ
_TEXT	SEGMENT
this$ = 144
__$ReturnUdt$ = 152
?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ PROC ; bvh::Triangle<float,1,0>::bounding_box, COMDAT

; 43   :     BoundingBox<Scalar> bounding_box() const {

$LN149:
	mov	r11, rsp
	sub	rsp, 136				; 00000088H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 47   :         return bbox;

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm1, QWORD PTR [rcx+12]

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm5, DWORD PTR [rcx+32]

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm1

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	addss	xmm5, DWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rsp+112], xmm6

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	shufps	xmm0, xmm0, 85				; 00000055H
	movaps	XMMWORD PTR [rsp+96], xmm7

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movaps	xmm7, xmm3
	movaps	XMMWORD PTR [r11-56], xmm8

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movaps	xmm8, xmm7
	movaps	XMMWORD PTR [r11-72], xmm9

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm9, QWORD PTR [rcx]
	movaps	XMMWORD PTR [r11-88], xmm10
	subss	xmm9, xmm1
	movss	xmm10, DWORD PTR [rcx+8]
	subss	xmm10, DWORD PTR [rcx+20]
	movaps	XMMWORD PTR [r11-104], xmm11
	movsd	xmm11, QWORD PTR [rcx]
	shufps	xmm11, xmm11, 85			; 00000055H

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movaps	xmm1, xmm9

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	subss	xmm11, xmm0

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm0, QWORD PTR [rcx+24]
	addss	xmm8, xmm0
	movaps	xmm6, xmm0

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	minss	xmm1, xmm3

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	shufps	xmm6, xmm6, 85				; 00000055H
	movaps	xmm0, xmm7

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	maxss	xmm9, xmm7

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	shufps	xmm0, xmm0, 85				; 00000055H
	addss	xmm6, xmm0

; 53   :             values[i] = f(i);

	movaps	xmm2, xmm11
	movaps	xmm0, xmm3

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movaps	xmm4, xmm8

; 53   :             values[i] = f(i);

	shufps	xmm0, xmm0, 85				; 00000055H

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	minss	xmm4, xmm1

; 53   :             values[i] = f(i);

	minss	xmm2, xmm0
	movaps	xmm1, xmm10
	maxss	xmm10, DWORD PTR [rcx+8]
	minss	xmm1, DWORD PTR [rcx+8]
	movaps	xmm3, xmm6

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	maxss	xmm8, xmm9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm9, XMMWORD PTR [r11-72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 30   :         min = bvh::min(min, v);

	movaps	xmm0, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	minss	xmm3, xmm2
	movaps	xmm2, xmm5
	maxss	xmm5, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm10, XMMWORD PTR [r11-88]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	minss	xmm2, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 30   :         min = bvh::min(min, v);

	unpcklps xmm0, xmm3
	movsd	QWORD PTR [rdx], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movaps	xmm0, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm7, XMMWORD PTR [rsp+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	shufps	xmm0, xmm0, 85				; 00000055H
	maxss	xmm11, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 30   :         min = bvh::min(min, v);

	movss	DWORD PTR [rdx+8], xmm2

; 31   :         max = bvh::max(max, v);

	movaps	xmm0, xmm8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm8, XMMWORD PTR [r11-56]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	maxss	xmm6, xmm11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm11, XMMWORD PTR [r11-104]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 31   :         max = bvh::max(max, v);

	unpcklps xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	movaps	xmm6, XMMWORD PTR [rsp+112]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 31   :         max = bvh::max(max, v);

	movsd	QWORD PTR [rdx+12], xmm0
	movss	DWORD PTR [rdx+20], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 48   :     }

	add	rsp, 136				; 00000088H
	ret	0
?bounding_box@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$BoundingBox@M@2@XZ ENDP ; bvh::Triangle<float,1,0>::bounding_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAA@XZ PROC ; std::allocator<bvh::Triangle<float,1,0> >::allocator<bvh::Triangle<float,1,0> >, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAA@XZ ENDP ; std::allocator<bvh::Triangle<float,1,0> >::allocator<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z
_TEXT	SEGMENT
left_bbox$4$ = 48
left_bbox$3$ = 52
$T1 = 56
$T2 = 56
$T3 = 56
other_axis$$sroa$1841$1$ = 80
other_axis$$sroa$1561$1$ = 84
__$ReturnUdt$GSCopy$1$ = 88
bvh$1$ = 104
right_bbox$3$ = 112
s$ = 112
s$ = 112
s$ = 112
s$ = 112
d$4 = 120
$T5 = 120
$T6 = 120
left_bbox$ = 136
right_bbox$ = 160
$T7 = 184
best_splits$ = 184
__$ArrayPad$ = 248
this$ = 336
__$ReturnUdt$ = 344
item$ = 352
?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z PROC ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::build, COMDAT

; 167  :     std::optional<std::pair<WorkItem, WorkItem>> build(const WorkItem& item) {

$LN467:
	mov	r11, rsp
	push	rbp
	push	rbx
	push	rdi
	push	r13
	push	r15
	lea	rbp, QWORD PTR [r11-72]
	sub	rsp, 288				; 00000120H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rdi, r8
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rdx

; 168  :         auto& bvh  = builder.bvh;

	mov	r8, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	r13, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	r15, QWORD PTR [rdi]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 168  :         auto& bvh  = builder.bvh;

	mov	rax, QWORD PTR [r8+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 23   :         size_t work_size() const { return end - begin; }

	mov	rcx, QWORD PTR [rdi+16]
	mov	rdx, QWORD PTR [rdi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	shl	r15, 5
	add	r15, QWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 168  :         auto& bvh  = builder.bvh;

	mov	QWORD PTR bvh$1$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 23   :         size_t work_size() const { return end - begin; }

	mov	rax, rcx
	sub	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 176  :         if (item.work_size() <= 1 || item.depth >= builder.max_depth) {

	cmp	rax, 1
	jbe	$LN18@build
	mov	rax, QWORD PTR [r8+8]
	cmp	QWORD PTR [rdi+24], rax
	jae	$LN18@build
	mov	QWORD PTR [r11+32], rsi

; 187  :             best_splits[axis] = find_split(axis, item.begin, item.end);

	mov	r9, rdx
	mov	QWORD PTR [r11-48], r12
	lea	rdx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+32], rcx
	xor	r8d, r8d
	mov	QWORD PTR [r11-56], r14
	mov	rcx, rbx
	movaps	XMMWORD PTR [r11-72], xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 224  :         : first(), second() {}

	mov	DWORD PTR best_splits$[rbp-224], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 187  :             best_splits[axis] = find_split(axis, item.begin, item.end);

	call	?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split
	mov	r9, QWORD PTR [rdi+8]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	r12d, 1
	mov	rcx, rbx
	mov	r8d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 340  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR best_splits$[rbp-256], xmm0

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR best_splits$[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 187  :             best_splits[axis] = find_split(axis, item.begin, item.end);

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rsp+32], rax
	call	?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split
	mov	r9, QWORD PTR [rdi+8]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	esi, 2
	mov	rcx, rbx
	mov	r8d, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 340  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR [rax]
	movss	DWORD PTR best_splits$[rbp-240], xmm0

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR best_splits$[rbp-232], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 187  :             best_splits[axis] = find_split(axis, item.begin, item.end);

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rsp+32], rax
	call	?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split

; 190  :         if (best_splits[0].first > best_splits[1].first)

	movss	xmm0, DWORD PTR best_splits$[rbp-256]
	xor	r9d, r9d
	comiss	xmm0, DWORD PTR best_splits$[rbp-240]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 23   :         size_t work_size() const { return end - begin; }

	mov	rdx, QWORD PTR [rdi+16]
	mov	r10, rdx
	mov	r8, QWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 198  :         auto max_split_cost = node.bounding_box_proxy().half_area() *

	mov	r11, QWORD PTR [rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 340  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm1, DWORD PTR [rax]
	movss	DWORD PTR best_splits$[rbp-224], xmm1

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	rax, QWORD PTR [rax+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 190  :         if (best_splits[0].first > best_splits[1].first)

	cmova	r9d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	QWORD PTR best_splits$[rbp-216], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	xmm4, DWORD PTR [r15+12]
	movss	xmm3, DWORD PTR [r15+4]

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	xmm5, DWORD PTR [r15+20]

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm2, xmm3
	subss	xmm2, DWORD PTR [r15]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 192  :         if (best_splits[best_axis].first > best_splits[2].first)

	mov	eax, r9d
	add	rax, rax
	movss	xmm0, DWORD PTR best_splits$[rbp+rax*8-256]
	comiss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movaps	xmm1, xmm4
	movaps	xmm0, xmm5
	subss	xmm1, DWORD PTR [r15+8]
	subss	xmm0, DWORD PTR [r15+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 192  :         if (best_splits[best_axis].first > best_splits[2].first)

	cmova	r9d, esi

; 195  :         auto split_index = best_splits[best_axis].second;

	mov	r14d, r9d
	add	r14, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 23   :         size_t work_size() const { return end - begin; }

	sub	r10, r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 200  :         if (best_splits[best_axis].first >= max_split_cost) {

	movaps	xmm6, xmm1
	addss	xmm6, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm1, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 195  :         auto split_index = best_splits[best_axis].second;

	mov	rsi, QWORD PTR best_splits$[rbp+r14*8-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 198  :         auto max_split_cost = node.bounding_box_proxy().half_area() *

	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	addss	xmm6, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 198  :         auto max_split_cost = node.bounding_box_proxy().half_area() *

	js	SHORT $LN445@build
	cvtsi2ss xmm0, r10
	jmp	SHORT $LN446@build
$LN445@build:
	mov	rax, r10
	mov	rcx, r10
	shr	rcx, 1
	and	eax, r12d
	or	rcx, rax
	cvtsi2ss xmm0, rcx
	addss	xmm0, xmm0
$LN446@build:
	subss	xmm0, DWORD PTR [r11+24]
	mulss	xmm6, xmm0

; 200  :         if (best_splits[best_axis].first >= max_split_cost) {

	movss	xmm0, DWORD PTR best_splits$[rbp+r14*8-256]
	comiss	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+256]
	jb	SHORT $LN430@build

; 201  :             if (item.work_size() > builder.max_leaf_size) {

	cmp	r10, QWORD PTR [r11+16]
	jbe	$LN22@build
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	subss	xmm3, DWORD PTR [r15]

; 53   :             values[i] = f(i);

	subss	xmm4, DWORD PTR [r15+8]
	subss	xmm5, DWORD PTR [r15+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 55   :         unsigned axis = 0;

	xor	r9d, r9d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 204  :                 split_index = (item.begin + item.end) / 2;

	lea	rsi, QWORD PTR [r8+rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 57   :         if (d[axis] < d[2]) axis = 2;

	mov	eax, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	DWORD PTR d$4[rsp], xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 55   :         unsigned axis = 0;

	comiss	xmm4, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	DWORD PTR d$4[rsp+4], xmm4
	movss	DWORD PTR d$4[rbp-248], xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 56   :         if (d[0] < d[1]) axis = 1;

	cmova	r9d, r12d

; 57   :         if (d[axis] < d[2]) axis = 2;

	comiss	xmm5, DWORD PTR d$4[rsp+r9*4]
	cmova	r9d, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 204  :                 split_index = (item.begin + item.end) / 2;

	shr	rsi, 1
$LN430@build:

; 208  :             }
; 209  :         }
; 210  : 
; 211  :         unsigned other_axis[2] = { (best_axis + 1) % 3, (best_axis + 2) % 3 };

	lea	r10d, DWORD PTR [r9+1]
	mov	r14d, r9d
	mov	eax, -1431655765			; aaaaaaabH
	mul	r10d
	mov	eax, -1431655765			; aaaaaaabH
	shr	edx, 1
	lea	ecx, DWORD PTR [rdx+rdx*2]
	sub	r10d, ecx
	lea	ecx, DWORD PTR [r9+2]
	mul	ecx
	mov	DWORD PTR other_axis$$sroa$1841$1$[rsp], r10d
	shr	edx, 1
	lea	eax, DWORD PTR [rdx+rdx*2]
	sub	ecx, eax
	mov	DWORD PTR other_axis$$sroa$1561$1$[rsp], ecx

; 212  : 
; 213  :         for (size_t i = item.begin;  i < split_index; ++i) marks[references[best_axis][i]] = 1;

	cmp	r8, rsi
	jae	SHORT $LN431@build
	npad	8
$LL7@build:
	mov	rax, QWORD PTR [rbx+r9*8+24]
	mov	rcx, QWORD PTR [rax+r8*8]
	inc	r8
	mov	rax, QWORD PTR [rbx+72]
	mov	BYTE PTR [rcx+rax], r12b
	cmp	r8, rsi
	jb	SHORT $LL7@build
$LN431@build:

; 214  :         for (size_t i = split_index; i < item.end;    ++i) marks[references[best_axis][i]] = 0;

	mov	rdx, rsi
	cmp	rsi, QWORD PTR [rdi+16]
	jae	SHORT $LN9@build
	npad	14
$LL10@build:
	mov	rax, QWORD PTR [rbx+r9*8+24]
	mov	rcx, QWORD PTR [rax+rdx*8]
	inc	rdx
	mov	rax, QWORD PTR [rbx+72]
	mov	BYTE PTR [rcx+rax], 0
	cmp	rdx, QWORD PTR [rdi+16]
	jb	SHORT $LL10@build
$LN9@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T2[rsp+12]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], 2139095039		; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T6[rbp-244]
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	mov	eax, DWORD PTR $T6[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T6[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T5[rbp-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	QWORD PTR left_bbox$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rcx, QWORD PTR $T5[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T2[rsp]
	mov	DWORD PTR left_bbox$4$[rsp], eax
	mov	DWORD PTR left_bbox$[rbp-248], eax
	mov	eax, DWORD PTR $T2[rsp+8]
	movsd	QWORD PTR left_bbox$[rbp-244], xmm0
	mov	DWORD PTR left_bbox$3$[rsp], eax
	mov	DWORD PTR left_bbox$[rbp-236], eax

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], 2139095039		; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T1[rsp+12]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	mov	eax, DWORD PTR $T5[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 224  :             { std::stable_partition(references[other_axis[0]] + item.begin, references[other_axis[0]] + item.end, partition_predicate); }

	mov	r8, rbx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T1[rsp]
	mov	r12d, DWORD PTR $T1[rsp+8]
	mov	DWORD PTR right_bbox$3$[rsp], eax
	mov	DWORD PTR right_bbox$[rbp-236], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 224  :             { std::stable_partition(references[other_axis[0]] + item.begin, references[other_axis[0]] + item.end, partition_predicate); }

	mov	eax, DWORD PTR other_axis$$sroa$1841$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	QWORD PTR right_bbox$[rbp-256], xmm0
	movsd	xmm0, QWORD PTR $T5[rsp]
	mov	DWORD PTR right_bbox$[rbp-248], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 224  :             { std::stable_partition(references[other_axis[0]] + item.begin, references[other_axis[0]] + item.end, partition_predicate); }

	mov	rcx, QWORD PTR [rbx+rax*8+24]
	mov	rax, QWORD PTR [rdi+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	QWORD PTR right_bbox$[rbp-244], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 224  :             { std::stable_partition(references[other_axis[0]] + item.begin, references[other_axis[0]] + item.end, partition_predicate); }

	lea	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	call	??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ; std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >

; 225  :             #pragma omp task if (should_spawn_tasks) default(shared)
; 226  :             { std::stable_partition(references[other_axis[1]] + item.begin, references[other_axis[1]] + item.end, partition_predicate); }

	mov	eax, DWORD PTR other_axis$$sroa$1561$1$[rsp]
	mov	r8, rbx
	mov	rcx, QWORD PTR [rbx+rax*8+24]
	mov	rax, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [rcx+rax*8]
	call	??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ; std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rcx, QWORD PTR [rdi+8]

; 229  :                 for (size_t i = item.begin; i < split_index; ++i)

	cmp	rcx, rsi
	jae	$LN444@build

; 230  :                     left_bbox.extend(bboxes[references[best_axis][i]]);

	mov	rax, QWORD PTR [rbx+r14*8+24]
	mov	r8, rsi
	mov	rdx, QWORD PTR [rbx+8]
	sub	r8, rcx
	lea	r9, QWORD PTR [rax+rcx*8]
	npad	2
$LL13@build:
	mov	rax, QWORD PTR [r9]
	lea	r9, QWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [rdx+rcx*8]
	movss	xmm2, DWORD PTR [rdx+rcx*8+4]
	movss	xmm1, DWORD PTR [rdx+rcx*8+8]
	minss	xmm0, DWORD PTR left_bbox$[rbp-256]
	minss	xmm2, DWORD PTR left_bbox$[rbp-252]
	minss	xmm1, DWORD PTR left_bbox$[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	unpcklps xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm2, DWORD PTR [rdx+rcx*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movsd	QWORD PTR left_bbox$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [rdx+rcx*8+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movss	DWORD PTR left_bbox$4$[rsp], xmm1
	movss	DWORD PTR left_bbox$[rbp-248], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm1, DWORD PTR [rdx+rcx*8+20]
	maxss	xmm0, DWORD PTR left_bbox$[rbp-244]
	maxss	xmm2, DWORD PTR left_bbox$[rbp-240]
	maxss	xmm1, DWORD PTR left_bbox$[rbp-236]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	unpcklps xmm0, xmm2
	movsd	QWORD PTR left_bbox$[rbp-244], xmm0
	movss	DWORD PTR left_bbox$3$[rsp], xmm1
	movss	DWORD PTR left_bbox$[rbp-236], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 229  :                 for (size_t i = item.begin; i < split_index; ++i)

	sub	r8, 1
	jne	SHORT $LL13@build
$LN444@build:

; 234  :                 for (size_t i = split_index; i < item.end; ++i)

	mov	r8, QWORD PTR [rdi+16]
	cmp	rsi, r8
	jae	$LN15@build

; 235  :                     right_bbox.extend(bboxes[references[best_axis][i]]);

	mov	rax, QWORD PTR [rbx+r14*8+24]
	sub	r8, rsi
	mov	rdx, QWORD PTR [rbx+8]
	lea	r9, QWORD PTR [rax+rsi*8]
	npad	11
$LL16@build:
	mov	rax, QWORD PTR [r9]
	lea	r9, QWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [rdx+rcx*8]
	movss	xmm2, DWORD PTR [rdx+rcx*8+4]
	movss	xmm1, DWORD PTR [rdx+rcx*8+8]
	minss	xmm0, DWORD PTR right_bbox$[rbp-256]
	minss	xmm2, DWORD PTR right_bbox$[rbp-252]
	minss	xmm1, DWORD PTR right_bbox$[rbp-248]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	unpcklps xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm2, DWORD PTR [rdx+rcx*8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movsd	QWORD PTR right_bbox$[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [rdx+rcx*8+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movd	r12d, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm1, DWORD PTR [rdx+rcx*8+20]
	maxss	xmm0, DWORD PTR right_bbox$[rbp-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	mov	DWORD PTR right_bbox$[rbp-248], r12d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	maxss	xmm2, DWORD PTR right_bbox$[rbp-240]
	maxss	xmm1, DWORD PTR right_bbox$[rbp-236]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	unpcklps xmm0, xmm2
	movsd	QWORD PTR right_bbox$[rbp-244], xmm0
	movss	DWORD PTR right_bbox$3$[rsp], xmm1
	movss	DWORD PTR right_bbox$[rbp-236], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 234  :                 for (size_t i = split_index; i < item.end; ++i)

	sub	r8, 1
	jne	SHORT $LL16@build
	mov	r13, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
$LN15@build:

; 242  :         { first_child = bvh.node_count; bvh.node_count += 2; }

	mov	rcx, QWORD PTR bvh$1$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 42   :                 node.bounds[0] = bbox.min[0];

	movss	xmm0, DWORD PTR left_bbox$[rbp-256]

; 43   :                 node.bounds[1] = bbox.max[0];

	movss	xmm1, DWORD PTR left_bbox$[rbp-244]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 242  :         { first_child = bvh.node_count; bvh.node_count += 2; }

	mov	rdx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	mov	rax, rdx
	mov	rcx, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 246  :         node.first_child_or_primitive = static_cast<IndexType>(first_child);

	mov	DWORD PTR [r15+28], edx

; 247  :         node.primitive_count          = 0;

	mov	DWORD PTR [r15+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3442 :         return _Mypair._Myval2[_Idx];

	shl	rax, 5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 42   :                 node.bounds[0] = bbox.min[0];

	movss	DWORD PTR [rax+rcx], xmm0

; 43   :                 node.bounds[1] = bbox.max[0];

	movss	DWORD PTR [rax+rcx+4], xmm1

; 44   :                 node.bounds[2] = bbox.min[1];

	movss	xmm0, DWORD PTR left_bbox$[rbp-252]

; 45   :                 node.bounds[3] = bbox.max[1];

	movss	xmm1, DWORD PTR left_bbox$[rbp-240]
	movss	DWORD PTR [rax+rcx+8], xmm0
	movss	DWORD PTR [rax+rcx+12], xmm1

; 46   :                 node.bounds[4] = bbox.min[2];

	movss	xmm0, DWORD PTR left_bbox$4$[rsp]

; 47   :                 node.bounds[5] = bbox.max[2];

	movss	xmm1, DWORD PTR left_bbox$3$[rsp]
	movss	DWORD PTR [rax+rcx+16], xmm0

; 42   :                 node.bounds[0] = bbox.min[0];

	movss	xmm0, DWORD PTR right_bbox$[rbp-256]

; 47   :                 node.bounds[5] = bbox.max[2];

	movss	DWORD PTR [rax+rcx+20], xmm1

; 43   :                 node.bounds[1] = bbox.max[0];

	movss	xmm1, DWORD PTR right_bbox$[rbp-244]
	movss	DWORD PTR [rax+rcx+36], xmm1

; 45   :                 node.bounds[3] = bbox.max[1];

	movss	xmm1, DWORD PTR right_bbox$[rbp-240]
	movss	DWORD PTR [rax+rcx+44], xmm1

; 47   :                 node.bounds[5] = bbox.max[2];

	movss	xmm1, DWORD PTR right_bbox$3$[rsp]
	movss	DWORD PTR [rax+rcx+32], xmm0
	movss	xmm0, DWORD PTR right_bbox$[rbp-252]
	movss	DWORD PTR [rax+rcx+52], xmm1
	movss	DWORD PTR [rax+rcx+40], xmm0
	mov	DWORD PTR [rax+rcx+48], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdi+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 251  :         WorkItem first_item (first_child + 0, item.begin, split_index, item.depth + 1);

	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-248], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 251  :         WorkItem first_item (first_child + 0, item.begin, split_index, item.depth + 1);

	inc	rcx

; 252  :         WorkItem second_item(first_child + 1, split_index, item.end,   item.depth + 1);

	lea	rax, QWORD PTR [rdx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-256], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR $T7[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 252  :         WorkItem second_item(first_child + 1, split_index, item.end,   item.depth + 1);

	mov	QWORD PTR $T7[rbp-224], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [r13], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-232], rcx
	mov	QWORD PTR $T7[rbp-240], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm1, XMMWORD PTR $T7[rbp-240]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-216], rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR $T7[rbp-224]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-208], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [r13+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T7[rbp-200], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm1, XMMWORD PTR $T7[rbp-208]
	mov	BYTE PTR [r13+64], 1
	movups	XMMWORD PTR [r13+32], xmm0
	movups	XMMWORD PTR [r13+48], xmm1
$LN463@build:
	mov	r12, QWORD PTR [rsp+280]
	mov	rsi, QWORD PTR [rsp+360]
	mov	r14, QWORD PTR [rsp+272]
$LN464@build:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 254  :     }

	mov	rax, r13
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 288				; 00000120H
	pop	r15
	pop	r13
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
$LN22@build:

; 173  :             node.primitive_count          = static_cast<IndexType>(end - begin);

	sub	edx, r8d
	mov	DWORD PTR [r15+28], r8d
	mov	DWORD PTR [r15+24], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [r13+64], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 207  :                 return std::nullopt;

	jmp	SHORT $LN463@build
$LN18@build:

; 173  :             node.primitive_count          = static_cast<IndexType>(end - begin);

	sub	ecx, edx
	mov	DWORD PTR [r15+28], edx
	mov	DWORD PTR [r15+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [r13+64], 0
	jmp	SHORT $LN464@build
?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z ENDP ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ??R<lambda_1>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@AEAUNode@?$Bvh@M@3@_K2@Z
_TEXT	SEGMENT
this$dead$ = 8
node$ = 16
begin$ = 24
end$ = 32
??R<lambda_1>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@AEAUNode@?$Bvh@M@3@_K2@Z PROC ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_1>::operator(), COMDAT

; 172  :             node.first_child_or_primitive = static_cast<IndexType>(begin);
; 173  :             node.primitive_count          = static_cast<IndexType>(end - begin);

	sub	r9d, r8d
	mov	DWORD PTR [rdx+28], r8d
	mov	DWORD PTR [rdx+24], r9d

; 174  :         };

	ret	0
??R<lambda_1>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@AEAUNode@?$Bvh@M@3@_K2@Z ENDP ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ??R<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@_K@Z PROC ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::operator(), COMDAT

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+72]
	cmp	BYTE PTR [rdx+rcx], 0
	setne	al
	ret	0
??R<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEBA@_K@Z ENDP ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ??0<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEAA@PEAV23@@Z
_TEXT	SEGMENT
this$ = 8
_This$ = 16
??0<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEAA@PEAV23@@Z PROC ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::<lambda_2>, COMDAT

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@3@@Z@QEAA@PEAV23@@Z ENDP ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::<lambda_2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
s$ = 64
s$ = 64
__$ArrayPad$ = 72
__$ReturnUdt$ = 96
?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ PROC		; bvh::BoundingBox<float>::empty, COMDAT

; 78   :     bvh_always_inline static BoundingBox empty() {

$LN15:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rcx, QWORD PTR $T2[rsp]
	lea	r8, QWORD PTR s$[rsp]
	lea	rdx, QWORD PTR $T2[rsp+12]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	lea	r8, QWORD PTR s$[rsp]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rsp], 2139095039		; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T1[rsp+12]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T1[rsp]

; 79   :         return BoundingBox(

	mov	rax, rbx

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	mov	ecx, DWORD PTR $T1[rsp+8]
	movsd	QWORD PTR [rbx], xmm0
	movsd	xmm0, QWORD PTR $T2[rsp]
	mov	DWORD PTR [rbx+8], ecx
	mov	ecx, DWORD PTR $T2[rsp+8]
	movsd	QWORD PTR [rbx+12], xmm0
	mov	DWORD PTR [rbx+20], ecx

; 80   :             Vector3<Scalar>(std::numeric_limits<Scalar>::max()),
; 81   :             Vector3<Scalar>(-std::numeric_limits<Scalar>::max()));
; 82   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?empty@?$BoundingBox@M@bvh@@SA?AU12@XZ ENDP		; bvh::BoundingBox<float>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z
_TEXT	SEGMENT
this$ = 48
bbox$ = 56
?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z PROC	; bvh::BoundingBox<float>::extend, COMDAT

; 23   :     bvh_always_inline BoundingBox& extend(const BoundingBox& bbox) {

$LN51:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 26   :         return *this;

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm2, DWORD PTR [rdx+4]
	movsd	xmm1, QWORD PTR [rcx]
	minss	xmm3, xmm1
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR [rdx+8]
	minss	xmm1, DWORD PTR [rcx+8]
	shufps	xmm0, xmm0, 85				; 00000055H
	minss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm1, QWORD PTR [rcx+12]
	movsd	xmm3, QWORD PTR [rdx+12]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [rdx+16]
	maxss	xmm3, xmm1
	movss	xmm1, DWORD PTR [rdx+20]
	maxss	xmm1, DWORD PTR [rcx+20]
	shufps	xmm0, xmm0, 85				; 00000055H
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rcx+12], xmm0
	movss	DWORD PTR [rcx+20], xmm1

; 27   :     }

	add	rsp, 40					; 00000028H
	ret	0
?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU12@@Z ENDP	; bvh::BoundingBox<float>::extend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??B?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??B?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEBA_NXZ PROC ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator bool, COMDAT

; 389  :         return this->_Has_value;

	movzx	eax, BYTE PTR [rcx+64]

; 390  :     }

	ret	0
??B?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEBA_NXZ ENDP ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??C?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@XZ PROC ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator->, COMDAT

; 380  : #if _CONTAINER_DEBUG_LEVEL > 0
; 381  :         _STL_VERIFY(this->_Has_value, "Cannot access value of empty optional");
; 382  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 383  :         return _STD addressof(this->_Value);

	mov	rax, rcx

; 384  :     }

	ret	0
??C?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@XZ ENDP ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?release@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3455 :     }

	ret	0
?release@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?release@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAPEA_KXZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAPEA_KXZ PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3455 :     }

	ret	0
?release@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAPEA_KXZ ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@QEAAX_K@Z PROC ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@QEAAX_K@Z ENDP ; `bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEAUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEAUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*, COMDAT

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+16]

; 168  :         return const_cast<reference>(_Mybase::operator*());

	mov	rax, QWORD PTR [rax+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rdx
	and	rdx, QWORD PTR [rcx+8]

; 168  :         return const_cast<reference>(_Mybase::operator*());

	mov	rax, QWORD PTR [rax+rdx*8]

; 169  :     }

	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEAUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data, COMDAT

; 1645 :         return _Mypair._Myval2;

	mov	rax, rcx

; 1646 :     }

	ret	0
?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal, COMDAT

; 1637 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1638 :     }

	ret	0
?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Tidy, COMDAT

; 1584 :     void _Tidy() noexcept { // free all storage

$LN77:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1045 :         return _Mysize() == 0;

	mov	rax, QWORD PTR [rcx+32]

; 1584 :     void _Tidy() noexcept { // free all storage

	mov	rdi, rcx

; 1045 :         return _Mysize() == 0;

	test	rax, rax

; 1585 :         _Orphan_all();
; 1586 : 
; 1587 :         _Alpty _Almap(_Getal());
; 1588 :         while (!empty()) {

	je	SHORT $LN65@Tidy
$LL2@Tidy:

; 1208 :         if (--_Mysize() == 0) {

	sub	rax, 1
	mov	QWORD PTR [rcx+32], rax
	jne	SHORT $LL2@Tidy

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR [rcx+24], 0
$LN65@Tidy:

; 1589 :             pop_back();
; 1590 :         }
; 1591 : 
; 1592 :         if (_Map() != nullptr) {

	cmp	QWORD PTR [rcx+8], 0
	je	SHORT $LN64@Tidy
	mov	QWORD PTR [rsp+56], rbx

; 1593 :             for (size_type _Block = _Mapsize(); _Block > 0;) { // free storage for a block and destroy pointer

	mov	rbx, QWORD PTR [rcx+16]
	test	rbx, rbx
	je	SHORT $LN5@Tidy
	npad	7
$LL4@Tidy:

; 1594 :                 if (_Map()[--_Block]) { // free block

	mov	rax, QWORD PTR [rdi+8]
	dec	rbx
	mov	rcx, QWORD PTR [rax+rbx*8]
	test	rcx, rcx
	je	SHORT $LN43@Tidy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN43@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1593 :             for (size_type _Block = _Mapsize(); _Block > 0;) { // free storage for a block and destroy pointer

	test	rbx, rbx
	jne	SHORT $LL4@Tidy
$LN5@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+8]
	mov	rbx, QWORD PTR [rsp+56]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN35@Tidy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN32@Tidy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN35@Tidy:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN64@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1603 :         _Mapsize() = 0;

	mov	QWORD PTR [rdi+16], 0

; 1604 :         _Map()     = nullptr;

	mov	QWORD PTR [rdi+8], 0

; 1605 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN32@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN74@Tidy:
?_Tidy@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?pop_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::pop_back, COMDAT

; 1191 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1192 :         if (empty()) {
; 1193 :             _STL_REPORT_ERROR("deque empty before pop");
; 1194 :         } else { // something to erase, do it
; 1195 :             size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1196 :             _Orphan_off(_Newoff);
; 1197 :             size_type _Block = _Getblock(_Newoff);
; 1198 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size));
; 1199 :             if (--_Mysize() == 0) {
; 1200 :                 _Myoff() = 0;
; 1201 :             }
; 1202 :         }
; 1203 : 
; 1204 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1205 :         size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1206 :         size_type _Block  = _Getblock(_Newoff);
; 1207 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _Block_size));
; 1208 :         if (--_Mysize() == 0) {

	sub	QWORD PTR [rcx+32], 1
	jne	SHORT $LN2@pop_back

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR [rcx+24], 0
$LN2@pop_back:

; 1210 :         }
; 1211 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1212 :     }

	ret	0
?pop_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::push_back, COMDAT

; 1185 :     void push_back(const _Ty& _Val) {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]

; 1185 :     void push_back(const _Ty& _Val) {

	mov	rsi, rdx

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax

; 1185 :     void push_back(const _Ty& _Val) {

	mov	rbx, rcx

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN4@push_back

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN4@push_back:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rcx, QWORD PTR [rbx+16]
	dec	rcx
	and	QWORD PTR [rbx+24], rcx

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rax, QWORD PTR [rbx+32]
	add	rax, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rax, rcx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rax*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN5@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN5@push_back:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1188 :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 1188 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?empty@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_NXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::empty, COMDAT

; 1045 :         return _Mysize() == 0;

	cmp	QWORD PTR [rcx+32], 0
	sete	al

; 1046 :     }

	ret	0
?empty@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_NXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Unchecked_end@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@2@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Unchecked_end, COMDAT

; 955  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

	mov	rax, QWORD PTR [rcx+32]
	add	rax, QWORD PTR [rcx+24]

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	mov	QWORD PTR [rdx+8], rax

; 955  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

	mov	rax, rdx

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	mov	QWORD PTR [rdx], rcx

; 956  :     }

	ret	0
?_Unchecked_end@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@2@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ?half_area@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?half_area@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBAMXZ PROC ; bvh::Bvh<float>::Node::BoundingBoxProxy::half_area, COMDAT

; 52   :                 return BoundingBox<Scalar>(

	mov	rax, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	xmm2, DWORD PTR [rax+12]
	subss	xmm2, DWORD PTR [rax+8]

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm3, DWORD PTR [rax+4]
	subss	xmm3, DWORD PTR [rax]

; 53   :             values[i] = f(i);

	movss	xmm0, DWORD PTR [rax+20]
	subss	xmm0, DWORD PTR [rax+16]
	movaps	xmm1, xmm2
	addss	xmm1, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm2, xmm3
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 61   :             Scalar half_area() const { return to_bounding_box().half_area(); }

	ret	0
?half_area@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBAMXZ ENDP ; bvh::Bvh<float>::Node::BoundingBoxProxy::half_area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ?to_bounding_box@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@4@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?to_bounding_box@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@4@XZ PROC ; bvh::Bvh<float>::Node::BoundingBoxProxy::to_bounding_box, COMDAT

; 52   :                 return BoundingBox<Scalar>(

	mov	r8, QWORD PTR [rcx]

; 58   :                 return static_cast<BoundingBox<Scalar>>(*this);

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	xmm1, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movss	xmm0, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	xmm3, DWORD PTR [r8+12]

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	xmm4, DWORD PTR [r8+20]
	movss	xmm2, DWORD PTR [r8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	unpcklps xmm0, xmm1
	movsd	QWORD PTR [rdx], xmm0
	movss	xmm0, DWORD PTR [r8+4]
	unpcklps xmm0, xmm3
	movsd	QWORD PTR [rdx+12], xmm0
	movss	DWORD PTR [rdx+20], xmm4
	movss	DWORD PTR [rdx+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 59   :             }

	ret	0
?to_bounding_box@BoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@4@XZ ENDP ; bvh::Bvh<float>::Node::BoundingBoxProxy::to_bounding_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
;	COMDAT ?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ PROC ; bvh::Triangle<float,1,0>::p2, COMDAT

; 41   :     Vector3<Scalar> p2() const { return p0 + e2; }

$LN26:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm2, QWORD PTR [rcx+24]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 41   :     Vector3<Scalar> p2() const { return p0 + e2; }

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movsd	xmm0, QWORD PTR [rcx]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	addss	xmm0, xmm2
	addss	xmm1, DWORD PTR [rcx+4]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx], xmm0
	movss	DWORD PTR [rdx+4], xmm1

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm1, DWORD PTR [rcx+32]
	addss	xmm1, DWORD PTR [rcx+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 41   :     Vector3<Scalar> p2() const { return p0 + e2; }

	add	rsp, 40					; 00000028H
	ret	0
?p2@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ENDP ; bvh::Triangle<float,1,0>::p2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
;	COMDAT ?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ PROC ; bvh::Triangle<float,1,0>::p1, COMDAT

; 40   :     Vector3<Scalar> p1() const { return p0 - e1; }

$LN26:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm3, QWORD PTR [rcx+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 40   :     Vector3<Scalar> p1() const { return p0 - e1; }

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm0, QWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+4]
	subss	xmm0, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+4], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm1, DWORD PTR [rcx+8]
	subss	xmm1, DWORD PTR [rcx+20]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 40   :     Vector3<Scalar> p1() const { return p0 - e1; }

	add	rsp, 40					; 00000028H
	ret	0
?p1@?$Triangle@M$00$0A@@bvh@@QEBA?AU?$Vector@M$02@2@XZ ENDP ; bvh::Triangle<float,1,0>::p1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
;	COMDAT ?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z
_TEXT	SEGMENT
bbox$ = 32
$T2 = 56
$T3 = 56
$T4 = 56
tv2046 = 80
$T5 = 80
$T6 = 96
$T7 = 96
$T8 = 96
s$ = 120
s$ = 120
s$ = 120
s$ = 120
__$ArrayPad$ = 128
this$ = 240
__$ReturnUdt$ = 248
axis$ = 256
begin$ = 264
end$ = 272
?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z PROC ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split, COMDAT

; 131  :     std::pair<Scalar, size_t> find_split(int axis, size_t begin, size_t end) {

$LN240:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 176				; 000000b0H
	movaps	XMMWORD PTR [rax-72], xmm6
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-145], rax
	movsxd	rbx, r8d
	mov	rdi, rdx
	mov	r15, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rbp-145], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rbp-145]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 131  :     std::pair<Scalar, size_t> find_split(int axis, size_t begin, size_t end) {

	mov	r14, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T3[rbp-133]
	lea	rcx, QWORD PTR $T3[rbp-145]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	movss	xmm7, DWORD PTR __real@7f7fffff
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rbp-145]
	lea	rdx, QWORD PTR $T5[rbp-133]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rbp-145], 2139095039	; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rcx, QWORD PTR $T5[rbp-145]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T5[rbp-145]
	mov	eax, DWORD PTR $T5[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 133  :         for (size_t i = end - 1; i > begin; --i) {

	mov	r13, QWORD PTR end$[rbp-145]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	QWORD PTR bbox$[rbp-145], xmm0
	movsd	xmm0, QWORD PTR $T3[rbp-145]
	mov	DWORD PTR bbox$[rbp-137], eax
	mov	eax, DWORD PTR $T3[rbp-137]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 133  :         for (size_t i = end - 1; i > begin; --i) {

	lea	rsi, QWORD PTR [r13-1]
	mov	QWORD PTR tv2046[rbp-145], rbx
	mov	rdx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	QWORD PTR bbox$[rbp-133], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 131  :     std::pair<Scalar, size_t> find_split(int axis, size_t begin, size_t end) {

	lea	rbx, QWORD PTR [rbx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	mov	DWORD PTR bbox$[rbp-125], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 133  :         for (size_t i = end - 1; i > begin; --i) {

	cmp	rsi, r14
	jbe	$LN218@find_split

; 134  :             bbox.extend(bboxes[references[axis][i]]);

	mov	rax, QWORD PTR [rbx+r15+48]
	mov	r10, QWORD PTR [r15+8]
	lea	r8, QWORD PTR [rax+rsi*4]
	mov	rax, QWORD PTR [rbx+r15+24]
	lea	r9, QWORD PTR [rax+rsi*8]
	npad	3
$LL4@find_split:
	mov	rax, QWORD PTR [r9]
	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [r10+rcx*8]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm1, DWORD PTR [r10+rcx*8+20]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movaps	xmm5, xmm0
	movss	xmm4, DWORD PTR [r10+rcx*8+8]
	movaps	xmm6, xmm0
	minss	xmm6, DWORD PTR bbox$[rbp-145]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	maxss	xmm1, DWORD PTR bbox$[rbp-125]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	minss	xmm4, DWORD PTR bbox$[rbp-137]
	movsd	QWORD PTR $T8[rbp-133], xmm0
	shufps	xmm5, xmm5, 85				; 00000055H
	minss	xmm5, DWORD PTR bbox$[rbp-141]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movaps	xmm0, xmm6

; 25   :         max = bvh::max(max, bbox.max);

	movss	DWORD PTR bbox$[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	subss	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movss	DWORD PTR bbox$[rbp-137], xmm4
	unpcklps xmm0, xmm5
	movsd	QWORD PTR bbox$[rbp-145], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm0, QWORD PTR [r10+rcx*8+12]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 135  :             costs[axis][i] = bbox.half_area() * static_cast<Scalar>(end - i);

	mov	rcx, r13
	sub	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	QWORD PTR $T7[rbp-133], xmm0
	movaps	xmm2, xmm0
	movaps	xmm3, xmm0
	maxss	xmm3, DWORD PTR bbox$[rbp-133]
	shufps	xmm2, xmm2, 85				; 00000055H
	maxss	xmm2, DWORD PTR bbox$[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	movaps	xmm0, xmm3
	subss	xmm3, xmm6
	unpcklps xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	subss	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	movsd	QWORD PTR bbox$[rbp-133], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 135  :             costs[axis][i] = bbox.half_area() * static_cast<Scalar>(end - i);

	xorps	xmm0, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movaps	xmm5, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	addss	xmm5, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm5, xmm1
	addss	xmm5, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 135  :             costs[axis][i] = bbox.half_area() * static_cast<Scalar>(end - i);

	js	SHORT $LN229@find_split
	cvtsi2ss xmm0, rcx
	jmp	SHORT $LN230@find_split
$LN229@find_split:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm0, rax
	addss	xmm0, xmm0
$LN230@find_split:
	mulss	xmm5, xmm0
	dec	rdx
	sub	r9, 8
	movss	DWORD PTR [r8], xmm5
	sub	r8, 4
	cmp	rdx, r14
	ja	$LL4@find_split
$LN218@find_split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	r8, QWORD PTR s$[rbp-145]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rbp-145], -8388609		; ff7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T6[rbp-133]
	lea	rcx, QWORD PTR $T6[rbp-145]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	lea	r8, QWORD PTR s$[rbp-145]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	DWORD PTR s$[rbp-145], 2139095039	; 7f7fffffH
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

	lea	rdx, QWORD PTR $T2[rbp-133]
	lea	rcx, QWORD PTR $T2[rbp-145]
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR $T6[rbp-145]
	mov	eax, DWORD PTR $T2[rbp-137]
	movsd	xmm1, QWORD PTR $T2[rbp-145]
	movsd	QWORD PTR $T4[rbp-133], xmm0
	mov	DWORD PTR $T4[rbp-137], eax
	mov	eax, DWORD PTR $T6[rbp-137]
	mov	DWORD PTR $T4[rbp-125], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR [rdi], 2139095039		; 7f7fffffH
	mov	QWORD PTR [rdi+8], r13
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 137  :         bbox = BoundingBox<Scalar>::empty();

	movups	xmm0, XMMWORD PTR $T4[rbp-145]
	movsd	xmm0, xmm1
	movups	XMMWORD PTR bbox$[rbp-145], xmm0
	movsd	xmm0, QWORD PTR $T4[rbp-129]
	movsd	QWORD PTR bbox$[rbp-129], xmm0

; 139  :         for (size_t i = begin; i < end - 1; ++i) {

	cmp	r14, rsi
	jae	$LN231@find_split
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 79   :         return BoundingBox(

	mov	r10, QWORD PTR [rbx+r15+48]
	lea	r8, QWORD PTR [r14+1]
	mov	r13, QWORD PTR tv2046[rbp-145]
	lea	r9, QWORD PTR [r14*4]
	lea	r11, QWORD PTR [r14*8]
	sub	rsi, r14
	npad	11
$LL7@find_split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 140  :             bbox.extend(bboxes[references[axis][i]]);

	mov	rax, QWORD PTR [r15+r13*8+24]
	mov	rcx, QWORD PTR [r11+rax]
	mov	rax, QWORD PTR [r15+8]
	lea	rdx, QWORD PTR [rcx+rcx*2]

; 141  :             auto cost = bbox.half_area() * static_cast<Scalar>(i + 1 - begin) + costs[axis][i + 1];

	mov	rcx, r8
	sub	rcx, r14
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm6, QWORD PTR [rax+rdx*8]
	minss	xmm6, DWORD PTR bbox$[rbp-145]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rax+rdx*8+12]
	maxss	xmm3, DWORD PTR bbox$[rbp-133]
	movsd	xmm2, QWORD PTR [rax+rdx*8+12]
	movss	xmm1, DWORD PTR [rax+rdx*8+20]
	maxss	xmm1, DWORD PTR bbox$[rbp-125]

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm5, DWORD PTR [rax+rdx*8+4]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movaps	xmm0, xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	minss	xmm5, DWORD PTR bbox$[rbp-141]
	movss	xmm4, DWORD PTR [rax+rdx*8+8]
	minss	xmm4, DWORD PTR bbox$[rbp-137]

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	shufps	xmm2, xmm2, 85				; 00000055H
	maxss	xmm2, DWORD PTR bbox$[rbp-129]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	unpcklps xmm0, xmm5
	movsd	QWORD PTR bbox$[rbp-145], xmm0

; 25   :         max = bvh::max(max, bbox.max);

	movaps	xmm0, xmm3
	subss	xmm3, xmm6
	movss	DWORD PTR bbox$[rbp-125], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	subss	xmm1, xmm4
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 24   :         min = bvh::min(min, bbox.min);

	movss	DWORD PTR bbox$[rbp-137], xmm4

; 25   :         max = bvh::max(max, bbox.max);

	unpcklps xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	subss	xmm2, xmm5
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 25   :         max = bvh::max(max, bbox.max);

	movsd	QWORD PTR bbox$[rbp-133], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movaps	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm0, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 141  :             auto cost = bbox.half_area() * static_cast<Scalar>(i + 1 - begin) + costs[axis][i + 1];

	xorps	xmm1, xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	addss	xmm0, xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 141  :             auto cost = bbox.half_area() * static_cast<Scalar>(i + 1 - begin) + costs[axis][i + 1];

	js	SHORT $LN227@find_split
	cvtsi2ss xmm1, rcx
	jmp	SHORT $LN228@find_split
$LN227@find_split:
	mov	rax, rcx
	and	ecx, 1
	shr	rax, 1
	or	rax, rcx
	cvtsi2ss xmm1, rax
	addss	xmm1, xmm1
$LN228@find_split:
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [r10+r9+4]

; 142  :             if (cost < best_split.first)

	comiss	xmm7, xmm0
	jbe	SHORT $LN5@find_split
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 340  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	DWORD PTR [rdi], xmm0
	movaps	xmm7, xmm0

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	QWORD PTR [rdi+8], r8
	mov	r10, QWORD PTR [rbx+r15+48]
$LN5@find_split:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 139  :         for (size_t i = begin; i < end - 1; ++i) {

	add	r11, 8
	add	r9, 4
	inc	r8
	sub	rsi, 1
	jne	$LL7@find_split
$LN231@find_split:

; 143  :                 best_split = std::make_pair(cost, i + 1);
; 144  :         }
; 145  :         return best_split;
; 146  :     }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-145]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+88]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?find_split@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAA?AU?$pair@M_K@std@@H_K0@Z ENDP ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::find_split
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ
_TEXT	SEGMENT
d$ = 24
__$ArrayPad$ = 40
this$ = 64
?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ PROC		; bvh::BoundingBox<float>::largest_axis, COMDAT

; 53   :     bvh_always_inline unsigned largest_axis() const {

$LN38:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm1, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 55   :         unsigned axis = 0;

	xor	eax, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm3, QWORD PTR [rcx+12]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [rcx+16]
	subss	xmm3, xmm1
	movss	xmm1, DWORD PTR [rcx+20]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 57   :         if (d[axis] < d[2]) axis = 2;

	mov	edx, 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	subss	xmm1, DWORD PTR [rcx+8]
	shufps	xmm0, xmm0, 85				; 00000055H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 56   :         if (d[0] < d[1]) axis = 1;

	mov	ecx, 1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	subss	xmm2, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR d$[rsp], xmm3
	movss	DWORD PTR d$[rsp+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 55   :         unsigned axis = 0;

	comiss	xmm2, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	DWORD PTR d$[rsp+4], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 56   :         if (d[0] < d[1]) axis = 1;

	cmova	eax, ecx

; 57   :         if (d[axis] < d[2]) axis = 2;

	comiss	xmm1, DWORD PTR d$[rsp+rax*4]
	cmova	eax, edx

; 58   :         return axis;
; 59   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?largest_axis@?$BoundingBox@M@bvh@@QEBAIXZ ENDP		; bvh::BoundingBox<float>::largest_axis
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z PROC ; bvh::BoundingBox<float>::extend, COMDAT

; 29   :     bvh_always_inline BoundingBox& extend(const Vector3<Scalar>& v) {

$LN51:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 32   :         return *this;

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm2, DWORD PTR [rdx+4]
	movsd	xmm1, QWORD PTR [rcx]
	minss	xmm3, xmm1
	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR [rdx+8]
	minss	xmm1, DWORD PTR [rcx+8]
	shufps	xmm0, xmm0, 85				; 00000055H
	minss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 30   :         min = bvh::min(min, v);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm1, QWORD PTR [rcx+12]
	movsd	xmm3, QWORD PTR [rdx]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [rdx+4]
	maxss	xmm3, xmm1
	movss	xmm1, DWORD PTR [rdx+8]
	maxss	xmm1, DWORD PTR [rcx+20]
	shufps	xmm0, xmm0, 85				; 00000055H
	maxss	xmm2, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 31   :         max = bvh::max(max, v);

	movaps	xmm0, xmm3
	unpcklps xmm0, xmm2
	movsd	QWORD PTR [rcx+12], xmm0
	movss	DWORD PTR [rcx+20], xmm1

; 33   :     }

	add	rsp, 40					; 00000028H
	ret	0
?extend@?$BoundingBox@M@bvh@@QEAAAEAU12@AEBU?$Vector@M$02@2@@Z ENDP ; bvh::BoundingBox<float>::extend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@0@Z
_TEXT	SEGMENT
this$ = 8
min$ = 16
max$ = 24
??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@0@Z PROC ; bvh::BoundingBox<float>::BoundingBox<float>, COMDAT

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@0@Z ENDP ; bvh::BoundingBox<float>::BoundingBox<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@@Z PROC ; bvh::BoundingBox<float>::BoundingBox<float>, COMDAT

; 14   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& v) : min(v), max(v) {}

	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0?$BoundingBox@M@bvh@@QEAA@AEBU?$Vector@M$02@1@@Z ENDP ; bvh::BoundingBox<float>::BoundingBox<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0?$Vector@M$02@bvh@@QEAA@M@Z
_TEXT	SEGMENT
s$GSCopy$ = 32
__$ArrayPad$ = 40
this$ = 64
s$ = 72
??0?$Vector@M$02@bvh@@QEAA@M@Z PROC			; bvh::Vector<float,3>::Vector<float,3>, COMDAT

; 38   :     bvh_always_inline explicit Vector(Scalar s) { std::fill(values, values + N, s); }

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	lea	rdx, QWORD PTR [rcx+12]
	movss	DWORD PTR s$GSCopy$[rsp], xmm1
	lea	r8, QWORD PTR s$GSCopy$[rsp]
	mov	rbx, rcx
	call	??$fill@PEAMM@std@@YAXQEAM0AEBM@Z	; std::fill<float *,float>
	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$Vector@M$02@bvh@@QEAA@M@Z ENDP			; bvh::Vector<float,3>::Vector<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??0?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Unullopt_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Unullopt_t@1@@Z PROC ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [rcx+64], 0

; 227  :     constexpr optional(nullopt_t) noexcept {}

	mov	rax, rcx
	ret	0
??0?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Unullopt_t@1@@Z ENDP ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ PROC ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [rcx+64], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 127  :     _Non_trivial_move_assign()                                           = default;

	mov	rax, rcx
	ret	0
??0?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ ENDP ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h
;	COMDAT ??0?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ PROC ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [rcx+64], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xsmf_control.h

; 90   :     _Non_trivial_copy_assign()                                = default;

	mov	rax, rcx
	ret	0
??0?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@XZ ENDP ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??0?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@XZ PROC ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [rcx+64], 0
	mov	rax, rcx
	ret	0
??0?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@XZ ENDP ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\array
;	COMDAT ??A?$array@PEIA_K$02@std@@QEAAAEAPEIA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$array@PEIA_K$02@std@@QEAAAEAPEIA_K_K@Z PROC	; std::array<unsigned __int64 * __restrict,3>::operator[], COMDAT

; 533  : #if _CONTAINER_DEBUG_LEVEL > 0
; 534  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 535  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 536  : 
; 537  :         return _Elems[_Pos];

	lea	rax, QWORD PTR [rcx+rdx*8]

; 538  :     }

	ret	0
??A?$array@PEIA_K$02@std@@QEAAAEAPEIA_K_K@Z ENDP	; std::array<unsigned __int64 * __restrict,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$ = 24
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >, COMDAT

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	mov	QWORD PTR [rcx], r8
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEBUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEBUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*, COMDAT

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax+16]

; 46   :         _Size_type _Block = _Mycont->_Getblock(_Myoff);
; 47   :         _Size_type _Off   = _Myoff % _Block_size;
; 48   :         return _Mycont->_Map[_Block][_Off];

	mov	rax, QWORD PTR [rax+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rdx
	and	rdx, QWORD PTR [rcx+8]

; 46   :         _Size_type _Block = _Mycont->_Getblock(_Myoff);
; 47   :         _Size_type _Off   = _Myoff % _Block_size;
; 48   :         return _Mycont->_Map[_Block][_Off];

	mov	rax, QWORD PTR [rax+rdx*8]

; 49   :     }

	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEBAAEBUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Pdeque$ = 24
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >, COMDAT

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	mov	QWORD PTR [rcx], r8
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first, COMDAT

; 1523 :         return *this;

	mov	rax, rcx

; 1524 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAAAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEB_KXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize, COMDAT

; 1681 :         return _Get_data()._Mysize;

	lea	rax, QWORD PTR [rcx+32]

; 1682 :     }

	ret	0
?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEB_KXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize, COMDAT

; 1677 :         return _Get_data()._Mysize;

	lea	rax, QWORD PTR [rcx+32]

; 1678 :     }

	ret	0
?_Mysize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Myoff@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Myoff@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Myoff, COMDAT

; 1669 :         return _Get_data()._Myoff;

	lea	rax, QWORD PTR [rcx+24]

; 1670 :     }

	ret	0
?_Myoff@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Mapsize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mapsize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mapsize, COMDAT

; 1661 :         return _Get_data()._Mapsize;

	lea	rax, QWORD PTR [rcx+16]

; 1662 :     }

	ret	0
?_Mapsize@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEA_KXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Map@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Map@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Map, COMDAT

; 1653 :         return _Get_data()._Map;

	lea	rax, QWORD PTR [rcx+8]

; 1654 :     }

	ret	0
?_Map@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Getblock@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Getblock@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBA_K_K@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getblock, COMDAT

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rcx+16]
	dec	rax
	and	rax, rdx

; 1629 :         return _Get_data()._Getblock(_Off);
; 1630 :     }

	ret	0
?_Getblock@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBA_K_K@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 967  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 968  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*8]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN17@deallocate

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN14@deallocate

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN17@deallocate:

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 970  :     }

	add	rsp, 40					; 00000028H

; 265  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@deallocate:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@deallocate:
?deallocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAUWorkItem@TopDownBuildTask@bvh@@_K@Z PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXQEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp
;	COMDAT ??BBoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@3@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??BBoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@3@XZ PROC ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator bvh::BoundingBox<float>, COMDAT

; 52   :                 return BoundingBox<Scalar>(

	mov	r8, QWORD PTR [rcx]
	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	xmm1, DWORD PTR [r8+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	movss	xmm0, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 22   :         v[I] = s;

	movss	xmm3, DWORD PTR [r8+12]

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	xmm4, DWORD PTR [r8+20]
	movss	xmm2, DWORD PTR [r8+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 15   :     bvh_always_inline BoundingBox(const Vector3<Scalar>& min, const Vector3<Scalar>& max) : min(min), max(max) {}

	unpcklps xmm0, xmm1
	movsd	QWORD PTR [rdx], xmm0
	movss	xmm0, DWORD PTR [r8+4]
	unpcklps xmm0, xmm3
	movsd	QWORD PTR [rdx+12], xmm0
	movss	DWORD PTR [rdx+20], xmm4
	movss	DWORD PTR [rdx+8], xmm2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bvh.hpp

; 55   :             }

	ret	0
??BBoundingBoxProxy@Node@?$Bvh@M@bvh@@QEBA?AU?$BoundingBox@M@3@XZ ENDP ; bvh::Bvh<float>::Node::BoundingBoxProxy::operator bvh::BoundingBox<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\array
;	COMDAT ??A?$array@PEIAM$02@std@@QEAAAEAPEIAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$array@PEIAM$02@std@@QEAAAEAPEIAM_K@Z PROC		; std::array<float * __restrict,3>::operator[], COMDAT

; 533  : #if _CONTAINER_DEBUG_LEVEL > 0
; 534  :         _STL_VERIFY(_Pos < _Size, "array subscript out of range");
; 535  : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 536  : 
; 537  :         return _Elems[_Pos];

	lea	rax, QWORD PTR [rcx+rdx*8]

; 538  :     }

	ret	0
??A?$array@PEIAM$02@std@@QEAAAEAPEIAM_K@Z ENDP		; std::array<float * __restrict,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?half_area@?$BoundingBox@M@bvh@@QEBAMXZ
_TEXT	SEGMENT
this$ = 48
?half_area@?$BoundingBox@M@bvh@@QEBAMXZ PROC		; bvh::BoundingBox<float>::half_area, COMDAT

; 43   :     bvh_always_inline Scalar half_area() const {

$LN38:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm1, QWORD PTR [rcx]
	movsd	xmm4, QWORD PTR [rcx+12]
	movaps	xmm0, xmm1
	movss	xmm3, DWORD PTR [rcx+16]
	subss	xmm4, xmm1
	movss	xmm2, DWORD PTR [rcx+20]
	subss	xmm2, DWORD PTR [rcx+8]
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm3, xmm0

; 53   :             values[i] = f(i);

	movaps	xmm0, xmm4
	addss	xmm0, xmm3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 45   :         return (d[0] + d[1]) * d[2] + d[0] * d[1];

	mulss	xmm4, xmm3
	mulss	xmm0, xmm2
	addss	xmm0, xmm4

; 46   :     }

	add	rsp, 40					; 00000028H
	ret	0
?half_area@?$BoundingBox@M@bvh@@QEBAMXZ ENDP		; bvh::BoundingBox<float>::half_area
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp
;	COMDAT ?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ PROC ; bvh::BoundingBox<float>::diagonal, COMDAT

; 35   :     bvh_always_inline Vector3<Scalar> diagonal() const {

$LN26:
	sub	rsp, 40					; 00000028H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm3, QWORD PTR [rcx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 36   :         return max - min;

	mov	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm0, QWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR [rcx+16]
	subss	xmm0, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+4], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm1, DWORD PTR [rcx+20]
	subss	xmm1, DWORD PTR [rcx+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+8], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\bounding_box.hpp

; 37   :     }

	add	rsp, 40					; 00000028H
	ret	0
?diagonal@?$BoundingBox@M@bvh@@QEBA?AU?$Vector@M$02@2@XZ ENDP ; bvh::BoundingBox<float>::diagonal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??A?$Vector@M$02@bvh@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$Vector@M$02@bvh@@QEAAAEAM_K@Z PROC			; bvh::Vector<float,3>::operator[], COMDAT

; 88   :     bvh_always_inline Scalar& operator [] (size_t i) { return values[i]; }

	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??A?$Vector@M$02@bvh@@QEAAAEAM_K@Z ENDP			; bvh::Vector<float,3>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??0?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@XZ PROC ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>, COMDAT

; 78   :     constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} // initialize an empty optional

	mov	BYTE PTR [rcx+64], 0
	mov	rax, rcx
	ret	0
??0?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@XZ ENDP ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data, COMDAT

; 1649 :         return _Mypair._Myval2;

	mov	rax, rcx

; 1650 :     }

	ret	0
?_Get_data@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_K_K@Z PROC ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Getblock, COMDAT

; 562  :         // NB: _Mapsize and _Block_size are guaranteed to be powers of 2
; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rcx+16]
	dec	rax
	and	rax, rdx

; 564  :     }

	ret	0
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_K_K@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1186 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1189 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	QWORD PTR [rcx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@$0A@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$reset@PEAUNode@?$Bvh@M@bvh@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXPEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$reset@PEAUNode@?$Bvh@M@bvh@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXPEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::reset<bvh::Bvh<float>::Node *,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rax, rax
	je	SHORT $LN8@reset

; 3194 :         delete[] _Ptr;

	mov	rcx, rax
	jmp	??_V@YAXPEAX@Z				; operator delete[]
$LN8@reset:

; 3461 :             _Mypair._Get_first()(_Old);
; 3462 :         }
; 3463 :     }

	ret	0
??$reset@PEAUNode@?$Bvh@M@bvh@@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXPEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::reset<bvh::Bvh<float>::Node *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@0@AEAU10@@Z PROC ; std::move<std::default_delete<bvh::Bvh<float>::Node [0]> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@0@AEAU10@@Z ENDP ; std::move<std::default_delete<bvh::Bvh<float>::Node [0]> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@AEAV10@@Z PROC ; std::addressof<std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@@std@@YAPEAV?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$reset@PEA_K$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAXPEA_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$reset@PEA_K$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAXPEA_K@Z PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::reset<unsigned __int64 *,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3460 :         if (_Old) {

	test	rax, rax
	je	SHORT $LN8@reset

; 3194 :         delete[] _Ptr;

	mov	rcx, rax
	jmp	??_V@YAXPEAX@Z				; operator delete[]
$LN8@reset:

; 3461 :             _Mypair._Get_first()(_Old);
; 3462 :         }
; 3463 :     }

	ret	0
??$reset@PEA_K$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAAXPEA_K@Z ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::reset<unsigned __int64 *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$default_delete@$$BY0A@_K@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@_K@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$default_delete@$$BY0A@_K@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@_K@0@AEAU10@@Z PROC ; std::move<std::default_delete<unsigned __int64 [0]> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$default_delete@$$BY0A@_K@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@_K@0@AEAU10@@Z ENDP ; std::move<std::default_delete<unsigned __int64 [0]> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEA_KU?$default_delete@$$BY0A@_K@std@@$0A@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@PEA_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEA_KU?$default_delete@$$BY0A@_K@std@@$0A@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@PEA_K@Z PROC ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><unsigned __int64 *,std::default_delete<unsigned __int64 [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEA_KU?$default_delete@$$BY0A@_K@std@@$0A@$0A@@?$unique_ptr@$$BY0A@_KU?$default_delete@$$BY0A@_K@std@@@std@@QEAA@PEA_K@Z ENDP ; std::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> >::unique_ptr<unsigned __int64 [0],std::default_delete<unsigned __int64 [0]> ><unsigned __int64 *,std::default_delete<unsigned __int64 [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$set@MMM@?$Vector@M$02@bvh@@QEAAXMMM@Z
_TEXT	SEGMENT
this$ = 8
<args_0>$ = 16
<args_1>$ = 24
<args_2>$ = 32
??$set@MMM@?$Vector@M$02@bvh@@QEAAXMMM@Z PROC		; bvh::Vector<float,3>::set<float,float,float>, COMDAT

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR [rcx+8], xmm3

; 58   :         VectorSetter<0, Scalar, N>::set(*this, Scalar(args)...);
; 59   :     }

	ret	0
??$set@MMM@?$Vector@M$02@bvh@@QEAAXMMM@Z ENDP		; bvh::Vector<float,3>::set<float,float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z
_TEXT	SEGMENT
this$ = 64
<_Val_0>$ = 72
<_Val_1>$ = 80
<_Val_2>$ = 88
??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back_with_unused_capacity<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >, COMDAT

; 789  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN4:
	sub	rsp, 56					; 00000038H

; 790  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 791  :         auto& _My_data   = _Mypair._Myval2;
; 792  :         pointer& _Mylast = _My_data._Mylast;
; 793  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 794  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 795  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 796  :             _ASAN_VECTOR_MODIFY(1);
; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	QWORD PTR [rsp+32], r9
	mov	r10, rcx
	mov	r9, r8
	mov	r8, rdx
	mov	rdx, QWORD PTR [rcx+8]
	call	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r10+8]

; 806  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+48]
	mov	QWORD PTR [r10+8], rdx

; 807  : 
; 808  :         return _Result;
; 809  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back_with_unused_capacity@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAAEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@3@00@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back_with_unused_capacity<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z
_TEXT	SEGMENT
<_Val_0>$1$ = 48
this$ = 128
_Whereptr$ = 136
<_Val_0>$ = 144
<_Val_1>$ = 152
<_Val_2>$ = 160
??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >, COMDAT

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN163:
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r10, QWORD PTR [rcx]
	mov	r15, rdx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r14, QWORD PTR [rcx+8]
	sub	rdx, r10
	sub	r14, r10
	mov	QWORD PTR <_Val_0>$1$[rsp], r8
	sar	r14, 4
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rdx

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

	mov	r8, 384307168202282325			; 0555555555555555H
	mov	r13, r9
	mov	r12, rdx
	mov	rsi, rcx
	sar	r12, 3
	mov	rax, r12
	shr	rax, 63					; 0000003fH
	add	r12, rax
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	imul	r14, rax
	cmp	r14, r8
	je	$LN161@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

	inc	r14

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, r10
	mov	QWORD PTR [rsp+144], rbx
	sar	rcx, 4
	imul	rcx, rax

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8
	mov	QWORD PTR [rsp+72], rbp
	mov	rdx, rcx
	mov	QWORD PTR [rsp+64], rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN142@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rcx, r14
	cmp	rax, r14
	cmovae	rcx, rax
	cmp	rcx, r8
	ja	$LN142@Emplace_re

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rdi, QWORD PTR [rcx+rcx*2]
	shl	rdi, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN25@Emplace_re

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	$LN142@Emplace_re

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN121@Emplace_re

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN26@Emplace_re

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN26@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR <_Val_2>$[rsp]
	lea	rbp, QWORD PTR [r12+r12*2]
	mov	r8, QWORD PTR <_Val_0>$1$[rsp]
	mov	r9, r13
	shl	rbp, 4
	add	rbp, rbx
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rbp
	call	??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r8, QWORD PTR [rsi+8]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rsi]
	cmp	r15, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

	jmp	SHORT $LN159@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r15
	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [rbp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r15

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r15
$LN159@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN112@Emplace_re

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rsi+16]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN124@Emplace_re

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN121@Emplace_re

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN124@Emplace_re:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN112@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rbx

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [r14+r14*2]
	shl	rcx, 4

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 857  :         return _Newvec + _Whereoff;

	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]

; 2030 :         _Mylast  = _Newvec + _Newsize;

	add	rcx, rbx
	mov	QWORD PTR [rsi+8], rcx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rdi+rbx]
	mov	rbx, QWORD PTR [rsp+144]
	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+16], rcx

; 858  :     }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	ret	0
$LN121@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN161@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 825  :             _Xlength();

	call	?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Xlength
	int	3
$LN142@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN158@Emplace_re:
??$_Emplace_reallocate@U?$Vector@M$02@bvh@@U12@U12@@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAPEAU?$Triangle@M$00$0A@@bvh@@QEAU23@$$QEAU?$Vector@M$02@3@11@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_reallocate<bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z PROC ; std::make_unique<bvh::BoundingBox<float> [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 24
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@U?$BoundingBox@M@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@_K@Z ENDP ; std::make_unique<bvh::BoundingBox<float> [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 40
__$ReturnUdt$ = 64
_Size$ = 72
??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z PROC ; std::make_unique<bvh::Vector<float,3> [0],0>, COMDAT

; 3481 : _NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	eax, 12
	mul	rdx
	mov	rdi, rax
	mov	rax, -1
	cmovo	rdi, rax
	mov	rcx, rdi
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r8, rdi
	xor	edx, edx
	mov	rcx, rax
	mov	rbx, rax
	call	memset
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rsi], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3483 :     return unique_ptr<_Ty>(new _Elem[_Size]());

	mov	rax, rsi

; 3484 : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$make_unique@$$BY0A@U?$Vector@M$02@bvh@@$0A@@std@@YA?AV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@_K@Z ENDP ; std::make_unique<bvh::Vector<float,3> [0],0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z PROC ; std::move<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z PROC ; std::move<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$make_pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Val1$ = 16
_Val2$ = 24
??$make_pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@@Z PROC ; std::make_pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >, COMDAT

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r9d, r9d
	mov	QWORD PTR [rdx], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 562  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

	mov	rax, rcx

; 563  : }

	ret	0
??$make_pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@YA?AU?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@0@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@@Z ENDP ; std::make_pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@@std@@YA$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Val$dead$ = 80
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1511 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN134:
	push	rsi
	push	r14
	sub	rsp, 40					; 00000028H

; 1512 :         if (_Newsize > max_size()) {

	mov	r8, 576460752303423487			; 07ffffffffffffffH
	mov	rsi, rdx
	mov	r14, rcx
	cmp	rdx, r8
	ja	$LN132@Resize_rea
	mov	QWORD PTR [rsp+80], rbx

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8
	mov	QWORD PTR [rsp+88], rbp

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	sub	rbp, QWORD PTR [rcx]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, QWORD PTR [r14]
	sar	rcx, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx

; 1514 :         }
; 1515 : 
; 1516 :         auto& _Al         = _Getal();
; 1517 :         auto& _My_data    = _Mypair._Myval2;
; 1518 :         pointer& _Myfirst = _My_data._Myfirst;
; 1519 :         pointer& _Mylast  = _My_data._Mylast;
; 1520 : 
; 1521 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 5

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	shr	rdx, 1
	sub	rax, rdx
	mov	QWORD PTR [rsp+32], rdi
	cmp	rcx, rax
	ja	$LN114@Resize_rea

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rdx+rcx]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rbx, rsi
	jae	SHORT $LN11@Resize_rea

; 1973 :             return _Newsize; // geometric growth would be insufficient

	mov	rbx, rsi
	jmp	SHORT $LN112@Resize_rea
$LN11@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rbx, r8
	ja	$LN114@Resize_rea
$LN112@Resize_rea:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rbx, 5

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN109@Resize_rea

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	$LN114@Resize_rea

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN96@Resize_rea

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN109@Resize_rea:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN24@Resize_rea

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN24@Resize_rea:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	edi, edi
$LN21@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1525 :         const pointer _Appended_first = _Newvec + _Oldsize;

	mov	rcx, rbp

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	mov	r8, rsi
	shl	rcx, 5
	add	rcx, rdi
	sub	r8, rbp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2041 :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN46@Resize_rea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1533 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

	shl	r8, 5
	xor	edx, edx
	call	memset
$LN46@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1931 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1932 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [r14]
	test	rcx, rcx
	je	SHORT $LN87@Resize_rea

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [r14+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN99@Resize_rea

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN96@Resize_rea

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN99@Resize_rea:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN87@Resize_rea:
	mov	rbp, QWORD PTR [rsp+88]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	rbx, QWORD PTR [rsp+80]

; 2027 :         }
; 2028 : 
; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [r14], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	shl	rsi, 5
	add	rsi, rdi
	mov	rdi, QWORD PTR [rsp+32]
	mov	QWORD PTR [r14+8], rsi

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [r14+16], rax

; 1548 :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	rsi
	ret	0
$LN96@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN132@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1513 :             _Xlength();

	call	?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Xlength
	int	3
$LN114@Resize_rea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN130@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 2026 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 2027 :     // value-initialize _Count objects to raw _First, using _Al
; 2028 :     using _Ptrty = typename _Alloc::value_type*;
; 2029 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2030 : #if _HAS_CXX20
; 2031 :         if (!_STD is_constant_evaluated())
; 2032 : #endif // _HAS_CXX20
; 2033 :         {
; 2034 :             auto _PFirst = _Unfancy(_First);
; 2035 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2036 :             return _First + _Count;
; 2037 :         }
; 2038 :     }
; 2039 : 
; 2040 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2041 :     for (; 0 < _Count; --_Count) {

	test	rdx, rdx
	je	SHORT $LN22@Uninitiali
	shl	rbx, 5
	xor	edx, edx
	mov	r8, rbx
	call	memset
	lea	rax, QWORD PTR [rbx+rdi]

; 2042 :         _Backout._Emplace_back();
; 2043 :     }
; 2044 : 
; 2045 :     return _Backout._Release();
; 2046 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN22@Uninitiali:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@_KAEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YA$$QEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z PROC ; std::forward<bvh::Bvh<float>::Node *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z ENDP ; std::forward<bvh::Bvh<float>::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAUNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAUNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> ><bvh::Bvh<float>::Node *,std::default_delete<bvh::Bvh<float>::Node [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAUNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@UNode@?$Bvh@M@bvh@@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> >::unique_ptr<bvh::Bvh<float>::Node [0],std::default_delete<bvh::Bvh<float>::Node [0]> ><bvh::Bvh<float>::Node *,std::default_delete<bvh::Bvh<float>::Node [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAMU?$default_delete@$$BY0A@M@std@@$0A@$0A@@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@PEAM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAMU?$default_delete@$$BY0A@M@std@@$0A@$0A@@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@PEAM@Z PROC ; std::unique_ptr<float [0],std::default_delete<float [0]> >::unique_ptr<float [0],std::default_delete<float [0]> ><float *,std::default_delete<float [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAMU?$default_delete@$$BY0A@M@std@@$0A@$0A@@?$unique_ptr@$$BY0A@MU?$default_delete@$$BY0A@M@std@@@std@@QEAA@PEAM@Z ENDP ; std::unique_ptr<float [0],std::default_delete<float [0]> >::unique_ptr<float [0],std::default_delete<float [0]> ><float *,std::default_delete<float [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAIU?$default_delete@$$BY0A@I@std@@$0A@$0A@@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@PEAI@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAIU?$default_delete@$$BY0A@I@std@@$0A@$0A@@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@PEAI@Z PROC ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> ><unsigned int *,std::default_delete<unsigned int [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAIU?$default_delete@$$BY0A@I@std@@$0A@$0A@@?$unique_ptr@$$BY0A@IU?$default_delete@$$BY0A@I@std@@@std@@QEAA@PEAI@Z ENDP ; std::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> >::unique_ptr<unsigned int [0],std::default_delete<unsigned int [0]> ><unsigned int *,std::default_delete<unsigned int [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAEU?$default_delete@$$BY0A@E@std@@$0A@$0A@@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@PEAE@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAEU?$default_delete@$$BY0A@E@std@@$0A@$0A@@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@PEAE@Z PROC ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> ><unsigned char *,std::default_delete<unsigned char [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAEU?$default_delete@$$BY0A@E@std@@$0A@$0A@@?$unique_ptr@$$BY0A@EU?$default_delete@$$BY0A@E@std@@@std@@QEAA@PEAE@Z ENDP ; std::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> >::unique_ptr<unsigned char [0],std::default_delete<unsigned char [0]> ><unsigned char *,std::default_delete<unsigned char [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$fill@PEA_KH@std@@YAXQEA_K0AEBH@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEA_KH@std@@YAXQEA_K0AEBH@Z PROC		; std::fill<unsigned __int64 *,int>, COMDAT

; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [r8], 0
	jne	SHORT $LN6@fill

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));

	sub	rdx, rcx

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	and	rdx, -8
	mov	r8, rdx
	xor	edx, edx
	jmp	memset
$LN6@fill:

; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN3@fill
	npad	4
$LL4@fill:

; 5056 :             *_UFirst = _Val;

	movsxd	rax, DWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	add	rcx, 8
	cmp	rcx, rdx
	jne	SHORT $LL4@fill
$LN3@fill:

; 5057 :         }
; 5058 :     }
; 5059 : }

	ret	0
??$fill@PEA_KH@std@@YAXQEA_K0AEBH@Z ENDP		; std::fill<unsigned __int64 *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEIAI$0A@@std@@YAXAEAPEIAI0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEIAI$0A@@std@@YAXAEAPEIAI0@Z PROC		; std::swap<unsigned int * __restrict,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEIAI$0A@@std@@YAXAEAPEIAI0@Z ENDP		; std::swap<unsigned int * __restrict,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@PEIA_K$0A@@std@@YAXAEAPEIA_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEIA_K$0A@@std@@YAXAEAPEIA_K0@Z PROC		; std::swap<unsigned __int64 * __restrict,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 101  :     _Right   = _STD move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 102  : }

	ret	0
??$swap@PEIA_K$0A@@std@@YAXAEAPEIA_K0@Z ENDP		; std::swap<unsigned __int64 * __restrict,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@$$QEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@$$QEAH@std@@YA$$QEAHAEAH@Z PROC		; std::forward<int &&>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@$$QEAH@std@@YA$$QEAHAEAH@Z ENDP		; std::forward<int &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
<_Vals_1>$ = 64
<_Vals_2>$ = 72
<_Vals_3>$ = 80
??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<int,int,unsigned __int64 &,int>, COMDAT

; 1148 :     void _Emplace_back_internal(_Tys&&... _Vals) {

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
	mov	rsi, r9
	inc	rax
	mov	rbp, r8
	mov	r14, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@Emplace_ba

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN2@Emplace_ba:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rcx, QWORD PTR [rbx+16]
	dec	rcx
	and	QWORD PTR [rbx+24], rcx

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rax, QWORD PTR [rbx+32]
	add	rax, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rax, rcx

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rax*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN3@Emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN3@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1163 :     }

	mov	rbp, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [rdi+rax]
	mov	rax, QWORD PTR <_Vals_3>$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1163 :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsxd	r8, DWORD PTR [rax]
	movsxd	rax, DWORD PTR [r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [r9], rax
	mov	QWORD PTR [r9+8], rcx
	mov	QWORD PTR [r9+16], rdx
	mov	QWORD PTR [r9+24], r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 1163 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Emplace_back_internal@HHAEA_KH@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX$$QEAH0AEA_K0@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<int,int,unsigned __int64 &,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$swap@UWorkItem@TopDownBuildTask@bvh@@$0A@@std@@YAXAEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@UWorkItem@TopDownBuildTask@bvh@@$0A@@std@@YAXAEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::swap<bvh::TopDownBuildTask::WorkItem,0>, COMDAT

; 99   :     _Ty _Tmp = _STD move(_Left);
; 100  :     _Left    = _STD move(_Right);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	xmm2, XMMWORD PTR [rcx]
	movups	xmm3, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 101  :     _Right   = _STD move(_Tmp);

	movups	XMMWORD PTR [rdx], xmm2
	movups	XMMWORD PTR [rdx+16], xmm3

; 102  : }

	ret	0
??$swap@UWorkItem@TopDownBuildTask@bvh@@$0A@@std@@YAXAEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::swap<bvh::TopDownBuildTask::WorkItem,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
;	COMDAT ??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z
_TEXT	SEGMENT
$T1 = 32
stack$ = 48
more_work$2 = 96
first_item$3 = 176
work_item$4 = 208
new_task$5 = 240
__$ArrayPad$ = 320
this$ = 384
task$ = 392
<args_0>$ = 400
??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z PROC ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 47   :     void run_task(BuildTask& task, Args&&... args) {

$LN285:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-80]
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, r8
	mov	rbx, rdx
	mov	r14, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR stack$[rsp+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	movdqu	XMMWORD PTR stack$[rsp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	xor	r15d, r15d
	mov	QWORD PTR stack$[rsp+16], r15
	mov	QWORD PTR stack$[rsp+24], r15
	mov	QWORD PTR stack$[rsp+32], r15
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r15+16]
	call	??2@YAPEAX_K@Z				; operator new

; 1206 :         _Myproxy            = _New_proxy;

	mov	QWORD PTR [rax+8], r15
	mov	QWORD PTR stack$[rsp], rax

; 1207 :         _New_proxy->_Mycont = this;

	lea	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rcx, QWORD PTR stack$[rsp+32]
	lea	rax, QWORD PTR [rcx+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN208@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	rcx, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN208@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	add	rcx, rax

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [rax+rdi], 0
	jne	SHORT $LN209@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR stack$[rsp+8]
$LN209@run_task:

; 1157 :         }
; 1158 : 
; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rax+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	add	r8, 1
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 51   :         while (!stack.empty()) {

	je	$LN3@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 43   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

	lea	rax, QWORD PTR stack$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	npad	14
$LL2@run_task:

; 955  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

	mov	rcx, QWORD PTR stack$[rsp+24]
	dec	rcx

; 67   :         --_Myoff;

	add	rcx, r8

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR [rax+16]
	dec	rdx
	and	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 99   :         return c.back();

	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR [rax+rdx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 52   :             auto work_item = stack.top();

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR work_item$4[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR work_item$4[rbp-240], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1208 :         if (--_Mysize() == 0) {

	sub	r8, 1
	mov	QWORD PTR stack$[rsp+32], r8
	jne	SHORT $LN39@run_task

; 1209 :             _Myoff() = 0;

	mov	QWORD PTR stack$[rsp+24], r15
$LN39@run_task:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 56   :             auto more_work = task.build(work_item);

	lea	r8, QWORD PTR work_item$4[rbp-256]
	lea	rdx, QWORD PTR more_work$2[rsp]
	mov	rcx, rbx
	call	?build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@2@@Z ; bvh::SweepSahBuildTask<bvh::Bvh<float> >::build

; 57   :             if (more_work) {

	cmp	BYTE PTR more_work$2[rbp-192], 0
	je	$LN282@run_task

; 23   :         size_t work_size() const { return end - begin; }

	mov	rcx, QWORD PTR more_work$2[rbp-208]
	sub	rcx, QWORD PTR more_work$2[rbp-216]
	mov	rax, QWORD PTR more_work$2[rsp+16]
	sub	rax, QWORD PTR more_work$2[rsp+8]

; 58   :                 if (more_work->first.work_size() > more_work->second.work_size())

	cmp	rax, rcx
	jbe	SHORT $LN281@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 99   :     _Ty _Tmp = _STD move(_Left);

	movaps	xmm2, XMMWORD PTR more_work$2[rsp]
	movaps	xmm3, XMMWORD PTR more_work$2[rsp+16]

; 100  :     _Left    = _STD move(_Right);

	movaps	xmm0, XMMWORD PTR more_work$2[rbp-224]
	movaps	XMMWORD PTR more_work$2[rsp], xmm0
	movaps	xmm1, XMMWORD PTR more_work$2[rbp-208]
	movaps	XMMWORD PTR more_work$2[rsp+16], xmm1

; 101  :     _Right   = _STD move(_Tmp);

	movaps	XMMWORD PTR more_work$2[rbp-224], xmm2
	movaps	XMMWORD PTR more_work$2[rbp-208], xmm3
$LN281@run_task:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rcx, QWORD PTR stack$[rsp+32]
	lea	rax, QWORD PTR [rcx+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN54@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	rcx, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN54@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax
	add	rcx, rax

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [rax+rdi], 0
	jne	SHORT $LN55@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR stack$[rsp+8]
$LN55@run_task:

; 1157 :         }
; 1158 : 
; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rax+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movaps	xmm0, XMMWORD PTR more_work$2[rbp-224]
	movups	XMMWORD PTR [rax], xmm0
	movaps	xmm1, XMMWORD PTR more_work$2[rbp-208]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	inc	r8
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 62   :                 auto first_item = more_work->first;

	movaps	xmm1, XMMWORD PTR more_work$2[rsp]
	movups	XMMWORD PTR first_item$3[rbp-256], xmm1
	movaps	xmm0, XMMWORD PTR more_work$2[rsp+16]
	movups	XMMWORD PTR first_item$3[rbp-240], xmm0

; 23   :         size_t work_size() const { return end - begin; }

	movq	rcx, xmm0
	psrldq	xmm1, 8
	movq	rax, xmm1
	sub	rcx, rax

; 63   :                 if (first_item.work_size() > task_spawn_threshold) {

	cmp	rcx, QWORD PTR [r14]
	jbe	SHORT $LN6@run_task

; 64   :                     BuildTask new_task(task);

	movups	xmm0, XMMWORD PTR [rbx]
	movaps	XMMWORD PTR new_task$5[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rbx+16]
	movaps	XMMWORD PTR new_task$5[rbp-240], xmm1
	movups	xmm0, XMMWORD PTR [rbx+32]
	movaps	XMMWORD PTR new_task$5[rbp-224], xmm0
	movups	xmm1, XMMWORD PTR [rbx+48]
	movaps	XMMWORD PTR new_task$5[rbp-208], xmm1
	movups	xmm0, XMMWORD PTR [rbx+64]
	movaps	XMMWORD PTR new_task$5[rbp-192], xmm0

; 65   :                     #pragma omp task firstprivate(new_task, first_item)
; 66   :                     { run_task(new_task, first_item); }

	lea	r8, QWORD PTR first_item$3[rbp-256]
	lea	rdx, QWORD PTR new_task$5[rbp-256]
	mov	rcx, r14
	call	??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>
$LN282@run_task:

; 51   :         while (!stack.empty()) {

	mov	r8, QWORD PTR stack$[rsp+32]
$LN145@run_task:
	test	r8, r8
	jne	$LL2@run_task
$LN3@run_task:
	lea	rcx, QWORD PTR stack$[rsp]
	call	??1?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::~deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >

; 67   :                 } else {
; 68   :                     stack.push(first_item);
; 69   :                 }
; 70   :             }
; 71   :         }
; 72   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+400]
	add	rsp, 336				; 00000150H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN6@run_task:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	lea	rax, QWORD PTR [r8+1]
	mov	rdx, QWORD PTR stack$[rsp+16]
	cmp	rdx, rax
	ja	SHORT $LN107@run_task

; 1150 :             _Growmap(1);

	lea	rcx, QWORD PTR stack$[rsp]
	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
	mov	r8, QWORD PTR stack$[rsp+32]
	mov	rdx, QWORD PTR stack$[rsp+16]
$LN107@run_task:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	dec	rdx
	mov	rax, QWORD PTR stack$[rsp+24]
	and	rax, rdx
	mov	QWORD PTR stack$[rsp+24], rax
	lea	rcx, QWORD PTR [r8+rax]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rcx, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rcx*8]
	mov	rax, QWORD PTR stack$[rsp+8]
	cmp	QWORD PTR [rax+rdi], 0
	jne	SHORT $LN108@run_task
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR stack$[rsp+8]
	mov	QWORD PTR [rcx+rdi], rax
	mov	rax, QWORD PTR stack$[rsp+8]
$LN108@run_task:

; 1157 :         }
; 1158 : 
; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rax+rdi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR first_item$3[rbp-256]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR first_item$3[rbp-240]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	mov	r8, QWORD PTR stack$[rsp+32]
	inc	r8
	mov	QWORD PTR stack$[rsp+32], r8
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 57   :             if (more_work) {

	jmp	$LN145@run_task
	int	3
??$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z ENDP ; bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
stack$ = 48
more_work$2 = 96
first_item$3 = 176
work_item$4 = 208
new_task$5 = 240
__$ArrayPad$ = 320
this$ = 384
task$ = 392
<args_0>$ = 400
?dtor$0@?0???$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z@4HA PROC ; `bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>'::`1'::dtor$0
	lea	rcx, QWORD PTR stack$[rdx]
	jmp	??1?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$run_task@V?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@AEAUWorkItem@TopDownBuildTask@2@@TopDownBuilder@bvh@@IEAAXAEAV?$SweepSahBuildTask@U?$Bvh@M@bvh@@@1@AEAUWorkItem@TopDownBuildTask@1@@Z@4HA ENDP ; `bvh::TopDownBuilder::run_task<bvh::SweepSahBuildTask<bvh::Bvh<float> >,bvh::TopDownBuildTask::WorkItem &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack
;	COMDAT ??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

	mov	rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 126  :     decltype(auto) emplace(_Valty&&... _Val) {

	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN6@emplace

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN6@emplace:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rdx, QWORD PTR [rbx+16]
	dec	rdx
	and	QWORD PTR [rbx+24], rdx
	mov	r8, QWORD PTR [rbx+24]

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	add	r8, QWORD PTR [rbx+32]

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	mov	rax, QWORD PTR [rbx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	r8, rdx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [r8*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN7@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN7@emplace:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 132  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]
	mov	rcx, QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rdx, QWORD PTR [rbx+24]
	dec	rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 128  :         return c.emplace_back(_STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	add	rdx, rcx
	mov	rcx, QWORD PTR [rbx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 132  :     }

	mov	rbx, QWORD PTR [rsp+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rcx
	and	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\stack

; 128  :         return c.emplace_back(_STD forward<_Valty>(_Val)...);

	mov	rax, QWORD PTR [rax+rdx*8]

; 132  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$emplace@AEAUWorkItem@TopDownBuildTask@bvh@@@?$stack@UWorkItem@TopDownBuildTask@bvh@@V?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::stack<bvh::TopDownBuildTask::WorkItem,std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> > >::emplace<bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	rsi, rdx

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	inc	rax

; 856  :     decltype(auto) emplace_back(_Valty&&... _Val) {

	mov	rbx, rcx

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN4@emplace_ba

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN4@emplace_ba:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	rcx, QWORD PTR [rbx+16]
	dec	rcx
	and	QWORD PTR [rbx+24], rcx

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	mov	rax, QWORD PTR [rbx+32]
	add	rax, QWORD PTR [rbx+24]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rax, rcx

; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rax*8]
	mov	rax, QWORD PTR [rbx+8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN5@emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN5@emplace_ba:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 863  :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	mov	rax, QWORD PTR [rbx+24]

; 1162 :         ++_Mysize();

	mov	rdx, QWORD PTR [rbx+32]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rax
	mov	rcx, QWORD PTR [rbx+16]
	add	rdx, rax

; 857  :         _Orphan_all();
; 858  :         _Emplace_back_internal(_STD forward<_Valty>(_Val)...);
; 859  : 
; 860  : #if _HAS_CXX17
; 861  :         return back();

	mov	rax, QWORD PTR [rbx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	dec	rcx

; 863  :     }

	mov	rbx, QWORD PTR [rsp+48]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rdx, rcx

; 857  :         _Orphan_all();
; 858  :         _Emplace_back_internal(_STD forward<_Valty>(_Val)...);
; 859  : 
; 860  : #if _HAS_CXX17
; 861  :         return back();

	mov	rax, QWORD PTR [rax+rdx*8]

; 863  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$emplace_back@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA?A_TAEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::emplace_back<bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?HM$02@1@YA?AU01@AEBU01@0@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?HM$02@1@YA?AU01@AEBU01@0@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator+<float,3>'::`2'::<lambda_1>,0>, COMDAT

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm0, DWORD PTR [rdx+12]

; 54   :     }

	mov	rax, rcx

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	addss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+16]
	addss	xmm1, DWORD PTR [rdx+4]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 95   :     return Vector<Scalar, N>([=] (size_t i) { return a[i] + b[i]; });

	movss	xmm0, DWORD PTR [rdx+20]
	addss	xmm0, DWORD PTR [rdx+8]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm0

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$?HM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?HM$02@1@YA?AU01@AEBU01@0@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator+<float,3>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?DM$02@1@YA?AU01@AEBU01@M@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?DM$02@1@YA?AU01@AEBU01@M@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator*<float,3>'::`2'::<lambda_1>,0>, COMDAT

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	movss	xmm2, DWORD PTR [rdx+12]

; 54   :     }

	mov	rax, rcx

; 125  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] * s; });

	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	mulss	xmm0, DWORD PTR [rdx]
	mulss	xmm1, DWORD PTR [rdx+4]
	mulss	xmm2, DWORD PTR [rdx+8]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm2

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$?DM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@M@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?DM$02@1@YA?AU01@AEBU01@M@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator*<float,3>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Prev_iter@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@0@V10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
??$_Prev_iter@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@0@V10@@Z PROC ; std::_Prev_iter<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > > >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 67   :         --_Myoff;

	dec	QWORD PTR [rdx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1451 :     return --_First;

	mov	rax, rcx
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0

; 1452 : }

	ret	0
??$_Prev_iter@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@0@V10@@Z ENDP ; std::_Prev_iter<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><bvh::TopDownBuildTask::WorkItem>, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU_Container_proxy@std@@$$T@std@@YAPEAU_Container_proxy@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1131 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 16
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1><>, COMDAT

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1203 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN44:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new

; 1204 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1205 :         _Construct_in_place(*_New_proxy, this);
; 1206 :         _Myproxy            = _New_proxy;

	mov	QWORD PTR [rax+8], 0
	mov	QWORD PTR [rbx], rax

; 1207 :         _New_proxy->_Mycont = this;

	mov	QWORD PTR [rax], rbx

; 1208 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0M_K$0A@@?$pair@M_K@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??$?0M_K$0A@@?$pair@M_K@std@@QEAA@XZ PROC		; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64,0>, COMDAT

; 224  :         : first(), second() {}

	xor	eax, eax
	mov	DWORD PTR [rcx], eax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??$?0M_K$0A@@?$pair@M_K@std@@QEAA@XZ ENDP		; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?4U?$pair@M_K@std@@$0A@@?$pair@M_K@std@@QEAAAEAU01@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?4U?$pair@M_K@std@@$0A@@?$pair@M_K@std@@QEAAAEAU01@$$QEAU01@@Z PROC ; std::pair<float,unsigned __int64>::operator=<std::pair<float,unsigned __int64>,0>, COMDAT

; 340  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 341  :         second = _STD forward<_Ty2>(_Right.second);

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 342  :         return *this;

	mov	rax, rcx

; 343  :     }

	ret	0
??$?4U?$pair@M_K@std@@$0A@@?$pair@M_K@std@@QEAAAEAU01@$$QEAU01@@Z ENDP ; std::pair<float,unsigned __int64>::operator=<std::pair<float,unsigned __int64>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
_TEXT	SEGMENT
$T2 = 64
_Temp_buf$3 = 80
__$ArrayPad$ = 4192
_First$ = 4240
_Last$ = 4248
_Pred$ = 4256
??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z PROC ; std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >, COMDAT

; 6107 : _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred) {

$LN71:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	mov	eax, 4208				; 00001070H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rdi, rcx

; 6077 :         if (_First == _Last) { // the input range is true (already partitioned)

	cmp	rcx, rdx
	je	SHORT $LN54@stable_par
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rcx, QWORD PTR [r8+72]
	npad	4
$LL6@stable_par:
	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6081 :         if (!_Pred(*_First)) { // excluded the leading true range

	je	SHORT $LN55@stable_par

; 6082 :             break;
; 6083 :         }
; 6084 : 
; 6085 :         ++_First;

	add	rdi, 8

; 123  :             _Return_temporary_buffer(_Data);
; 124  :         }
; 125  :     }
; 126  : 
; 127  :     _Ty* _Data; // points to heap memory iff _Capacity > _Optimistic_count
; 128  :     ptrdiff_t _Capacity;
; 129  :     _Aligned_storage_t<sizeof(_Ty), alignof(_Ty)> _Stack_space[_Optimistic_count];
; 130  : };
; 131  : 
; 132  : #ifdef __cpp_lib_concepts
; 133  : namespace ranges {
; 134  :     _EXPORT_STD template <class _In, class _Fun>
; 135  :     struct in_fun_result {
; 136  :         /* [[no_unique_address]] */ _In in;
; 137  :         /* [[no_unique_address]] */ _Fun fun;
; 138  : 
; 139  :         template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Fun&> _FFun>
; 140  :         constexpr operator in_fun_result<_IIn, _FFun>() const& {
; 141  :             return {in, fun};
; 142  :         }
; 143  : 
; 144  :         template <_Convertible_from<_In> _IIn, _Convertible_from<_Fun> _FFun>
; 145  :         constexpr operator in_fun_result<_IIn, _FFun>() && {
; 146  :             return {_STD move(in), _STD move(fun)};
; 147  :         }
; 148  :     };
; 149  : 
; 150  :     _EXPORT_STD template <class _In1, class _In2, class _Out>
; 151  :     struct in_in_out_result {
; 152  :         /* [[no_unique_address]] */ _In1 in1;
; 153  :         /* [[no_unique_address]] */ _In2 in2;
; 154  :         /* [[no_unique_address]] */ _Out out;
; 155  : 
; 156  :         template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2,
; 157  :             _Convertible_from<const _Out&> _OOut>
; 158  :         constexpr operator in_in_out_result<_IIn1, _IIn2, _OOut>() const& {
; 159  :             return {in1, in2, out};
; 160  :         }
; 161  : 
; 162  :         template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2, _Convertible_from<_Out> _OOut>
; 163  :         constexpr operator in_in_out_result<_IIn1, _IIn2, _OOut>() && {
; 164  :             return {_STD move(in1), _STD move(in2), _STD move(out)};
; 165  :         }
; 166  :     };
; 167  : 
; 168  :     _EXPORT_STD template <class _In, class _Out1, class _Out2>
; 169  :     struct in_out_out_result {
; 170  :         /* [[no_unique_address]] */ _In in;
; 171  :         /* [[no_unique_address]] */ _Out1 out1;
; 172  :         /* [[no_unique_address]] */ _Out2 out2;
; 173  : 
; 174  :         template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out1&> _OOut1,
; 175  :             _Convertible_from<const _Out2&> _OOut2>
; 176  :         constexpr operator in_out_out_result<_IIn, _OOut1, _OOut2>() const& {
; 177  :             return {in, out1, out2};
; 178  :         }
; 179  : 
; 180  :         template <_Convertible_from<_In> _IIn, _Convertible_from<_Out1> _OOut1, _Convertible_from<_Out2> _OOut2>
; 181  :         constexpr operator in_out_out_result<_IIn, _OOut1, _OOut2>() && {
; 182  :             return {_STD move(in), _STD move(out1), _STD move(out2)};
; 183  :         }
; 184  :     };
; 185  : 
; 186  :     _EXPORT_STD template <class _Ty>
; 187  :     struct min_max_result {
; 188  :         /* [[no_unique_address]] */ _Ty min;
; 189  :         /* [[no_unique_address]] */ _Ty max;
; 190  : 
; 191  :         template <_Convertible_from<const _Ty&> _Ty2>
; 192  :         constexpr operator min_max_result<_Ty2>() const& {
; 193  :             return {min, max};
; 194  :         }
; 195  : 
; 196  :         template <_Convertible_from<_Ty> _Ty2>
; 197  :         constexpr operator min_max_result<_Ty2>() && {
; 198  :             return {_STD move(min), _STD move(max)};
; 199  :         }
; 200  :     };
; 201  : 
; 202  :     _EXPORT_STD template <class _In>
; 203  :     struct in_found_result {
; 204  :         /* [[no_unique_address]] */ _In in;
; 205  :         bool found;
; 206  : 
; 207  :         template <_Convertible_from<const _In&> _IIn>
; 208  :         constexpr operator in_found_result<_IIn>() const& {
; 209  :             return {in, found};
; 210  :         }
; 211  : 
; 212  :         template <_Convertible_from<_In> _IIn>
; 213  :         constexpr operator in_found_result<_IIn>() && {
; 214  :             return {_STD move(in), found};
; 215  :         }
; 216  :     };
; 217  : 
; 218  : #if _HAS_CXX23
; 219  :     _EXPORT_STD template <class _In, class _Ty>
; 220  :     struct in_value_result {
; 221  :         /* [[no_unique_address]] */ _In in;
; 222  :         /* [[no_unique_address]] */ _Ty value;
; 223  : 
; 224  :         template <class _IIn, class _TTy>
; 225  :             requires convertible_to<const _In&, _IIn> && convertible_to<const _Ty&, _TTy>
; 226  :         constexpr operator in_value_result<_IIn, _TTy>() const& {
; 227  :             return {in, value};
; 228  :         }
; 229  : 
; 230  :         template <class _IIn, class _TTy>
; 231  :             requires convertible_to<_In, _IIn> && convertible_to<_Ty, _TTy>
; 232  :         constexpr operator in_value_result<_IIn, _TTy>() && {
; 233  :             return {_STD move(in), _STD move(value)};
; 234  :         }
; 235  :     };
; 236  : #endif // _HAS_CXX23
; 237  : } // namespace ranges
; 238  : #endif // __cpp_lib_concepts
; 239  : 
; 240  : _EXPORT_STD template <class _InIt, class _Fn>
; 241  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)
; 242  :     _Adl_verify_range(_First, _Last);
; 243  :     auto _UFirst      = _Get_unwrapped(_First);
; 244  :     const auto _ULast = _Get_unwrapped(_Last);
; 245  :     for (; _UFirst != _ULast; ++_UFirst) {
; 246  :         _Func(*_UFirst);
; 247  :     }
; 248  : 
; 249  :     return _Func;
; 250  : }
; 251  : 
; 252  : #if _HAS_CXX17
; 253  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
; 254  : void for_each(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Fn _Func) noexcept; // terminates
; 255  : 
; 256  : _EXPORT_STD template <class _InIt, class _Diff, class _Fn>
; 257  : _CONSTEXPR20 _InIt for_each_n(_InIt _First, const _Diff _Count_raw, _Fn _Func) {
; 258  :     // perform function for each element [_First, _First + _Count)
; 259  :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 260  :     if (0 < _Count) {
; 261  :         auto _UFirst = _Get_unwrapped_n(_First, _Count);
; 262  :         do {
; 263  :             _Func(*_UFirst);
; 264  :             --_Count;
; 265  :             ++_UFirst;
; 266  :         } while (0 < _Count);
; 267  : 
; 268  :         _Seek_wrapped(_First, _UFirst);
; 269  :     }
; 270  : 
; 271  :     return _First;
; 272  : }
; 273  : 
; 274  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
; 275  : _FwdIt for_each_n(_ExPo&& _Exec, _FwdIt _First, _Diff _Count_raw, _Fn _Func) noexcept; // terminates
; 276  : #endif // _HAS_CXX17
; 277  : 
; 278  : #ifdef __cpp_lib_concepts
; 279  : namespace ranges {
; 280  :     _EXPORT_STD template <class _In, class _Fun>
; 281  :     using for_each_result = in_fun_result<_In, _Fun>;
; 282  : 
; 283  :     class _For_each_fn : private _Not_quite_object {
; 284  :     public:
; 285  :         using _Not_quite_object::_Not_quite_object;
; 286  : 
; 287  :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 288  :             indirectly_unary_invocable<projected<_It, _Pj>> _Fn>
; 289  :         constexpr for_each_result<_It, _Fn> operator()(_It _First, _Se _Last, _Fn _Func, _Pj _Proj = {}) const {
; 290  :             _Adl_verify_range(_First, _Last);
; 291  : 
; 292  :             auto _UResult = _For_each_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 293  :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Func), _Pass_fn(_Proj));
; 294  : 
; 295  :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 296  :             return {_STD move(_First), _STD move(_UResult.fun)};
; 297  :         }
; 298  : 
; 299  :         template <input_range _Rng, class _Pj = identity,
; 300  :             indirectly_unary_invocable<projected<iterator_t<_Rng>, _Pj>> _Fn>
; 301  :         constexpr for_each_result<borrowed_iterator_t<_Rng>, _Fn> operator()(
; 302  :             _Rng&& _Range, _Fn _Func, _Pj _Proj = {}) const {
; 303  :             auto _First = _RANGES begin(_Range);
; 304  : 
; 305  :             auto _UResult = _For_each_unchecked(
; 306  :                 _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _STD move(_Func), _Pass_fn(_Proj));
; 307  : 
; 308  :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 309  :             return {_STD move(_First), _STD move(_UResult.fun)};
; 310  :         }
; 311  : 
; 312  :     private:
; 313  :         template <class _It, class _Se, class _Pj, class _Fn>
; 314  :         _NODISCARD static constexpr for_each_result<_It, _Fn> _For_each_unchecked(
; 315  :             _It _First, const _Se _Last, _Fn _Func, _Pj _Proj) {
; 316  :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 317  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 318  :             _STL_INTERNAL_STATIC_ASSERT(indirectly_unary_invocable<_Fn, projected<_It, _Pj>>);
; 319  : 
; 320  :             for (; _First != _Last; ++_First) {
; 321  :                 _STD invoke(_Func, _STD invoke(_Proj, *_First));
; 322  :             }
; 323  : 
; 324  :             return {_STD move(_First), _STD move(_Func)};
; 325  :         }
; 326  :     };
; 327  : 
; 328  :     _EXPORT_STD inline constexpr _For_each_fn for_each{_Not_quite_object::_Construct_tag{}};
; 329  : 
; 330  :     _EXPORT_STD template <class _In, class _Fun>
; 331  :     using for_each_n_result = in_fun_result<_In, _Fun>;
; 332  : 
; 333  :     class _For_each_n_fn : private _Not_quite_object {
; 334  :     public:
; 335  :         using _Not_quite_object::_Not_quite_object;
; 336  : 
; 337  :         template <input_iterator _It, class _Pj = identity, indirectly_unary_invocable<projected<_It, _Pj>> _Fn>
; 338  :         constexpr for_each_n_result<_It, _Fn> operator()(
; 339  :             _It _First, iter_difference_t<_It> _Count, _Fn _Func, _Pj _Proj = {}) const {
; 340  :             if (0 < _Count) {
; 341  :                 auto _UFirst = _Get_unwrapped_n(_STD move(_First), _Count);
; 342  :                 do {
; 343  :                     _STD invoke(_Func, _STD invoke(_Proj, *_UFirst));
; 344  :                     --_Count;
; 345  :                     ++_UFirst;
; 346  :                 } while (0 < _Count);
; 347  : 
; 348  :                 _Seek_wrapped(_First, _STD move(_UFirst));
; 349  :             }
; 350  : 
; 351  :             return {_STD move(_First), _STD move(_Func)};
; 352  :         }
; 353  :     };
; 354  : 
; 355  :     _EXPORT_STD inline constexpr _For_each_n_fn for_each_n{_Not_quite_object::_Construct_tag{}};
; 356  : } // namespace ranges
; 357  : #endif // __cpp_lib_concepts
; 358  : 
; 359  : #if _HAS_CXX17
; 360  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 361  : _NODISCARD _FwdIt find_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 362  : #endif // _HAS_CXX17
; 363  : 
; 364  : _EXPORT_STD template <class _InIt, class _Pr>
; 365  : _NODISCARD _CONSTEXPR20 _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {
; 366  :     // find first element that satisfies !_Pred
; 367  :     _Adl_verify_range(_First, _Last);
; 368  :     auto _UFirst      = _Get_unwrapped(_First);
; 369  :     const auto _ULast = _Get_unwrapped(_Last);
; 370  :     for (; _UFirst != _ULast; ++_UFirst) {
; 371  :         if (!_Pred(*_UFirst)) {
; 372  :             break;
; 373  :         }
; 374  :     }
; 375  : 
; 376  :     _Seek_wrapped(_First, _UFirst);
; 377  :     return _First;
; 378  : }
; 379  : 
; 380  : #if _HAS_CXX17
; 381  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 382  : _NODISCARD _FwdIt find_if_not(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 383  : #endif // _HAS_CXX17
; 384  : 
; 385  : _EXPORT_STD template <class _FwdIt, class _Pr>
; 386  : _NODISCARD _CONSTEXPR20 _FwdIt adjacent_find(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
; 387  :     // find first satisfying _Pred with successor
; 388  :     _Adl_verify_range(_First, _Last);
; 389  :     auto _UFirst = _Get_unwrapped(_First);
; 390  :     auto _ULast  = _Get_unwrapped(_Last);
; 391  :     if (_UFirst != _ULast) {
; 392  :         for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) {
; 393  :             if (_Pred(*_UFirst, *_UNext)) {
; 394  :                 _ULast = _UFirst;
; 395  :                 break;
; 396  :             }
; 397  :         }
; 398  :     }
; 399  : 
; 400  :     _Seek_wrapped(_Last, _ULast);
; 401  :     return _Last;
; 402  : }
; 403  : 
; 404  : _EXPORT_STD template <class _FwdIt>
; 405  : _NODISCARD _CONSTEXPR20 _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last) { // find first matching successor
; 406  :     return _STD adjacent_find(_First, _Last, equal_to<>{});
; 407  : }
; 408  : 
; 409  : #if _HAS_CXX17
; 410  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 411  : _NODISCARD _FwdIt adjacent_find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 412  : 
; 413  : _EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
; 414  : _NODISCARD _FwdIt adjacent_find(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last) noexcept /* terminates */ {
; 415  :     // find first matching successor
; 416  :     return _STD adjacent_find(_STD forward<_ExPo>(_Exec), _First, _Last, equal_to{});
; 417  : }
; 418  : #endif // _HAS_CXX17
; 419  : 
; 420  : #ifdef __cpp_lib_concepts
; 421  : namespace ranges {
; 422  :     class _Count_fn : private _Not_quite_object {
; 423  :     public:
; 424  :         using _Not_quite_object::_Not_quite_object;
; 425  : 
; 426  :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
; 427  :             requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
; 428  :         _NODISCARD constexpr iter_difference_t<_It> operator()(
; 429  :             _It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
; 430  :             _Adl_verify_range(_First, _Last);
; 431  :             return _Count_unchecked(
; 432  :                 _Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _Val, _Pass_fn(_Proj));
; 433  :         }
; 434  : 
; 435  :         template <input_range _Rng, class _Ty, class _Pj = identity>
; 436  :             requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
; 437  :         _NODISCARD constexpr range_difference_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
; 438  :             return _Count_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));
; 439  :         }
; 440  : 
; 441  :     private:
; 442  :         template <class _It, class _Se, class _Ty, class _Pj>
; 443  :         _NODISCARD static constexpr iter_difference_t<_It> _Count_unchecked(
; 444  :             _It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj) {
; 445  :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 446  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 447  :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>);
; 448  : 
; 449  : #if _USE_STD_VECTOR_ALGORITHMS
; 450  :             if constexpr (is_same_v<_Pj, identity> && _Vector_alg_in_find_is_safe<_It, _Ty>
; 451  :                           && sized_sentinel_for<_Se, _It>) {
; 452  :                 if (!_STD is_constant_evaluated()) {
; 453  :                     if (!_STD _Could_compare_equal_to_value_type<_It>(_Val)) {
; 454  :                         return 0;
; 455  :                     }
; 456  : 
; 457  :                     const auto _First_ptr = _To_address(_First);
; 458  :                     const auto _Last_ptr  = _First_ptr + (_Last - _First);
; 459  : 
; 460  :                     return static_cast<iter_difference_t<_It>>(__std_count_trivial(_First_ptr, _Last_ptr, _Val));
; 461  :                 }
; 462  :             }
; 463  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 464  : 
; 465  :             iter_difference_t<_It> _Count = 0;
; 466  :             for (; _First != _Last; ++_First) {
; 467  :                 if (_STD invoke(_Proj, *_First) == _Val) {
; 468  :                     ++_Count;
; 469  :                 }
; 470  :             }
; 471  : 
; 472  :             return _Count;
; 473  :         }
; 474  :     };
; 475  : 
; 476  :     _EXPORT_STD inline constexpr _Count_fn count{_Not_quite_object::_Construct_tag{}};
; 477  : } // namespace ranges
; 478  : #endif // __cpp_lib_concepts
; 479  : 
; 480  : _EXPORT_STD template <class _InIt, class _Pr>
; 481  : _NODISCARD _CONSTEXPR20 _Iter_diff_t<_InIt> count_if(_InIt _First, _InIt _Last, _Pr _Pred) {
; 482  :     // count elements satisfying _Pred
; 483  :     _Adl_verify_range(_First, _Last);
; 484  :     auto _UFirst               = _Get_unwrapped(_First);
; 485  :     const auto _ULast          = _Get_unwrapped(_Last);
; 486  :     _Iter_diff_t<_InIt> _Count = 0;
; 487  :     for (; _UFirst != _ULast; ++_UFirst) {
; 488  :         if (_Pred(*_UFirst)) {
; 489  :             ++_Count;
; 490  :         }
; 491  :     }
; 492  : 
; 493  :     return _Count;
; 494  : }
; 495  : 
; 496  : #if _HAS_CXX17
; 497  : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 498  : _NODISCARD _Iter_diff_t<_FwdIt> count_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 499  : #endif // _HAS_CXX17
; 500  : 
; 501  : #ifdef __cpp_lib_concepts
; 502  : namespace ranges {
; 503  :     class _Count_if_fn : private _Not_quite_object {
; 504  :     public:
; 505  :         using _Not_quite_object::_Not_quite_object;
; 506  : 
; 507  :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 508  :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 509  :         _NODISCARD constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 510  :             _Adl_verify_range(_First, _Last);
; 511  :             return _Count_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 512  :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 513  :         }
; 514  : 
; 515  :         template <input_range _Rng, class _Pj = identity,
; 516  :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 517  :         _NODISCARD constexpr range_difference_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 518  :             return _Count_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 519  :         }
; 520  : 
; 521  :     private:
; 522  :         template <class _It, class _Se, class _Pj, class _Pr>
; 523  :         _NODISCARD static constexpr iter_difference_t<_It> _Count_if_unchecked(
; 524  :             _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 525  :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 526  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 527  :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 528  : 
; 529  :             iter_difference_t<_It> _Count = 0;
; 530  :             for (; _First != _Last; ++_First) {
; 531  :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 532  :                     ++_Count;
; 533  :                 }
; 534  :             }
; 535  : 
; 536  :             return _Count;
; 537  :         }
; 538  :     };
; 539  : 
; 540  :     _EXPORT_STD inline constexpr _Count_if_fn count_if{_Not_quite_object::_Construct_tag{}};
; 541  : } // namespace ranges
; 542  : #endif // __cpp_lib_concepts
; 543  : 
; 544  : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 545  : _NODISCARD _CONSTEXPR20 pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred) {
; 546  :     // return [_First1, _Last1)/[_First2, ...) mismatch
; 547  :     _Adl_verify_range(_First1, _Last1);
; 548  :     auto _UFirst1      = _Get_unwrapped(_First1);
; 549  :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 550  :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 551  :     while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
; 552  :         ++_UFirst1;
; 553  :         ++_UFirst2;
; 554  :     }
; 555  : 
; 556  :     _Seek_wrapped(_First2, _UFirst2);
; 557  :     _Seek_wrapped(_First1, _UFirst1);
; 558  :     return {_First1, _First2};
; 559  : }
; 560  : 
; 561  : #if _HAS_CXX17
; 562  : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 563  : _NODISCARD pair<_FwdIt1, _FwdIt2> mismatch(
; 564  :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) noexcept; // terminates
; 565  : #endif // _HAS_CXX17
; 566  : 
; 567  : _EXPORT_STD template <class _InIt1, class _InIt2>
; 568  : _NODISCARD _CONSTEXPR20 pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
; 569  :     // return [_First1, _Last1)/[_First2, ...) mismatch
; 570  :     return _STD mismatch(_First1, _Last1, _First2, equal_to<>{});
; 571  : }
; 572  : 
; 573  : #if _HAS_CXX17
; 574  : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 575  : _NODISCARD pair<_FwdIt1, _FwdIt2> mismatch(
; 576  :     _ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept /* terminates */ {
; 577  :     // return [_First1, _Last1)/[_First2, ...) mismatch
; 578  :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 579  :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 580  :     return _STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
; 581  : }
; 582  : #endif // _HAS_CXX17
; 583  : 
; 584  : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 585  : _NODISCARD _CONSTEXPR20 pair<_InIt1, _InIt2> mismatch(
; 586  :     _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
; 587  :     // return [_First1, _Last1)/[_First2, _Last2) mismatch
; 588  :     _Adl_verify_range(_First1, _Last1);
; 589  :     _Adl_verify_range(_First2, _Last2);
; 590  :     auto _UFirst1      = _Get_unwrapped(_First1);
; 591  :     auto _ULast1       = _Get_unwrapped(_Last1);
; 592  :     auto _UFirst2      = _Get_unwrapped(_First2);
; 593  :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 594  :     if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
; 595  :         using _CT         = _Common_diff_t<_InIt1, _InIt2>;
; 596  :         const _CT _Count1 = _ULast1 - _UFirst1;
; 597  :         const _CT _Count2 = _ULast2 - _UFirst2;
; 598  :         const auto _Count = static_cast<_Iter_diff_t<_InIt1>>((_STD min)(_Count1, _Count2));
; 599  :         _ULast1           = _UFirst1 + _Count;
; 600  :         while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
; 601  :             ++_UFirst1;
; 602  :             ++_UFirst2;
; 603  :         }
; 604  :     } else {
; 605  :         while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred(*_UFirst1, *_UFirst2)) {
; 606  :             ++_UFirst1;
; 607  :             ++_UFirst2;
; 608  :         }
; 609  :     }
; 610  : 
; 611  :     _Seek_wrapped(_First2, _UFirst2);
; 612  :     _Seek_wrapped(_First1, _UFirst1);
; 613  :     return {_First1, _First2};
; 614  : }
; 615  : 
; 616  : #if _HAS_CXX17
; 617  : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 618  : _NODISCARD pair<_FwdIt1, _FwdIt2> mismatch(
; 619  :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 620  : #endif // _HAS_CXX17
; 621  : 
; 622  : _EXPORT_STD template <class _InIt1, class _InIt2>
; 623  : _NODISCARD _CONSTEXPR20 pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
; 624  :     // return [_First1, _Last1)/[_First2, _Last2) mismatch
; 625  :     return _STD mismatch(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 626  : }
; 627  : 
; 628  : #if _HAS_CXX17
; 629  : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 630  : _NODISCARD pair<_FwdIt1, _FwdIt2> mismatch(
; 631  :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) noexcept /* terminates */ {
; 632  :     // return [_First1, _Last1)/[_First2, _Last2) mismatch
; 633  :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 634  :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 635  :     return _STD mismatch(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 636  : }
; 637  : #endif // _HAS_CXX17
; 638  : 
; 639  : #ifdef __cpp_lib_concepts
; 640  : namespace ranges {
; 641  :     template <input_iterator _It1, input_iterator _It2, _Integer_like _Size, class _Pr, class _Pj1, class _Pj2>
; 642  :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 643  :     _NODISCARD constexpr bool _Equal_count(
; 644  :         _It1 _First1, _It2 _First2, _Size _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 645  :         _STL_INTERNAL_CHECK(_Count >= 0);
; 646  :         if constexpr (_Equal_memcmp_is_safe<_It1, _It2, _Pr> && same_as<_Pj1, identity> && same_as<_Pj2, identity>) {
; 647  :             if (!_STD is_constant_evaluated()) {
; 648  :                 return _Memcmp_count(_First1, _First2, static_cast<size_t>(_Count)) == 0;
; 649  :             }
; 650  :         }
; 651  : 
; 652  :         for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
; 653  :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 654  :                 return false;
; 655  :             }
; 656  :         }
; 657  : 
; 658  :         return true;
; 659  :     }
; 660  : 
; 661  :     class _Equal_fn : private _Not_quite_object {
; 662  :     private:
; 663  :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 664  :         _NODISCARD static constexpr bool _Equal_4(
; 665  :             _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 666  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 667  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 668  :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 669  : 
; 670  :             for (;;) {
; 671  :                 if (_First1 == _Last1) {
; 672  :                     return _First2 == _Last2;
; 673  :                 } else if (_First2 == _Last2) {
; 674  :                     return false;
; 675  :                 }
; 676  : 
; 677  :                 if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 678  :                     return false;
; 679  :                 }
; 680  : 
; 681  :                 ++_First1;
; 682  :                 ++_First2;
; 683  :             }
; 684  :         }
; 685  : 
; 686  :     public:
; 687  :         using _Not_quite_object::_Not_quite_object;
; 688  : 
; 689  :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 690  :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 691  :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 692  :         _NODISCARD constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 693  :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 694  :             _Adl_verify_range(_First1, _Last1);
; 695  :             _Adl_verify_range(_First2, _Last2);
; 696  :             auto _UFirst1 = _Unwrap_iter<_Se1>(_STD move(_First1));
; 697  :             auto _ULast1  = _Unwrap_sent<_It1>(_STD move(_Last1));
; 698  :             auto _UFirst2 = _Unwrap_iter<_Se2>(_STD move(_First2));
; 699  :             auto _ULast2  = _Unwrap_sent<_It2>(_STD move(_Last2));
; 700  : 
; 701  :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 702  :                 const auto _Count = _ULast1 - _UFirst1;
; 703  :                 if (_Count != _ULast2 - _UFirst2) {
; 704  :                     return false;
; 705  :                 }
; 706  : 
; 707  :                 return _RANGES _Equal_count(_STD move(_UFirst1), _STD move(_UFirst2), _Count, _Pass_fn(_Pred),
; 708  :                     _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 709  :             } else {
; 710  :                 return _Equal_4(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2), _STD move(_ULast2),
; 711  :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 712  :             }
; 713  :         }
; 714  : 
; 715  :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 716  :             class _Pj2 = identity>
; 717  :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 718  :         _NODISCARD constexpr bool operator()(
; 719  :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 720  :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 721  :                 using _Size1      = _Make_unsigned_like_t<range_size_t<_Rng1>>;
; 722  :                 const auto _Count = static_cast<_Size1>(_RANGES size(_Range1));
; 723  :                 using _Size2      = _Make_unsigned_like_t<range_size_t<_Rng2>>;
; 724  :                 if (_Count != static_cast<_Size2>(_RANGES size(_Range2))) {
; 725  :                     return false;
; 726  :                 }
; 727  :                 return _RANGES _Equal_count(
; 728  :                     _Ubegin(_Range1), _Ubegin(_Range2), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 729  :             } else {
; 730  :                 return _Equal_4(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2), _Pass_fn(_Pred),
; 731  :                     _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 732  :             }
; 733  :         }
; 734  :     };
; 735  : 
; 736  :     _EXPORT_STD inline constexpr _Equal_fn equal{_Not_quite_object::_Construct_tag{}};
; 737  : } // namespace ranges
; 738  : #endif // __cpp_lib_concepts
; 739  : 
; 740  : _EXPORT_STD template <class _FwdIt1, class _FwdIt2, class _Pr>
; 741  : _NODISCARD _CONSTEXPR20 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
; 742  :     // test if [_First1, _Last1) == permuted [_First2, ...)
; 743  :     _Adl_verify_range(_First1, _Last1);
; 744  :     auto _UFirst1      = _Get_unwrapped(_First1);
; 745  :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 746  :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
; 747  : 
; 748  :     for (;; ++_UFirst1, (void) ++_UFirst2) { // trim matching prefix
; 749  :         if (_UFirst1 == _ULast1) { // everything matched
; 750  :             return true;
; 751  :         }
; 752  : 
; 753  :         if (!_Pred(*_UFirst1, *_UFirst2)) { // found first inequality, check match counts in suffix
; 754  :             break;
; 755  :         }
; 756  :     }
; 757  : 
; 758  :     // Narrowing _Iter_diff_t<_FwdIt1> to _Iter_diff_t<_FwdIt2> is OK because the second range must be at least as long
; 759  :     // as the first.
; 760  :     const auto _Dist2 = static_cast<_Iter_diff_t<_FwdIt2>>(_STD distance(_UFirst1, _ULast1));
; 761  :     return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, _STD next(_UFirst2, _Dist2), _Pass_fn(_Pred));
; 762  : }
; 763  : 
; 764  : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 765  : _NODISCARD _CONSTEXPR20 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2) {
; 766  :     // test if [_First1, _Last1) == permuted [_First2, ...)
; 767  :     return _STD is_permutation(_First1, _Last1, _First2, equal_to<>{});
; 768  : }
; 769  : 
; 770  : _EXPORT_STD template <class _FwdIt1, class _FwdIt2, class _Pr>
; 771  : _NODISCARD _CONSTEXPR20 bool is_permutation(
; 772  :     _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
; 773  :     // test if [_First1, _Last1) == permuted [_First2, _Last2)
; 774  :     _Adl_verify_range(_First1, _Last1);
; 775  :     _Adl_verify_range(_First2, _Last2);
; 776  :     auto _UFirst1 = _Get_unwrapped(_First1);
; 777  :     auto _ULast1  = _Get_unwrapped(_Last1);
; 778  :     auto _UFirst2 = _Get_unwrapped(_First2);
; 779  :     auto _ULast2  = _Get_unwrapped(_Last2);
; 780  :     if constexpr (_Is_ranges_random_iter_v<_FwdIt1> && _Is_ranges_random_iter_v<_FwdIt2>) {
; 781  :         if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
; 782  :             return false;
; 783  :         }
; 784  : 
; 785  :         for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) { // trim matching prefix
; 786  :             if (!_Pred(*_UFirst1, *_UFirst2)) {
; 787  :                 // found first inequality, check match counts in suffix
; 788  :                 return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred));
; 789  :             }
; 790  :         }
; 791  : 
; 792  :         return true;
; 793  :     } else {
; 794  :         static_assert(_Is_ranges_fwd_iter_v<_FwdIt1> && _Is_ranges_fwd_iter_v<_FwdIt2>,
; 795  :             "Iterators must be at least forward iterators");
; 796  :         for (;; ++_UFirst1, (void) ++_UFirst2) { // trim matching prefix
; 797  :             if (_UFirst1 == _ULast1) {
; 798  :                 return _UFirst2 == _ULast2;
; 799  :             }
; 800  : 
; 801  :             if (_UFirst2 == _ULast2) {
; 802  :                 return false;
; 803  :             }
; 804  : 
; 805  :             if (!_Pred(*_UFirst1, *_UFirst2)) { // found first inequality, check match counts in suffix
; 806  :                 break;
; 807  :             }
; 808  :         }
; 809  : 
; 810  :         auto _Next1 = _UFirst1;
; 811  :         auto _Next2 = _UFirst2;
; 812  :         for (;; ++_Next1, (void) ++_Next2) { // check for same lengths
; 813  :             if (_Next1 == _ULast1) {
; 814  :                 if (_Next2 == _ULast2) {
; 815  :                     return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred));
; 816  :                 }
; 817  : 
; 818  :                 return false; // sequence 1 is shorter than sequence 2, not a permutation
; 819  :             }
; 820  : 
; 821  :             if (_Next2 == _ULast2) {
; 822  :                 return false; // sequence 1 is longer than sequence 2, not a permutation
; 823  :             }
; 824  :         }
; 825  :     }
; 826  : }
; 827  : 
; 828  : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 829  : _NODISCARD _CONSTEXPR20 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) {
; 830  :     // test if [_First1, _Last1) == permuted [_First2, _Last2)
; 831  :     return _STD is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 832  : }
; 833  : 
; 834  : #ifdef __cpp_lib_concepts
; 835  : namespace ranges {
; 836  :     class _Is_permutation_fn : private _Not_quite_object {
; 837  :     public:
; 838  :         using _Not_quite_object::_Not_quite_object;
; 839  : 
; 840  :         template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
; 841  :             class _Pj1 = identity, class _Pj2 = identity,
; 842  :             indirect_equivalence_relation<projected<_It1, _Pj1>, projected<_It2, _Pj2>> _Pr = ranges::equal_to>
; 843  :         _NODISCARD constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 844  :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 845  :             _Adl_verify_range(_First1, _Last1);
; 846  :             _Adl_verify_range(_First2, _Last2);
; 847  :             auto _UFirst1 = _Unwrap_iter<_Se1>(_STD move(_First1));
; 848  :             auto _ULast1  = _Unwrap_sent<_It1>(_STD move(_Last1));
; 849  :             auto _UFirst2 = _Unwrap_iter<_Se2>(_STD move(_First2));
; 850  :             auto _ULast2  = _Unwrap_sent<_It2>(_STD move(_Last2));
; 851  : 
; 852  :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 853  :                 const auto _Count = _ULast1 - _UFirst1;
; 854  :                 if (_ULast2 - _UFirst2 != _Count) {
; 855  :                     return false;
; 856  :                 }
; 857  : 
; 858  :                 return _Is_permutation_sized(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
; 859  :                     _STD move(_ULast2), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 860  :             } else {
; 861  :                 return _Is_permutation_unsized(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
; 862  :                     _STD move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 863  :             }
; 864  :         }
; 865  : 
; 866  :         template <forward_range _Rng1, forward_range _Rng2, class _Pj1 = identity, class _Pj2 = identity,
; 867  :             indirect_equivalence_relation<projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>> _Pr =
; 868  :                 ranges::equal_to>
; 869  :         _NODISCARD constexpr bool operator()(
; 870  :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 871  :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 872  :                 const auto _Count = _RANGES distance(_Range1);
; 873  :                 if (_RANGES distance(_Range2) != _Count) {
; 874  :                     return false;
; 875  :                 }
; 876  : 
; 877  :                 return _Is_permutation_sized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2), _Count,
; 878  :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 879  :             } else {
; 880  :                 return _Is_permutation_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
; 881  :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 882  :             }
; 883  :         }
; 884  : 
; 885  :     private:
; 886  :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 887  :         _NODISCARD static constexpr bool _Is_permutation_sized(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
; 888  :             iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 889  :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
; 890  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 891  :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
; 892  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 893  :             _STL_INTERNAL_STATIC_ASSERT(
; 894  :                 indirect_equivalence_relation<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>);
; 895  :             _STL_INTERNAL_CHECK(_RANGES distance(_First1, _Last1) == _Count);
; 896  :             _STL_INTERNAL_CHECK(_RANGES distance(_First2, _Last2) == _Count);
; 897  : 
; 898  :             for (;; ++_First1, (void) ++_First2, --_Count) { // trim matching prefixes
; 899  :                 if (_Count == 0) { // everything matched
; 900  :                     return true;
; 901  :                 }
; 902  : 
; 903  :                 if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) { // mismatch
; 904  :                     break;
; 905  :                 }
; 906  :             }
; 907  : 
; 908  :             if (_Count == 1) { // single non-matching elements remain; not a permutation
; 909  :                 return false;
; 910  :             }
; 911  :             // If we get here, _Count > 1 and initial elements do not match.
; 912  : 
; 913  :             if constexpr (bidirectional_iterator<_It1> && bidirectional_iterator<_It2>) {
; 914  :                 // determine final iterator values
; 915  :                 auto _Final1 = _Find_last_iterator(_First1, _Last1, _Count);
; 916  :                 auto _Final2 = _Find_last_iterator(_First2, _Last2, _Count);
; 917  : 
; 918  :                 for (;;) { // trim matching suffixes
; 919  :                     --_Final1;
; 920  :                     --_Final2;
; 921  :                     if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Final1), _STD invoke(_Proj2, *_Final2))) { // mismatch
; 922  :                         break;
; 923  :                     }
; 924  : 
; 925  :                     if (--_Count == 1) {
; 926  :                         return false; // initial elements still do not match
; 927  :                     }
; 928  :                 }
; 929  :                 // If we get here, _Count > 1, initial elements do not match, and final elements do not match.
; 930  : 
; 931  :                 // We've trimmed matching prefixes and matching suffixes.
; 932  :                 // Now we need to compare each range's prefix to the other range's suffix.
; 933  : 
; 934  :                 const auto _ProjectedPred = [&]<class _Ty1, class _Ty2>(_Ty1&& _Left, _Ty2&& _Right) -> bool {
; 935  :                     return _STD invoke(_Pred, _STD invoke(_Proj1, _STD forward<_Ty1>(_Left)),
; 936  :                         _STD invoke(_Proj2, _STD forward<_Ty2>(_Right)));
; 937  :                 };
; 938  : 
; 939  :                 const _TrimResult _Res = _Trim_completely(_First1, _Final1, _First2, _Final2, _ProjectedPred);
; 940  : 
; 941  :                 if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
; 942  :                     return _Res == _TrimResult::_ReturnTrue;
; 943  :                 }
; 944  : 
; 945  :                 ++_Final1;
; 946  :                 ++_Final2;
; 947  :                 // If we get here, initial elements do not match, final elements do not match, and ranges have length
; 948  :                 // at least 2 and at most _Count.
; 949  : 
; 950  :                 // We've trimmed matching prefixes, matching suffixes,
; 951  :                 // and each range's prefix matching the other range's suffix. That is, given:
; 952  :                 // Range 1: [A, ..., B]
; 953  :                 // Range 2: [X, ..., Y]
; 954  :                 // we know that A != X, A != Y, B != X, and B != Y.
; 955  :                 // (A == B and X == Y are possible but irrelevant.)
; 956  : 
; 957  :                 return _Match_counts(_STD move(_First1), _STD move(_Final1), _STD move(_First2), _STD move(_Final2),
; 958  :                     _Pred, _Proj1, _Proj2);
; 959  :             } else {
; 960  :                 return _Match_counts(_STD move(_First1), _STD move(_Last1), _STD move(_First2), _STD move(_Last2),
; 961  :                     _Pred, _Proj1, _Proj2);
; 962  :             }
; 963  :         }
; 964  : 
; 965  :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 966  :         _NODISCARD static constexpr bool _Is_permutation_unsized(
; 967  :             _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 968  :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
; 969  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 970  :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
; 971  :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 972  :             _STL_INTERNAL_STATIC_ASSERT(
; 973  :                 indirect_equivalence_relation<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>);
; 974  : 
; 975  :             for (;; ++_First1, (void) ++_First2) { // trim matching prefixes
; 976  :                 if (_First1 == _Last1) { // first range is a prefix of second
; 977  :                     return _First2 == _Last2;
; 978  :                 } else if (_First2 == _Last2) { // second range is a proper prefix of first
; 979  :                     return false;
; 980  :                 }
; 981  : 
; 982  :                 if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) { // mismatch
; 983  :                     break;
; 984  :                 }
; 985  :             }
; 986  :             // If we get here, initial elements do not match.
; 987  : 
; 988  :             // determine final iterator values and validate lengths
; 989  :             auto _Final1 = _First1;
; 990  :             auto _Final2 = _First2;
; 991  :             for (;;) {
; 992  :                 ++_Final1;
; 993  :                 ++_Final2;
; 994  :                 if (_Final1 == _Last1) {
; 995  :                     if (_Final2 == _Last2) {
; 996  :                         break; // equal lengths
; 997  :                     }
; 998  : 
; 999  :                     return false; // different lengths; not a permutation
; 1000 :                 } else if (_Final2 == _Last2) {
; 1001 :                     return false; // ditto different lengths
; 1002 :                 }
; 1003 :             }
; 1004 :             // If we get here, initial elements do not match and ranges have equal lengths.
; 1005 : 
; 1006 :             if constexpr (bidirectional_iterator<_It1> && bidirectional_iterator<_It2>) {
; 1007 :                 for (;;) { // trim matching suffixes
; 1008 :                     if (--_Final1 == _First1) {
; 1009 :                         return false; // initial elements still do not match
; 1010 :                     }
; 1011 :                     --_Final2; // since ranges have equal lengths, _Final2 cannot equal _First2
; 1012 : 
; 1013 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Final1), _STD invoke(_Proj2, *_Final2))) { // mismatch
; 1014 :                         break;
; 1015 :                     }
; 1016 :                 }
; 1017 :                 // If we get here, initial elements do not match, final elements do not match, and ranges have length
; 1018 :                 // at least 2.
; 1019 : 
; 1020 :                 // We've trimmed matching prefixes and matching suffixes.
; 1021 :                 // Now we need to compare each range's prefix to the other range's suffix.
; 1022 : 
; 1023 :                 const auto _ProjectedPred = [&]<class _Ty1, class _Ty2>(_Ty1&& _Left, _Ty2&& _Right) -> bool {
; 1024 :                     return _STD invoke(_Pred, _STD invoke(_Proj1, _STD forward<_Ty1>(_Left)),
; 1025 :                         _STD invoke(_Proj2, _STD forward<_Ty2>(_Right)));
; 1026 :                 };
; 1027 : 
; 1028 :                 const _TrimResult _Res = _Trim_completely(_First1, _Final1, _First2, _Final2, _ProjectedPred);
; 1029 : 
; 1030 :                 if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
; 1031 :                     return _Res == _TrimResult::_ReturnTrue;
; 1032 :                 }
; 1033 : 
; 1034 :                 ++_Final1;
; 1035 :                 ++_Final2;
; 1036 :                 // If we get here, initial elements do not match, final elements do not match, and ranges have length
; 1037 :                 // at least 2.
; 1038 : 
; 1039 :                 // We've trimmed matching prefixes, matching suffixes,
; 1040 :                 // and each range's prefix matching the other range's suffix. That is, given:
; 1041 :                 // Range 1: [A, ..., B]
; 1042 :                 // Range 2: [X, ..., Y]
; 1043 :                 // we know that A != X, A != Y, B != X, and B != Y.
; 1044 :                 // (A == B and X == Y are possible but irrelevant.)
; 1045 :             }
; 1046 : 
; 1047 :             return _Match_counts(
; 1048 :                 _STD move(_First1), _STD move(_Final1), _STD move(_First2), _STD move(_Final2), _Pred, _Proj1, _Proj2);
; 1049 :         }
; 1050 : 
; 1051 :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 1052 :         _NODISCARD static constexpr bool _Match_counts(const _It1 _First1, const _Se1 _Last1, const _It2 _First2,
; 1053 :             const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 1054 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
; 1055 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 1056 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
; 1057 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 1058 :             _STL_INTERNAL_STATIC_ASSERT(
; 1059 :                 indirect_equivalence_relation<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>);
; 1060 : 
; 1061 :             for (auto _Current = _First1; _Current != _Last1; ++_Current) {
; 1062 :                 bool _Found = false;
; 1063 :                 auto _Mid1  = _First1;
; 1064 :                 for (; _Mid1 != _Current; ++_Mid1) {
; 1065 :                     if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Current), _STD invoke(_Proj1, *_Mid1))) {
; 1066 :                         // this value appears earlier in the first range so we've already counted occurrences
; 1067 :                         _Found = true;
; 1068 :                         break;
; 1069 :                     }
; 1070 :                 }
; 1071 : 
; 1072 :                 if (_Found) {
; 1073 :                     continue;
; 1074 :                 }
; 1075 : 
; 1076 :                 // count occurrences of this value in the first range
; 1077 :                 iter_difference_t<_It1> _Occurrences = 1;
; 1078 :                 while (++_Mid1 != _Last1) {
; 1079 :                     if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Current), _STD invoke(_Proj1, *_Mid1))) {
; 1080 :                         ++_Occurrences;
; 1081 :                     }
; 1082 :                 }
; 1083 : 
; 1084 :                 // subtract occurrences in the second range
; 1085 :                 for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2) {
; 1086 :                     if (_STD invoke(_Pred, _STD invoke(_Proj1, *_Current), _STD invoke(_Proj2, *_Mid2))) {
; 1087 :                         if (--_Occurrences < 0) {
; 1088 :                             // value appears more in second range than first; not a permutation
; 1089 :                             return false;
; 1090 :                         }
; 1091 :                     }
; 1092 :                 }
; 1093 : 
; 1094 :                 if (_Occurrences != 0) {
; 1095 :                     // value appears more in first range than second; not a permutation
; 1096 :                     return false;
; 1097 :                 }
; 1098 :             }
; 1099 : 
; 1100 :             return true;
; 1101 :         }
; 1102 :     };
; 1103 : 
; 1104 :     _EXPORT_STD inline constexpr _Is_permutation_fn is_permutation{_Not_quite_object::_Construct_tag{}};
; 1105 : } // namespace ranges
; 1106 : #endif // __cpp_lib_concepts
; 1107 : 
; 1108 : _EXPORT_STD template <class _InIt, class _Pr>
; 1109 : _NODISCARD _CONSTEXPR20 bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { // test if all elements satisfy _Pred
; 1110 :     _Adl_verify_range(_First, _Last);
; 1111 :     auto _UFirst      = _Get_unwrapped(_First);
; 1112 :     const auto _ULast = _Get_unwrapped(_Last);
; 1113 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1114 :         if (!_Pred(*_UFirst)) {
; 1115 :             return false;
; 1116 :         }
; 1117 :     }
; 1118 : 
; 1119 :     return true;
; 1120 : }
; 1121 : 
; 1122 : #if _HAS_CXX17
; 1123 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1124 : _NODISCARD bool all_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 1125 : #endif // _HAS_CXX17
; 1126 : 
; 1127 : #ifdef __cpp_lib_concepts
; 1128 : namespace ranges {
; 1129 :     class _All_of_fn : private _Not_quite_object {
; 1130 :     public:
; 1131 :         using _Not_quite_object::_Not_quite_object;
; 1132 : 
; 1133 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 1134 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1135 :         _NODISCARD constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 1136 :             _Adl_verify_range(_First, _Last);
; 1137 : 
; 1138 :             return _All_of_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 1139 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1140 :         }
; 1141 : 
; 1142 :         template <input_range _Rng, class _Pj = identity,
; 1143 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1144 :         _NODISCARD constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 1145 :             return _All_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1146 :         }
; 1147 : 
; 1148 :     private:
; 1149 :         template <class _It, class _Se, class _Pj, class _Pr>
; 1150 :         _NODISCARD static constexpr bool _All_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 1151 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1152 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1153 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1154 : 
; 1155 :             for (; _First != _Last; ++_First) {
; 1156 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1157 :                     return false;
; 1158 :                 }
; 1159 :             }
; 1160 : 
; 1161 :             return true;
; 1162 :         }
; 1163 :     };
; 1164 : 
; 1165 :     _EXPORT_STD inline constexpr _All_of_fn all_of{_Not_quite_object::_Construct_tag{}};
; 1166 : } // namespace ranges
; 1167 : #endif // __cpp_lib_concepts
; 1168 : 
; 1169 : _EXPORT_STD template <class _InIt, class _Pr>
; 1170 : _NODISCARD _CONSTEXPR20 bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
; 1171 :     // test if any element satisfies _Pred
; 1172 :     _Adl_verify_range(_First, _Last);
; 1173 :     auto _UFirst      = _Get_unwrapped(_First);
; 1174 :     const auto _ULast = _Get_unwrapped(_Last);
; 1175 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1176 :         if (_Pred(*_UFirst)) {
; 1177 :             return true;
; 1178 :         }
; 1179 :     }
; 1180 : 
; 1181 :     return false;
; 1182 : }
; 1183 : 
; 1184 : #if _HAS_CXX17
; 1185 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1186 : _NODISCARD bool any_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 1187 : #endif // _HAS_CXX17
; 1188 : 
; 1189 : #ifdef __cpp_lib_concepts
; 1190 : namespace ranges {
; 1191 :     class _Any_of_fn : private _Not_quite_object {
; 1192 :     public:
; 1193 :         using _Not_quite_object::_Not_quite_object;
; 1194 : 
; 1195 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 1196 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1197 :         _NODISCARD constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 1198 :             _Adl_verify_range(_First, _Last);
; 1199 : 
; 1200 :             return _Any_of_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 1201 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1202 :         }
; 1203 : 
; 1204 :         template <input_range _Rng, class _Pj = identity,
; 1205 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1206 :         _NODISCARD constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 1207 :             return _Any_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1208 :         }
; 1209 : 
; 1210 :     private:
; 1211 :         template <class _It, class _Se, class _Pj, class _Pr>
; 1212 :         _NODISCARD static constexpr bool _Any_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 1213 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1214 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1215 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1216 : 
; 1217 :             for (; _First != _Last; ++_First) {
; 1218 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1219 :                     return true;
; 1220 :                 }
; 1221 :             }
; 1222 : 
; 1223 :             return false;
; 1224 :         }
; 1225 :     };
; 1226 : 
; 1227 :     _EXPORT_STD inline constexpr _Any_of_fn any_of{_Not_quite_object::_Construct_tag{}};
; 1228 : } // namespace ranges
; 1229 : #endif // __cpp_lib_concepts
; 1230 : 
; 1231 : _EXPORT_STD template <class _InIt, class _Pr>
; 1232 : _NODISCARD _CONSTEXPR20 bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
; 1233 :     // test if no elements satisfy _Pred
; 1234 :     _Adl_verify_range(_First, _Last);
; 1235 :     auto _UFirst      = _Get_unwrapped(_First);
; 1236 :     const auto _ULast = _Get_unwrapped(_Last);
; 1237 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1238 :         if (_Pred(*_UFirst)) {
; 1239 :             return false;
; 1240 :         }
; 1241 :     }
; 1242 : 
; 1243 :     return true;
; 1244 : }
; 1245 : 
; 1246 : #if _HAS_CXX17
; 1247 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1248 : _NODISCARD bool none_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 1249 : #endif // _HAS_CXX17
; 1250 : 
; 1251 : #ifdef __cpp_lib_concepts
; 1252 : namespace ranges {
; 1253 :     class _None_of_fn : private _Not_quite_object {
; 1254 :     public:
; 1255 :         using _Not_quite_object::_Not_quite_object;
; 1256 : 
; 1257 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 1258 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1259 :         _NODISCARD constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 1260 :             _Adl_verify_range(_First, _Last);
; 1261 : 
; 1262 :             return _None_of_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 1263 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1264 :         }
; 1265 : 
; 1266 :         template <input_range _Rng, class _Pj = identity,
; 1267 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1268 :         _NODISCARD constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 1269 :             return _None_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1270 :         }
; 1271 : 
; 1272 :     private:
; 1273 :         template <class _It, class _Se, class _Pj, class _Pr>
; 1274 :         _NODISCARD static constexpr bool _None_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 1275 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1276 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1277 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1278 : 
; 1279 :             for (; _First != _Last; ++_First) {
; 1280 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1281 :                     return false;
; 1282 :                 }
; 1283 :             }
; 1284 : 
; 1285 :             return true;
; 1286 :         }
; 1287 :     };
; 1288 : 
; 1289 :     _EXPORT_STD inline constexpr _None_of_fn none_of{_Not_quite_object::_Construct_tag{}};
; 1290 : 
; 1291 : #if _HAS_CXX23
; 1292 :     class _Contains_fn : private _Not_quite_object {
; 1293 :     public:
; 1294 :         using _Not_quite_object::_Not_quite_object;
; 1295 : 
; 1296 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
; 1297 :             requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
; 1298 :         _NODISCARD constexpr bool operator()(_It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
; 1299 :             _Adl_verify_range(_First, _Last);
; 1300 :             const auto _ULast = _Unwrap_sent<_It>(_STD move(_Last));
; 1301 :             const auto _UResult =
; 1302 :                 _RANGES _Find_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _ULast, _Val, _Pass_fn(_Proj));
; 1303 :             return _UResult != _ULast;
; 1304 :         }
; 1305 : 
; 1306 :         template <input_range _Rng, class _Ty, class _Pj = identity>
; 1307 :             requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
; 1308 :         _NODISCARD constexpr bool operator()(_Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
; 1309 :             const auto _UResult = _RANGES _Find_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));
; 1310 :             return _UResult != _Uend(_Range);
; 1311 :         }
; 1312 :     };
; 1313 : 
; 1314 :     _EXPORT_STD inline constexpr _Contains_fn contains{_Not_quite_object::_Construct_tag{}};
; 1315 : 
; 1316 :     class _Contains_subrange_fn : private _Not_quite_object {
; 1317 :     public:
; 1318 :         using _Not_quite_object::_Not_quite_object;
; 1319 : 
; 1320 :         template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
; 1321 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 1322 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 1323 :         _NODISCARD constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 1324 :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 1325 :             _Adl_verify_range(_First2, _Last2);
; 1326 :             auto _UFirst2 = _Unwrap_iter<_Se2>(_STD move(_First2));
; 1327 :             auto _ULast2  = _Unwrap_sent<_It2>(_STD move(_Last2));
; 1328 : 
; 1329 :             if (_UFirst2 == _ULast2) {
; 1330 :                 return true;
; 1331 :             }
; 1332 : 
; 1333 :             const auto _Match = _RANGES search(_STD move(_First1), _STD move(_Last1), _STD move(_UFirst2),
; 1334 :                 _STD move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 1335 :             return !_Match.empty();
; 1336 :         }
; 1337 : 
; 1338 :         template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 1339 :             class _Pj2 = identity>
; 1340 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 1341 :         _NODISCARD constexpr bool operator()(
; 1342 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 1343 :             if (_RANGES empty(_Range2)) {
; 1344 :                 return true;
; 1345 :             }
; 1346 : 
; 1347 :             const auto _Match = _RANGES search(_Range1, _Range2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 1348 :             return !_Match.empty();
; 1349 :         }
; 1350 :     };
; 1351 : 
; 1352 :     _EXPORT_STD inline constexpr _Contains_subrange_fn contains_subrange{_Not_quite_object::_Construct_tag{}};
; 1353 : #endif // _HAS_CXX23
; 1354 : 
; 1355 :     _EXPORT_STD template <class _In, class _Out>
; 1356 :     using copy_n_result = in_out_result<_In, _Out>;
; 1357 : 
; 1358 :     class _Copy_n_fn : private _Not_quite_object {
; 1359 :     public:
; 1360 :         using _Not_quite_object::_Not_quite_object;
; 1361 : 
; 1362 :         template <input_iterator _It, weakly_incrementable _Out>
; 1363 :             requires indirectly_copyable<_It, _Out>
; 1364 :         constexpr copy_n_result<_It, _Out> operator()(_It _First, iter_difference_t<_It> _Count, _Out _Result) const {
; 1365 :             auto _UFirst = _Get_unwrapped_n(_STD move(_First), _Count);
; 1366 :             if constexpr (_Iter_copy_cat<decltype(_UFirst), _Out>::_Bitcopy_assignable) {
; 1367 :                 if (!_STD is_constant_evaluated()) {
; 1368 :                     _Result = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _STD move(_Result));
; 1369 :                     _UFirst += _Count;
; 1370 :                     _Seek_wrapped(_First, _STD move(_UFirst));
; 1371 :                     return {_STD move(_First), _STD move(_Result)};
; 1372 :                 }
; 1373 :             }
; 1374 : 
; 1375 :             for (; _Count > 0; ++_UFirst, (void) ++_Result, --_Count) {
; 1376 :                 *_Result = *_UFirst;
; 1377 :             }
; 1378 : 
; 1379 :             _Seek_wrapped(_First, _STD move(_UFirst));
; 1380 :             return {_STD move(_First), _STD move(_Result)};
; 1381 :         }
; 1382 :     };
; 1383 : 
; 1384 :     _EXPORT_STD inline constexpr _Copy_n_fn copy_n{_Not_quite_object::_Construct_tag{}};
; 1385 : 
; 1386 :     _EXPORT_STD template <class _In, class _Out>
; 1387 :     using copy_backward_result = in_out_result<_In, _Out>;
; 1388 : 
; 1389 :     class _Copy_backward_fn : private _Not_quite_object {
; 1390 :     public:
; 1391 :         using _Not_quite_object::_Not_quite_object;
; 1392 : 
; 1393 :         template <bidirectional_iterator _It1, sentinel_for<_It1> _Se1, bidirectional_iterator _It2>
; 1394 :             requires indirectly_copyable<_It1, _It2>
; 1395 :         constexpr copy_backward_result<_It1, _It2> operator()(_It1 _First, _Se1 _Last, _It2 _Result) const {
; 1396 :             _Adl_verify_range(_First, _Last);
; 1397 :             auto _UFirst = _Unwrap_iter<_Se1>(_STD move(_First));
; 1398 :             auto _ULast  = _Get_final_iterator_unwrapped<_It1>(_UFirst, _STD move(_Last));
; 1399 :             _Seek_wrapped(_First, _ULast);
; 1400 :             _Result = _Copy_backward_unchecked(_STD move(_UFirst), _STD move(_ULast), _STD move(_Result));
; 1401 :             return {_STD move(_First), _STD move(_Result)};
; 1402 :         }
; 1403 : 
; 1404 :         template <bidirectional_range _Rng, bidirectional_iterator _It>
; 1405 :             requires indirectly_copyable<iterator_t<_Rng>, _It>
; 1406 :         constexpr copy_backward_result<borrowed_iterator_t<_Rng>, _It> operator()(_Rng&& _Range, _It _Result) const {
; 1407 :             auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 1408 :             _Result     = _Copy_backward_unchecked(_Ubegin(_Range), _ULast, _STD move(_Result));
; 1409 :             return {_Rewrap_iterator(_Range, _STD move(_ULast)), _STD move(_Result)};
; 1410 :         }
; 1411 :     };
; 1412 : 
; 1413 :     _EXPORT_STD inline constexpr _Copy_backward_fn copy_backward{_Not_quite_object::_Construct_tag{}};
; 1414 : } // namespace ranges
; 1415 : #endif // __cpp_lib_concepts
; 1416 : 
; 1417 : _EXPORT_STD template <class _InIt, class _OutIt, class _Pr>
; 1418 : _CONSTEXPR20 _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { // copy each satisfying _Pred
; 1419 :     _Adl_verify_range(_First, _Last);
; 1420 :     auto _UFirst      = _Get_unwrapped(_First);
; 1421 :     const auto _ULast = _Get_unwrapped(_Last);
; 1422 :     auto _UDest       = _Get_unwrapped_unverified(_Dest);
; 1423 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1424 :         if (_Pred(*_UFirst)) {
; 1425 :             *_UDest = *_UFirst;
; 1426 :             ++_UDest;
; 1427 :         }
; 1428 :     }
; 1429 : 
; 1430 :     _Seek_wrapped(_Dest, _UDest);
; 1431 :     return _Dest;
; 1432 : }
; 1433 : 
; 1434 : #if _HAS_CXX17
; 1435 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1436 : _FwdIt2 copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept /* terminates */ {
; 1437 :     // copy each satisfying _Pred
; 1438 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 1439 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 1440 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 1441 :     return _STD copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
; 1442 : }
; 1443 : #endif // _HAS_CXX17
; 1444 : 
; 1445 : #ifdef __cpp_lib_concepts
; 1446 : namespace ranges {
; 1447 :     _EXPORT_STD template <class _In, class _Out>
; 1448 :     using copy_if_result = in_out_result<_In, _Out>;
; 1449 : 
; 1450 :     class _Copy_if_fn : private _Not_quite_object {
; 1451 :     public:
; 1452 :         using _Not_quite_object::_Not_quite_object;
; 1453 : 
; 1454 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
; 1455 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1456 :             requires indirectly_copyable<_It, _Out>
; 1457 :         constexpr copy_if_result<_It, _Out> operator()(
; 1458 :             _It _First, _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
; 1459 :             _Adl_verify_range(_First, _Last);
; 1460 :             auto _UResult = _Copy_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 1461 :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1462 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1463 :             return {_STD move(_First), _STD move(_UResult.out)};
; 1464 :         }
; 1465 : 
; 1466 :         template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
; 1467 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1468 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 1469 :         constexpr copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 1470 :             _Rng&& _Range, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
; 1471 :             auto _First   = _RANGES begin(_Range);
; 1472 :             auto _UResult = _Copy_if_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 1473 :                 _STD move(_Result), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1474 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1475 :             return {_STD move(_First), _STD move(_UResult.out)};
; 1476 :         }
; 1477 : 
; 1478 :     private:
; 1479 :         template <class _It, class _Se, class _Out, class _Pj, class _Pr>
; 1480 :         _NODISCARD static constexpr copy_if_result<_It, _Out> _Copy_if_unchecked(
; 1481 :             _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
; 1482 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1483 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1484 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1485 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 1486 : 
; 1487 :             for (; _First != _Last; ++_First) {
; 1488 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1489 :                     *_Result = *_First;
; 1490 :                     ++_Result;
; 1491 :                 }
; 1492 :             }
; 1493 : 
; 1494 :             return {_STD move(_First), _STD move(_Result)};
; 1495 :         }
; 1496 :     };
; 1497 : 
; 1498 :     _EXPORT_STD inline constexpr _Copy_if_fn copy_if{_Not_quite_object::_Construct_tag{}};
; 1499 : 
; 1500 :     _EXPORT_STD template <class _In, class _Out>
; 1501 :     using move_result = in_out_result<_In, _Out>;
; 1502 : 
; 1503 :     template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 1504 :         requires indirectly_movable<_It, _Out>
; 1505 :     constexpr move_result<_It, _Out> _Move_unchecked(_It _First, _Se _Last, _Out _Result) {
; 1506 :         if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_assignable) {
; 1507 :             if (!_STD is_constant_evaluated()) {
; 1508 :                 auto _Final = _RANGES next(_First, _STD move(_Last));
; 1509 :                 _Result     = _Copy_memmove(_STD move(_First), _Final, _STD move(_Result));
; 1510 :                 return {_STD move(_Final), _STD move(_Result)};
; 1511 :             }
; 1512 :         }
; 1513 : 
; 1514 :         for (; _First != _Last; ++_First, (void) ++_Result) {
; 1515 :             *_Result = _RANGES iter_move(_First);
; 1516 :         }
; 1517 : 
; 1518 :         return {_STD move(_First), _STD move(_Result)};
; 1519 :     }
; 1520 : 
; 1521 :     class _Move_fn : private _Not_quite_object {
; 1522 :     public:
; 1523 :         using _Not_quite_object::_Not_quite_object;
; 1524 : 
; 1525 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 1526 :             requires indirectly_movable<_It, _Out>
; 1527 :         constexpr move_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
; 1528 :             _Adl_verify_range(_First, _Last);
; 1529 :             auto _UResult = _RANGES _Move_unchecked(
; 1530 :                 _Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result));
; 1531 : 
; 1532 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1533 :             return {_STD move(_First), _STD move(_UResult.out)};
; 1534 :         }
; 1535 : 
; 1536 :         template <input_range _Rng, weakly_incrementable _Out>
; 1537 :             requires indirectly_movable<iterator_t<_Rng>, _Out>
; 1538 :         constexpr move_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
; 1539 :             auto _First = _RANGES begin(_Range);
; 1540 :             auto _UResult =
; 1541 :                 _RANGES _Move_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _STD move(_Result));
; 1542 : 
; 1543 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1544 :             return {_STD move(_First), _STD move(_UResult.out)};
; 1545 :         }
; 1546 :     };
; 1547 : 
; 1548 :     _EXPORT_STD inline constexpr _Move_fn move{_Not_quite_object::_Construct_tag{}};
; 1549 : 
; 1550 :     _EXPORT_STD template <class _In, class _Out>
; 1551 :     using move_backward_result = in_out_result<_In, _Out>;
; 1552 : 
; 1553 :     // concept-constrained for strict enforcement as it is used by several algorithms
; 1554 :     template <bidirectional_iterator _It1, bidirectional_iterator _It2>
; 1555 :         requires indirectly_movable<_It1, _It2>
; 1556 :     constexpr _It2 _Move_backward_common(const _It1 _First, _It1 _Last, _It2 _Result) {
; 1557 :         if constexpr (_Iter_move_cat<_It1, _It2>::_Bitcopy_assignable) {
; 1558 :             if (!_STD is_constant_evaluated()) {
; 1559 :                 return _Copy_backward_memmove(_First, _Last, _Result);
; 1560 :             }
; 1561 :         }
; 1562 : 
; 1563 :         while (_First != _Last) {
; 1564 :             *--_Result = _RANGES iter_move(--_Last);
; 1565 :         }
; 1566 : 
; 1567 :         return _Result;
; 1568 :     }
; 1569 : 
; 1570 :     class _Move_backward_fn : private _Not_quite_object {
; 1571 :     public:
; 1572 :         using _Not_quite_object::_Not_quite_object;
; 1573 : 
; 1574 :         template <bidirectional_iterator _It1, sentinel_for<_It1> _Se1, bidirectional_iterator _It2>
; 1575 :             requires indirectly_movable<_It1, _It2>
; 1576 :         constexpr move_backward_result<_It1, _It2> operator()(_It1 _First, _Se1 _Last, _It2 _Result) const {
; 1577 :             _Adl_verify_range(_First, _Last);
; 1578 :             auto _UFirst = _Unwrap_iter<_Se1>(_STD move(_First));
; 1579 :             auto _ULast  = _Get_final_iterator_unwrapped<_It1>(_UFirst, _STD move(_Last));
; 1580 :             _Seek_wrapped(_First, _ULast);
; 1581 :             _Result = _RANGES _Move_backward_common(_STD move(_UFirst), _STD move(_ULast), _STD move(_Result));
; 1582 :             return {_STD move(_First), _STD move(_Result)};
; 1583 :         }
; 1584 : 
; 1585 :         template <bidirectional_range _Rng, bidirectional_iterator _It>
; 1586 :             requires indirectly_movable<iterator_t<_Rng>, _It>
; 1587 :         constexpr move_backward_result<borrowed_iterator_t<_Rng>, _It> operator()(_Rng&& _Range, _It _Result) const {
; 1588 :             auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 1589 :             _Result     = _RANGES _Move_backward_common(_Ubegin(_Range), _ULast, _STD move(_Result));
; 1590 :             return {_Rewrap_iterator(_Range, _STD move(_ULast)), _STD move(_Result)};
; 1591 :         }
; 1592 :     };
; 1593 : 
; 1594 :     _EXPORT_STD inline constexpr _Move_backward_fn move_backward{_Not_quite_object::_Construct_tag{}};
; 1595 : } // namespace ranges
; 1596 : #endif // __cpp_lib_concepts
; 1597 : 
; 1598 : _EXPORT_STD template <class _InIt, class _OutIt1, class _OutIt2, class _Pr>
; 1599 : _CONSTEXPR20 pair<_OutIt1, _OutIt2> partition_copy(
; 1600 :     _InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false, _Pr _Pred) {
; 1601 :     // copy true partition to _Dest_true, false to _Dest_false
; 1602 :     _Adl_verify_range(_First, _Last);
; 1603 :     auto _UFirst      = _Get_unwrapped(_First);
; 1604 :     const auto _ULast = _Get_unwrapped(_Last);
; 1605 :     auto _UDest_true  = _Get_unwrapped_unverified(_Dest_true);
; 1606 :     auto _UDest_false = _Get_unwrapped_unverified(_Dest_false);
; 1607 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1608 :         if (_Pred(*_UFirst)) {
; 1609 :             *_UDest_true = *_UFirst;
; 1610 :             ++_UDest_true;
; 1611 :         } else {
; 1612 :             *_UDest_false = *_UFirst;
; 1613 :             ++_UDest_false;
; 1614 :         }
; 1615 :     }
; 1616 : 
; 1617 :     _Seek_wrapped(_Dest_false, _UDest_false);
; 1618 :     _Seek_wrapped(_Dest_true, _UDest_true);
; 1619 :     return {_Dest_true, _Dest_false};
; 1620 : }
; 1621 : 
; 1622 : #if _HAS_CXX17
; 1623 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
; 1624 :     _Enable_if_execution_policy_t<_ExPo> = 0>
; 1625 : pair<_FwdIt2, _FwdIt3> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest_true, _FwdIt3 _Dest_false,
; 1626 :     _Pr _Pred) noexcept /* terminates */ {
; 1627 :     // copy true partition to _Dest_true, false to _Dest_false
; 1628 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 1629 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 1630 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 1631 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt3);
; 1632 :     return _STD partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
; 1633 : }
; 1634 : 
; 1635 : #ifdef __cpp_lib_concepts
; 1636 : namespace ranges {
; 1637 :     _EXPORT_STD template <class _In, class _Out1, class _Out2>
; 1638 :     using partition_copy_result = in_out_out_result<_In, _Out1, _Out2>;
; 1639 : 
; 1640 :     class _Partition_copy_fn : private _Not_quite_object {
; 1641 :     public:
; 1642 :         using _Not_quite_object::_Not_quite_object;
; 1643 : 
; 1644 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out1, weakly_incrementable _Out2,
; 1645 :             class _Pj = identity, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1646 :             requires indirectly_copyable<_It, _Out1> && indirectly_copyable<_It, _Out2>
; 1647 :         constexpr partition_copy_result<_It, _Out1, _Out2> operator()(
; 1648 :             _It _First, _Se _Last, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj = {}) const {
; 1649 :             _Adl_verify_range(_First, _Last);
; 1650 :             auto _UResult = _Partition_copy_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 1651 :                 _Unwrap_sent<_It>(_STD move(_Last)), _Get_unwrapped_unverified(_STD move(_Dest_true)),
; 1652 :                 _Get_unwrapped_unverified(_STD move(_Dest_false)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1653 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1654 :             _Seek_wrapped(_Dest_true, _STD move(_UResult.out1));
; 1655 :             _Seek_wrapped(_Dest_false, _STD move(_UResult.out2));
; 1656 :             return {_STD move(_First), _STD move(_Dest_true), _STD move(_Dest_false)};
; 1657 :         }
; 1658 : 
; 1659 :         template <input_range _Rng, weakly_incrementable _Out1, weakly_incrementable _Out2, class _Pj = identity,
; 1660 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1661 :             requires indirectly_copyable<iterator_t<_Rng>, _Out1> && indirectly_copyable<iterator_t<_Rng>, _Out2>
; 1662 :         constexpr partition_copy_result<borrowed_iterator_t<_Rng>, _Out1, _Out2> operator()(
; 1663 :             _Rng&& _Range, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj = {}) const {
; 1664 :             auto _First   = _RANGES begin(_Range);
; 1665 :             auto _UResult = _Partition_copy_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 1666 :                 _Get_unwrapped_unverified(_STD move(_Dest_true)), _Get_unwrapped_unverified(_STD move(_Dest_false)),
; 1667 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1668 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 1669 :             _Seek_wrapped(_Dest_true, _STD move(_UResult.out1));
; 1670 :             _Seek_wrapped(_Dest_false, _STD move(_UResult.out2));
; 1671 :             return {_STD move(_First), _STD move(_Dest_true), _STD move(_Dest_false)};
; 1672 :         }
; 1673 : 
; 1674 :     private:
; 1675 :         template <class _It, class _Se, class _Out1, class _Out2, class _Pr, class _Pj>
; 1676 :         _NODISCARD static constexpr partition_copy_result<_It, _Out1, _Out2> _Partition_copy_unchecked(
; 1677 :             _It _First, const _Se _Last, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj) {
; 1678 :             // copy true partition to _Dest_true, false to _Dest_false
; 1679 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1680 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1681 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out1> && weakly_incrementable<_Out2>);
; 1682 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1683 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out1> && indirectly_copyable<_It, _Out2>);
; 1684 : 
; 1685 :             for (; _First != _Last; ++_First) {
; 1686 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1687 :                     *_Dest_true = *_First;
; 1688 :                     ++_Dest_true;
; 1689 :                 } else {
; 1690 :                     *_Dest_false = *_First;
; 1691 :                     ++_Dest_false;
; 1692 :                 }
; 1693 :             }
; 1694 : 
; 1695 :             return {_STD move(_First), _STD move(_Dest_true), _STD move(_Dest_false)};
; 1696 :         }
; 1697 :     };
; 1698 : 
; 1699 :     _EXPORT_STD inline constexpr _Partition_copy_fn partition_copy{_Not_quite_object::_Construct_tag{}};
; 1700 : } // namespace ranges
; 1701 : #endif // __cpp_lib_concepts
; 1702 : #endif // _HAS_CXX17
; 1703 : 
; 1704 : _EXPORT_STD template <class _InIt, class _Pr>
; 1705 : _NODISCARD _CONSTEXPR20 bool is_partitioned(const _InIt _First, const _InIt _Last, _Pr _Pred) {
; 1706 :     // test if [_First, _Last) partitioned by _Pred
; 1707 :     _Adl_verify_range(_First, _Last);
; 1708 :     auto _UFirst      = _Get_unwrapped(_First);
; 1709 :     const auto _ULast = _Get_unwrapped(_Last);
; 1710 : 
; 1711 :     for (;; ++_UFirst) { // skip true partition
; 1712 :         if (_UFirst == _ULast) {
; 1713 :             return true;
; 1714 :         }
; 1715 : 
; 1716 :         if (!_Pred(*_UFirst)) {
; 1717 :             break;
; 1718 :         }
; 1719 :     }
; 1720 : 
; 1721 :     while (++_UFirst != _ULast) { // verify false partition
; 1722 :         if (_Pred(*_UFirst)) {
; 1723 :             return false; // found out of place element
; 1724 :         }
; 1725 :     }
; 1726 : 
; 1727 :     return true;
; 1728 : }
; 1729 : 
; 1730 : #if _HAS_CXX17
; 1731 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1732 : _NODISCARD bool is_partitioned(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 1733 : #endif // _HAS_CXX17
; 1734 : 
; 1735 : #ifdef __cpp_lib_concepts
; 1736 : namespace ranges {
; 1737 :     class _Is_partitioned_fn : private _Not_quite_object {
; 1738 :     public:
; 1739 :         using _Not_quite_object::_Not_quite_object;
; 1740 : 
; 1741 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 1742 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1743 :         _NODISCARD constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 1744 :             _Adl_verify_range(_First, _Last);
; 1745 :             return _Is_partitioned_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 1746 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1747 :         }
; 1748 : 
; 1749 :         template <input_range _Rng, class _Pj = identity,
; 1750 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1751 :         _NODISCARD constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 1752 :             return _Is_partitioned_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1753 :         }
; 1754 : 
; 1755 :     private:
; 1756 :         template <class _It, class _Se, class _Pr, class _Pj>
; 1757 :         _NODISCARD static constexpr bool _Is_partitioned_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 1758 :             // test if [_First, _Last) is partitioned with respect to _Pred and _Proj
; 1759 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 1760 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1761 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1762 : 
; 1763 :             for (;; ++_First) { // skip true partition
; 1764 :                 if (_First == _Last) {
; 1765 :                     return true;
; 1766 :                 }
; 1767 : 
; 1768 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1769 :                     break;
; 1770 :                 }
; 1771 :             }
; 1772 : 
; 1773 :             while (++_First != _Last) { // verify false partition
; 1774 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 1775 :                     return false; // found out of place element
; 1776 :                 }
; 1777 :             }
; 1778 : 
; 1779 :             return true;
; 1780 :         }
; 1781 :     };
; 1782 : 
; 1783 :     _EXPORT_STD inline constexpr _Is_partitioned_fn is_partitioned{_Not_quite_object::_Construct_tag{}};
; 1784 : } // namespace ranges
; 1785 : #endif // __cpp_lib_concepts
; 1786 : 
; 1787 : _EXPORT_STD template <class _FwdIt, class _Pr>
; 1788 : _NODISCARD _CONSTEXPR20 _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
; 1789 :     // find beginning of false partition in [_First, _Last)
; 1790 :     _Adl_verify_range(_First, _Last);
; 1791 :     auto _UFirst      = _Get_unwrapped(_First);
; 1792 :     const auto _ULast = _Get_unwrapped(_Last);
; 1793 :     auto _Count       = _STD distance(_UFirst, _ULast);
; 1794 :     while (0 < _Count) { // divide and conquer, find half that contains answer
; 1795 :         const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count / 2);
; 1796 :         const auto _UMid   = _STD next(_UFirst, _Count2);
; 1797 : 
; 1798 :         if (_Pred(*_UMid)) { // try top half
; 1799 :             _UFirst = _Next_iter(_UMid);
; 1800 :             _Count -= _Count2;
; 1801 :             --_Count;
; 1802 :         } else {
; 1803 :             _Count = _Count2;
; 1804 :         }
; 1805 :     }
; 1806 : 
; 1807 :     _Seek_wrapped(_First, _UFirst);
; 1808 :     return _First;
; 1809 : }
; 1810 : 
; 1811 : #ifdef __cpp_lib_concepts
; 1812 : namespace ranges {
; 1813 :     class _Partition_point_fn : private _Not_quite_object {
; 1814 :     public:
; 1815 :         using _Not_quite_object::_Not_quite_object;
; 1816 : 
; 1817 :         template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 1818 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 1819 :         _NODISCARD constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 1820 :             _Adl_verify_range(_First, _Last);
; 1821 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 1822 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 1823 :                 const auto _Length = _Unwrap_sent<_It>(_STD move(_Last)) - _UFirst;
; 1824 :                 _UFirst = _Partition_point_n_unchecked(_STD move(_UFirst), _Length, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1825 :             } else {
; 1826 :                 _UFirst = _Partition_point_unchecked(
; 1827 :                     _STD move(_UFirst), _Unwrap_sent<_It>(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1828 :             }
; 1829 : 
; 1830 :             _Seek_wrapped(_First, _STD move(_UFirst));
; 1831 :             return _First;
; 1832 :         }
; 1833 : 
; 1834 :         template <forward_range _Rng, class _Pj = identity,
; 1835 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 1836 :         _NODISCARD constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 1837 :             if constexpr (sized_range<_Rng>) {
; 1838 :                 const auto _Length = _RANGES distance(_Range);
; 1839 :                 auto _UFirst = _Partition_point_n_unchecked(_Ubegin(_Range), _Length, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1840 :                 return _Rewrap_iterator(_Range, _STD move(_UFirst));
; 1841 :             } else {
; 1842 :                 auto _UFirst =
; 1843 :                     _Partition_point_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 1844 :                 return _Rewrap_iterator(_Range, _STD move(_UFirst));
; 1845 :             }
; 1846 :         }
; 1847 : 
; 1848 :     private:
; 1849 :         template <class _It, class _Pr, class _Pj>
; 1850 :         _NODISCARD static constexpr _It _Partition_point_n_unchecked(
; 1851 :             _It _First, iter_difference_t<_It> _Length, _Pr _Pred, _Pj _Proj) {
; 1852 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 1853 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1854 :             _STL_INTERNAL_CHECK(_Length >= 0);
; 1855 : 
; 1856 :             while (_Length > 0) {
; 1857 :                 const auto _Half = static_cast<iter_difference_t<_It>>(_Length / 2);
; 1858 :                 auto _Mid        = _RANGES next(_First, _Half);
; 1859 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_Mid))) { // _Mid is before the partition point
; 1860 :                     _First = _STD move(_Mid);
; 1861 :                     ++_First;
; 1862 :                     _Length -= _Half;
; 1863 :                     --_Length;
; 1864 :                 } else { // _Mid is at or past the partition point
; 1865 :                     _Length = _Half;
; 1866 :                 }
; 1867 :             }
; 1868 : 
; 1869 :             return _First;
; 1870 :         }
; 1871 : 
; 1872 :         template <class _It, class _Se, class _Pr, class _Pj>
; 1873 :         _NODISCARD static constexpr _It _Partition_point_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 1874 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 1875 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 1876 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 1877 : 
; 1878 :             // Instead of blindly seeking the end of the range, probe elements at exponentially increasing intervals to
; 1879 :             // find an element past the partition point.
; 1880 :             iter_difference_t<_It> _Skip = 2;
; 1881 :             for (;;) {
; 1882 :                 auto _Mid = _First;
; 1883 :                 _Skip -= _RANGES advance(_Mid, _Skip, _Last);
; 1884 :                 if (_Mid == _Last) { // we've located the end of the range
; 1885 :                     break;
; 1886 :                 }
; 1887 : 
; 1888 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_Mid))) { // _Mid is at or past the partition point
; 1889 :                     break;
; 1890 :                 }
; 1891 : 
; 1892 :                 _First = _STD move(_Mid);
; 1893 :                 ++_First;
; 1894 : 
; 1895 :                 using _Uty = _Make_unsigned_like_t<iter_difference_t<_It>>;
; 1896 :                 if (static_cast<_Uty>(_Skip) <= (static_cast<_Uty>(-1) >> 1)) {
; 1897 :                     _Skip <<= 1;
; 1898 :                 }
; 1899 :             }
; 1900 : 
; 1901 :             return _Partition_point_n_unchecked(_STD move(_First), _Skip, _Pred, _Proj);
; 1902 :         }
; 1903 :     };
; 1904 : 
; 1905 :     _EXPORT_STD inline constexpr _Partition_point_fn partition_point{_Not_quite_object::_Construct_tag{}};
; 1906 : } // namespace ranges
; 1907 : #endif // __cpp_lib_concepts
; 1908 : 
; 1909 : template <class _InIt1, class _InIt2, class _Pr>
; 1910 : _NODISCARD _CONSTEXPR20 bool _Equal_rev_pred_unchecked(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 1911 :     // compare [_First1, ...) to [_First2, _Last2)
; 1912 :     if constexpr (_Equal_memcmp_is_safe<_InIt1, _InIt2, _Pr>) {
; 1913 : #if _HAS_CXX20
; 1914 :         if (!_STD is_constant_evaluated())
; 1915 : #endif // _HAS_CXX20
; 1916 :         {
; 1917 :             return _Memcmp_ranges(_First2, _Last2, _First1) == 0;
; 1918 :         }
; 1919 :     }
; 1920 : 
; 1921 :     for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
; 1922 :         if (!_Pred(*_First1, *_First2)) {
; 1923 :             return false;
; 1924 :         }
; 1925 :     }
; 1926 : 
; 1927 :     return true;
; 1928 : }
; 1929 : 
; 1930 : _EXPORT_STD template <class _FwdItHaystack, class _FwdItPat, class _Pr>
; 1931 : _NODISCARD _CONSTEXPR20 _FwdItHaystack search(_FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
; 1932 :     const _FwdItPat _Last2, _Pr _Pred) { // find first [_First2, _Last2) satisfying _Pred
; 1933 :     _Adl_verify_range(_First1, _Last1);
; 1934 :     _Adl_verify_range(_First2, _Last2);
; 1935 :     auto _UFirst1       = _Get_unwrapped(_First1);
; 1936 :     const auto _ULast1  = _Get_unwrapped(_Last1);
; 1937 :     const auto _UFirst2 = _Get_unwrapped(_First2);
; 1938 :     const auto _ULast2  = _Get_unwrapped(_Last2);
; 1939 :     if constexpr (_Is_ranges_random_iter_v<_FwdItHaystack> && _Is_ranges_random_iter_v<_FwdItPat>) {
; 1940 :         const _Iter_diff_t<_FwdItPat> _Count2 = _ULast2 - _UFirst2;
; 1941 :         if (_ULast1 - _UFirst1 >= _Count2) {
; 1942 :             const auto _Last_possible = _ULast1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
; 1943 :             for (;; ++_UFirst1) {
; 1944 :                 if (_Equal_rev_pred_unchecked(_UFirst1, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
; 1945 :                     _Seek_wrapped(_Last1, _UFirst1);
; 1946 :                     break;
; 1947 :                 }
; 1948 : 
; 1949 :                 if (_UFirst1 == _Last_possible) {
; 1950 :                     break;
; 1951 :                 }
; 1952 :             }
; 1953 :         }
; 1954 :     } else {
; 1955 :         for (;; ++_UFirst1) { // loop until match or end of a sequence
; 1956 :             auto _UMid1 = _UFirst1;
; 1957 :             for (auto _UMid2 = _UFirst2;; ++_UMid1, (void) ++_UMid2) {
; 1958 :                 if (_UMid2 == _ULast2) {
; 1959 :                     _Seek_wrapped(_Last1, _UFirst1);
; 1960 :                     return _Last1;
; 1961 :                 } else if (_UMid1 == _ULast1) {
; 1962 :                     return _Last1;
; 1963 :                 } else if (!_Pred(*_UMid1, *_UMid2)) {
; 1964 :                     break;
; 1965 :                 }
; 1966 :             }
; 1967 :         }
; 1968 :     }
; 1969 : 
; 1970 :     return _Last1;
; 1971 : }
; 1972 : 
; 1973 : #if _HAS_CXX17
; 1974 : _EXPORT_STD template <class _ExPo, class _FwdItHaystack, class _FwdItPat, class _Pr,
; 1975 :     _Enable_if_execution_policy_t<_ExPo> = 0>
; 1976 : _NODISCARD _FwdItHaystack search(_ExPo&& _Exec, _FwdItHaystack _First1, _FwdItHaystack _Last1, _FwdItPat _First2,
; 1977 :     _FwdItPat _Last2, _Pr _Pred) noexcept; // terminates
; 1978 : #endif // _HAS_CXX17
; 1979 : 
; 1980 : _EXPORT_STD template <class _FwdItHaystack, class _FwdItPat>
; 1981 : _NODISCARD _CONSTEXPR20 _FwdItHaystack search(
; 1982 :     const _FwdItHaystack _First1, const _FwdItHaystack _Last1, const _FwdItPat _First2, const _FwdItPat _Last2) {
; 1983 :     // find first [_First2, _Last2) match
; 1984 :     return _STD search(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 1985 : }
; 1986 : 
; 1987 : #if _HAS_CXX17
; 1988 : _EXPORT_STD template <class _ExPo, class _FwdItHaystack, class _FwdItPat, _Enable_if_execution_policy_t<_ExPo> = 0>
; 1989 : _NODISCARD _FwdItHaystack search(_ExPo&& _Exec, const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
; 1990 :     const _FwdItPat _First2, const _FwdItPat _Last2) noexcept /* terminates */ {
; 1991 :     // find first [_First2, _Last2) match
; 1992 :     return _STD search(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 1993 : }
; 1994 : #endif // _HAS_CXX17
; 1995 : 
; 1996 : _EXPORT_STD template <class _FwdItHaystack, class _Searcher>
; 1997 : _NODISCARD _CONSTEXPR20 _FwdItHaystack search(
; 1998 :     const _FwdItHaystack _First, const _FwdItHaystack _Last, const _Searcher& _Search) {
; 1999 :     // find _Search's pattern in [_First, _Last)
; 2000 :     return _Search(_First, _Last).first;
; 2001 : }
; 2002 : 
; 2003 : _EXPORT_STD template <class _FwdIt, class _Diff, class _Ty, class _Pr>
; 2004 : _NODISCARD _CONSTEXPR20 _FwdIt search_n(
; 2005 :     const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) {
; 2006 :     // find first _Count * _Val satisfying _Pred
; 2007 :     const _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 2008 :     if (_Count <= 0) {
; 2009 :         return _First;
; 2010 :     }
; 2011 : 
; 2012 :     if (static_cast<uintmax_t>(_Count) > static_cast<uintmax_t>((numeric_limits<_Iter_diff_t<_FwdIt>>::max)())) {
; 2013 :         // if the number of _Vals searched for is larger than the longest possible sequence, we can't find it
; 2014 :         return _Last;
; 2015 :     }
; 2016 : 
; 2017 :     _Adl_verify_range(_First, _Last);
; 2018 :     auto _UFirst      = _Get_unwrapped(_First);
; 2019 :     const auto _ULast = _Get_unwrapped(_Last);
; 2020 :     if constexpr (_Is_ranges_random_iter_v<_FwdIt>) {
; 2021 :         const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
; 2022 :         auto _UOld_first       = _UFirst;
; 2023 :         for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _ULast - _UOld_first;) { // enough room, look for a match
; 2024 :             _UFirst = _UOld_first + _Inc;
; 2025 :             if (_Pred(*_UFirst, _Val)) { // found part of possible match, check it out
; 2026 :                 _Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
; 2027 :                 auto _UMid                   = _UFirst;
; 2028 : 
; 2029 :                 while (_UOld_first != _UFirst && _Pred(*_Prev_iter(_UFirst), _Val)) { // back up over any skipped prefix
; 2030 :                     --_Count1;
; 2031 :                     --_UFirst;
; 2032 :                 }
; 2033 : 
; 2034 :                 if (_Count1 <= _ULast - _UMid) {
; 2035 :                     for (;;) { // enough left, test suffix
; 2036 :                         if (--_Count1 == 0) {
; 2037 :                             _Seek_wrapped(_Last, _UFirst); // found rest of match, report it
; 2038 :                             return _Last;
; 2039 :                         } else if (!_Pred(*++_UMid, _Val)) { // short match not at end
; 2040 :                             break;
; 2041 :                         }
; 2042 :                     }
; 2043 :                 }
; 2044 :                 _UOld_first = ++_UMid; // failed match, take small jump
; 2045 :                 _Inc        = 0;
; 2046 :             } else { // no match, take big jump and back up as needed
; 2047 :                 _UOld_first = _Next_iter(_UFirst);
; 2048 :                 _Inc        = _Count_diff - 1;
; 2049 :             }
; 2050 :         }
; 2051 :     } else {
; 2052 :         for (; _UFirst != _ULast; ++_UFirst) {
; 2053 :             if (_Pred(*_UFirst, _Val)) { // found start of possible match, check it out
; 2054 :                 auto _UMid = _UFirst;
; 2055 : 
; 2056 :                 for (_Algorithm_int_t<_Diff> _Count1 = _Count;;) {
; 2057 :                     if (--_Count1 == 0) {
; 2058 :                         _Seek_wrapped(_Last, _UFirst); // found rest of match, report it
; 2059 :                         return _Last;
; 2060 :                     } else if (++_UMid == _ULast) {
; 2061 :                         return _Last; // short match at end
; 2062 :                     } else if (!_Pred(*_UMid, _Val)) { // short match not at end
; 2063 :                         break;
; 2064 :                     }
; 2065 :                 }
; 2066 : 
; 2067 :                 _UFirst = _UMid; // pick up just beyond failed match
; 2068 :             }
; 2069 :         }
; 2070 :     }
; 2071 : 
; 2072 :     return _Last;
; 2073 : }
; 2074 : 
; 2075 : #if _HAS_CXX17
; 2076 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Ty, class _Pr,
; 2077 :     _Enable_if_execution_policy_t<_ExPo> = 0>
; 2078 : _NODISCARD _FwdIt search_n(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Diff _Count_raw, const _Ty& _Val,
; 2079 :     _Pr _Pred) noexcept; // terminates
; 2080 : #endif // _HAS_CXX17
; 2081 : 
; 2082 : _EXPORT_STD template <class _FwdIt, class _Diff, class _Ty>
; 2083 : _NODISCARD _CONSTEXPR20 _FwdIt search_n(const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val) {
; 2084 :     // find first _Count * _Val match
; 2085 :     return _STD search_n(_First, _Last, _Count, _Val, equal_to<>{});
; 2086 : }
; 2087 : 
; 2088 : #if _HAS_CXX17
; 2089 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 2090 : _NODISCARD _FwdIt search_n(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Diff _Count,
; 2091 :     const _Ty& _Val) noexcept /* terminates */ { // find first _Count * _Val match
; 2092 :     return _STD search_n(_STD forward<_ExPo>(_Exec), _First, _Last, _Count, _Val, equal_to{});
; 2093 : }
; 2094 : #endif // _HAS_CXX17
; 2095 : 
; 2096 : #ifdef __cpp_lib_concepts
; 2097 : namespace ranges {
; 2098 :     class _Search_n_fn : private _Not_quite_object {
; 2099 :     public:
; 2100 :         using _Not_quite_object::_Not_quite_object;
; 2101 : 
; 2102 :         template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pr = ranges::equal_to,
; 2103 :             class _Pj = identity>
; 2104 :             requires indirectly_comparable<_It, const _Ty*, _Pr, _Pj>
; 2105 :         _NODISCARD constexpr subrange<_It> operator()(_It _First, _Se _Last, const iter_difference_t<_It> _Count,
; 2106 :             const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 2107 :             _Adl_verify_range(_First, _Last);
; 2108 : 
; 2109 :             if (_Count <= 0) {
; 2110 :                 return {_First, _First};
; 2111 :             }
; 2112 : 
; 2113 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 2114 :             auto _ULast  = _Unwrap_sent<_It>(_STD move(_Last));
; 2115 : 
; 2116 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 2117 :                 const auto _Dist = _ULast - _UFirst;
; 2118 :                 auto _UResult =
; 2119 :                     _Search_n_sized(_STD move(_UFirst), _Dist, _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2120 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2121 :             } else {
; 2122 :                 auto _UResult = _Search_n_unsized(
; 2123 :                     _STD move(_UFirst), _STD move(_ULast), _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2124 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2125 :             }
; 2126 :         }
; 2127 : 
; 2128 :         template <forward_range _Rng, class _Ty, class _Pr = ranges::equal_to, class _Pj = identity>
; 2129 :             requires indirectly_comparable<iterator_t<_Rng>, const _Ty*, _Pr, _Pj>
; 2130 :         _NODISCARD constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, const range_difference_t<_Rng> _Count,
; 2131 :             const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 2132 :             auto _First = _RANGES begin(_Range);
; 2133 : 
; 2134 :             if (_Count <= 0) {
; 2135 :                 return {_First, _First};
; 2136 :             }
; 2137 : 
; 2138 :             if constexpr (sized_range<_Rng>) {
; 2139 :                 const auto _Dist = _RANGES distance(_Range);
; 2140 : 
; 2141 :                 auto _UResult =
; 2142 :                     _Search_n_sized(_Get_unwrapped(_First), _Dist, _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2143 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_First, _STD move(_UResult));
; 2144 :             } else {
; 2145 :                 auto _UResult = _Search_n_unsized(
; 2146 :                     _Unwrap_range_iter<_Rng>(_First), _Uend(_Range), _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2147 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_First, _STD move(_UResult));
; 2148 :             }
; 2149 :         }
; 2150 : 
; 2151 :     private:
; 2152 :         template <class _It, class _Ty, class _Pr, class _Pj>
; 2153 :         _NODISCARD static constexpr subrange<_It> _Search_n_sized(_It _First, iter_difference_t<_It> _Dist,
; 2154 :             const _Ty& _Val, const iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
; 2155 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 2156 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It, const _Ty*, _Pr, _Pj>);
; 2157 :             _STL_INTERNAL_CHECK(_Count > 0);
; 2158 :             // pre: _First + [0, _Dist) is a valid counted range
; 2159 : 
; 2160 :             if constexpr (bidirectional_iterator<_It>) {
; 2161 :                 if (_Dist < _Count) {
; 2162 :                     _RANGES advance(_First, _Dist);
; 2163 :                     return {_First, _First};
; 2164 :                 }
; 2165 : 
; 2166 :                 auto _Last = _RANGES next(_First, _Count);
; 2167 :                 auto _Mid1 = _First;
; 2168 :                 auto _Mid2 = _Last;
; 2169 :                 for (;;) {
; 2170 :                     // Invariants: _Last - _First == _Count, [_First, _Mid1) and [_Mid2, _Last) match _Val:
; 2171 :                     //
; 2172 :                     // _First  _Mid1    _Mid2    _Last
; 2173 :                     // |=======|????????|========|??????...
; 2174 : 
; 2175 :                     --_Mid2;
; 2176 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj, *_Mid2), _Val)) { // mismatch; skip past it
; 2177 :                         ++_Mid2;
; 2178 :                         const auto _Delta = _RANGES distance(_First, _Mid2);
; 2179 : 
; 2180 :                         if (_Dist - _Delta < _Count) { // not enough space left
; 2181 :                             _First = _STD move(_Last);
; 2182 :                             _Dist -= _Count;
; 2183 :                             break;
; 2184 :                         }
; 2185 : 
; 2186 :                         _First = _STD move(_Mid2);
; 2187 :                         _Dist -= _Delta;
; 2188 :                         _Mid1 = _Last;
; 2189 :                         _RANGES advance(_Last, _Delta);
; 2190 :                         _Mid2 = _Last;
; 2191 :                         continue;
; 2192 :                     }
; 2193 : 
; 2194 :                     if (_Mid2 == _Mid1) { // [_Mid1, _Mid2) is empty, so [_First, _Last) all match
; 2195 :                         return {_STD move(_First), _STD move(_Last)};
; 2196 :                     }
; 2197 :                 }
; 2198 :             } else {
; 2199 :                 for (; _Dist >= _Count; ++_First, (void) --_Dist) {
; 2200 :                     if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _Val)) {
; 2201 :                         auto _Saved = _First;
; 2202 :                         for (iter_difference_t<_It> _Len = 0;;) {
; 2203 :                             ++_First;
; 2204 :                             if (++_Len == _Count) { // match
; 2205 :                                 return {_STD move(_Saved), _STD move(_First)};
; 2206 :                             }
; 2207 : 
; 2208 :                             if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First), _Val)) { // mismatch
; 2209 :                                 _Dist -= _Len;
; 2210 :                                 break;
; 2211 :                             }
; 2212 :                         }
; 2213 :                     }
; 2214 :                 }
; 2215 :             }
; 2216 : 
; 2217 :             _RANGES advance(_First, _Dist);
; 2218 :             return {_First, _First};
; 2219 :         }
; 2220 : 
; 2221 :         template <class _It, class _Se, class _Ty, class _Pr, class _Pj>
; 2222 :         _NODISCARD static constexpr subrange<_It> _Search_n_unsized(
; 2223 :             _It _First, const _Se _Last, const _Ty& _Val, const iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
; 2224 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 2225 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2226 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It, const _Ty*, _Pr, _Pj>);
; 2227 :             _STL_INTERNAL_CHECK(_Count > 0);
; 2228 : 
; 2229 :             for (; _First != _Last; ++_First) {
; 2230 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _Val)) {
; 2231 :                     auto _Saved = _First;
; 2232 :                     for (auto _Len = _Count;;) {
; 2233 :                         ++_First;
; 2234 :                         if (--_Len == 0) { // match
; 2235 :                             return {_STD move(_Saved), _STD move(_First)};
; 2236 :                         }
; 2237 : 
; 2238 :                         if (_First == _Last) { // no more to match against
; 2239 :                             return {_First, _First};
; 2240 :                         }
; 2241 : 
; 2242 :                         if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First), _Val)) { // mismatch
; 2243 :                             break;
; 2244 :                         }
; 2245 :                     }
; 2246 :                 }
; 2247 :             }
; 2248 : 
; 2249 :             return {_First, _First};
; 2250 :         }
; 2251 :     };
; 2252 : 
; 2253 :     _EXPORT_STD inline constexpr _Search_n_fn search_n{_Not_quite_object::_Construct_tag{}};
; 2254 : 
; 2255 : #if _HAS_CXX23
; 2256 :     class _Starts_with_fn : private _Not_quite_object {
; 2257 :     public:
; 2258 :         using _Not_quite_object::_Not_quite_object;
; 2259 : 
; 2260 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 2261 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 2262 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 2263 :         _NODISCARD constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 2264 :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 2265 :             _Adl_verify_range(_First1, _Last1);
; 2266 :             _Adl_verify_range(_First2, _Last2);
; 2267 : 
; 2268 :             auto _UFirst1      = _Unwrap_iter<_Se1>(_STD move(_First1));
; 2269 :             auto _ULast1       = _Unwrap_sent<_It1>(_STD move(_Last1));
; 2270 :             auto _UFirst2      = _Unwrap_iter<_Se2>(_STD move(_First2));
; 2271 :             const auto _ULast2 = _Unwrap_sent<_It2>(_STD move(_Last2));
; 2272 :             if constexpr (_Sized_or_unreachable_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 2273 :                 const iter_difference_t<_It2> _Count2 = _ULast2 - _UFirst2;
; 2274 :                 if constexpr (sized_sentinel_for<_Se1, _It1>) {
; 2275 :                     if (_Count2 > _ULast1 - _UFirst1) {
; 2276 :                         return false;
; 2277 :                     }
; 2278 :                 }
; 2279 : 
; 2280 :                 return _RANGES _Equal_count(_STD move(_UFirst1), _STD move(_UFirst2),
; 2281 :                     static_cast<iter_difference_t<_It1>>(_Count2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 2282 :             } else {
; 2283 :                 const auto _Result = _RANGES _Mismatch_4(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
; 2284 :                     _ULast2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 2285 :                 return _Result.in2 == _ULast2;
; 2286 :             }
; 2287 :         }
; 2288 : 
; 2289 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 2290 :             class _Pj2 = identity>
; 2291 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 2292 :         _NODISCARD constexpr bool operator()(
; 2293 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 2294 :             if constexpr (_Sized_or_infinite_range<_Rng1> && sized_range<_Rng2>) {
; 2295 :                 const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
; 2296 :                 if constexpr (sized_range<_Rng1>) {
; 2297 :                     if (_Count2 > _RANGES distance(_Range1)) {
; 2298 :                         return false;
; 2299 :                     }
; 2300 :                 }
; 2301 : 
; 2302 :                 return _RANGES _Equal_count(_Ubegin(_Range1), _Ubegin(_Range2),
; 2303 :                     static_cast<range_difference_t<_Rng1>>(_Count2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
; 2304 :                     _Pass_fn(_Proj2));
; 2305 :             } else {
; 2306 :                 const auto _ULast2 = _Uend(_Range2);
; 2307 :                 const auto _Result = _RANGES _Mismatch_4(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _ULast2,
; 2308 :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 2309 :                 return _Result.in2 == _ULast2;
; 2310 :             }
; 2311 :         }
; 2312 :     };
; 2313 : 
; 2314 :     _EXPORT_STD inline constexpr _Starts_with_fn starts_with{_Not_quite_object::_Construct_tag{}};
; 2315 : 
; 2316 :     class _Ends_with_fn : private _Not_quite_object {
; 2317 :     public:
; 2318 :         using _Not_quite_object::_Not_quite_object;
; 2319 : 
; 2320 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 2321 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 2322 :             requires (forward_iterator<_It1> || sized_sentinel_for<_Se1, _It1>)
; 2323 :                   && (forward_iterator<_It2> || sized_sentinel_for<_Se2, _It2>)
; 2324 :                   && indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 2325 :         _NODISCARD constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 2326 :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 2327 :             _Adl_verify_range(_First1, _Last1);
; 2328 :             _Adl_verify_range(_First2, _Last2);
; 2329 :             auto _UFirst1 = _Unwrap_iter<_Se1>(_STD move(_First1));
; 2330 :             auto _ULast1  = _Unwrap_sent<_It1>(_STD move(_Last1));
; 2331 :             auto _UFirst2 = _Unwrap_iter<_Se2>(_STD move(_First2));
; 2332 :             auto _ULast2  = _Unwrap_sent<_It2>(_STD move(_Last2));
; 2333 : 
; 2334 :             const auto _Count1 = _Distance_helper(_UFirst1, _ULast1);
; 2335 :             const auto _Count2 = _Distance_helper(_UFirst2, _ULast2);
; 2336 : 
; 2337 :             return _Ends_with_impl(_STD move(_UFirst1), _STD move(_ULast1), _Count1, _STD move(_UFirst2),
; 2338 :                 _STD move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 2339 :         }
; 2340 : 
; 2341 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 2342 :             class _Pj2 = identity>
; 2343 :             requires (forward_range<_Rng1> || sized_range<_Rng1>) && (forward_range<_Rng2> || sized_range<_Rng2>)
; 2344 :                   && indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 2345 :         _NODISCARD constexpr bool operator()(
; 2346 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 2347 :             const auto _Count1 = _Distance_helper(_Range1);
; 2348 :             const auto _Count2 = _Distance_helper(_Range2);
; 2349 : 
; 2350 :             return _Ends_with_impl(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2), _Uend(_Range2), _Count2,
; 2351 :                 _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 2352 :         }
; 2353 : 
; 2354 :     private:
; 2355 :         struct _Not_a_difference {};
; 2356 : 
; 2357 :         template <class _It, class _Se>
; 2358 :         _NODISCARD static constexpr auto _Distance_helper(const _It& _First, const _Se& _Last) {
; 2359 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2360 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 2361 :                 return _Last - _First;
; 2362 :             } else {
; 2363 :                 return _Not_a_difference{};
; 2364 :             }
; 2365 :         }
; 2366 : 
; 2367 :         template <class _Rng>
; 2368 :         _NODISCARD static constexpr auto _Distance_helper(_Rng&& _Range) {
; 2369 :             _STL_INTERNAL_STATIC_ASSERT(range<_Rng>);
; 2370 :             if constexpr (sized_range<_Rng>) {
; 2371 :                 return _RANGES distance(_Range);
; 2372 :             } else {
; 2373 :                 return _Not_a_difference{};
; 2374 :             }
; 2375 :         }
; 2376 : 
; 2377 :         template <class _Ty, class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
; 2378 :         _NODISCARD static constexpr bool _Match_backwards(
; 2379 :             const _Ty _First1, _It1 _Last1, const _It2 _First2, _It2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 2380 :             _STL_INTERNAL_STATIC_ASSERT(same_as<_Ty, _It1> || same_as<_Ty, unreachable_sentinel_t>);
; 2381 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It1>);
; 2382 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It2>);
; 2383 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 2384 : 
; 2385 :             for (;;) {
; 2386 :                 if (_First2 == _Last2) { // needle exhausted - match
; 2387 :                     return true;
; 2388 :                 }
; 2389 : 
; 2390 :                 if (_First1 == _Last1) { // haystack exhausted - no match
; 2391 :                     return false;
; 2392 :                 }
; 2393 : 
; 2394 :                 --_Last1;
; 2395 :                 --_Last2;
; 2396 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Last1), _STD invoke(_Proj2, *_Last2))) {
; 2397 :                     return false; // non-equal elements - no match
; 2398 :                 }
; 2399 :             }
; 2400 :         }
; 2401 : 
; 2402 :         template <class _It1, class _Se1, class _Diff1, class _It2, class _Pr, class _Pj1, class _Pj2>
; 2403 :         _NODISCARD static constexpr bool _Ends_with_sized_needle(_It1 _First1, _Se1 _Last1, _Diff1 _Count1,
; 2404 :             _It2 _First2, iter_difference_t<_It2> _Count2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 2405 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It1> && sentinel_for<_Se1, _It1>);
; 2406 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1> || same_as<_Diff1, iter_difference_t<_It1>>);
; 2407 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It2>);
; 2408 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 2409 : 
; 2410 :             constexpr bool _Sized1 = !same_as<_Diff1, _Not_a_difference>;
; 2411 : 
; 2412 :             if constexpr (random_access_iterator<_It1> && _Sized1) {
; 2413 :                 _First1 += static_cast<iter_difference_t<_It1>>(_Count1 - _Count2);
; 2414 :             } else if constexpr (_Bidi_common<_It1, _Se1>) {
; 2415 :                 if constexpr (_Sized1) {
; 2416 :                     if ((_Count1 >> 1) >= _Count2) { // beginning of potential match is closer to _Last1
; 2417 :                         _RANGES advance(_Last1, static_cast<iter_difference_t<_It1>>(-_Count2));
; 2418 :                         _First1 = _STD move(_Last1);
; 2419 :                     } else { // beginning of potential match is closer to _First1
; 2420 :                         _RANGES advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
; 2421 :                     }
; 2422 :                 } else { // Only second range is sized
; 2423 :                     if (_RANGES advance(_Last1, static_cast<iter_difference_t<_It1>>(-_Count2), _First1) != 0) {
; 2424 :                         // distance(_First1, _Last1) < _Count2
; 2425 :                         return false;
; 2426 :                     }
; 2427 :                     _First1 = _STD move(_Last1);
; 2428 :                 }
; 2429 :             } else if constexpr (forward_iterator<_It1>) {
; 2430 :                 auto _Mid1  = _First1;
; 2431 :                 auto _Count = _Count2;
; 2432 :                 do {
; 2433 :                     if (_Mid1 == _Last1) { // distance(_First1, _Last1) < _Count2
; 2434 :                         return false;
; 2435 :                     }
; 2436 : 
; 2437 :                     ++_Mid1;
; 2438 :                 } while (--_Count != 0);
; 2439 : 
; 2440 :                 // At this point, distance(_First1, _Mid1) == _Count2
; 2441 :                 while (_Mid1 != _Last1) {
; 2442 :                     ++_First1;
; 2443 :                     ++_Mid1;
; 2444 :                 }
; 2445 :             } else {
; 2446 :                 _RANGES advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
; 2447 :             }
; 2448 : 
; 2449 :             return _RANGES _Equal_count(_STD move(_First1), _STD move(_First2),
; 2450 :                 static_cast<iter_difference_t<_It1>>(_Count2), _Pred, _Proj1, _Proj2);
; 2451 :         }
; 2452 : 
; 2453 :         template <class _It1, class _Se1, class _Diff1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 2454 :         _NODISCARD static constexpr bool _Ends_with_unsized_needle(
; 2455 :             _It1 _First1, _Se1 _Last1, _Diff1 _Count1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 2456 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It1> && sentinel_for<_Se1, _It1>);
; 2457 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1> || same_as<_Diff1, iter_difference_t<_It1>>);
; 2458 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2> && sentinel_for<_Se2, _It2>);
; 2459 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 2460 : 
; 2461 :             constexpr bool _Sized1 = !same_as<_Diff1, _Not_a_difference>;
; 2462 : 
; 2463 :             iter_difference_t<_It2> _Count2 = 0;
; 2464 : 
; 2465 :             if constexpr (_Sized1) {
; 2466 :                 for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2, (void) ++_Count2) {
; 2467 :                     if (_Count2 == _Count1) { // distance(_First1, _Last1) < distance(_First2, _Last2)
; 2468 :                         return false;
; 2469 :                     }
; 2470 :                 }
; 2471 : 
; 2472 :                 _RANGES advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
; 2473 :             } else { // first range isn't sized, so must be forward
; 2474 :                 auto _Mid1 = _First1;
; 2475 :                 for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid1, (void) ++_Mid2, ++_Count2) {
; 2476 :                     if (_Mid1 == _Last1) { // distance(_First1, _Last1) < distance(_First2, _Last2)
; 2477 :                         return false;
; 2478 :                     }
; 2479 :                 }
; 2480 : 
; 2481 :                 // distance(_First1, _Mid1) == distance(_First2, _Last2) == _Count2
; 2482 :                 while (_Mid1 != _Last1) {
; 2483 :                     ++_First1;
; 2484 :                     ++_Mid1;
; 2485 :                 }
; 2486 :             }
; 2487 : 
; 2488 :             return _RANGES _Equal_count(_STD move(_First1), _STD move(_First2),
; 2489 :                 static_cast<iter_difference_t<_It1>>(_Count2), _Pred, _Proj1, _Proj2);
; 2490 :         }
; 2491 : 
; 2492 :         template <class _It1, class _Se1, class _Diff1, class _It2, class _Se2, class _Diff2, class _Pr, class _Pj1,
; 2493 :             class _Pj2>
; 2494 :         _NODISCARD static constexpr bool _Ends_with_impl(_It1 _First1, _Se1 _Last1, _Diff1 _Count1, _It2 _First2,
; 2495 :             _Se2 _Last2, _Diff2 _Count2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 2496 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 2497 :             _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_Diff1, iter_difference_t<_It1>, _Not_a_difference>);
; 2498 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 2499 :             _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_Diff2, iter_difference_t<_It2>, _Not_a_difference>);
; 2500 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 2501 : 
; 2502 :             constexpr bool _Sized1           = !same_as<_Diff1, _Not_a_difference>;
; 2503 :             constexpr bool _Sized2           = !same_as<_Diff2, _Not_a_difference>;
; 2504 :             constexpr bool _Both_sized       = _Sized1 && _Sized2;
; 2505 :             constexpr bool _Both_bidi_common = _Bidi_common<_It1, _Se1> && _Bidi_common<_It2, _Se2>;
; 2506 : 
; 2507 :             if constexpr (_Both_sized) {
; 2508 :                 if (_Count2 > _Count1) {
; 2509 :                     return false;
; 2510 :                 }
; 2511 :             }
; 2512 : 
; 2513 :             if constexpr (_Sized2) {
; 2514 :                 if (_Count2 == 0) {
; 2515 :                     return true;
; 2516 :                 }
; 2517 :             }
; 2518 : 
; 2519 :             if constexpr (_Both_bidi_common && !(random_access_iterator<_It1> && _Both_sized)) {
; 2520 :                 if constexpr (_Both_sized) {
; 2521 :                     return _Match_backwards(unreachable_sentinel, _STD move(_Last1), _STD move(_First2),
; 2522 :                         _STD move(_Last2), _Pred, _Proj1, _Proj2);
; 2523 :                 } else {
; 2524 :                     return _Match_backwards(_STD move(_First1), _STD move(_Last1), _STD move(_First2),
; 2525 :                         _STD move(_Last2), _Pred, _Proj1, _Proj2);
; 2526 :                 }
; 2527 :             } else if constexpr (_Sized2) {
; 2528 :                 return _Ends_with_sized_needle(
; 2529 :                     _STD move(_First1), _STD move(_Last1), _Count1, _STD move(_First2), _Count2, _Pred, _Proj1, _Proj2);
; 2530 :             } else {
; 2531 :                 return _Ends_with_unsized_needle(_STD move(_First1), _STD move(_Last1), _Count1, _STD move(_First2),
; 2532 :                     _STD move(_Last2), _Pred, _Proj1, _Proj2);
; 2533 :             }
; 2534 :         }
; 2535 :     };
; 2536 : 
; 2537 :     _EXPORT_STD inline constexpr _Ends_with_fn ends_with{_Not_quite_object::_Construct_tag{}};
; 2538 : 
; 2539 :     template <class _Fn>
; 2540 :     class _Flipped {
; 2541 :     private:
; 2542 :         _Fn _Func;
; 2543 : 
; 2544 :     public:
; 2545 :         template <class _Ty, class _Uty>
; 2546 :             requires invocable<_Fn&, _Uty, _Ty>
; 2547 :         invoke_result_t<_Fn&, _Uty, _Ty> operator()(_Ty&&, _Uty&&);
; 2548 :     };
; 2549 : 
; 2550 :     template <class _Fn, class _Ty, class _It, class _Uty>
; 2551 :     concept _Indirectly_binary_left_foldable_impl =
; 2552 :         movable<_Ty> && movable<_Uty> && convertible_to<_Ty, _Uty> && invocable<_Fn&, _Uty, iter_reference_t<_It>>
; 2553 :         && assignable_from<_Uty&, invoke_result_t<_Fn&, _Uty, iter_reference_t<_It>>>;
; 2554 : 
; 2555 :     template <class _Fn, class _Ty, class _It>
; 2556 :     concept _Indirectly_binary_left_foldable =
; 2557 :         copy_constructible<_Fn> && indirectly_readable<_It> && invocable<_Fn&, _Ty, iter_reference_t<_It>>
; 2558 :         && convertible_to<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>,
; 2559 :             decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>>
; 2560 :         && _Indirectly_binary_left_foldable_impl<_Fn, _Ty, _It,
; 2561 :             decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>>;
; 2562 : 
; 2563 :     template <class _Fn, class _Ty, class _It>
; 2564 :     concept _Indirectly_binary_right_foldable = _Indirectly_binary_left_foldable<_Flipped<_Fn>, _Ty, _It>;
; 2565 : 
; 2566 :     _EXPORT_STD template <class _It, class _Ty>
; 2567 :     using fold_left_with_iter_result = in_value_result<_It, _Ty>;
; 2568 : 
; 2569 :     _EXPORT_STD template <class _It, class _Ty>
; 2570 :     using fold_left_first_with_iter_result = in_value_result<_It, _Ty>;
; 2571 : 
; 2572 :     class _Fold_left_with_iter_fn : private _Not_quite_object {
; 2573 :     public:
; 2574 :         using _Not_quite_object::_Not_quite_object;
; 2575 : 
; 2576 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, _Indirectly_binary_left_foldable<_Ty, _It> _Fn>
; 2577 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
; 2578 :             _Adl_verify_range(_First, _Last);
; 2579 :             return _Fold_left_with_iter_impl<_It>(
; 2580 :                 _STD move(_First), _STD move(_Last), _STD move(_Init), _Pass_fn(_Func));
; 2581 :         }
; 2582 : 
; 2583 :         template <input_range _Rng, class _Ty, _Indirectly_binary_left_foldable<_Ty, iterator_t<_Rng>> _Fn>
; 2584 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
; 2585 :             return _Fold_left_with_iter_impl<borrowed_iterator_t<_Rng>>(
; 2586 :                 _RANGES begin(_Range), _RANGES end(_Range), _STD move(_Init), _Pass_fn(_Func));
; 2587 :         }
; 2588 : 
; 2589 :     private:
; 2590 :         template <class _RetIt, class _It, class _Se, class _Ty, class _Fn>
; 2591 :         _NODISCARD constexpr auto _Fold_left_with_iter_impl(_It&& _First, _Se&& _Last, _Ty&& _Init, _Fn _Func) const {
; 2592 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 2593 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2594 :             _STL_INTERNAL_STATIC_ASSERT(_Indirectly_binary_left_foldable<_Fn, _Ty, _It>);
; 2595 : 
; 2596 :             using _Uty         = decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>;
; 2597 :             using _Return_type = fold_left_with_iter_result<_RetIt, _Uty>;
; 2598 : 
; 2599 :             if (_First == _Last) {
; 2600 :                 return _Return_type{_STD move(_First), static_cast<_Uty>(_STD move(_Init))};
; 2601 :             } else {
; 2602 :                 auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 2603 :                 auto _ULast  = _Unwrap_sent<_It>(_STD move(_Last));
; 2604 : 
; 2605 :                 _Uty _Accum = _STD invoke(_Func, _STD move(_Init), *_UFirst);
; 2606 :                 for (++_UFirst; _UFirst != _ULast; ++_UFirst) {
; 2607 :                     _Accum = _STD invoke(_Func, _STD move(_Accum), *_UFirst);
; 2608 :                 }
; 2609 : 
; 2610 :                 _Seek_wrapped(_First, _STD move(_UFirst));
; 2611 :                 return _Return_type{_STD move(_First), _STD move(_Accum)};
; 2612 :             }
; 2613 :         }
; 2614 :     };
; 2615 : 
; 2616 :     _EXPORT_STD inline constexpr _Fold_left_with_iter_fn fold_left_with_iter{_Not_quite_object::_Construct_tag{}};
; 2617 : 
; 2618 :     class _Fold_left_fn : private _Not_quite_object {
; 2619 :     public:
; 2620 :         using _Not_quite_object::_Not_quite_object;
; 2621 : 
; 2622 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, _Indirectly_binary_left_foldable<_Ty, _It> _Fn>
; 2623 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
; 2624 :             return _RANGES fold_left_with_iter(_STD move(_First), _Last, _STD move(_Init), _Pass_fn(_Func)).value;
; 2625 :         }
; 2626 : 
; 2627 :         template <input_range _Rng, class _Ty, _Indirectly_binary_left_foldable<_Ty, iterator_t<_Rng>> _Fn>
; 2628 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
; 2629 :             return _RANGES fold_left_with_iter(_STD forward<_Rng>(_Range), _STD move(_Init), _Pass_fn(_Func)).value;
; 2630 :         }
; 2631 :     };
; 2632 : 
; 2633 :     _EXPORT_STD inline constexpr _Fold_left_fn fold_left{_Not_quite_object::_Construct_tag{}};
; 2634 : 
; 2635 :     class _Fold_left_first_with_iter_fn : private _Not_quite_object {
; 2636 :     public:
; 2637 :         using _Not_quite_object::_Not_quite_object;
; 2638 : 
; 2639 :         template <input_iterator _It, sentinel_for<_It> _Se,
; 2640 :             _Indirectly_binary_left_foldable<iter_value_t<_It>, _It> _Fn>
; 2641 :             requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
; 2642 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
; 2643 :             _Adl_verify_range(_First, _Last);
; 2644 :             return _Fold_left_first_with_iter_impl<_It>(_STD move(_First), _STD move(_Last), _Pass_fn(_Func));
; 2645 :         }
; 2646 : 
; 2647 :         template <input_range _Rng, _Indirectly_binary_left_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
; 2648 :             requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
; 2649 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
; 2650 :             return _Fold_left_first_with_iter_impl<borrowed_iterator_t<_Rng>>(
; 2651 :                 _RANGES begin(_Range), _RANGES end(_Range), _Pass_fn(_Func));
; 2652 :         }
; 2653 : 
; 2654 :     private:
; 2655 :         template <class _RetIt, class _It, class _Se, class _Fn>
; 2656 :         _NODISCARD constexpr auto _Fold_left_first_with_iter_impl(_It&& _First, _Se&& _Last, _Fn _Func) const {
; 2657 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 2658 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2659 :             _STL_INTERNAL_STATIC_ASSERT(_Indirectly_binary_left_foldable<_Fn, iter_value_t<_It>, _It>);
; 2660 :             _STL_INTERNAL_STATIC_ASSERT(constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
; 2661 : 
; 2662 :             using _Uty =
; 2663 :                 decltype(_RANGES fold_left(_STD move(_First), _Last, static_cast<iter_value_t<_It>>(*_First), _Func));
; 2664 :             using _Return_type = fold_left_first_with_iter_result<_RetIt, optional<_Uty>>;
; 2665 :             if (_First == _Last) {
; 2666 :                 return _Return_type{_STD move(_First), optional<_Uty>{}};
; 2667 :             } else {
; 2668 :                 auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 2669 :                 auto _ULast  = _Unwrap_sent<_It>(_STD move(_Last));
; 2670 : 
; 2671 :                 optional<_Uty> _Init{in_place, *_UFirst};
; 2672 :                 _Uty& _Init_ref = *_Init;
; 2673 :                 for (++_UFirst; _UFirst != _ULast; ++_UFirst) {
; 2674 :                     _Init_ref = _STD invoke(_Func, _STD move(_Init_ref), *_UFirst);
; 2675 :                 }
; 2676 : 
; 2677 :                 _Seek_wrapped(_First, _STD move(_UFirst));
; 2678 :                 return _Return_type{_STD move(_First), _STD move(_Init)};
; 2679 :             }
; 2680 :         }
; 2681 :     };
; 2682 : 
; 2683 :     _EXPORT_STD inline constexpr _Fold_left_first_with_iter_fn fold_left_first_with_iter{
; 2684 :         _Not_quite_object::_Construct_tag{}};
; 2685 : 
; 2686 :     class _Fold_left_first_fn : private _Not_quite_object {
; 2687 :     public:
; 2688 :         using _Not_quite_object::_Not_quite_object;
; 2689 : 
; 2690 :         template <input_iterator _It, sentinel_for<_It> _Se,
; 2691 :             _Indirectly_binary_left_foldable<iter_value_t<_It>, _It> _Fn>
; 2692 :             requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
; 2693 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
; 2694 :             return _RANGES fold_left_first_with_iter(_STD move(_First), _STD move(_Last), _Pass_fn(_Func)).value;
; 2695 :         }
; 2696 : 
; 2697 :         template <input_range _Rng, _Indirectly_binary_left_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
; 2698 :             requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
; 2699 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
; 2700 :             return _RANGES fold_left_first_with_iter(_STD forward<_Rng>(_Range), _Pass_fn(_Func)).value;
; 2701 :         }
; 2702 :     };
; 2703 : 
; 2704 :     _EXPORT_STD inline constexpr _Fold_left_first_fn fold_left_first{_Not_quite_object::_Construct_tag{}};
; 2705 : 
; 2706 :     template <class _It, class _Se, class _Ty, class _Fn>
; 2707 :     _NODISCARD constexpr auto _Fold_right_unchecked(_It _First, _Se _Last, _Ty _Init, _Fn _Func) {
; 2708 :         _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It>);
; 2709 :         _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2710 :         _STL_INTERNAL_STATIC_ASSERT(_Indirectly_binary_right_foldable<_Fn, _Ty, _It>);
; 2711 : 
; 2712 :         using _Uty = decay_t<invoke_result_t<_Fn&, iter_reference_t<_It>, _Ty>>;
; 2713 :         if (_First == _Last) {
; 2714 :             return static_cast<_Uty>(_STD move(_Init));
; 2715 :         } else {
; 2716 :             _It _Tail   = _RANGES next(_First, _Last);
; 2717 :             _Uty _Accum = _STD invoke(_Func, *--_Tail, _STD move(_Init));
; 2718 :             while (_First != _Tail) {
; 2719 :                 _Accum = _STD invoke(_Func, *--_Tail, _STD move(_Accum));
; 2720 :             }
; 2721 :             return _Accum;
; 2722 :         }
; 2723 :     }
; 2724 : 
; 2725 :     class _Fold_right_fn : private _Not_quite_object {
; 2726 :     public:
; 2727 :         using _Not_quite_object::_Not_quite_object;
; 2728 : 
; 2729 :         template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Ty,
; 2730 :             _Indirectly_binary_right_foldable<_Ty, _It> _Fn>
; 2731 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
; 2732 :             _Adl_verify_range(_First, _Last);
; 2733 :             return _RANGES _Fold_right_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 2734 :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Init), _Pass_fn(_Func));
; 2735 :         }
; 2736 : 
; 2737 :         template <bidirectional_range _Rng, class _Ty, _Indirectly_binary_right_foldable<_Ty, iterator_t<_Rng>> _Fn>
; 2738 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
; 2739 :             return _RANGES _Fold_right_unchecked(_Ubegin(_Range), _Uend(_Range), _STD move(_Init), _Pass_fn(_Func));
; 2740 :         }
; 2741 :     };
; 2742 : 
; 2743 :     _EXPORT_STD inline constexpr _Fold_right_fn fold_right{_Not_quite_object::_Construct_tag{}};
; 2744 : 
; 2745 :     class _Fold_right_last_fn : private _Not_quite_object {
; 2746 :     public:
; 2747 :         using _Not_quite_object::_Not_quite_object;
; 2748 : 
; 2749 :         template <bidirectional_iterator _It, sentinel_for<_It> _Se,
; 2750 :             _Indirectly_binary_right_foldable<iter_value_t<_It>, _It> _Fn>
; 2751 :             requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
; 2752 :         _NODISCARD constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
; 2753 :             _Adl_verify_range(_First, _Last);
; 2754 :             return _Fold_right_last_unchecked(
; 2755 :                 _Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _Pass_fn(_Func));
; 2756 :         }
; 2757 : 
; 2758 :         template <bidirectional_range _Rng,
; 2759 :             _Indirectly_binary_right_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
; 2760 :             requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
; 2761 :         _NODISCARD constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
; 2762 :             return _Fold_right_last_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Func));
; 2763 :         }
; 2764 : 
; 2765 :     private:
; 2766 :         template <class _It, class _Se, class _Fn>
; 2767 :         _NODISCARD constexpr auto _Fold_right_last_unchecked(_It _First, _Se _Last, _Fn _Func) const {
; 2768 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It>);
; 2769 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2770 :             _STL_INTERNAL_STATIC_ASSERT(_Indirectly_binary_right_foldable<_Fn, iter_value_t<_It>, _It>);
; 2771 :             _STL_INTERNAL_STATIC_ASSERT(constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
; 2772 : 
; 2773 :             using _Uty = decltype(_RANGES fold_right(_First, _Last, static_cast<iter_value_t<_It>>(*_First), _Func));
; 2774 :             if (_First == _Last) {
; 2775 :                 return optional<_Uty>{};
; 2776 :             } else {
; 2777 :                 _It _Tail = _RANGES prev(_RANGES next(_First, _STD move(_Last)));
; 2778 :                 return optional<_Uty>{in_place, _RANGES _Fold_right_unchecked(_STD move(_First), _Tail,
; 2779 :                                                     static_cast<iter_value_t<_It>>(*_Tail), _STD move(_Func))};
; 2780 :             }
; 2781 :         }
; 2782 :     };
; 2783 : 
; 2784 :     _EXPORT_STD inline constexpr _Fold_right_last_fn fold_right_last{_Not_quite_object::_Construct_tag{}};
; 2785 : 
; 2786 :     class _Find_last_fn : private _Not_quite_object {
; 2787 :     public:
; 2788 :         using _Not_quite_object::_Not_quite_object;
; 2789 : 
; 2790 :         template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
; 2791 :             requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
; 2792 :         _NODISCARD constexpr subrange<_It> operator()(_It _First, _Se _Last, const _Ty& _Value, _Pj _Proj = {}) const {
; 2793 :             _Adl_verify_range(_First, _Last);
; 2794 : 
; 2795 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 2796 :             if constexpr (bidirectional_iterator<_It>) {
; 2797 :                 auto _ULast   = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 2798 :                 auto _UResult = _Find_last_unchecked(_STD move(_UFirst), _STD move(_ULast), _Value, _Pass_fn(_Proj));
; 2799 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2800 :             } else {
; 2801 :                 auto _ULast   = _Unwrap_sent<_It>(_STD move(_Last));
; 2802 :                 auto _UResult = _Find_last_unchecked(_STD move(_UFirst), _STD move(_ULast), _Value, _Pass_fn(_Proj));
; 2803 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2804 :             }
; 2805 :         }
; 2806 : 
; 2807 :         template <forward_range _Rng, class _Ty, class _Pj = identity>
; 2808 :             requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
; 2809 :         _NODISCARD constexpr borrowed_subrange_t<_Rng> operator()(
; 2810 :             _Rng&& _Range, const _Ty& _Value, _Pj _Proj = {}) const {
; 2811 :             if constexpr (bidirectional_range<_Rng>) {
; 2812 :                 auto _UResult = _Find_last_unchecked(
; 2813 :                     _Ubegin(_Range), _Get_final_iterator_unwrapped(_Range), _Value, _Pass_fn(_Proj));
; 2814 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 2815 :             } else {
; 2816 :                 auto _UResult = _Find_last_unchecked(_Ubegin(_Range), _Uend(_Range), _Value, _Pass_fn(_Proj));
; 2817 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 2818 :             }
; 2819 :         }
; 2820 : 
; 2821 :     private:
; 2822 :         template <class _It, class _Se, class _Ty, class _Pj>
; 2823 :         _NODISCARD static constexpr subrange<_It> _Find_last_unchecked(
; 2824 :             _It _First, _Se _Last, const _Ty& _Value, _Pj _Proj) {
; 2825 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 2826 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2827 :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>);
; 2828 : 
; 2829 :             if constexpr (_Bidi_common<_It, _Se>) {
; 2830 :                 for (auto _Result = _Last; _Result != _First;) {
; 2831 :                     if (_STD invoke(_Proj, *--_Result) == _Value) {
; 2832 :                         return {_STD move(_Result), _STD move(_Last)};
; 2833 :                     }
; 2834 :                 }
; 2835 :                 return {_Last, _Last};
; 2836 :             } else if constexpr (same_as<_It, _Se>) {
; 2837 :                 auto _Result = _Last;
; 2838 :                 for (; _First != _Last; ++_First) {
; 2839 :                     if (_STD invoke(_Proj, *_First) == _Value) {
; 2840 :                         _Result = _First;
; 2841 :                     }
; 2842 :                 }
; 2843 :                 return {_STD move(_Result), _STD move(_Last)};
; 2844 :             } else {
; 2845 :                 auto _Result = _First;
; 2846 :                 bool _Found  = false;
; 2847 :                 for (;; ++_First) {
; 2848 :                     if (_First == _Last) {
; 2849 :                         if (!_Found) {
; 2850 :                             _Result = _First;
; 2851 :                         }
; 2852 :                         break;
; 2853 :                     }
; 2854 : 
; 2855 :                     if (_STD invoke(_Proj, *_First) == _Value) {
; 2856 :                         _Result = _First;
; 2857 :                         _Found  = true;
; 2858 :                     }
; 2859 :                 }
; 2860 :                 return {_STD move(_Result), _STD move(_First)};
; 2861 :             }
; 2862 :         }
; 2863 :     };
; 2864 : 
; 2865 :     _EXPORT_STD inline constexpr _Find_last_fn find_last{_Not_quite_object::_Construct_tag{}};
; 2866 : 
; 2867 :     template <bool _Search_for>
; 2868 :     class _Find_last_if_fn : private _Not_quite_object {
; 2869 :     public:
; 2870 :         using _Not_quite_object::_Not_quite_object;
; 2871 : 
; 2872 :         template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
; 2873 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 2874 :         _NODISCARD constexpr subrange<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 2875 :             _Adl_verify_range(_First, _Last);
; 2876 : 
; 2877 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 2878 :             if constexpr (bidirectional_iterator<_It>) {
; 2879 :                 auto _ULast = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 2880 :                 auto _UResult =
; 2881 :                     _Find_last_if_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2882 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2883 :             } else {
; 2884 :                 auto _ULast = _Unwrap_sent<_It>(_STD move(_Last));
; 2885 :                 auto _UResult =
; 2886 :                     _Find_last_if_unchecked(_STD move(_UFirst), _STD move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2887 :                 return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 2888 :             }
; 2889 :         }
; 2890 : 
; 2891 :         template <forward_range _Rng, class _Pj = identity,
; 2892 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 2893 :         _NODISCARD constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 2894 :             if constexpr (bidirectional_range<_Rng>) {
; 2895 :                 auto _UResult = _Find_last_if_unchecked(
; 2896 :                     _Ubegin(_Range), _Get_final_iterator_unwrapped(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2897 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 2898 :             } else {
; 2899 :                 auto _UResult =
; 2900 :                     _Find_last_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 2901 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 2902 :             }
; 2903 :         }
; 2904 : 
; 2905 :     private:
; 2906 :         template <class _It, class _Se, class _Pj, class _Pr>
; 2907 :         _NODISCARD static constexpr subrange<_It> _Find_last_if_unchecked(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj) {
; 2908 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 2909 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 2910 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 2911 : 
; 2912 :             if constexpr (_Bidi_common<_It, _Se>) {
; 2913 :                 for (auto _Result = _Last; _Result != _First;) {
; 2914 :                     if (_STD invoke_r<bool>(_Pred, _STD invoke(_Proj, *--_Result)) == _Search_for) {
; 2915 :                         return {_STD move(_Result), _STD move(_Last)};
; 2916 :                     }
; 2917 :                 }
; 2918 :                 return {_Last, _Last};
; 2919 :             } else if constexpr (same_as<_It, _Se>) {
; 2920 :                 auto _Result = _Last;
; 2921 :                 for (; _First != _Last; ++_First) {
; 2922 :                     if (_STD invoke_r<bool>(_Pred, _STD invoke(_Proj, *_First)) == _Search_for) {
; 2923 :                         _Result = _First;
; 2924 :                     }
; 2925 :                 }
; 2926 :                 return {_STD move(_Result), _STD move(_Last)};
; 2927 :             } else {
; 2928 :                 auto _Result = _First;
; 2929 :                 bool _Found  = false;
; 2930 :                 for (;; ++_First) {
; 2931 :                     if (_First == _Last) {
; 2932 :                         if (!_Found) {
; 2933 :                             _Result = _First;
; 2934 :                         }
; 2935 :                         break;
; 2936 :                     }
; 2937 : 
; 2938 :                     if (_STD invoke_r<bool>(_Pred, _STD invoke(_Proj, *_First)) == _Search_for) {
; 2939 :                         _Result = _First;
; 2940 :                         _Found  = true;
; 2941 :                     }
; 2942 :                 }
; 2943 :                 return {_STD move(_Result), _STD move(_First)};
; 2944 :             }
; 2945 :         }
; 2946 :     };
; 2947 : 
; 2948 :     _EXPORT_STD inline constexpr _Find_last_if_fn<true> find_last_if{_Not_quite_object::_Construct_tag{}};
; 2949 :     _EXPORT_STD inline constexpr _Find_last_if_fn<false> find_last_if_not{_Not_quite_object::_Construct_tag{}};
; 2950 : #endif // _HAS_CXX23
; 2951 : } // namespace ranges
; 2952 : #endif // __cpp_lib_concepts
; 2953 : 
; 2954 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2, class _Pr>
; 2955 : _NODISCARD _CONSTEXPR20 _FwdIt1 find_end(
; 2956 :     _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
; 2957 :     // find last [_First2, _Last2) satisfying _Pred
; 2958 :     _Adl_verify_range(_First1, _Last1);
; 2959 :     _Adl_verify_range(_First2, _Last2);
; 2960 :     auto _UFirst1       = _Get_unwrapped(_First1);
; 2961 :     const auto _ULast1  = _Get_unwrapped(_Last1);
; 2962 :     const auto _UFirst2 = _Get_unwrapped(_First2);
; 2963 :     const auto _ULast2  = _Get_unwrapped(_Last2);
; 2964 :     if constexpr (_Is_ranges_random_iter_v<_FwdIt1> && _Is_ranges_random_iter_v<_FwdIt2>) {
; 2965 :         const _Iter_diff_t<_FwdIt2> _Count2 = _ULast2 - _UFirst2;
; 2966 :         if (_Count2 > 0 && _Count2 <= _ULast1 - _UFirst1) {
; 2967 :             for (auto _UCandidate = _ULast1 - static_cast<_Iter_diff_t<_FwdIt1>>(_Count2);; --_UCandidate) {
; 2968 :                 if (_Equal_rev_pred_unchecked(_UCandidate, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
; 2969 :                     _Seek_wrapped(_First1, _UCandidate);
; 2970 :                     return _First1;
; 2971 :                 }
; 2972 : 
; 2973 :                 if (_UCandidate == _UFirst1) {
; 2974 :                     break;
; 2975 :                 }
; 2976 :             }
; 2977 :         }
; 2978 : 
; 2979 :         return _Last1;
; 2980 :     } else if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
; 2981 :         for (auto _UCandidate = _ULast1;; --_UCandidate) { // try a match at _UCandidate
; 2982 :             auto _UNext1 = _UCandidate;
; 2983 :             auto _UNext2 = _ULast2;
; 2984 :             for (;;) { // test if [_UFirst2, _ULast2) is a suffix of [_UFirst1, _UCandidate)
; 2985 :                 if (_UFirst2 == _UNext2) { // match found
; 2986 :                     _Seek_wrapped(_First1, _UNext1);
; 2987 :                     return _First1;
; 2988 :                 }
; 2989 : 
; 2990 :                 if (_UFirst1 == _UNext1) {
; 2991 :                     // [_UFirst1, _UCandidate) is shorter than [_UFirst2, _ULast2), remaining candidates nonviable
; 2992 :                     return _Last1;
; 2993 :                 }
; 2994 : 
; 2995 :                 --_UNext1;
; 2996 :                 --_UNext2;
; 2997 :                 if (!_Pred(*_UNext1, *_UNext2)) { // counterexample found
; 2998 :                     break;
; 2999 :                 }
; 3000 :             }
; 3001 :         }
; 3002 :     } else {
; 3003 :         auto _UResult = _ULast1;
; 3004 :         for (;;) { // try a match at _UFirst1
; 3005 :             auto _UNext1 = _UFirst1;
; 3006 :             auto _UNext2 = _UFirst2;
; 3007 :             for (;;) { // test if [_UFirst2, _ULast2) is a prefix of [_UFirst1, _ULast1)
; 3008 :                 const bool _End_of_needle = static_cast<bool>(_UNext2 == _ULast2);
; 3009 :                 if (_End_of_needle) { // match candidate found
; 3010 :                     _UResult = _UFirst1;
; 3011 :                 }
; 3012 : 
; 3013 :                 if (_UNext1 == _ULast1) {
; 3014 :                     // trying the next candidate would make [_UFirst1, _ULast1) shorter than [_UFirst2, _ULast2), done
; 3015 :                     _Seek_wrapped(_First1, _UResult);
; 3016 :                     return _First1;
; 3017 :                 }
; 3018 : 
; 3019 :                 if (_End_of_needle || !_Pred(*_UNext1, *_UNext2)) {
; 3020 :                     break; // end of match or counterexample found, go to the next candidate
; 3021 :                 }
; 3022 : 
; 3023 :                 ++_UNext1;
; 3024 :                 ++_UNext2;
; 3025 :             }
; 3026 : 
; 3027 :             ++_UFirst1;
; 3028 :         }
; 3029 : 
; 3030 :         _Seek_wrapped(_First1, _UResult);
; 3031 :         return _First1;
; 3032 :     }
; 3033 : }
; 3034 : 
; 3035 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 3036 : _NODISCARD _CONSTEXPR20 _FwdIt1 find_end(
; 3037 :     _FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2) {
; 3038 :     // find last [_First2, _Last2) match
; 3039 :     return _STD find_end(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 3040 : }
; 3041 : 
; 3042 : #if _HAS_CXX17
; 3043 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3044 : _NODISCARD _FwdIt1 find_end(
; 3045 :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 3046 : 
; 3047 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3048 : _NODISCARD _FwdIt1 find_end(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) noexcept
; 3049 : /* terminates */ { // find last [_First2, _Last2) match
; 3050 :     return _STD find_end(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 3051 : }
; 3052 : #endif // _HAS_CXX17
; 3053 : 
; 3054 : #ifdef __cpp_lib_concepts
; 3055 : namespace ranges {
; 3056 :     class _Find_end_fn : private _Not_quite_object {
; 3057 :     private:
; 3058 :         template <class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
; 3059 :         _NODISCARD static constexpr subrange<_It1> _Random_access_sized_ranges(_It1 _First1,
; 3060 :             const iter_difference_t<_It1> _Count1, _It2 _First2, const iter_difference_t<_It2> _Count2, _Pr _Pred,
; 3061 :             _Pj1 _Proj1, _Pj2 _Proj2) {
; 3062 :             _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<_It1>);
; 3063 :             _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<_It2>);
; 3064 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 3065 :             // pre: _First1 + [0, _Count1) is a valid counted range
; 3066 :             // pre: _First2 + [0, _Count2) is a valid counted range
; 3067 : 
; 3068 :             if (_Count2 > 0 && _Count2 <= _Count1) {
; 3069 :                 const auto _Count2_as1 = static_cast<iter_difference_t<_It1>>(_Count2);
; 3070 : 
; 3071 :                 for (auto _Candidate = _First1 + (_Count1 - _Count2_as1);; --_Candidate) {
; 3072 :                     auto [_Match, _Mid1] =
; 3073 :                         _RANGES _Equal_rev_pred(_Candidate, _First2, _First2 + _Count2, _Pred, _Proj1, _Proj2);
; 3074 :                     if (_Match) {
; 3075 :                         return {_STD move(_Candidate), _STD move(_Mid1)};
; 3076 :                     }
; 3077 : 
; 3078 :                     if (_Candidate == _First1) {
; 3079 :                         break;
; 3080 :                     }
; 3081 :                 }
; 3082 :             }
; 3083 : 
; 3084 :             _First1 += _Count1;
; 3085 :             return {_First1, _First1};
; 3086 :         }
; 3087 : 
; 3088 :         template <class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
; 3089 :         _NODISCARD static constexpr subrange<_It1> _Bidi_common_ranges(
; 3090 :             _It1 _First1, _It1 _Last1, _It2 _First2, const _It2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 3091 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It1>);
; 3092 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It2>);
; 3093 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 3094 : 
; 3095 :             for (auto _Candidate = _Last1;; --_Candidate) { // try a match at _Candidate
; 3096 :                 auto _Next1 = _Candidate;
; 3097 :                 auto _Next2 = _Last2;
; 3098 :                 for (;;) { // test if [_First2, _Last2) is a suffix of [_First1, _Candidate)
; 3099 :                     if (_First2 == _Next2) { // match found
; 3100 :                         return {_STD move(_Next1), _STD move(_Candidate)};
; 3101 :                     }
; 3102 : 
; 3103 :                     if (_First1 == _Next1) {
; 3104 :                         // [_First1, _Candidate) is shorter than [_First2, _Last2); remaining candidates nonviable
; 3105 :                         return {_Last1, _Last1};
; 3106 :                     }
; 3107 : 
; 3108 :                     --_Next1;
; 3109 :                     --_Next2;
; 3110 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Next1), _STD invoke(_Proj2, *_Next2))) {
; 3111 :                         break; // mismatch
; 3112 :                     }
; 3113 :                 }
; 3114 :             }
; 3115 :         }
; 3116 : 
; 3117 :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 3118 :         _NODISCARD static constexpr subrange<_It1> _Forward_ranges(
; 3119 :             _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 3120 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
; 3121 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 3122 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
; 3123 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 3124 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 3125 : 
; 3126 :             subrange<_It1> _Match{};
; 3127 :             bool _Found = false;
; 3128 : 
; 3129 :             for (;; ++_First1) { // try a match at _First1
; 3130 :                 auto _Next1 = _First1;
; 3131 :                 auto _Next2 = _First2;
; 3132 :                 for (;; ++_Next1, (void) ++_Next2) { // test if [_First2, _Last2) is a prefix of [_First1, _Last1)
; 3133 :                     const bool _End_of_needle = _Next2 == _Last2;
; 3134 :                     if (_End_of_needle) { // match candidate found
; 3135 :                         _Match = subrange{_First1, _Next1};
; 3136 :                         _Found = true;
; 3137 :                     }
; 3138 : 
; 3139 :                     if (_Next1 == _Last1) { // haystack exhausted
; 3140 :                         if (!_Found) {
; 3141 :                             _Match = subrange{_Next1, _Next1};
; 3142 :                         }
; 3143 : 
; 3144 :                         return _Match;
; 3145 :                     }
; 3146 : 
; 3147 :                     if (_End_of_needle) {
; 3148 :                         break; // end of match found, go to the next candidate
; 3149 :                     }
; 3150 : 
; 3151 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Next1), _STD invoke(_Proj2, *_Next2))) {
; 3152 :                         break; // mismatch, go to the next candidate
; 3153 :                     }
; 3154 :                 }
; 3155 :             }
; 3156 :         }
; 3157 : 
; 3158 :     public:
; 3159 :         using _Not_quite_object::_Not_quite_object;
; 3160 : 
; 3161 :         template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
; 3162 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 3163 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 3164 :         _NODISCARD constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
; 3165 :             _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3166 :             _Adl_verify_range(_First1, _Last1);
; 3167 :             _Adl_verify_range(_First2, _Last2);
; 3168 :             auto _UFirst1 = _Unwrap_iter<_Se1>(_First1);
; 3169 :             auto _ULast1  = _Unwrap_sent<_It1>(_Last1);
; 3170 :             auto _UFirst2 = _Unwrap_iter<_Se2>(_First2);
; 3171 :             auto _ULast2  = _Unwrap_sent<_It2>(_Last2);
; 3172 : 
; 3173 :             if constexpr (random_access_iterator<_It1> && sized_sentinel_for<_Se1, _It1> && random_access_iterator<_It2>
; 3174 :                           && sized_sentinel_for<_Se2, _It2>) {
; 3175 :                 const auto _Count1 = _ULast1 - _UFirst1;
; 3176 :                 const auto _Count2 = _ULast2 - _UFirst2;
; 3177 :                 auto _UResult = _Random_access_sized_ranges(_STD move(_UFirst1), _Count1, _STD move(_UFirst2), _Count2,
; 3178 :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3179 :                 return _Rewrap_subrange<subrange<_It1>>(_First1, _STD move(_UResult));
; 3180 :             } else if constexpr (_Bidi_common<_It1, _Se1> && _Bidi_common<_It2, _Se2>) {
; 3181 :                 auto _UResult = _Bidi_common_ranges(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
; 3182 :                     _STD move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3183 :                 return _Rewrap_subrange<subrange<_It1>>(_First1, _STD move(_UResult));
; 3184 :             } else {
; 3185 :                 auto _UResult = _Forward_ranges(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
; 3186 :                     _STD move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3187 :                 return _Rewrap_subrange<subrange<_It1>>(_First1, _STD move(_UResult));
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 3192 :             class _Pj2 = identity>
; 3193 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 3194 :         _NODISCARD constexpr borrowed_subrange_t<_Rng1> operator()(
; 3195 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3196 :             if constexpr (random_access_range<_Rng1> && sized_range<_Rng1> && random_access_range<_Rng2>
; 3197 :                           && sized_range<_Rng2>) {
; 3198 :                 auto _UResult = _Random_access_sized_ranges(_Ubegin(_Range1), _RANGES distance(_Range1),
; 3199 :                     _Ubegin(_Range2), _RANGES distance(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3200 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, _STD move(_UResult));
; 3201 :             } else if constexpr (_Bidi_common_range<_Rng1> && _Bidi_common_range<_Rng2>) {
; 3202 :                 auto _UResult = _Bidi_common_ranges(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
; 3203 :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3204 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, _STD move(_UResult));
; 3205 :             } else {
; 3206 :                 auto _UResult = _Forward_ranges(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
; 3207 :                     _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3208 :                 return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, _STD move(_UResult));
; 3209 :             }
; 3210 :         }
; 3211 :     };
; 3212 : 
; 3213 :     _EXPORT_STD inline constexpr _Find_end_fn find_end{_Not_quite_object::_Construct_tag{}};
; 3214 : } // namespace ranges
; 3215 : #endif // __cpp_lib_concepts
; 3216 : 
; 3217 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2, class _Pr>
; 3218 : _NODISCARD _CONSTEXPR20 _FwdIt1 find_first_of(
; 3219 :     _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
; 3220 :     // look for one of [_First2, _Last2) satisfying _Pred with element
; 3221 :     _Adl_verify_range(_First1, _Last1);
; 3222 :     _Adl_verify_range(_First2, _Last2);
; 3223 :     auto _UFirst1       = _Get_unwrapped(_First1);
; 3224 :     const auto _ULast1  = _Get_unwrapped(_Last1);
; 3225 :     const auto _UFirst2 = _Get_unwrapped(_First2);
; 3226 :     const auto _ULast2  = _Get_unwrapped(_Last2);
; 3227 :     for (; _UFirst1 != _ULast1; ++_UFirst1) {
; 3228 :         for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2) {
; 3229 :             if (_Pred(*_UFirst1, *_UMid2)) {
; 3230 :                 _Seek_wrapped(_First1, _UFirst1);
; 3231 :                 return _First1;
; 3232 :             }
; 3233 :         }
; 3234 :     }
; 3235 : 
; 3236 :     _Seek_wrapped(_First1, _UFirst1);
; 3237 :     return _First1;
; 3238 : }
; 3239 : 
; 3240 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 3241 : _NODISCARD _CONSTEXPR20 _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 3242 :     const _FwdIt2 _Last2) { // look for one of [_First2, _Last2) that matches element
; 3243 :     return _STD find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 3244 : }
; 3245 : 
; 3246 : #if _HAS_CXX17
; 3247 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3248 : _NODISCARD _FwdIt1 find_first_of(
; 3249 :     _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 3250 : 
; 3251 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3252 : _NODISCARD _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 3253 :     const _FwdIt2 _Last2) noexcept /* terminates */ { // look for one of [_First2, _Last2) that matches element
; 3254 :     return _STD find_first_of(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 3255 : }
; 3256 : #endif // _HAS_CXX17
; 3257 : 
; 3258 : #ifdef __cpp_lib_concepts
; 3259 : namespace ranges {
; 3260 :     class _Find_first_of_fn : private _Not_quite_object {
; 3261 :     public:
; 3262 :         using _Not_quite_object::_Not_quite_object;
; 3263 : 
; 3264 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
; 3265 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 3266 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 3267 :         _NODISCARD constexpr _It1 operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
; 3268 :             _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3269 :             _Adl_verify_range(_First1, _Last1);
; 3270 :             _Adl_verify_range(_First2, _Last2);
; 3271 : 
; 3272 :             auto _UResult = _Find_first_of_unchecked(_Unwrap_iter<_Se1>(_STD move(_First1)),
; 3273 :                 _Unwrap_sent<_It1>(_STD move(_Last1)), _Unwrap_iter<_Se2>(_STD move(_First2)),
; 3274 :                 _Unwrap_sent<_It2>(_STD move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3275 : 
; 3276 :             _Seek_wrapped(_First1, _STD move(_UResult));
; 3277 :             return _First1;
; 3278 :         }
; 3279 : 
; 3280 :         template <input_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 3281 :             class _Pj2 = identity>
; 3282 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 3283 :         _NODISCARD constexpr borrowed_iterator_t<_Rng1> operator()(
; 3284 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3285 :             auto _First1 = _RANGES begin(_Range1);
; 3286 : 
; 3287 :             auto _UResult = _Find_first_of_unchecked(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 3288 :                 _Ubegin(_Range2), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3289 : 
; 3290 :             _Seek_wrapped(_First1, _STD move(_UResult));
; 3291 :             return _First1;
; 3292 :         }
; 3293 : 
; 3294 :     private:
; 3295 :         template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
; 3296 :         _NODISCARD static constexpr _It1 _Find_first_of_unchecked(_It1 _First1, const _Se1 _Last1, const _It2 _First2,
; 3297 :             const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 3298 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It1>);
; 3299 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 3300 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
; 3301 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 3302 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
; 3303 : 
; 3304 :             for (; _First1 != _Last1; ++_First1) {
; 3305 :                 for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2) {
; 3306 :                     if (_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_Mid2))) {
; 3307 :                         return _First1;
; 3308 :                     }
; 3309 :                 }
; 3310 :             }
; 3311 : 
; 3312 :             return _First1;
; 3313 :         }
; 3314 :     };
; 3315 : 
; 3316 :     _EXPORT_STD inline constexpr _Find_first_of_fn find_first_of{_Not_quite_object::_Construct_tag{}};
; 3317 : 
; 3318 :     _EXPORT_STD template <class _In1, class _In2>
; 3319 :     using swap_ranges_result = in_in_result<_In1, _In2>;
; 3320 : 
; 3321 :     class _Swap_ranges_fn : private _Not_quite_object {
; 3322 :     public:
; 3323 :         using _Not_quite_object::_Not_quite_object;
; 3324 : 
; 3325 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2>
; 3326 :             requires indirectly_swappable<_It1, _It2>
; 3327 :         constexpr swap_ranges_result<_It1, _It2> operator()(
; 3328 :             _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2) const {
; 3329 :             _Adl_verify_range(_First1, _Last1);
; 3330 :             _Adl_verify_range(_First2, _Last2);
; 3331 : 
; 3332 :             auto _UResult =
; 3333 :                 _Swap_ranges_unchecked(_Unwrap_iter<_Se1>(_STD move(_First1)), _Unwrap_sent<_It1>(_STD move(_Last1)),
; 3334 :                     _Unwrap_iter<_Se2>(_STD move(_First2)), _Unwrap_sent<_It2>(_STD move(_Last2)));
; 3335 : 
; 3336 :             _Seek_wrapped(_First1, _STD move(_UResult.in1));
; 3337 :             _Seek_wrapped(_First2, _STD move(_UResult.in2));
; 3338 :             return {_STD move(_First1), _STD move(_First2)};
; 3339 :         }
; 3340 : 
; 3341 :         template <input_range _Rng1, input_range _Rng2>
; 3342 :             requires indirectly_swappable<iterator_t<_Rng1>, iterator_t<_Rng2>>
; 3343 :         constexpr swap_ranges_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
; 3344 :             _Rng1&& _Range1, _Rng2&& _Range2) const {
; 3345 :             auto _First1 = _RANGES begin(_Range1);
; 3346 :             auto _First2 = _RANGES begin(_Range2);
; 3347 : 
; 3348 :             auto _UResult = _Swap_ranges_unchecked(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 3349 :                 _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2));
; 3350 : 
; 3351 :             _Seek_wrapped(_First1, _STD move(_UResult.in1));
; 3352 :             _Seek_wrapped(_First2, _STD move(_UResult.in2));
; 3353 :             return {_STD move(_First1), _STD move(_First2)};
; 3354 :         }
; 3355 : 
; 3356 :     private:
; 3357 :         template <class _It1, class _Se1, class _It2, class _Se2>
; 3358 :         _NODISCARD static constexpr swap_ranges_result<_It1, _It2> _Swap_ranges_unchecked(
; 3359 :             _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2) {
; 3360 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It1>);
; 3361 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
; 3362 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It2>);
; 3363 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
; 3364 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_swappable<_It1, _It2>);
; 3365 : 
; 3366 : #if _USE_STD_VECTOR_ALGORITHMS
; 3367 :             using _Elem1 = remove_reference_t<iter_reference_t<_It1>>;
; 3368 :             using _Elem2 = remove_reference_t<iter_reference_t<_It2>>;
; 3369 :             if constexpr (same_as<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1> //
; 3370 :                           && contiguous_iterator<_It1> && _Sized_or_unreachable_sentinel_for<_Se1, _It1> //
; 3371 :                           && contiguous_iterator<_It2> && _Sized_or_unreachable_sentinel_for<_Se2, _It2>) {
; 3372 :                 if (!_STD is_constant_evaluated()) {
; 3373 :                     constexpr bool _Is_sized1 = sized_sentinel_for<_Se1, _It1>;
; 3374 :                     constexpr bool _Is_sized2 = sized_sentinel_for<_Se2, _It2>;
; 3375 :                     const auto _First1_addr   = _STD to_address(_First1);
; 3376 :                     const auto _First2_addr   = _STD to_address(_First2);
; 3377 :                     if constexpr (_Is_sized1 && _Is_sized2) {
; 3378 :                         const size_t _Count =
; 3379 :                             (_STD min)(static_cast<size_t>(_Last1 - _First1), static_cast<size_t>(_Last2 - _First2));
; 3380 :                         const auto _Last1_addr = _First1_addr + _Count;
; 3381 :                         __std_swap_ranges_trivially_swappable_noalias(_First1_addr, _Last1_addr, _First2_addr);
; 3382 :                         return {_First1 + _Count, _First2 + _Count};
; 3383 :                     } else if constexpr (_Is_sized1) {
; 3384 :                         const auto _Final1     = _RANGES next(_First1, _Last1);
; 3385 :                         const auto _Last1_addr = _STD to_address(_Final1);
; 3386 :                         __std_swap_ranges_trivially_swappable_noalias(_First1_addr, _Last1_addr, _First2_addr);
; 3387 :                         return {_Final1, _First2 + (_Last1 - _First1)};
; 3388 :                     } else if constexpr (_Is_sized2) {
; 3389 :                         const auto _Final2     = _RANGES next(_First2, _Last2);
; 3390 :                         const auto _Last2_addr = _STD to_address(_Final2);
; 3391 :                         __std_swap_ranges_trivially_swappable_noalias(_First2_addr, _Last2_addr, _First1_addr);
; 3392 :                         return {_First1 + (_Last2 - _First2), _Final2};
; 3393 :                     } else {
; 3394 :                         _STL_ASSERT(false, "Tried to swap_ranges with two unreachable sentinels");
; 3395 :                     }
; 3396 :                 }
; 3397 :             }
; 3398 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 3399 : 
; 3400 :             for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
; 3401 :                 _RANGES iter_swap(_First1, _First2);
; 3402 :             }
; 3403 : 
; 3404 :             return {_STD move(_First1), _STD move(_First2)};
; 3405 :         }
; 3406 :     };
; 3407 : 
; 3408 :     _EXPORT_STD inline constexpr _Swap_ranges_fn swap_ranges{_Not_quite_object::_Construct_tag{}};
; 3409 : } // namespace ranges
; 3410 : #endif // __cpp_lib_concepts
; 3411 : 
; 3412 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 3413 : _CONSTEXPR20 _FwdIt2 swap_ranges(const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
; 3414 :     // swap [_First1, _Last1) with [_First2, ...)
; 3415 :     _Adl_verify_range(_First1, _Last1);
; 3416 :     const auto _UFirst1 = _Get_unwrapped(_First1);
; 3417 :     const auto _ULast1  = _Get_unwrapped(_Last1);
; 3418 :     const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
; 3419 :     _Verify_ranges_do_not_overlap(_UFirst1, _ULast1, _UFirst2);
; 3420 :     _Seek_wrapped(_First2, _Swap_ranges_unchecked(_UFirst1, _ULast1, _UFirst2));
; 3421 :     return _First2;
; 3422 : }
; 3423 : 
; 3424 : #if _HAS_CXX17
; 3425 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3426 : _FwdIt2 swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest) noexcept /* terminates */ {
; 3427 :     // swap [_First1, _Last1) with [_Dest, ...)
; 3428 :     // not parallelized as benchmarks show it isn't worth it
; 3429 :     return _STD swap_ranges(_First1, _Last1, _Dest);
; 3430 : }
; 3431 : #endif // _HAS_CXX17
; 3432 : 
; 3433 : _EXPORT_STD template <class _FwdIt1, class _FwdIt2>
; 3434 : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right
; 3435 :     swap(*_Left, *_Right); // intentional ADL
; 3436 : }
; 3437 : 
; 3438 : _EXPORT_STD template <class _InIt, class _OutIt, class _Fn>
; 3439 : _CONSTEXPR20 _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {
; 3440 :     // transform [_First, _Last) with _Func
; 3441 :     _Adl_verify_range(_First, _Last);
; 3442 :     auto _UFirst      = _Get_unwrapped(_First);
; 3443 :     const auto _ULast = _Get_unwrapped(_Last);
; 3444 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 3445 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
; 3446 :         *_UDest = _Func(*_UFirst);
; 3447 :     }
; 3448 : 
; 3449 :     _Seek_wrapped(_Dest, _UDest);
; 3450 :     return _Dest;
; 3451 : }
; 3452 : 
; 3453 : #if _HAS_CXX17
; 3454 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3455 : _FwdIt2 transform(_ExPo&& _Exec, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Fn _Func) noexcept; // terminates
; 3456 : #endif // _HAS_CXX17
; 3457 : 
; 3458 : _EXPORT_STD template <class _InIt1, class _InIt2, class _OutIt, class _Fn>
; 3459 : _CONSTEXPR20 _OutIt transform(
; 3460 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {
; 3461 :     // transform [_First1, _Last1) and [_First2, ...) with _Func
; 3462 :     _Adl_verify_range(_First1, _Last1);
; 3463 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 3464 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 3465 :     const auto _Count  = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
; 3466 :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Count);
; 3467 :     auto _UDest        = _Get_unwrapped_n(_Dest, _Count);
; 3468 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {
; 3469 :         *_UDest = _Func(*_UFirst1, *_UFirst2);
; 3470 :     }
; 3471 : 
; 3472 :     _Seek_wrapped(_Dest, _UDest);
; 3473 :     return _Dest;
; 3474 : }
; 3475 : 
; 3476 : #if _HAS_CXX17
; 3477 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Fn,
; 3478 :     _Enable_if_execution_policy_t<_ExPo> = 0>
; 3479 : _FwdIt3 transform(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt3 _Dest,
; 3480 :     _Fn _Func) noexcept; // terminates
; 3481 : #endif // _HAS_CXX17
; 3482 : 
; 3483 : #ifdef __cpp_lib_concepts
; 3484 : namespace ranges {
; 3485 :     _EXPORT_STD template <class _In, class _Out>
; 3486 :     using unary_transform_result = in_out_result<_In, _Out>;
; 3487 : 
; 3488 :     _EXPORT_STD template <class _In1, class _In2, class _Out>
; 3489 :     using binary_transform_result = in_in_out_result<_In1, _In2, _Out>;
; 3490 : 
; 3491 :     class _Transform_fn : private _Not_quite_object {
; 3492 :     public:
; 3493 :         using _Not_quite_object::_Not_quite_object;
; 3494 : 
; 3495 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, copy_constructible _Fn,
; 3496 :             class _Pj = identity>
; 3497 :             requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It, _Pj>>>
; 3498 :         constexpr unary_transform_result<_It, _Out> operator()(
; 3499 :             _It _First, _Se _Last, _Out _Result, _Fn _Func, _Pj _Proj = {}) const {
; 3500 :             _Adl_verify_range(_First, _Last);
; 3501 :             auto _UResult = _Transform_unary_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3502 :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj));
; 3503 : 
; 3504 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3505 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3506 :         }
; 3507 : 
; 3508 :         template <input_range _Rng, weakly_incrementable _Out, copy_constructible _Fn, class _Pj = identity>
; 3509 :             requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<iterator_t<_Rng>, _Pj>>>
; 3510 :         constexpr unary_transform_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 3511 :             _Rng&& _Range, _Out _Result, _Fn _Func, _Pj _Proj = {}) const {
; 3512 :             auto _First   = _RANGES begin(_Range);
; 3513 :             auto _UResult = _Transform_unary_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 3514 :                 _STD move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj));
; 3515 : 
; 3516 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3517 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3518 :         }
; 3519 : 
; 3520 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 3521 :             weakly_incrementable _Out, copy_constructible _Fn, class _Pj1 = identity, class _Pj2 = identity>
; 3522 :             requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It1, _Pj1>, projected<_It2, _Pj2>>>
; 3523 :         constexpr binary_transform_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2,
; 3524 :             _Se2 _Last2, _Out _Result, _Fn _Func, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3525 :             _Adl_verify_range(_First1, _Last1);
; 3526 :             _Adl_verify_range(_First2, _Last2);
; 3527 :             auto _UResult = _Transform_binary_unchecked(_Unwrap_iter<_Se1>(_STD move(_First1)),
; 3528 :                 _Unwrap_sent<_It1>(_STD move(_Last1)), _Unwrap_iter<_Se2>(_STD move(_First2)),
; 3529 :                 _Unwrap_sent<_It2>(_STD move(_Last2)), _STD move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj1),
; 3530 :                 _Pass_fn(_Proj2));
; 3531 : 
; 3532 :             _Seek_wrapped(_First1, _STD move(_UResult.in1));
; 3533 :             _Seek_wrapped(_First2, _STD move(_UResult.in2));
; 3534 :             return {_STD move(_First1), _STD move(_First2), _STD move(_UResult.out)};
; 3535 :         }
; 3536 : 
; 3537 :         template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, copy_constructible _Fn,
; 3538 :             class _Pj1 = identity, class _Pj2 = identity>
; 3539 :             requires indirectly_writable<_Out,
; 3540 :                 indirect_result_t<_Fn&, projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>>>
; 3541 :         constexpr binary_transform_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out> operator()(
; 3542 :             _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Fn _Func, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 3543 :             auto _First1  = _RANGES begin(_Range1);
; 3544 :             auto _First2  = _RANGES begin(_Range2);
; 3545 :             auto _UResult = _Transform_binary_unchecked(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 3546 :                 _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2), _STD move(_Result), _Pass_fn(_Func),
; 3547 :                 _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 3548 : 
; 3549 :             _Seek_wrapped(_First1, _STD move(_UResult.in1));
; 3550 :             _Seek_wrapped(_First2, _STD move(_UResult.in2));
; 3551 :             return {_STD move(_First1), _STD move(_First2), _STD move(_UResult.out)};
; 3552 :         }
; 3553 : 
; 3554 :     private:
; 3555 :         template <class _It, class _Se, class _Out, class _Fn, class _Pj>
; 3556 :         _NODISCARD static constexpr unary_transform_result<_It, _Out> _Transform_unary_unchecked(
; 3557 :             _It _First, const _Se _Last, _Out _Result, _Fn _Func, _Pj _Proj) {
; 3558 :             // transform projected [_First, _Last) with _Func
; 3559 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 3560 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 3561 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It, _Pj>>>);
; 3562 : 
; 3563 :             for (; _First != _Last; ++_First, (void) ++_Result) {
; 3564 :                 *_Result = _STD invoke(_Func, _STD invoke(_Proj, *_First));
; 3565 :             }
; 3566 : 
; 3567 :             return {_STD move(_First), _STD move(_Result)};
; 3568 :         }
; 3569 : 
; 3570 :         template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Fn, class _Pj1, class _Pj2>
; 3571 :         _NODISCARD static constexpr binary_transform_result<_It1, _It2, _Out> _Transform_binary_unchecked(_It1 _First1,
; 3572 :             const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Out _Result, _Fn _Func, _Pj1 _Proj1, _Pj2 _Proj2) {
; 3573 :             // transform projected [_First1, _Last1) and projected [_First2, _Last2) with _Func
; 3574 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It1>);
; 3575 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It2>);
; 3576 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 3577 :             _STL_INTERNAL_STATIC_ASSERT(
; 3578 :                 indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It1, _Pj1>, projected<_It2, _Pj2>>>);
; 3579 : 
; 3580 :             for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2, ++_Result) {
; 3581 :                 *_Result = _STD invoke(_Func, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2));
; 3582 :             }
; 3583 : 
; 3584 :             return {_STD move(_First1), _STD move(_First2), _STD move(_Result)};
; 3585 :         }
; 3586 :     };
; 3587 : 
; 3588 :     _EXPORT_STD inline constexpr _Transform_fn transform{_Not_quite_object::_Construct_tag{}};
; 3589 : } // namespace ranges
; 3590 : #endif // __cpp_lib_concepts
; 3591 : 
; 3592 : _EXPORT_STD template <class _FwdIt, class _Ty>
; 3593 : _CONSTEXPR20 void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) {
; 3594 :     // replace each matching _Oldval with _Newval
; 3595 :     _Adl_verify_range(_First, _Last);
; 3596 :     auto _UFirst      = _Get_unwrapped(_First);
; 3597 :     const auto _ULast = _Get_unwrapped(_Last);
; 3598 :     for (; _UFirst != _ULast; ++_UFirst) {
; 3599 :         if (*_UFirst == _Oldval) {
; 3600 :             *_UFirst = _Newval;
; 3601 :         }
; 3602 :     }
; 3603 : }
; 3604 : 
; 3605 : #if _HAS_CXX17
; 3606 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3607 : void replace(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Oldval,
; 3608 :     const _Ty& _Newval) noexcept; // terminates
; 3609 : #endif // _HAS_CXX17
; 3610 : 
; 3611 : #ifdef __cpp_lib_concepts
; 3612 : namespace ranges {
; 3613 :     class _Replace_fn : private _Not_quite_object {
; 3614 :     public:
; 3615 :         using _Not_quite_object::_Not_quite_object;
; 3616 : 
; 3617 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty1, class _Ty2, class _Pj = identity>
; 3618 :             requires indirectly_writable<_It, const _Ty2&>
; 3619 :                   && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty1*>
; 3620 :         constexpr _It operator()(
; 3621 :             _It _First, _Se _Last, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
; 3622 :             _Adl_verify_range(_First, _Last);
; 3623 :             auto _UResult = _Replace_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3624 :                 _Unwrap_sent<_It>(_STD move(_Last)), _Oldval, _Newval, _Pass_fn(_Proj));
; 3625 : 
; 3626 :             _Seek_wrapped(_First, _STD move(_UResult));
; 3627 :             return _First;
; 3628 :         }
; 3629 : 
; 3630 :         template <input_range _Rng, class _Ty1, class _Ty2, class _Pj = identity>
; 3631 :             requires indirectly_writable<iterator_t<_Rng>, const _Ty2&>
; 3632 :                   && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty1*>
; 3633 :         constexpr borrowed_iterator_t<_Rng> operator()(
; 3634 :             _Rng&& _Range, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
; 3635 :             auto _First   = _RANGES begin(_Range);
; 3636 :             auto _UResult = _Replace_unchecked(
; 3637 :                 _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _Oldval, _Newval, _Pass_fn(_Proj));
; 3638 : 
; 3639 :             _Seek_wrapped(_First, _STD move(_UResult));
; 3640 :             return _First;
; 3641 :         }
; 3642 : 
; 3643 :     private:
; 3644 :         template <class _It, class _Se, class _Ty1, class _Ty2, class _Pj>
; 3645 :         _NODISCARD static constexpr _It _Replace_unchecked(
; 3646 :             _It _First, const _Se _Last, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj) {
; 3647 :             // replace projected _Oldval with _Newval in [_First, _Last)
; 3648 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 3649 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3650 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_writable<_It, const _Ty2&>);
; 3651 :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty1*>);
; 3652 : 
; 3653 :             for (; _First != _Last; ++_First) {
; 3654 :                 if (_STD invoke(_Proj, *_First) == _Oldval) {
; 3655 :                     *_First = _Newval;
; 3656 :                 }
; 3657 :             }
; 3658 : 
; 3659 :             return _First;
; 3660 :         }
; 3661 :     };
; 3662 : 
; 3663 :     _EXPORT_STD inline constexpr _Replace_fn replace{_Not_quite_object::_Construct_tag{}};
; 3664 : } // namespace ranges
; 3665 : #endif // __cpp_lib_concepts
; 3666 : 
; 3667 : _EXPORT_STD template <class _FwdIt, class _Pr, class _Ty>
; 3668 : _CONSTEXPR20 void replace_if(const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val) {
; 3669 :     // replace each satisfying _Pred with _Val
; 3670 :     _Adl_verify_range(_First, _Last);
; 3671 :     auto _UFirst      = _Get_unwrapped(_First);
; 3672 :     const auto _ULast = _Get_unwrapped(_Last);
; 3673 :     for (; _UFirst != _ULast; ++_UFirst) {
; 3674 :         if (_Pred(*_UFirst)) {
; 3675 :             *_UFirst = _Val;
; 3676 :         }
; 3677 :     }
; 3678 : }
; 3679 : 
; 3680 : #if _HAS_CXX17
; 3681 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3682 : void replace_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val) noexcept; // terminates
; 3683 : #endif // _HAS_CXX17
; 3684 : 
; 3685 : #ifdef __cpp_lib_concepts
; 3686 : namespace ranges {
; 3687 :     class _Replace_if_fn : private _Not_quite_object {
; 3688 :     public:
; 3689 :         using _Not_quite_object::_Not_quite_object;
; 3690 : 
; 3691 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
; 3692 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 3693 :             requires indirectly_writable<_It, const _Ty&>
; 3694 :         constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
; 3695 :             _Adl_verify_range(_First, _Last);
; 3696 :             auto _UResult = _Replace_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3697 :                 _Unwrap_sent<_It>(_STD move(_Last)), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));
; 3698 : 
; 3699 :             _Seek_wrapped(_First, _STD move(_UResult));
; 3700 :             return _First;
; 3701 :         }
; 3702 : 
; 3703 :         template <input_range _Rng, class _Ty, class _Pj = identity,
; 3704 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 3705 :             requires indirectly_writable<iterator_t<_Rng>, const _Ty&>
; 3706 :         constexpr borrowed_iterator_t<_Rng> operator()(
; 3707 :             _Rng&& _Range, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
; 3708 :             auto _First   = _RANGES begin(_Range);
; 3709 :             auto _UResult = _Replace_if_unchecked(
; 3710 :                 _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));
; 3711 : 
; 3712 :             _Seek_wrapped(_First, _STD move(_UResult));
; 3713 :             return _First;
; 3714 :         }
; 3715 : 
; 3716 :     private:
; 3717 :         template <class _It, class _Se, class _Ty, class _Pj, class _Pr>
; 3718 :         _NODISCARD static constexpr _It _Replace_if_unchecked(
; 3719 :             _It _First, const _Se _Last, _Pr _Pred, const _Ty& _Newval, _Pj _Proj) {
; 3720 :             // replace projected _Oldval that fulfills _Pred with _Newval in [_First, _Last)
; 3721 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 3722 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3723 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_writable<_It, const _Ty&>);
; 3724 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 3725 : 
; 3726 :             for (; _First != _Last; ++_First) {
; 3727 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 3728 :                     *_First = _Newval;
; 3729 :                 }
; 3730 :             }
; 3731 : 
; 3732 :             return _First;
; 3733 :         }
; 3734 :     };
; 3735 : 
; 3736 :     _EXPORT_STD inline constexpr _Replace_if_fn replace_if{_Not_quite_object::_Construct_tag{}};
; 3737 : } // namespace ranges
; 3738 : #endif // __cpp_lib_concepts
; 3739 : 
; 3740 : _EXPORT_STD template <class _InIt, class _OutIt, class _Ty>
; 3741 : _CONSTEXPR20 _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval) {
; 3742 :     // copy replacing each matching _Oldval with _Newval
; 3743 :     _Adl_verify_range(_First, _Last);
; 3744 :     auto _UFirst      = _Get_unwrapped(_First);
; 3745 :     const auto _ULast = _Get_unwrapped(_Last);
; 3746 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 3747 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
; 3748 :         if (*_UFirst == _Oldval) {
; 3749 :             *_UDest = _Newval;
; 3750 :         } else {
; 3751 :             *_UDest = *_UFirst;
; 3752 :         }
; 3753 :     }
; 3754 : 
; 3755 :     _Seek_wrapped(_Dest, _UDest);
; 3756 :     return _Dest;
; 3757 : }
; 3758 : 
; 3759 : #if _HAS_CXX17
; 3760 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 3761 : _FwdIt2 replace_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, const _Ty& _Oldval,
; 3762 :     const _Ty& _Newval) noexcept /* terminates */ {
; 3763 :     // copy replacing each matching _Oldval with _Newval
; 3764 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 3765 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 3766 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 3767 :     return _STD replace_copy(_First, _Last, _Dest, _Oldval, _Newval);
; 3768 : }
; 3769 : #endif // _HAS_CXX17
; 3770 : 
; 3771 : #ifdef __cpp_lib_concepts
; 3772 : namespace ranges {
; 3773 :     _EXPORT_STD template <class _In, class _Out>
; 3774 :     using replace_copy_result = in_out_result<_In, _Out>;
; 3775 : 
; 3776 :     class _Replace_copy_fn : private _Not_quite_object {
; 3777 :     public:
; 3778 :         using _Not_quite_object::_Not_quite_object;
; 3779 : 
; 3780 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty1, class _Ty2, output_iterator<const _Ty2&> _Out,
; 3781 :             class _Pj = identity>
; 3782 :             requires indirectly_copyable<_It, _Out>
; 3783 :                   && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty1*>
; 3784 :         constexpr replace_copy_result<_It, _Out> operator()(
; 3785 :             _It _First, _Se _Last, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
; 3786 :             _Adl_verify_range(_First, _Last);
; 3787 :             auto _UResult = _Replace_copy_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3788 :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result), _Oldval, _Newval, _Pass_fn(_Proj));
; 3789 : 
; 3790 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3791 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3792 :         }
; 3793 : 
; 3794 :         template <input_range _Rng, class _Ty1, class _Ty2, output_iterator<const _Ty2&> _Out, class _Pj = identity>
; 3795 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 3796 :                   && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty1*>
; 3797 :         constexpr replace_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 3798 :             _Rng&& _Range, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
; 3799 :             auto _First   = _RANGES begin(_Range);
; 3800 :             auto _UResult = _Replace_copy_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 3801 :                 _STD move(_Result), _Oldval, _Newval, _Pass_fn(_Proj));
; 3802 : 
; 3803 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3804 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3805 :         }
; 3806 : 
; 3807 :     private:
; 3808 :         template <class _It, class _Se, class _Ty1, class _Ty2, class _Out, class _Pj>
; 3809 :         _NODISCARD static constexpr replace_copy_result<_It, _Out> _Replace_copy_unchecked(
; 3810 :             _It _First, const _Se _Last, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj) {
; 3811 :             // copy [_First, _Last) to _Result while replacing projected _Oldval with _Newval
; 3812 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 3813 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3814 :             _STL_INTERNAL_STATIC_ASSERT(output_iterator<_Out, const _Ty2&>);
; 3815 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 3816 :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<equal_to, projected<_It, _Pj>, const _Ty1*>);
; 3817 : 
; 3818 :             for (; _First != _Last; ++_First, (void) ++_Result) {
; 3819 :                 if (_STD invoke(_Proj, *_First) == _Oldval) {
; 3820 :                     *_Result = _Newval;
; 3821 :                 } else {
; 3822 :                     *_Result = *_First;
; 3823 :                 }
; 3824 :             }
; 3825 : 
; 3826 :             return {_STD move(_First), _STD move(_Result)};
; 3827 :         }
; 3828 :     };
; 3829 : 
; 3830 :     _EXPORT_STD inline constexpr _Replace_copy_fn replace_copy{_Not_quite_object::_Construct_tag{}};
; 3831 : } // namespace ranges
; 3832 : #endif // __cpp_lib_concepts
; 3833 : 
; 3834 : _EXPORT_STD template <class _InIt, class _OutIt, class _Pr, class _Ty>
; 3835 : _CONSTEXPR20 _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty& _Val) {
; 3836 :     // copy replacing each satisfying _Pred with _Val
; 3837 :     _Adl_verify_range(_First, _Last);
; 3838 :     auto _UFirst      = _Get_unwrapped(_First);
; 3839 :     const auto _ULast = _Get_unwrapped(_Last);
; 3840 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 3841 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
; 3842 :         if (_Pred(*_UFirst)) {
; 3843 :             *_UDest = _Val;
; 3844 :         } else {
; 3845 :             *_UDest = *_UFirst;
; 3846 :         }
; 3847 :     }
; 3848 : 
; 3849 :     _Seek_wrapped(_Dest, _UDest);
; 3850 :     return _Dest;
; 3851 : }
; 3852 : 
; 3853 : #if _HAS_CXX17
; 3854 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, class _Ty,
; 3855 :     _Enable_if_execution_policy_t<_ExPo> = 0>
; 3856 : _FwdIt2 replace_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred, const _Ty& _Val) noexcept
; 3857 : /* terminates */ {
; 3858 :     // copy replacing each satisfying _Pred with _Val
; 3859 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 3860 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 3861 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 3862 :     return _STD replace_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred), _Val);
; 3863 : }
; 3864 : #endif // _HAS_CXX17
; 3865 : 
; 3866 : #ifdef __cpp_lib_concepts
; 3867 : namespace ranges {
; 3868 :     _EXPORT_STD template <class _In, class _Out>
; 3869 :     using replace_copy_if_result = in_out_result<_In, _Out>;
; 3870 : 
; 3871 :     class _Replace_copy_if_fn : private _Not_quite_object {
; 3872 :     public:
; 3873 :         using _Not_quite_object::_Not_quite_object;
; 3874 : 
; 3875 :         template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, output_iterator<const _Ty&> _Out,
; 3876 :             class _Pj = identity, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 3877 :             requires indirectly_copyable<_It, _Out>
; 3878 :         constexpr replace_copy_if_result<_It, _Out> operator()(
; 3879 :             _It _First, _Se _Last, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
; 3880 :             _Adl_verify_range(_First, _Last);
; 3881 :             auto _UResult = _Replace_copy_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3882 :                 _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));
; 3883 : 
; 3884 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3885 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3886 :         }
; 3887 : 
; 3888 :         template <input_range _Rng, class _Ty, output_iterator<const _Ty&> _Out, class _Pj = identity,
; 3889 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 3890 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 3891 :         constexpr replace_copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 3892 :             _Rng&& _Range, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
; 3893 :             auto _First   = _RANGES begin(_Range);
; 3894 :             auto _UResult = _Replace_copy_if_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 3895 :                 _STD move(_Result), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));
; 3896 : 
; 3897 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 3898 :             return {_STD move(_First), _STD move(_UResult.out)};
; 3899 :         }
; 3900 : 
; 3901 :     private:
; 3902 :         template <class _It, class _Se, class _Ty, class _Out, class _Pj, class _Pr>
; 3903 :         _NODISCARD static constexpr replace_copy_if_result<_It, _Out> _Replace_copy_if_unchecked(
; 3904 :             _It _First, const _Se _Last, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj) {
; 3905 :             // copy [_First, _Last) to _Result while replacing _Oldval with _Newval if projected _Oldval fulfills _Pred
; 3906 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 3907 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 3908 :             _STL_INTERNAL_STATIC_ASSERT(output_iterator<_Out, const _Ty&>);
; 3909 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 3910 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 3911 : 
; 3912 :             for (; _First != _Last; ++_First, (void) ++_Result) {
; 3913 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 3914 :                     *_Result = _Newval;
; 3915 :                 } else {
; 3916 :                     *_Result = *_First;
; 3917 :                 }
; 3918 :             }
; 3919 : 
; 3920 :             return {_STD move(_First), _STD move(_Result)};
; 3921 :         }
; 3922 :     };
; 3923 : 
; 3924 :     _EXPORT_STD inline constexpr _Replace_copy_if_fn replace_copy_if{_Not_quite_object::_Construct_tag{}};
; 3925 : 
; 3926 :     class _Fill_fn : private _Not_quite_object {
; 3927 :     public:
; 3928 :         using _Not_quite_object::_Not_quite_object;
; 3929 : 
; 3930 :         template <class _Ty, output_iterator<const _Ty&> _It, sentinel_for<_It> _Se>
; 3931 :         constexpr _It operator()(_It _First, _Se _Last, const _Ty& _Value) const {
; 3932 :             _Adl_verify_range(_First, _Last);
; 3933 :             auto _UFirst      = _Unwrap_iter<_Se>(_STD move(_First));
; 3934 :             const auto _ULast = _Unwrap_sent<_It>(_STD move(_Last));
; 3935 :             if (!_STD is_constant_evaluated()) {
; 3936 :                 if constexpr (sized_sentinel_for<decltype(_ULast), decltype(_UFirst)>) {
; 3937 :                     if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 3938 :                         const auto _Distance = static_cast<size_t>(_ULast - _UFirst);
; 3939 :                         _Fill_memset(_UFirst, _Value, _Distance);
; 3940 :                         _Seek_wrapped(_First, _UFirst + _Distance);
; 3941 :                         return _First;
; 3942 :                     } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 3943 :                         if (_Is_all_bits_zero(_Value)) {
; 3944 :                             const auto _Distance = static_cast<size_t>(_ULast - _UFirst);
; 3945 :                             _Fill_zero_memset(_UFirst, _Distance);
; 3946 :                             _Seek_wrapped(_First, _UFirst + _Distance);
; 3947 :                             return _First;
; 3948 :                         }
; 3949 :                     }
; 3950 :                 }
; 3951 :             }
; 3952 : 
; 3953 :             for (; _UFirst != _ULast; ++_UFirst) {
; 3954 :                 *_UFirst = _Value;
; 3955 :             }
; 3956 : 
; 3957 :             _Seek_wrapped(_First, _STD move(_UFirst));
; 3958 :             return _First;
; 3959 :         }
; 3960 : 
; 3961 :         template <class _Ty, output_range<const _Ty&> _Rng>
; 3962 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Value) const {
; 3963 :             auto _First = _RANGES begin(_Range);
; 3964 :             _Seek_wrapped(_First, (*this)(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _Value));
; 3965 :             return _First;
; 3966 :         }
; 3967 :     };
; 3968 : 
; 3969 :     _EXPORT_STD inline constexpr _Fill_fn fill{_Not_quite_object::_Construct_tag{}};
; 3970 : 
; 3971 :     class _Generate_fn : private _Not_quite_object {
; 3972 :     public:
; 3973 :         using _Not_quite_object::_Not_quite_object;
; 3974 : 
; 3975 :         template <input_or_output_iterator _Out, sentinel_for<_Out> _Se, copy_constructible _Fn>
; 3976 :             requires invocable<_Fn&> && indirectly_writable<_Out, invoke_result_t<_Fn&>>
; 3977 :         constexpr _Out operator()(_Out _First, _Se _Last, _Fn _Gen) const {
; 3978 :             _Adl_verify_range(_First, _Last);
; 3979 :             _Seek_wrapped(_First, _Generate_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 3980 :                                       _Unwrap_sent<_Out>(_STD move(_Last)), _Pass_fn(_Gen)));
; 3981 :             return _First;
; 3982 :         }
; 3983 : 
; 3984 :         template <class _Rng, copy_constructible _Fn>
; 3985 :             requires invocable<_Fn&> && output_range<_Rng, invoke_result_t<_Fn&>>
; 3986 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Fn _Gen) const {
; 3987 :             auto _First = _RANGES begin(_Range);
; 3988 :             _Seek_wrapped(_First,
; 3989 :                 _Generate_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _Pass_fn(_Gen)));
; 3990 :             return _First;
; 3991 :         }
; 3992 : 
; 3993 :     private:
; 3994 :         template <class _Out, class _Se, class _Fn>
; 3995 :         _NODISCARD static constexpr _Out _Generate_unchecked(_Out _First, const _Se _Last, _Fn _Gen) {
; 3996 :             _STL_INTERNAL_STATIC_ASSERT(input_or_output_iterator<_Out>);
; 3997 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _Out>);
; 3998 :             _STL_INTERNAL_STATIC_ASSERT(copy_constructible<_Fn>);
; 3999 :             _STL_INTERNAL_STATIC_ASSERT(invocable<_Fn&>);
; 4000 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_writable<_Out, invoke_result_t<_Fn&>>);
; 4001 : 
; 4002 :             for (; _First != _Last; ++_First) {
; 4003 :                 *_First = _Gen();
; 4004 :             }
; 4005 : 
; 4006 :             return _First;
; 4007 :         }
; 4008 :     };
; 4009 : 
; 4010 :     _EXPORT_STD inline constexpr _Generate_fn generate{_Not_quite_object::_Construct_tag{}};
; 4011 : 
; 4012 :     class _Generate_n_fn : private _Not_quite_object {
; 4013 :     public:
; 4014 :         using _Not_quite_object::_Not_quite_object;
; 4015 : 
; 4016 :         template <input_or_output_iterator _Out, copy_constructible _Fn>
; 4017 :             requires invocable<_Fn&> && indirectly_writable<_Out, invoke_result_t<_Fn&>>
; 4018 :         constexpr _Out operator()(_Out _First, iter_difference_t<_Out> _Count, _Fn _Gen) const {
; 4019 :             if (_Count > 0) {
; 4020 :                 auto _UFirst = _Get_unwrapped_n(_STD move(_First), _Count);
; 4021 :                 do {
; 4022 :                     *_UFirst = _Gen();
; 4023 :                     ++_UFirst;
; 4024 :                 } while (--_Count > 0);
; 4025 : 
; 4026 :                 _Seek_wrapped(_First, _STD move(_UFirst));
; 4027 :             }
; 4028 : 
; 4029 :             return _First;
; 4030 :         }
; 4031 :     };
; 4032 : 
; 4033 :     _EXPORT_STD inline constexpr _Generate_n_fn generate_n{_Not_quite_object::_Construct_tag{}};
; 4034 : } // namespace ranges
; 4035 : #endif // __cpp_lib_concepts
; 4036 : 
; 4037 : _EXPORT_STD template <class _FwdIt, class _Fn>
; 4038 : _CONSTEXPR20 void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func) { // replace [_First, _Last) with _Func()
; 4039 :     _Adl_verify_range(_First, _Last);
; 4040 :     auto _UFirst      = _Get_unwrapped(_First);
; 4041 :     const auto _ULast = _Get_unwrapped(_Last);
; 4042 :     for (; _UFirst != _ULast; ++_UFirst) {
; 4043 :         *_UFirst = _Func();
; 4044 :     }
; 4045 : }
; 4046 : 
; 4047 : #if _HAS_CXX17
; 4048 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4049 : void generate(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Fn _Func) noexcept /* terminates */ {
; 4050 :     // replace [_First, _Last) with _Func()
; 4051 :     // not parallelized at present due to unclear parallelism requirements on _Func
; 4052 :     return _STD generate(_First, _Last, _Pass_fn(_Func));
; 4053 : }
; 4054 : #endif // _HAS_CXX17
; 4055 : 
; 4056 : _EXPORT_STD template <class _OutIt, class _Diff, class _Fn>
; 4057 : _CONSTEXPR20 _OutIt generate_n(_OutIt _Dest, const _Diff _Count_raw, _Fn _Func) {
; 4058 :     // replace [_Dest, _Dest + _Count) with _Func()
; 4059 :     _Algorithm_int_t<_Diff> _Count = _Count_raw;
; 4060 :     if (0 < _Count) {
; 4061 :         auto _UDest = _Get_unwrapped_n(_Dest, _Count);
; 4062 :         do {
; 4063 :             *_UDest = _Func();
; 4064 :             --_Count;
; 4065 :             ++_UDest;
; 4066 :         } while (0 < _Count);
; 4067 : 
; 4068 :         _Seek_wrapped(_Dest, _UDest);
; 4069 :     }
; 4070 : 
; 4071 :     return _Dest;
; 4072 : }
; 4073 : 
; 4074 : #if _HAS_CXX17
; 4075 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4076 : _FwdIt generate_n(_ExPo&&, const _FwdIt _Dest, const _Diff _Count_raw, _Fn _Func) noexcept /* terminates */ {
; 4077 :     // replace [_Dest, _Dest + _Count) with _Func()
; 4078 :     // not parallelized at present due to unclear parallelism requirements on _Func
; 4079 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 4080 :     return _STD generate_n(_Dest, _Count_raw, _Pass_fn(_Func));
; 4081 : }
; 4082 : #endif // _HAS_CXX17
; 4083 : 
; 4084 : _EXPORT_STD template <class _InIt, class _OutIt, class _Ty>
; 4085 : _CONSTEXPR20 _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val) {
; 4086 :     // copy omitting each matching _Val
; 4087 :     _Adl_verify_range(_First, _Last);
; 4088 :     auto _UFirst      = _Get_unwrapped(_First);
; 4089 :     const auto _ULast = _Get_unwrapped(_Last);
; 4090 :     auto _UDest       = _Get_unwrapped_unverified(_Dest);
; 4091 :     for (; _UFirst != _ULast; ++_UFirst) {
; 4092 :         if (!(*_UFirst == _Val)) {
; 4093 :             *_UDest = *_UFirst;
; 4094 :             ++_UDest;
; 4095 :         }
; 4096 :     }
; 4097 : 
; 4098 :     _Seek_wrapped(_Dest, _UDest);
; 4099 :     return _Dest;
; 4100 : }
; 4101 : 
; 4102 : #if _HAS_CXX17
; 4103 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4104 : _FwdIt2 remove_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, const _Ty& _Val) noexcept /* terminates */ {
; 4105 :     // copy omitting each matching _Val
; 4106 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4107 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4108 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4109 :     return _STD remove_copy(_First, _Last, _Dest, _Val);
; 4110 : }
; 4111 : #endif // _HAS_CXX17
; 4112 : 
; 4113 : _EXPORT_STD template <class _InIt, class _OutIt, class _Pr>
; 4114 : _CONSTEXPR20 _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
; 4115 :     // copy omitting each element satisfying _Pred
; 4116 :     _Adl_verify_range(_First, _Last);
; 4117 :     auto _UFirst      = _Get_unwrapped(_First);
; 4118 :     const auto _ULast = _Get_unwrapped(_Last);
; 4119 :     auto _UDest       = _Get_unwrapped_unverified(_Dest);
; 4120 :     for (; _UFirst != _ULast; ++_UFirst) {
; 4121 :         if (!_Pred(*_UFirst)) {
; 4122 :             *_UDest = *_UFirst;
; 4123 :             ++_UDest;
; 4124 :         }
; 4125 :     }
; 4126 : 
; 4127 :     _Seek_wrapped(_Dest, _UDest);
; 4128 :     return _Dest;
; 4129 : }
; 4130 : 
; 4131 : #if _HAS_CXX17
; 4132 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4133 : _FwdIt2 remove_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept /* terminates */ {
; 4134 :     // copy omitting each element satisfying _Pred
; 4135 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4136 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4137 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4138 :     return _STD remove_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
; 4139 : }
; 4140 : #endif // _HAS_CXX17
; 4141 : 
; 4142 : #if _HAS_CXX17
; 4143 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4144 : _NODISCARD_REMOVE_ALG _FwdIt remove(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; // terminates
; 4145 : 
; 4146 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4147 : _NODISCARD_REMOVE_ALG _FwdIt remove_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 4148 : #endif // _HAS_CXX17
; 4149 : 
; 4150 : #ifdef __cpp_lib_concepts
; 4151 : namespace ranges {
; 4152 :     class _Remove_fn : private _Not_quite_object {
; 4153 :     public:
; 4154 :         using _Not_quite_object::_Not_quite_object;
; 4155 : 
; 4156 :         template <permutable _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
; 4157 :             requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
; 4158 :         _NODISCARD_REMOVE_ALG constexpr subrange<_It> operator()(
; 4159 :             _It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
; 4160 :             _Adl_verify_range(_First, _Last);
; 4161 :             auto _UResult = _Remove_unchecked(
; 4162 :                 _Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _Val, _Pass_fn(_Proj));
; 4163 : 
; 4164 :             return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 4165 :         }
; 4166 : 
; 4167 :         template <forward_range _Rng, class _Ty, class _Pj = identity>
; 4168 :             requires permutable<iterator_t<_Rng>>
; 4169 :                   && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
; 4170 :         _NODISCARD_REMOVE_ALG constexpr borrowed_subrange_t<_Rng> operator()(
; 4171 :             _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
; 4172 :             auto _UResult = _Remove_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));
; 4173 : 
; 4174 :             return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 4175 :         }
; 4176 : 
; 4177 :     private:
; 4178 :         template <class _It, class _Se, class _Ty, class _Pj>
; 4179 :         _NODISCARD static constexpr subrange<_It> _Remove_unchecked(
; 4180 :             _It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj) {
; 4181 :             // Remove projected values equal to _Val from [_First, _Last)
; 4182 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 4183 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4184 :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>);
; 4185 : 
; 4186 :             _First     = _RANGES _Find_unchecked(_STD move(_First), _Last, _Val, _Proj);
; 4187 :             auto _Next = _First;
; 4188 :             if (_First == _Last) {
; 4189 :                 return {_STD move(_Next), _STD move(_First)};
; 4190 :             }
; 4191 : 
; 4192 :             while (++_First != _Last) {
; 4193 :                 if (_STD invoke(_Proj, *_First) != _Val) {
; 4194 :                     *_Next = _RANGES iter_move(_First);
; 4195 :                     ++_Next;
; 4196 :                 }
; 4197 :             }
; 4198 : 
; 4199 :             return {_STD move(_Next), _STD move(_First)};
; 4200 :         }
; 4201 :     };
; 4202 : 
; 4203 :     _EXPORT_STD inline constexpr _Remove_fn remove{_Not_quite_object::_Construct_tag{}};
; 4204 : 
; 4205 :     class _Remove_if_fn : private _Not_quite_object {
; 4206 :     public:
; 4207 :         using _Not_quite_object::_Not_quite_object;
; 4208 : 
; 4209 :         template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
; 4210 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 4211 :         _NODISCARD_REMOVE_ALG constexpr subrange<_It> operator()(
; 4212 :             _It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 4213 :             _Adl_verify_range(_First, _Last);
; 4214 :             auto _UResult = _Remove_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 4215 :                 _Unwrap_sent<_It>(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4216 : 
; 4217 :             return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 4218 :         }
; 4219 : 
; 4220 :         template <forward_range _Rng, class _Pj = identity,
; 4221 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 4222 :             requires permutable<iterator_t<_Rng>>
; 4223 :         _NODISCARD_REMOVE_ALG constexpr borrowed_subrange_t<_Rng> operator()(
; 4224 :             _Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 4225 :             auto _UResult = _Remove_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4226 : 
; 4227 :             return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 4228 :         }
; 4229 : 
; 4230 :     private:
; 4231 :         template <class _It, class _Se, class _Pr, class _Pj>
; 4232 :         _NODISCARD static constexpr subrange<_It> _Remove_if_unchecked(
; 4233 :             _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 4234 :             // Remove values whose projection satisfies _Pred from [_First, _Last)
; 4235 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 4236 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4237 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 4238 : 
; 4239 :             _First     = _RANGES _Find_if_unchecked(_STD move(_First), _Last, _Pred, _Proj);
; 4240 :             auto _Next = _First;
; 4241 :             if (_First == _Last) {
; 4242 :                 return {_STD move(_Next), _STD move(_First)};
; 4243 :             }
; 4244 : 
; 4245 :             while (++_First != _Last) {
; 4246 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 4247 :                     *_Next = _RANGES iter_move(_First);
; 4248 :                     ++_Next;
; 4249 :                 }
; 4250 :             }
; 4251 : 
; 4252 :             return {_STD move(_Next), _STD move(_First)};
; 4253 :         }
; 4254 :     };
; 4255 : 
; 4256 :     _EXPORT_STD inline constexpr _Remove_if_fn remove_if{_Not_quite_object::_Construct_tag{}};
; 4257 : 
; 4258 :     _EXPORT_STD template <class _In, class _Out>
; 4259 :     using remove_copy_result = in_out_result<_In, _Out>;
; 4260 : 
; 4261 :     class _Remove_copy_fn : private _Not_quite_object {
; 4262 :     public:
; 4263 :         using _Not_quite_object::_Not_quite_object;
; 4264 : 
; 4265 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Ty, class _Pj = identity>
; 4266 :             requires indirectly_copyable<_It, _Out>
; 4267 :                   && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
; 4268 :         constexpr remove_copy_result<_It, _Out> operator()(
; 4269 :             _It _First, _Se _Last, _Out _Result, const _Ty& _Val, _Pj _Proj = {}) const {
; 4270 :             _Adl_verify_range(_First, _Last);
; 4271 :             auto _UResult =
; 4272 :                 _Remove_copy_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 4273 :                     _Get_unwrapped_unverified(_STD move(_Result)), _Val, _Pass_fn(_Proj));
; 4274 : 
; 4275 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4276 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4277 :             return {_STD move(_First), _STD move(_Result)};
; 4278 :         }
; 4279 : 
; 4280 :         template <input_range _Rng, weakly_incrementable _Out, class _Ty, class _Pj = identity>
; 4281 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 4282 :                   && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
; 4283 :         constexpr remove_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 4284 :             _Rng&& _Range, _Out _Result, const _Ty& _Val, _Pj _Proj = {}) const {
; 4285 :             auto _First   = _RANGES begin(_Range);
; 4286 :             auto _UResult = _Remove_copy_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 4287 :                 _Get_unwrapped_unverified(_STD move(_Result)), _Val, _Pass_fn(_Proj));
; 4288 : 
; 4289 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4290 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4291 :             return {_STD move(_First), _STD move(_Result)};
; 4292 :         }
; 4293 : 
; 4294 :     private:
; 4295 :         template <class _It, class _Se, class _Out, class _Ty, class _Pj>
; 4296 :         _NODISCARD static constexpr remove_copy_result<_It, _Out> _Remove_copy_unchecked(
; 4297 :             _It _First, const _Se _Last, _Out _Result, const _Ty& _Val, _Pj _Proj) {
; 4298 :             // Copy [_First, _Last) to _Result except projected values equal to _Val
; 4299 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 4300 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4301 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 4302 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 4303 :             _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>);
; 4304 : 
; 4305 :             for (; _First != _Last; ++_First) {
; 4306 :                 if (_STD invoke(_Proj, *_First) != _Val) {
; 4307 :                     *_Result = *_First;
; 4308 :                     ++_Result;
; 4309 :                 }
; 4310 :             }
; 4311 : 
; 4312 :             return {_STD move(_First), _STD move(_Result)};
; 4313 :         }
; 4314 :     };
; 4315 : 
; 4316 :     _EXPORT_STD inline constexpr _Remove_copy_fn remove_copy{_Not_quite_object::_Construct_tag{}};
; 4317 : 
; 4318 :     _EXPORT_STD template <class _In, class _Out>
; 4319 :     using remove_copy_if_result = in_out_result<_In, _Out>;
; 4320 : 
; 4321 :     class _Remove_copy_if_fn : private _Not_quite_object {
; 4322 :     public:
; 4323 :         using _Not_quite_object::_Not_quite_object;
; 4324 : 
; 4325 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
; 4326 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 4327 :             requires indirectly_copyable<_It, _Out>
; 4328 :         constexpr remove_copy_if_result<_It, _Out> operator()(
; 4329 :             _It _First, _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
; 4330 :             _Adl_verify_range(_First, _Last);
; 4331 :             auto _UResult =
; 4332 :                 _Remove_copy_if_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 4333 :                     _Get_unwrapped_unverified(_STD move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4334 : 
; 4335 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4336 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4337 :             return {_STD move(_First), _STD move(_Result)};
; 4338 :         }
; 4339 : 
; 4340 :         template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
; 4341 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 4342 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 4343 :         constexpr remove_copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 4344 :             _Rng&& _Range, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
; 4345 :             auto _First   = _RANGES begin(_Range);
; 4346 :             auto _UResult = _Remove_copy_if_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 4347 :                 _Get_unwrapped_unverified(_STD move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4348 : 
; 4349 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4350 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4351 :             return {_STD move(_First), _STD move(_Result)};
; 4352 :         }
; 4353 : 
; 4354 :     private:
; 4355 :         template <class _It, class _Se, class _Out, class _Pr, class _Pj>
; 4356 :         _NODISCARD static constexpr remove_copy_if_result<_It, _Out> _Remove_copy_if_unchecked(
; 4357 :             _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
; 4358 :             // Copy [_First, _Last) to _Result except projected values that satisfy _Pred
; 4359 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 4360 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4361 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 4362 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 4363 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 4364 : 
; 4365 :             for (; _First != _Last; ++_First) {
; 4366 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 4367 :                     *_Result = *_First;
; 4368 :                     ++_Result;
; 4369 :                 }
; 4370 :             }
; 4371 : 
; 4372 :             return {_STD move(_First), _STD move(_Result)};
; 4373 :         }
; 4374 :     };
; 4375 : 
; 4376 :     _EXPORT_STD inline constexpr _Remove_copy_if_fn remove_copy_if{_Not_quite_object::_Construct_tag{}};
; 4377 : } // namespace ranges
; 4378 : #endif // __cpp_lib_concepts
; 4379 : 
; 4380 : _EXPORT_STD template <class _FwdIt, class _Pr>
; 4381 : _NODISCARD_UNIQUE_ALG _CONSTEXPR20 _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
; 4382 :     // remove each satisfying _Pred with previous
; 4383 :     _Adl_verify_range(_First, _Last);
; 4384 :     auto _UFirst      = _Get_unwrapped(_First);
; 4385 :     const auto _ULast = _Get_unwrapped(_Last);
; 4386 :     if (_UFirst != _ULast) {
; 4387 :         for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst) {
; 4388 :             if (_Pred(*_UFirstb, *_UFirst)) { // copy down
; 4389 :                 while (++_UFirst != _ULast) {
; 4390 :                     if (!_Pred(*_UFirstb, *_UFirst)) {
; 4391 :                         *++_UFirstb = _STD move(*_UFirst);
; 4392 :                     }
; 4393 :                 }
; 4394 : 
; 4395 :                 _Seek_wrapped(_Last, ++_UFirstb);
; 4396 :                 return _Last;
; 4397 :             }
; 4398 :         }
; 4399 :     }
; 4400 : 
; 4401 :     _Seek_wrapped(_Last, _ULast);
; 4402 :     return _Last;
; 4403 : }
; 4404 : 
; 4405 : _EXPORT_STD template <class _FwdIt>
; 4406 : _NODISCARD_UNIQUE_ALG _CONSTEXPR20 _FwdIt unique(_FwdIt _First, _FwdIt _Last) { // remove each matching previous
; 4407 :     return _STD unique(_First, _Last, equal_to<>{});
; 4408 : }
; 4409 : 
; 4410 : #if _HAS_CXX17
; 4411 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4412 : _NODISCARD_UNIQUE_ALG _FwdIt unique(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept /* terminates */ {
; 4413 :     // remove each satisfying _Pred with previous
; 4414 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4415 :     return _STD unique(_First, _Last, _Pass_fn(_Pred));
; 4416 : }
; 4417 : 
; 4418 : _EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4419 : _NODISCARD_UNIQUE_ALG _FwdIt unique(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept /* terminates */ {
; 4420 :     // remove each matching previous
; 4421 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4422 :     return _STD unique(_First, _Last);
; 4423 : }
; 4424 : #endif // _HAS_CXX17
; 4425 : 
; 4426 : #ifdef __cpp_lib_concepts
; 4427 : namespace ranges {
; 4428 :     class _Unique_fn : private _Not_quite_object {
; 4429 :     public:
; 4430 :         using _Not_quite_object::_Not_quite_object;
; 4431 : 
; 4432 :         template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
; 4433 :             indirect_equivalence_relation<projected<_It, _Pj>> _Pr = ranges::equal_to>
; 4434 :         _NODISCARD_UNIQUE_ALG constexpr subrange<_It> operator()(
; 4435 :             _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 4436 :             _Adl_verify_range(_First, _Last);
; 4437 :             auto _UResult = _Unique_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 4438 :                 _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4439 : 
; 4440 :             return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 4441 :         }
; 4442 : 
; 4443 :         template <forward_range _Rng, class _Pj = identity,
; 4444 :             indirect_equivalence_relation<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::equal_to>
; 4445 :             requires permutable<iterator_t<_Rng>>
; 4446 :         _NODISCARD_UNIQUE_ALG constexpr borrowed_subrange_t<_Rng> operator()(
; 4447 :             _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 4448 :             auto _UResult = _Unique_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4449 : 
; 4450 :             return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 4451 :         }
; 4452 : 
; 4453 :     private:
; 4454 :         template <class _It, class _Se, class _Pj, class _Pr>
; 4455 :         _NODISCARD static constexpr subrange<_It> _Unique_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
; 4456 :             // Remove adjacent elements from [_First, _Last) whose projections satisfy _Pred
; 4457 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 4458 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4459 :             _STL_INTERNAL_STATIC_ASSERT(indirect_equivalence_relation<_Pr, projected<_It, _Pj>>);
; 4460 : 
; 4461 :             auto _Current = _First;
; 4462 :             if (_First == _Last) {
; 4463 :                 return {_STD move(_Current), _STD move(_First)};
; 4464 :             }
; 4465 : 
; 4466 :             for (;; ++_Current) {
; 4467 :                 if (++_First == _Last) {
; 4468 :                     ++_Current;
; 4469 :                     return {_STD move(_Current), _STD move(_First)};
; 4470 :                 }
; 4471 : 
; 4472 :                 if (_STD invoke(_Pred, _STD invoke(_Proj, *_Current), _STD invoke(_Proj, *_First))) {
; 4473 :                     break;
; 4474 :                 }
; 4475 :             }
; 4476 : 
; 4477 :             while (++_First != _Last) {
; 4478 :                 if (!_STD invoke(_Pred, _STD invoke(_Proj, *_Current), _STD invoke(_Proj, *_First))) {
; 4479 :                     ++_Current;
; 4480 :                     *_Current = _RANGES iter_move(_First);
; 4481 :                 }
; 4482 :             }
; 4483 :             ++_Current;
; 4484 : 
; 4485 :             return {_STD move(_Current), _STD move(_First)};
; 4486 :         }
; 4487 :     };
; 4488 : 
; 4489 :     _EXPORT_STD inline constexpr _Unique_fn unique{_Not_quite_object::_Construct_tag{}};
; 4490 : } // namespace ranges
; 4491 : #endif // __cpp_lib_concepts
; 4492 : 
; 4493 : template <class _InIt, class _OutIt>
; 4494 : #ifdef __cpp_lib_concepts
; 4495 : concept
; 4496 : #else
; 4497 : _INLINE_VAR constexpr bool
; 4498 : #endif
; 4499 :     _Can_reread_dest = _Is_cpp17_fwd_iter_v<_OutIt> && is_same_v<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>;
; 4500 : 
; 4501 : _EXPORT_STD template <class _InIt, class _OutIt, class _Pr>
; 4502 : _CONSTEXPR20 _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
; 4503 :     // copy compressing pairs that match
; 4504 :     _Adl_verify_range(_First, _Last);
; 4505 : 
; 4506 :     auto _UFirst      = _Get_unwrapped(_First);
; 4507 :     const auto _ULast = _Get_unwrapped(_Last);
; 4508 : 
; 4509 :     if (_UFirst == _ULast) {
; 4510 :         return _Dest;
; 4511 :     }
; 4512 : 
; 4513 :     auto _UDest = _Get_unwrapped_unverified(_Dest);
; 4514 : 
; 4515 :     if constexpr (_Is_ranges_fwd_iter_v<_InIt>) { // can reread the source for comparison
; 4516 :         auto _Firstb = _UFirst;
; 4517 : 
; 4518 :         *_UDest = *_Firstb;
; 4519 :         ++_UDest;
; 4520 : 
; 4521 :         while (++_UFirst != _ULast) {
; 4522 :             if (!static_cast<bool>(_Pred(*_Firstb, *_UFirst))) { // copy unmatched
; 4523 :                 _Firstb = _UFirst;
; 4524 :                 *_UDest = *_Firstb;
; 4525 :                 ++_UDest;
; 4526 :             }
; 4527 :         }
; 4528 :     } else if constexpr (_Can_reread_dest<_InIt, _OutIt>) { // assignment copies T; can reread dest for comparison
; 4529 :         *_UDest = *_UFirst;
; 4530 : 
; 4531 :         while (++_UFirst != _ULast) {
; 4532 :             if (!static_cast<bool>(_Pred(*_UDest, *_UFirst))) {
; 4533 :                 *++_UDest = *_UFirst;
; 4534 :             }
; 4535 :         }
; 4536 : 
; 4537 :         ++_UDest;
; 4538 :     } else { // can't reread source or dest, construct a temporary
; 4539 :         _Iter_value_t<_InIt> _Val = *_UFirst;
; 4540 : 
; 4541 :         *_UDest = _Val;
; 4542 :         ++_UDest;
; 4543 : 
; 4544 :         while (++_UFirst != _ULast) {
; 4545 :             if (!static_cast<bool>(_Pred(_Val, *_UFirst))) { // copy unmatched
; 4546 :                 _Val    = *_UFirst;
; 4547 :                 *_UDest = _Val;
; 4548 :                 ++_UDest;
; 4549 :             }
; 4550 :         }
; 4551 :     }
; 4552 : 
; 4553 :     _Seek_wrapped(_Dest, _UDest);
; 4554 :     return _Dest;
; 4555 : }
; 4556 : 
; 4557 : _EXPORT_STD template <class _InIt, class _OutIt>
; 4558 : _CONSTEXPR20 _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy compressing pairs that match
; 4559 :     return _STD unique_copy(_First, _Last, _Dest, equal_to<>{});
; 4560 : }
; 4561 : 
; 4562 : #if _HAS_CXX17
; 4563 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4564 : _FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept /* terminates */ {
; 4565 :     // copy compressing pairs that match
; 4566 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4567 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4568 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4569 :     return _STD unique_copy(_First, _Last, _Dest, _Pass_fn(_Pred));
; 4570 : }
; 4571 : 
; 4572 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4573 : _FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 4574 :     // copy compressing pairs that match
; 4575 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 4576 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 4577 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 4578 :     return _STD unique_copy(_First, _Last, _Dest);
; 4579 : }
; 4580 : #endif // _HAS_CXX17
; 4581 : 
; 4582 : #ifdef __cpp_lib_concepts
; 4583 : namespace ranges {
; 4584 :     _EXPORT_STD template <class _In, class _Out>
; 4585 :     using unique_copy_result = in_out_result<_In, _Out>;
; 4586 : 
; 4587 :     template <class _It, class _Ty>
; 4588 :     concept _Is_input_with_value_type = input_iterator<_It> && same_as<iter_value_t<_It>, _Ty>;
; 4589 : 
; 4590 :     template <class _It, class _Out>
; 4591 :     concept _Can_reread_or_store = forward_iterator<_It> //
; 4592 :                                 || _Is_input_with_value_type<_Out, iter_value_t<_It>> //
; 4593 :                                 || indirectly_copyable_storable<_It, _Out>;
; 4594 : 
; 4595 :     class _Unique_copy_fn : private _Not_quite_object {
; 4596 :     public:
; 4597 :         using _Not_quite_object::_Not_quite_object;
; 4598 : 
; 4599 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
; 4600 :             indirect_equivalence_relation<projected<_It, _Pj>> _Pr = ranges::equal_to>
; 4601 :             requires indirectly_copyable<_It, _Out> && _Can_reread_or_store<_It, _Out>
; 4602 :         constexpr unique_copy_result<_It, _Out> operator()(
; 4603 :             _It _First, _Se _Last, _Out _Result, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 4604 :             _Adl_verify_range(_First, _Last);
; 4605 :             auto _UResult =
; 4606 :                 _Unique_copy_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)),
; 4607 :                     _Get_unwrapped_unverified(_STD move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4608 : 
; 4609 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4610 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4611 :             return {_STD move(_First), _STD move(_Result)};
; 4612 :         }
; 4613 : 
; 4614 :         template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
; 4615 :             indirect_equivalence_relation<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::equal_to>
; 4616 :             requires indirectly_copyable<iterator_t<_Rng>, _Out> && _Can_reread_or_store<iterator_t<_Rng>, _Out>
; 4617 :         constexpr unique_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 4618 :             _Rng&& _Range, _Out _Result, _Pr _Pred = {}, _Pj _Proj = {}) const {
; 4619 :             auto _First   = _RANGES begin(_Range);
; 4620 :             auto _UResult = _Unique_copy_unchecked(_Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
; 4621 :                 _Get_unwrapped_unverified(_STD move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 4622 : 
; 4623 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 4624 :             _Seek_wrapped(_Result, _STD move(_UResult.out));
; 4625 :             return {_STD move(_First), _STD move(_Result)};
; 4626 :         }
; 4627 : 
; 4628 :     private:
; 4629 :         template <class _It, class _Se, class _Out, class _Pj, class _Pr>
; 4630 :         _NODISCARD static constexpr unique_copy_result<_It, _Out> _Unique_copy_unchecked(
; 4631 :             _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
; 4632 :             // Copy elements from [_First, _Last) to _Result, compressing adjacent elements whose projections satisfy
; 4633 :             // _Pred
; 4634 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 4635 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 4636 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 4637 :             _STL_INTERNAL_STATIC_ASSERT(indirect_equivalence_relation<_Pr, projected<_It, _Pj>>);
; 4638 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 4639 :             _STL_INTERNAL_STATIC_ASSERT(_Can_reread_or_store<_It, _Out>);
; 4640 : 
; 4641 :             if (_First == _Last) {
; 4642 :                 return {_STD move(_First), _STD move(_Result)};
; 4643 :             }
; 4644 : 
; 4645 :             if constexpr (_Is_input_with_value_type<_Out, iter_value_t<_It>>) {
; 4646 :                 // Can reread _Result
; 4647 :                 *_Result = *_First;
; 4648 : 
; 4649 :                 while (++_First != _Last) {
; 4650 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj, *_Result), _STD invoke(_Proj, *_First))) {
; 4651 :                         ++_Result;
; 4652 :                         *_Result = *_First;
; 4653 :                     }
; 4654 :                 }
; 4655 :             } else if constexpr (forward_iterator<_It>) {
; 4656 :                 // Can reread _First
; 4657 :                 auto _Current = _First;
; 4658 :                 *_Result      = *_First;
; 4659 : 
; 4660 :                 while (++_First != _Last) {
; 4661 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj, *_Current), _STD invoke(_Proj, *_First))) {
; 4662 :                         _Current = _First;
; 4663 :                         ++_Result;
; 4664 :                         *_Result = *_First;
; 4665 :                     }
; 4666 :                 }
; 4667 :             } else {
; 4668 :                 // Neither _First nor _Result can be reread, construct temporary
; 4669 :                 iter_value_t<_It> _Val = *_First;
; 4670 : 
; 4671 :                 while (++_First != _Last) {
; 4672 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj, _Val), _STD invoke(_Proj, *_First))) {
; 4673 :                         *_Result = _STD move(_Val);
; 4674 :                         ++_Result;
; 4675 :                         _Val = *_First;
; 4676 :                     }
; 4677 :                 }
; 4678 :                 *_Result = _STD move(_Val);
; 4679 :             }
; 4680 :             ++_Result;
; 4681 : 
; 4682 :             return {_STD move(_First), _STD move(_Result)};
; 4683 :         }
; 4684 :     };
; 4685 : 
; 4686 :     _EXPORT_STD inline constexpr _Unique_copy_fn unique_copy{_Not_quite_object::_Construct_tag{}};
; 4687 : 
; 4688 :     // concept-constrained for strict enforcement as it is used by several algorithms
; 4689 :     template <bidirectional_iterator _It>
; 4690 :         requires permutable<_It>
; 4691 :     constexpr void _Reverse_common(_It _First, _It _Last) {
; 4692 : #if _USE_STD_VECTOR_ALGORITHMS
; 4693 :         if constexpr (contiguous_iterator<_It>) {
; 4694 :             using _Elem          = remove_reference_t<iter_reference_t<_It>>;
; 4695 :             constexpr size_t _Nx = sizeof(_Elem);
; 4696 :             constexpr bool _Allow_vectorization =
; 4697 :                 conjunction_v<_Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
; 4698 : 
; 4699 :             if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
; 4700 :                 if (!_STD is_constant_evaluated()) {
; 4701 :                     _Elem* const _First_addr = _STD to_address(_First);
; 4702 :                     _Elem* const _Last_addr  = _STD to_address(_Last);
; 4703 :                     if constexpr (_Nx == 1) {
; 4704 :                         __std_reverse_trivially_swappable_1(_First_addr, _Last_addr);
; 4705 :                     } else if constexpr (_Nx == 2) {
; 4706 :                         __std_reverse_trivially_swappable_2(_First_addr, _Last_addr);
; 4707 :                     } else if constexpr (_Nx == 4) {
; 4708 :                         __std_reverse_trivially_swappable_4(_First_addr, _Last_addr);
; 4709 :                     } else {
; 4710 :                         __std_reverse_trivially_swappable_8(_First_addr, _Last_addr);
; 4711 :                     }
; 4712 : 
; 4713 :                     return;
; 4714 :                 }
; 4715 :             }
; 4716 :         }
; 4717 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 4718 : 
; 4719 :         for (; _First != _Last && _First != --_Last; ++_First) {
; 4720 :             _RANGES iter_swap(_First, _Last);
; 4721 :         }
; 4722 :     }
; 4723 : 
; 4724 :     class _Reverse_fn : private _Not_quite_object {
; 4725 :     public:
; 4726 :         using _Not_quite_object::_Not_quite_object;
; 4727 : 
; 4728 :         template <bidirectional_iterator _It, sentinel_for<_It> _Se>
; 4729 :             requires permutable<_It>
; 4730 :         constexpr _It operator()(_It _First, _Se _Last) const {
; 4731 :             _Adl_verify_range(_First, _Last);
; 4732 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 4733 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 4734 :             _Seek_wrapped(_First, _ULast);
; 4735 :             _Reverse_common(_STD move(_UFirst), _STD move(_ULast));
; 4736 :             return _First;
; 4737 :         }
; 4738 : 
; 4739 :         template <bidirectional_range _Rng>
; 4740 :             requires permutable<iterator_t<_Rng>>
; 4741 :         constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
; 4742 :             auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 4743 :             _Reverse_common(_Ubegin(_Range), _ULast);
; 4744 :             return _Rewrap_iterator(_Range, _STD move(_ULast));
; 4745 :         }
; 4746 :     };
; 4747 : 
; 4748 :     _EXPORT_STD inline constexpr _Reverse_fn reverse{_Not_quite_object::_Construct_tag{}};
; 4749 : } // namespace ranges
; 4750 : #endif // __cpp_lib_concepts
; 4751 : 
; 4752 : _EXPORT_STD template <class _BidIt, class _OutIt>
; 4753 : _CONSTEXPR20 _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest) {
; 4754 :     // copy reversing elements in [_First, _Last)
; 4755 :     _Adl_verify_range(_First, _Last);
; 4756 :     const auto _UFirst = _Get_unwrapped(_First);
; 4757 :     auto _ULast        = _Get_unwrapped(_Last);
; 4758 :     auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));
; 4759 : 
; 4760 : #if _USE_STD_VECTOR_ALGORITHMS
; 4761 :     using _Elem                         = remove_reference_t<_Iter_ref_t<remove_const_t<decltype(_UFirst)>>>;
; 4762 :     using _DestElem                     = remove_reference_t<_Iter_ref_t<decltype(_UDest)>>;
; 4763 :     constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
; 4764 :         bool_constant<_Iterators_are_contiguous<decltype(_ULast), decltype(_UDest)>>, is_trivially_copyable<_Elem>,
; 4765 :         negation<is_volatile<_Elem>>>;
; 4766 :     constexpr size_t _Nx                = sizeof(_Elem);
; 4767 : 
; 4768 :     if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
; 4769 : #if _HAS_CXX20
; 4770 :         if (!_STD is_constant_evaluated())
; 4771 : #endif // _HAS_CXX20
; 4772 :         {
; 4773 :             if constexpr (_Nx == 1) {
; 4774 :                 __std_reverse_copy_trivially_copyable_1(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
; 4775 :             } else if constexpr (_Nx == 2) {
; 4776 :                 __std_reverse_copy_trivially_copyable_2(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
; 4777 :             } else if constexpr (_Nx == 4) {
; 4778 :                 __std_reverse_copy_trivially_copyable_4(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
; 4779 :             } else {
; 4780 :                 __std_reverse_copy_trivially_copyable_8(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
; 4781 :             }
; 4782 : 
; 4783 :             _UDest += _ULast - _UFirst;
; 4784 :             _Seek_wrapped(_Dest, _UDest);
; 4785 :             return _Dest;
; 4786 :         }
; 4787 :     }
; 4788 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 4789 : 
; 4790 :     for (; _UFirst != _ULast; ++_UDest) {
; 4791 :         *_UDest = *--_ULast;
; 4792 :     }
; 4793 : 
; 4794 :     _Seek_wrapped(_Dest, _UDest);
; 4795 :     return _Dest;
; 4796 : }
; 4797 : 
; 4798 : #if _HAS_CXX17
; 4799 : _EXPORT_STD template <class _ExPo, class _BidIt, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
; 4800 : _FwdIt reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last, _FwdIt _Dest) noexcept /* terminates */ {
; 4801 :     // copy reversing elements in [_First, _Last)
; 4802 :     // not parallelized as benchmarks show it isn't worth it
; 4803 :     _REQUIRE_PARALLEL_ITERATOR(_BidIt);
; 4804 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
; 4805 :     return _STD reverse_copy(_First, _Last, _Dest);
; 4806 : }
; 4807 : 
; 4808 : #ifdef __cpp_lib_concepts
; 4809 : namespace ranges {
; 4810 :     _EXPORT_STD template <class _In, class _Out>
; 4811 :     using reverse_copy_result = in_out_result<_In, _Out>;
; 4812 : 
; 4813 :     class _Reverse_copy_fn : private _Not_quite_object {
; 4814 :     public:
; 4815 :         using _Not_quite_object::_Not_quite_object;
; 4816 : 
; 4817 :         template <bidirectional_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 4818 :             requires indirectly_copyable<_It, _Out>
; 4819 :         constexpr reverse_copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
; 4820 :             _Adl_verify_range(_First, _Last);
; 4821 :             auto _UFirst = _Unwrap_iter<_Se>(_STD move(_First));
; 4822 :             auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, _STD move(_Last));
; 4823 :             _Seek_wrapped(_First, _ULast);
; 4824 :             _Result = _Reverse_copy_common(_STD move(_UFirst), _STD move(_ULast), _STD move(_Result));
; 4825 :             return {_STD move(_First), _STD move(_Result)};
; 4826 :         }
; 4827 : 
; 4828 :         template <bidirectional_range _Rng, weakly_incrementable _Out>
; 4829 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 4830 :         constexpr reverse_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
; 4831 :             if constexpr (common_range<_Rng>) {
; 4832 :                 _Result = _Reverse_copy_common(_Ubegin(_Range), _Uend(_Range), _STD move(_Result));
; 4833 :                 return {_RANGES end(_Range), _STD move(_Result)};
; 4834 :             } else {
; 4835 :                 auto _ULast = _Get_final_iterator_unwrapped(_Range);
; 4836 :                 _Result     = _Reverse_copy_common(_Ubegin(_Range), _ULast, _STD move(_Result));
; 4837 :                 return {_Rewrap_iterator(_Range, _STD move(_ULast)), _STD move(_Result)};
; 4838 :             }
; 4839 :         }
; 4840 : 
; 4841 :     private:
; 4842 :         template <class _It, class _Out>
; 4843 :         _NODISCARD static constexpr _Out _Reverse_copy_common(const _It _First, _It _Last, _Out _Result) {
; 4844 :             _STL_INTERNAL_STATIC_ASSERT(bidirectional_iterator<_It>);
; 4845 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 4846 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 4847 : 
; 4848 : #if _USE_STD_VECTOR_ALGORITHMS
; 4849 :             if constexpr (contiguous_iterator<_It> && contiguous_iterator<_Out>) {
; 4850 :                 using _Elem                         = remove_reference_t<iter_reference_t<_It>>;
; 4851 :                 using _DestElem                     = remove_reference_t<iter_reference_t<_Out>>;
; 4852 :                 constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
; 4853 :                     is_trivially_copyable<_Elem>, negation<is_volatile<_Elem>>>;
; 4854 :                 constexpr size_t _Nx                = sizeof(_Elem);
; 4855 : 
; 4856 :                 if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
; 4857 :                     if (!_STD is_constant_evaluated()) {
; 4858 :                         _Elem* const _First_addr      = _STD to_address(_First);
; 4859 :                         _Elem* const _Last_addr       = _STD to_address(_Last);
; 4860 :                         _DestElem* const _Result_addr = _STD to_address(_Result);
; 4861 :                         if constexpr (_Nx == 1) {
; 4862 :                             __std_reverse_copy_trivially_copyable_1(_First_addr, _Last_addr, _Result_addr);
; 4863 :                         } else if constexpr (_Nx == 2) {
; 4864 :                             __std_reverse_copy_trivially_copyable_2(_First_addr, _Last_addr, _Result_addr);
; 4865 :                         } else if constexpr (_Nx == 4) {
; 4866 :                             __std_reverse_copy_trivially_copyable_4(_First_addr, _Last_addr, _Result_addr);
; 4867 :                         } else {
; 4868 :                             __std_reverse_copy_trivially_copyable_8(_First_addr, _Last_addr, _Result_addr);
; 4869 :                         }
; 4870 : 
; 4871 :                         _Result += _Last - _First;
; 4872 :                         return _Result;
; 4873 :                     }
; 4874 :                 }
; 4875 :             }
; 4876 : #endif // _USE_STD_VECTOR_ALGORITHMS
; 4877 : 
; 4878 :             for (; _First != _Last; ++_Result) {
; 4879 :                 *_Result = *--_Last;
; 4880 :             }
; 4881 : 
; 4882 :             return _Result;
; 4883 :         }
; 4884 :     };
; 4885 : 
; 4886 :     _EXPORT_STD inline constexpr _Reverse_copy_fn reverse_copy{_Not_quite_object::_Construct_tag{}};
; 4887 : } // namespace ranges
; 4888 : #endif // __cpp_lib_concepts
; 4889 : #endif // _HAS_CXX17
; 4890 : 
; 4891 : #ifdef __cpp_lib_concepts
; 4892 : namespace ranges {
; 4893 :     template <permutable _It>
; 4894 :     _NODISCARD constexpr subrange<_It> _Reverse_until_mid_unchecked(_It _First, const _It _Mid, _It _Last) {
; 4895 :         // reverse until either _First or _Last hits _Mid
; 4896 :         _STL_INTERNAL_CHECK(_First != _Mid);
; 4897 :         _STL_INTERNAL_CHECK(_Mid != _Last);
; 4898 : 
; 4899 :         do {
; 4900 :             _RANGES iter_swap(_First, --_Last);
; 4901 :         } while (++_First != _Mid && _Last != _Mid);
; 4902 : 
; 4903 :         return {_STD move(_First), _STD move(_Last)};
; 4904 :     }
; 4905 : 
; 4906 :     template <permutable _It, sentinel_for<_It> _Se>
; 4907 :     _NODISCARD constexpr subrange<_It> _Rotate_unchecked(_It _First, _It _Mid, _Se _Last) {
; 4908 :         // Exchange the ranges [_First, _Mid) and [_Mid, _Last)
; 4909 :         // that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
; 4910 : 
; 4911 :         if (_First == _Mid) {
; 4912 :             auto _Final = _Get_final_iterator_unwrapped<_It>(_Mid, _STD move(_Last));
; 4913 :             return {_Final, _Final};
; 4914 :         }
; 4915 : 
; 4916 :         if (_Mid == _Last) {
; 4917 :             return {_STD move(_First), _STD move(_Mid)};
; 4918 :         }
; 4919 : 
; 4920 :         if constexpr (bidirectional_iterator<_It>) {
; 4921 :             _Reverse_common(_First, _Mid);
; 4922 :             auto _Final = _Get_final_iterator_unwrapped<_It>(_Mid, _STD move(_Last));
; 4923 :             _Reverse_common(_Mid, _Final);
; 4924 : 
; 4925 :             if constexpr (random_access_iterator<_It>) {
; 4926 :                 _Reverse_common(_First, _Final);
; 4927 :                 _First += _Final - _Mid;
; 4928 : 
; 4929 :                 return {_STD move(_First), _STD move(_Final)};
; 4930 :             } else {
; 4931 :                 const auto _Result = _RANGES _Reverse_until_mid_unchecked(_STD move(_First), _Mid, _Final);
; 4932 :                 auto _Mid_first    = _Result.begin();
; 4933 :                 auto _Mid_last     = _Result.end();
; 4934 :                 _Reverse_common(_Mid_first, _Mid_last);
; 4935 : 
; 4936 :                 if (_Mid_first == _Mid) {
; 4937 :                     return {_STD move(_Mid_last), _STD move(_Final)};
; 4938 :                 } else {
; 4939 :                     return {_STD move(_Mid_first), _STD move(_Final)};
; 4940 :                 }
; 4941 :             }
; 4942 :         } else {
; 4943 :             auto _Next = _Mid;
; 4944 :             do { // rotate the first cycle
; 4945 :                 _RANGES iter_swap(_First, _Next);
; 4946 :                 ++_First;
; 4947 :                 ++_Next;
; 4948 :                 if (_First == _Mid) {
; 4949 :                     _Mid = _Next;
; 4950 :                 }
; 4951 :             } while (_Next != _Last);
; 4952 : 
; 4953 :             auto _Begin = _First;
; 4954 : 
; 4955 :             while (_Mid != _Last) { // rotate subsequent cycles
; 4956 :                 _Next = _Mid;
; 4957 :                 do {
; 4958 :                     _RANGES iter_swap(_First, _Next);
; 4959 :                     ++_First;
; 4960 :                     ++_Next;
; 4961 :                     if (_First == _Mid) {
; 4962 :                         _Mid = _Next;
; 4963 :                     }
; 4964 :                 } while (_Next != _Last);
; 4965 :             }
; 4966 :             return {_STD move(_Begin), _STD move(_Mid)};
; 4967 :         }
; 4968 :     }
; 4969 : 
; 4970 :     class _Rotate_fn : private _Not_quite_object {
; 4971 :     public:
; 4972 :         using _Not_quite_object::_Not_quite_object;
; 4973 : 
; 4974 :         template <permutable _It, sentinel_for<_It> _Se>
; 4975 :         constexpr subrange<_It> operator()(_It _First, _It _Mid, _Se _Last) const {
; 4976 :             _Adl_verify_range(_First, _Mid);
; 4977 :             _Adl_verify_range(_Mid, _Last);
; 4978 :             auto _UResult = _RANGES _Rotate_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 4979 :                 _Unwrap_iter<_Se>(_STD move(_Mid)), _Unwrap_sent<_It>(_STD move(_Last)));
; 4980 : 
; 4981 :             return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 4982 :         }
; 4983 : 
; 4984 :         template <forward_range _Rng>
; 4985 :             requires permutable<iterator_t<_Rng>>
; 4986 :         constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, iterator_t<_Rng> _Mid) const {
; 4987 :             _Adl_verify_range(_RANGES begin(_Range), _Mid);
; 4988 :             _Adl_verify_range(_Mid, _RANGES end(_Range));
; 4989 :             auto _UResult =
; 4990 :                 _RANGES _Rotate_unchecked(_Ubegin(_Range), _Unwrap_range_iter<_Rng>(_STD move(_Mid)), _Uend(_Range));
; 4991 : 
; 4992 :             return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Mid, _STD move(_UResult));
; 4993 :         }
; 4994 :     };
; 4995 : 
; 4996 :     _EXPORT_STD inline constexpr _Rotate_fn rotate{_Not_quite_object::_Construct_tag{}};
; 4997 : } // namespace ranges
; 4998 : #endif // __cpp_lib_concepts
; 4999 : 
; 5000 : _EXPORT_STD template <class _FwdIt, class _OutIt>
; 5001 : _CONSTEXPR20 _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest) {
; 5002 :     // copy rotating [_First, _Last)
; 5003 :     _Adl_verify_range(_First, _Mid);
; 5004 :     _Adl_verify_range(_Mid, _Last);
; 5005 :     const auto _UFirst = _Get_unwrapped(_First);
; 5006 :     const auto _UMid   = _Get_unwrapped(_Mid);
; 5007 :     const auto _ULast  = _Get_unwrapped(_Last);
; 5008 :     auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
; 5009 :     _UDest             = _STD _Copy_unchecked(_UMid, _ULast, _UDest);
; 5010 :     _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _UMid, _UDest));
; 5011 :     return _Dest;
; 5012 : }
; 5013 : 
; 5014 : #if _HAS_CXX17
; 5015 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5016 : _FwdIt2 rotate_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Mid, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
; 5017 :     // copy rotating [_First, _Last)
; 5018 :     // not parallelized as benchmarks show it isn't worth it
; 5019 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5020 :     _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
; 5021 :     return _STD rotate_copy(_First, _Mid, _Last, _Dest);
; 5022 : }
; 5023 : 
; 5024 : #ifdef __cpp_lib_concepts
; 5025 : namespace ranges {
; 5026 :     _EXPORT_STD template <class _In, class _Out>
; 5027 :     using rotate_copy_result = in_out_result<_In, _Out>;
; 5028 : 
; 5029 :     class _Rotate_copy_fn : private _Not_quite_object {
; 5030 :     public:
; 5031 :         using _Not_quite_object::_Not_quite_object;
; 5032 : 
; 5033 :         template <forward_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
; 5034 :             requires indirectly_copyable<_It, _Out>
; 5035 :         constexpr rotate_copy_result<_It, _Out> operator()(_It _First, _It _Mid, _Se _Last, _Out _Result) const {
; 5036 :             _Adl_verify_range(_First, _Mid);
; 5037 :             _Adl_verify_range(_Mid, _Last);
; 5038 :             auto _UResult = _Rotate_copy_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 5039 :                 _Unwrap_iter<_Se>(_STD move(_Mid)), _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result));
; 5040 : 
; 5041 :             _Seek_wrapped(_First, _STD move(_UResult.in));
; 5042 :             return {_STD move(_First), _STD move(_UResult.out)};
; 5043 :         }
; 5044 : 
; 5045 :         template <forward_range _Rng, weakly_incrementable _Out>
; 5046 :             requires indirectly_copyable<iterator_t<_Rng>, _Out>
; 5047 :         constexpr rotate_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
; 5048 :             _Rng&& _Range, iterator_t<_Rng> _Mid, _Out _Result) const {
; 5049 :             _Adl_verify_range(_RANGES begin(_Range), _Mid);
; 5050 :             _Adl_verify_range(_Mid, _RANGES end(_Range));
; 5051 :             auto _UResult = _Rotate_copy_unchecked(
; 5052 :                 _Ubegin(_Range), _Unwrap_range_iter<_Rng>(_STD move(_Mid)), _Uend(_Range), _STD move(_Result));
; 5053 : 
; 5054 :             return {_Rewrap_iterator(_Range, _STD move(_UResult.in)), _STD move(_UResult.out)};
; 5055 :         }
; 5056 : 
; 5057 :     private:
; 5058 :         template <class _It, class _Se, class _Out>
; 5059 :         _NODISCARD static constexpr rotate_copy_result<_It, _Out> _Rotate_copy_unchecked(
; 5060 :             _It _First, _It _Mid, _Se _Last, _Out _Result) {
; 5061 :             // Copy the content of [_Mid, _Last) and [_First, _Mid) to _Result
; 5062 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 5063 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5064 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 5065 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 5066 : 
; 5067 :             auto _UResult1 = _RANGES _Copy_unchecked(_Mid, _STD move(_Last), _STD move(_Result));
; 5068 :             auto _UResult2 = _RANGES _Copy_unchecked(_STD move(_First), _STD move(_Mid), _STD move(_UResult1.out));
; 5069 :             return {_STD move(_UResult1.in), _STD move(_UResult2.out)};
; 5070 :         }
; 5071 :     };
; 5072 : 
; 5073 :     _EXPORT_STD inline constexpr _Rotate_copy_fn rotate_copy{_Not_quite_object::_Construct_tag{}};
; 5074 : } // namespace ranges
; 5075 : #endif // __cpp_lib_concepts
; 5076 : #endif // _HAS_CXX17
; 5077 : 
; 5078 : template <class _Diff, class _Urng>
; 5079 : class _Rng_from_urng { // wrap a URNG as an RNG
; 5080 : public:
; 5081 :     using _Ty0 = make_unsigned_t<_Diff>;
; 5082 :     using _Ty1 = _Invoke_result_t<_Urng&>;
; 5083 : 
; 5084 :     using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;
; 5085 : 
; 5086 :     explicit _Rng_from_urng(_Urng& _Func)
; 5087 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(static_cast<_Udiff>(-1)) {
; 5088 :         for (; static_cast<_Udiff>((_Urng::max)() - (_Urng::min)()) < _Bmask; _Bmask >>= 1) {
; 5089 :             --_Bits;
; 5090 :         }
; 5091 :     }
; 5092 : 
; 5093 :     _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)
; 5094 :         for (;;) { // try a sample random value
; 5095 :             _Udiff _Ret  = 0; // random bits
; 5096 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]
; 5097 : 
; 5098 :             while (_Mask < static_cast<_Udiff>(_Index - 1)) { // need more random bits
; 5099 :                 _Ret <<= _Bits - 1; // avoid full shift
; 5100 :                 _Ret <<= 1;
; 5101 :                 _Ret |= _Get_bits();
; 5102 :                 _Mask <<= _Bits - 1; // avoid full shift
; 5103 :                 _Mask <<= 1;
; 5104 :                 _Mask |= _Bmask;
; 5105 :             }
; 5106 : 
; 5107 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 5108 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == static_cast<_Udiff>(_Index - 1)) {
; 5109 :                 return static_cast<_Diff>(_Ret % _Index);
; 5110 :             }
; 5111 :         }
; 5112 :     }
; 5113 : 
; 5114 :     _Udiff _Get_all_bits() {
; 5115 :         _Udiff _Ret = 0;
; 5116 : 
; 5117 :         for (size_t _Num = 0; _Num < CHAR_BIT * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits
; 5118 :             _Ret <<= _Bits - 1; // avoid full shift
; 5119 :             _Ret <<= 1;
; 5120 :             _Ret |= _Get_bits();
; 5121 :         }
; 5122 : 
; 5123 :         return _Ret;
; 5124 :     }
; 5125 : 
; 5126 :     _Rng_from_urng(const _Rng_from_urng&)            = delete;
; 5127 :     _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;
; 5128 : 
; 5129 : private:
; 5130 :     _Udiff _Get_bits() { // return a random value within [0, _Bmask]
; 5131 :         for (;;) { // repeat until random value is in range
; 5132 :             const _Udiff _Val = static_cast<_Udiff>(_Ref() - (_Urng::min)());
; 5133 : 
; 5134 :             if (_Val <= _Bmask) {
; 5135 :                 return _Val;
; 5136 :             }
; 5137 :         }
; 5138 :     }
; 5139 : 
; 5140 :     _Urng& _Ref; // reference to URNG
; 5141 :     size_t _Bits; // number of random bits generated by _Get_bits()
; 5142 :     _Udiff _Bmask; // 2^_Bits - 1
; 5143 : };
; 5144 : 
; 5145 : #if _HAS_CXX17
; 5146 : template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
; 5147 : _SampleIt _Sample_reservoir_unchecked(
; 5148 :     _PopIt _First, const _PopIt _Last, const _SampleIt _Dest, const _Diff _Count, _RngFn& _RngFunc) {
; 5149 :     // source is input: use reservoir sampling (unstable)
; 5150 :     // pre: _SampleIt is random-access && 0 < _Count && the range [_Dest, _Dest + _Count) is valid
; 5151 :     using _Diff_sample = _Iter_diff_t<_SampleIt>;
; 5152 :     const auto _SCount = static_cast<_Diff_sample>(_Count);
; 5153 :     _Iter_diff_t<_PopIt> _Pop_size{};
; 5154 :     for (; _Pop_size < _SCount; ++_Pop_size, (void) ++_First) {
; 5155 :         // _Pop_size is less than _SCount, and [_Dest, _Dest + _SCount) is valid,
; 5156 :         // so [_Dest, _Dest + _Pop_size) must be valid, so narrowing to _Diff_sample
; 5157 :         // can't overflow
; 5158 :         const auto _Sample_pop = static_cast<_Diff_sample>(_Pop_size);
; 5159 :         if (_First == _Last) {
; 5160 :             return _Dest + _Sample_pop;
; 5161 :         }
; 5162 : 
; 5163 :         *(_Dest + _Sample_pop) = *_First;
; 5164 :     }
; 5165 :     for (; _First != _Last; ++_First) {
; 5166 :         const auto _Idx = _RngFunc(++_Pop_size);
; 5167 :         if (_Idx < _SCount) {
; 5168 :             *(_Dest + static_cast<_Diff_sample>(_Idx)) = *_First; // again, valid narrowing because _Idx < _SCount
; 5169 :         }
; 5170 :     }
; 5171 :     return _Dest + _SCount;
; 5172 : }
; 5173 : 
; 5174 : template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
; 5175 : _SampleIt _Sample_selection_unchecked(
; 5176 :     _PopIt _First, _Iter_diff_t<_PopIt> _Pop_size, _SampleIt _Dest, _Diff _Count, _RngFn& _RngFunc) {
; 5177 :     // source is forward *and* we know the source range size: use selection sampling (stable)
; 5178 :     // pre: _PopIt is forward && _Count <= _Pop_size
; 5179 :     using _CT = common_type_t<_Iter_diff_t<_PopIt>, _Diff>;
; 5180 :     for (; _Pop_size > 0; ++_First, (void) --_Pop_size) {
; 5181 :         if (static_cast<_CT>(_RngFunc(_Pop_size)) < static_cast<_CT>(_Count)) {
; 5182 :             --_Count;
; 5183 :             *_Dest = *_First;
; 5184 :             ++_Dest;
; 5185 :         }
; 5186 :     }
; 5187 :     return _Dest;
; 5188 : }
; 5189 : 
; 5190 : _EXPORT_STD template <class _PopIt, class _SampleIt, class _Diff, class _Urng>
; 5191 : _SampleIt sample(_PopIt _First, _PopIt _Last, _SampleIt _Dest, _Diff _Count, _Urng&& _Func) {
; 5192 :     // randomly select _Count elements from [_First, _Last) into _Dest
; 5193 :     static_assert(_Is_ranges_fwd_iter_v<_PopIt> || _Is_cpp17_random_iter_v<_SampleIt>,
; 5194 :         "If the source range is not forward, the destination range must be a Cpp17RandomAccessIterator.");
; 5195 : 
; 5196 :     static_assert(is_integral_v<_Diff>, "The sample size must have an integer type.");
; 5197 :     _Adl_verify_range(_First, _Last);
; 5198 :     if (0 < _Count) {
; 5199 :         auto _UFirst   = _Get_unwrapped(_First);
; 5200 :         auto _ULast    = _Get_unwrapped(_Last);
; 5201 :         using _PopDiff = _Iter_diff_t<_PopIt>;
; 5202 :         _Rng_from_urng<_PopDiff, remove_reference_t<_Urng>> _RngFunc(_Func);
; 5203 :         if constexpr (_Is_ranges_fwd_iter_v<_PopIt>) {
; 5204 :             // source is forward: use selection sampling (stable)
; 5205 :             using _CT            = common_type_t<_Diff, _PopDiff>;
; 5206 :             const auto _Pop_size = _STD distance(_UFirst, _ULast);
; 5207 :             if (static_cast<_CT>(_Count) > static_cast<_CT>(_Pop_size)) {
; 5208 :                 _Count = static_cast<_Diff>(_Pop_size); // narrowing OK because _Count is getting smaller
; 5209 :             }
; 5210 : 
; 5211 :             _Seek_wrapped(_Dest,
; 5212 :                 _Sample_selection_unchecked(_UFirst, _Pop_size, _Get_unwrapped_n(_Dest, _Count), _Count, _RngFunc));
; 5213 :         } else {
; 5214 :             static_assert(_Is_ranges_input_iter_v<_PopIt>, "Source iterators must be at least input iterators");
; 5215 :             // source is input: use reservoir sampling (unstable)
; 5216 :             _Seek_wrapped(_Dest,
; 5217 :                 _Sample_reservoir_unchecked(_UFirst, _ULast, _Get_unwrapped_unverified(_Dest), _Count, _RngFunc));
; 5218 :         }
; 5219 :     }
; 5220 : 
; 5221 :     return _Dest;
; 5222 : }
; 5223 : 
; 5224 : #ifdef __cpp_lib_concepts
; 5225 : // clang-format off
; 5226 : _EXPORT_STD template <class _Ty>
; 5227 : concept uniform_random_bit_generator = invocable<_Ty&>
; 5228 :     && unsigned_integral<invoke_result_t<_Ty&>>
; 5229 :     && requires {
; 5230 :         { (_Ty::min)() } -> same_as<invoke_result_t<_Ty&>>;
; 5231 :         { (_Ty::max)() } -> same_as<invoke_result_t<_Ty&>>;
; 5232 :         requires bool_constant<(_Ty::min)() < (_Ty::max)()>::value;
; 5233 :     };
; 5234 : // clang-format on
; 5235 : 
; 5236 : namespace ranges {
; 5237 :     class _Sample_fn : private _Not_quite_object {
; 5238 :     public:
; 5239 :         using _Not_quite_object::_Not_quite_object;
; 5240 : 
; 5241 :         template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Urng>
; 5242 :             requires (forward_iterator<_It> || random_access_iterator<_Out>)
; 5243 :                   && indirectly_copyable<_It, _Out> && uniform_random_bit_generator<remove_reference_t<_Urng>>
; 5244 :         _Out operator()(_It _First, _Se _Last, _Out _Result, iter_difference_t<_It> _Count, _Urng&& _Func) const {
; 5245 :             _Adl_verify_range(_First, _Last);
; 5246 :             if (_Count <= 0) {
; 5247 :                 return _Result;
; 5248 :             }
; 5249 : 
; 5250 :             _Rng_from_urng<iter_difference_t<_It>, remove_reference_t<_Urng>> _RngFunc(_Func);
; 5251 :             if constexpr (forward_iterator<_It>) {
; 5252 :                 auto _UFirst   = _Unwrap_iter<_Se>(_STD move(_First));
; 5253 :                 auto _Pop_size = _RANGES distance(_UFirst, _Unwrap_sent<_It>(_STD move(_Last)));
; 5254 :                 return _Sample_selection_unchecked(_STD move(_UFirst), _Pop_size, _STD move(_Result), _Count, _RngFunc);
; 5255 :             } else {
; 5256 :                 return _Sample_reservoir_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 5257 :                     _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result), _Count, _RngFunc);
; 5258 :             }
; 5259 :         }
; 5260 : 
; 5261 :         template <input_range _Rng, weakly_incrementable _Out, class _Urng>
; 5262 :             requires (forward_range<_Rng> || random_access_iterator<_Out>)
; 5263 :                   && indirectly_copyable<iterator_t<_Rng>, _Out>
; 5264 :                   && uniform_random_bit_generator<remove_reference_t<_Urng>>
; 5265 :         _Out operator()(_Rng&& _Range, _Out _Result, range_difference_t<_Rng> _Count, _Urng&& _Func) const {
; 5266 :             if (_Count <= 0) {
; 5267 :                 return _Result;
; 5268 :             }
; 5269 : 
; 5270 :             _Rng_from_urng<range_difference_t<_Rng>, remove_reference_t<_Urng>> _RngFunc(_Func);
; 5271 :             if constexpr (forward_range<_Rng>) {
; 5272 :                 auto _UFirst   = _Ubegin(_Range);
; 5273 :                 auto _Pop_size = _RANGES distance(_UFirst, _Uend(_Range));
; 5274 :                 return _Sample_selection_unchecked(_STD move(_UFirst), _Pop_size, _STD move(_Result), _Count, _RngFunc);
; 5275 :             } else {
; 5276 :                 return _Sample_reservoir_unchecked(
; 5277 :                     _Ubegin(_Range), _Uend(_Range), _STD move(_Result), _Count, _RngFunc);
; 5278 :             }
; 5279 :         }
; 5280 : 
; 5281 :     private:
; 5282 :         template <class _It, class _Out, class _Rng>
; 5283 :         _NODISCARD static _Out _Sample_selection_unchecked(
; 5284 :             _It _First, iter_difference_t<_It> _Pop_size, _Out _Result, iter_difference_t<_It> _Count, _Rng& _RngFunc) {
; 5285 :             // randomly select _Count elements from [_First, _First + _Pop_size) into _Result
; 5286 :             _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
; 5287 :             _STL_INTERNAL_STATIC_ASSERT(weakly_incrementable<_Out>);
; 5288 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 5289 : 
; 5290 :             if (_Count > _Pop_size) {
; 5291 :                 _Count = _Pop_size;
; 5292 :             }
; 5293 : 
; 5294 :             for (; _Pop_size > 0; ++_First, (void) --_Pop_size) {
; 5295 :                 if (_RngFunc(_Pop_size) < _Count) {
; 5296 :                     *_Result = *_First;
; 5297 :                     ++_Result;
; 5298 :                     if (--_Count == 0) {
; 5299 :                         break;
; 5300 :                     }
; 5301 :                 }
; 5302 :             }
; 5303 : 
; 5304 :             return _Result;
; 5305 :         }
; 5306 : 
; 5307 :         template <class _It, class _Se, class _Out, class _Rng>
; 5308 :         _NODISCARD static _Out _Sample_reservoir_unchecked(
; 5309 :             _It _First, const _Se _Last, _Out _Result, const iter_difference_t<_It> _Count, _Rng& _RngFunc) {
; 5310 :             // randomly select _Count elements from [_First, _Last) into _Result
; 5311 :             _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
; 5312 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5313 :             _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<_Out>);
; 5314 :             _STL_INTERNAL_STATIC_ASSERT(indirectly_copyable<_It, _Out>);
; 5315 : 
; 5316 :             iter_difference_t<_It> _Pop_size{};
; 5317 :             for (; _Pop_size < _Count; ++_Pop_size, (void) ++_First) {
; 5318 :                 if (_First == _Last) {
; 5319 :                     return _Result + _Pop_size;
; 5320 :                 }
; 5321 : 
; 5322 :                 *(_Result + _Pop_size) = *_First;
; 5323 :             }
; 5324 :             for (; _First != _Last; ++_First) {
; 5325 :                 const auto _Idx = _RngFunc(++_Pop_size);
; 5326 :                 if (_Idx < _Count) {
; 5327 :                     *(_Result + _Idx) = *_First;
; 5328 :                 }
; 5329 :             }
; 5330 : 
; 5331 :             return _Result + _Count;
; 5332 :         }
; 5333 :     };
; 5334 : 
; 5335 :     _EXPORT_STD inline constexpr _Sample_fn sample{_Not_quite_object::_Construct_tag{}};
; 5336 : } // namespace ranges
; 5337 : #endif // __cpp_lib_concepts
; 5338 : #endif // _HAS_CXX17
; 5339 : 
; 5340 : template <class _RanIt, class _RngFn>
; 5341 : void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {
; 5342 :     // shuffle [_First, _Last) using random function _RngFunc
; 5343 :     _Adl_verify_range(_First, _Last);
; 5344 :     auto _UFirst      = _Get_unwrapped(_First);
; 5345 :     const auto _ULast = _Get_unwrapped(_Last);
; 5346 :     if (_UFirst == _ULast) {
; 5347 :         return;
; 5348 :     }
; 5349 : 
; 5350 :     using _Diff         = _Iter_diff_t<_RanIt>;
; 5351 :     auto _UTarget       = _UFirst;
; 5352 :     _Diff _Target_index = 1;
; 5353 :     for (; ++_UTarget != _ULast; ++_Target_index) { // randomly place an element from [_First, _Target] at _Target
; 5354 :         _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
; 5355 :         _STL_ASSERT(0 <= _Off && _Off <= _Target_index, "random value out of range");
; 5356 :         if (_Off != _Target_index) { // avoid self-move-assignment
; 5357 :             swap(*_UTarget, *(_UFirst + _Off)); // intentional ADL
; 5358 :         }
; 5359 :     }
; 5360 : }
; 5361 : 
; 5362 : _EXPORT_STD template <class _RanIt, class _Urng>
; 5363 : void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { // shuffle [_First, _Last) using URNG _Func
; 5364 :     using _Urng0 = remove_reference_t<_Urng>;
; 5365 :     _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
; 5366 :     _Random_shuffle1(_First, _Last, _RngFunc);
; 5367 : }
; 5368 : 
; 5369 : #ifdef __cpp_lib_concepts
; 5370 : namespace ranges {
; 5371 :     class _Shuffle_fn : private _Not_quite_object {
; 5372 :     public:
; 5373 :         using _Not_quite_object::_Not_quite_object;
; 5374 : 
; 5375 :         template <random_access_iterator _It, sentinel_for<_It> _Se, class _Urng>
; 5376 :             requires permutable<_It> && uniform_random_bit_generator<remove_reference_t<_Urng>>
; 5377 :         _It operator()(_It _First, _Se _Last, _Urng&& _Func) const {
; 5378 :             _Adl_verify_range(_First, _Last);
; 5379 : 
; 5380 :             _Rng_from_urng<iter_difference_t<_It>, remove_reference_t<_Urng>> _RngFunc(_Func);
; 5381 :             auto _UResult =
; 5382 :                 _Shuffle_unchecked(_Unwrap_iter<_Se>(_STD move(_First)), _Unwrap_sent<_It>(_STD move(_Last)), _RngFunc);
; 5383 : 
; 5384 :             _Seek_wrapped(_First, _STD move(_UResult));
; 5385 :             return _First;
; 5386 :         }
; 5387 : 
; 5388 :         template <random_access_range _Rng, class _Urng>
; 5389 :             requires permutable<iterator_t<_Rng>> && uniform_random_bit_generator<remove_reference_t<_Urng>>
; 5390 :         borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Urng&& _Func) const {
; 5391 :             _Rng_from_urng<range_difference_t<_Rng>, remove_reference_t<_Urng>> _RngFunc(_Func);
; 5392 : 
; 5393 :             return _Rewrap_iterator(_Range, _Shuffle_unchecked(_Ubegin(_Range), _Uend(_Range), _RngFunc));
; 5394 :         }
; 5395 : 
; 5396 :     private:
; 5397 :         template <class _It, class _Se, class _Rng>
; 5398 :         _NODISCARD static _It _Shuffle_unchecked(_It _First, const _Se _Last, _Rng& _Func) {
; 5399 :             // shuffle [_First, _Last) using random function _Func
; 5400 :             _STL_INTERNAL_STATIC_ASSERT(random_access_iterator<_It>);
; 5401 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5402 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 5403 : 
; 5404 :             if (_First == _Last) {
; 5405 :                 return _First;
; 5406 :             }
; 5407 :             using _Diff = iter_difference_t<_It>;
; 5408 : 
; 5409 :             auto _Target        = _First;
; 5410 :             _Diff _Target_index = 1;
; 5411 :             for (; ++_Target != _Last; ++_Target_index) {
; 5412 :                 // randomly place an element from [_First, _Target] at _Target
; 5413 :                 const _Diff _Off = _Func(_Target_index + 1);
; 5414 :                 _STL_ASSERT(0 <= _Off && _Off <= _Target_index, "random value out of range");
; 5415 :                 if (_Off != _Target_index) { // avoid self-move-assignment
; 5416 :                     _RANGES iter_swap(_Target, _First + _Off);
; 5417 :                 }
; 5418 :             }
; 5419 :             return _Target;
; 5420 :         }
; 5421 :     };
; 5422 : 
; 5423 :     _EXPORT_STD inline constexpr _Shuffle_fn shuffle{_Not_quite_object::_Construct_tag{}};
; 5424 : } // namespace ranges
; 5425 : #endif // __cpp_lib_concepts
; 5426 : 
; 5427 : #if _HAS_AUTO_PTR_ETC
; 5428 : _EXPORT_STD template <class _RanIt, class _RngFn>
; 5429 : void random_shuffle(_RanIt _First, _RanIt _Last, _RngFn&& _RngFunc) {
; 5430 :     // shuffle [_First, _Last) using random function _RngFunc
; 5431 :     _Random_shuffle1(_First, _Last, _RngFunc);
; 5432 : }
; 5433 : 
; 5434 : struct _Rand_urng_from_func { // wrap rand() as a URNG
; 5435 :     using result_type = unsigned int;
; 5436 : 
; 5437 :     static result_type(min)() { // return minimum possible generated value
; 5438 :         return 0;
; 5439 :     }
; 5440 : 
; 5441 :     static result_type(max)() { // return maximum possible generated value
; 5442 :         return RAND_MAX;
; 5443 :     }
; 5444 : 
; 5445 :     result_type operator()() { // invoke rand()
; 5446 :         return static_cast<result_type>(_CSTD rand());
; 5447 :     }
; 5448 : };
; 5449 : 
; 5450 : _EXPORT_STD template <class _RanIt>
; 5451 : void random_shuffle(_RanIt _First, _RanIt _Last) { // shuffle [_First, _Last) using rand()
; 5452 :     _Rand_urng_from_func _Func;
; 5453 :     _STD shuffle(_First, _Last, _Func);
; 5454 : }
; 5455 : #endif // _HAS_AUTO_PTR_ETC
; 5456 : 
; 5457 : #if _HAS_CXX20
; 5458 : _EXPORT_STD template <class _FwdIt>
; 5459 : constexpr _FwdIt shift_left(_FwdIt _First, const _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) {
; 5460 :     // shift [_First, _Last) left by _Pos_to_shift
; 5461 :     // positions; returns the end of the resulting range
; 5462 :     _STL_ASSERT(_Pos_to_shift >= 0, "shift count must be non-negative (N4950 [alg.shift]/1)");
; 5463 : 
; 5464 :     _Adl_verify_range(_First, _Last);
; 5465 : 
; 5466 :     if (_Pos_to_shift == 0) {
; 5467 :         return _Last;
; 5468 :     }
; 5469 : 
; 5470 :     const auto _UFirst = _Get_unwrapped(_First);
; 5471 :     const auto _ULast  = _Get_unwrapped(_Last);
; 5472 :     auto _Start_at     = _UFirst;
; 5473 : 
; 5474 :     if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
; 5475 :         if (_Pos_to_shift >= _ULast - _UFirst) {
; 5476 :             return _First;
; 5477 :         }
; 5478 :         _Start_at += _Pos_to_shift;
; 5479 :     } else {
; 5480 :         for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
; 5481 :             if (_Start_at == _ULast) {
; 5482 :                 return _First;
; 5483 :             }
; 5484 :             ++_Start_at;
; 5485 :         }
; 5486 :     }
; 5487 : 
; 5488 :     _Seek_wrapped(_First, _STD _Move_unchecked(_Start_at, _ULast, _UFirst));
; 5489 :     return _First;
; 5490 : }
; 5491 : 
; 5492 : _EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5493 : _FwdIt shift_left(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) noexcept /* terminates */ {
; 5494 :     // shift [_First, _Last) left by _Pos_to_shift positions
; 5495 :     // not parallelized as benchmarks show it isn't worth it
; 5496 :     return _STD shift_left(_First, _Last, _Pos_to_shift);
; 5497 : }
; 5498 : 
; 5499 : _EXPORT_STD template <class _FwdIt>
; 5500 : constexpr _FwdIt shift_right(_FwdIt _First, const _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) {
; 5501 :     // shift [_First, _Last) right by _Pos_to_shift
; 5502 :     // positions; returns the beginning of the resulting range
; 5503 :     _STL_ASSERT(_Pos_to_shift >= 0, "shift count must be non-negative (N4950 [alg.shift]/5)");
; 5504 : 
; 5505 :     _Adl_verify_range(_First, _Last);
; 5506 : 
; 5507 :     if (_Pos_to_shift == 0) {
; 5508 :         return _First;
; 5509 :     }
; 5510 : 
; 5511 :     const auto _UFirst = _Get_unwrapped(_First);
; 5512 :     const auto _ULast  = _Get_unwrapped(_Last);
; 5513 : 
; 5514 :     if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
; 5515 :         auto _UEnd_at = _ULast;
; 5516 :         if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
; 5517 :             if (_Pos_to_shift >= _ULast - _UFirst) {
; 5518 :                 return _Last;
; 5519 :             }
; 5520 :             _UEnd_at -= _Pos_to_shift;
; 5521 :         } else {
; 5522 :             for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
; 5523 :                 if (_UEnd_at == _UFirst) {
; 5524 :                     return _Last;
; 5525 :                 }
; 5526 :                 --_UEnd_at;
; 5527 :             }
; 5528 :         }
; 5529 : 
; 5530 :         _Seek_wrapped(_First, _Move_backward_unchecked(_UFirst, _UEnd_at, _ULast));
; 5531 :         return _First;
; 5532 :     } else {
; 5533 :         auto _UResult = _UFirst;
; 5534 : 
; 5535 :         for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
; 5536 :             if (_UResult == _ULast) {
; 5537 :                 return _Last;
; 5538 :             }
; 5539 :             ++_UResult;
; 5540 :         }
; 5541 :         _Seek_wrapped(_First, _UResult);
; 5542 : 
; 5543 :         auto _Trail = _UFirst;
; 5544 :         auto _Lead  = _UResult;
; 5545 : 
; 5546 :         for (; _Trail != _UResult; ++_Trail, (void) ++_Lead) {
; 5547 :             if (_Lead == _ULast) {
; 5548 :                 _STD _Move_unchecked(_UFirst, _Trail, _UResult);
; 5549 : 
; 5550 :                 return _First;
; 5551 :             }
; 5552 :         }
; 5553 : 
; 5554 :         // Here, _Trail = _UFirst + original _Pos_to_shift
; 5555 :         // Here, _Lead = _UFirst + 2 * original _Pos_to_shift
; 5556 : 
; 5557 :         for (;;) {
; 5558 :             // This loop swaps the range [_UFirst, _UResult) with [_Trail, _Lead),
; 5559 :             // advancing _Trail and _Lead by _Pos_to_shift
; 5560 :             for (auto _Mid = _UFirst; _Mid != _UResult; ++_Mid, (void) ++_Trail, ++_Lead) {
; 5561 :                 if (_Lead == _ULast) {
; 5562 :                     _Trail = _STD _Move_unchecked(_Mid, _UResult, _Trail);
; 5563 :                     _STD _Move_unchecked(_UFirst, _Mid, _Trail);
; 5564 : 
; 5565 :                     return _First;
; 5566 :                 }
; 5567 :                 swap(*_Mid, *_Trail); // intentional ADL
; 5568 :             }
; 5569 :         }
; 5570 :     }
; 5571 : }
; 5572 : 
; 5573 : _EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5574 : _FwdIt shift_right(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) noexcept /* terminates */ {
; 5575 :     // shift [_First, _Last) right by _Pos_to_shift positions
; 5576 :     // not parallelized as benchmarks show it isn't worth it
; 5577 :     return _STD shift_right(_First, _Last, _Pos_to_shift);
; 5578 : }
; 5579 : #endif // _HAS_CXX20
; 5580 : 
; 5581 : #if _HAS_CXX23 && defined(__cpp_lib_concepts) // TRANSITION, GH-395
; 5582 : namespace ranges {
; 5583 :     class _Shift_left_fn : private _Not_quite_object {
; 5584 :     public:
; 5585 :         using _Not_quite_object::_Not_quite_object;
; 5586 : 
; 5587 :         template <permutable _It, sentinel_for<_It> _Se>
; 5588 :         constexpr subrange<_It> operator()(_It _First, const _Se _Last, iter_difference_t<_It> _Pos_to_shift) const {
; 5589 :             _STL_ASSERT(_Pos_to_shift >= 0, "shift count must be non-negative (N4950 [alg.shift]/1)");
; 5590 : 
; 5591 :             _Adl_verify_range(_First, _Last);
; 5592 :             auto _Result = _First;
; 5593 :             _Unwrap_iter_t<_It, _Se> _UResult;
; 5594 : 
; 5595 :             if (_Pos_to_shift == 0) {
; 5596 :                 _UResult = _Get_final_iterator_unwrapped<_It>(_Unwrap_iter<_Se>(_Result), _Last);
; 5597 :             } else {
; 5598 :                 _UResult = _Shift_left_impl(_Unwrap_iter<_Se>(_First), _Unwrap_sent<_It>(_Last), _Pos_to_shift);
; 5599 :             }
; 5600 :             _Seek_wrapped(_Result, _UResult);
; 5601 :             return {_STD move(_First), _STD move(_Result)};
; 5602 :         }
; 5603 : 
; 5604 :         template <forward_range _Rng>
; 5605 :             requires permutable<iterator_t<_Rng>>
; 5606 :         constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, range_difference_t<_Rng> _Pos_to_shift) const {
; 5607 :             _STL_ASSERT(_Pos_to_shift >= 0, "shift count must be non-negative (N4950 [alg.shift]/1)");
; 5608 : 
; 5609 :             if (_Pos_to_shift == 0) {
; 5610 :                 auto _Last = _Rewrap_iterator(_Range, _Get_final_iterator_unwrapped(_Range));
; 5611 :                 return {_RANGES begin(_Range), _STD move(_Last)};
; 5612 :             }
; 5613 : 
; 5614 :             if constexpr (sized_range<_Rng>) {
; 5615 :                 auto _First = _RANGES begin(_Range);
; 5616 :                 if (_RANGES distance(_Range) <= _Pos_to_shift) {
; 5617 :                     return {_First, _First};
; 5618 :                 }
; 5619 : 
; 5620 :                 auto _UFirst   = _Unwrap_range_iter<_Rng>(_First);
; 5621 :                 auto _Start_at = _RANGES next(_UFirst, _Pos_to_shift);
; 5622 :                 auto _Result   = _RANGES _Move_unchecked(_STD move(_Start_at), _Uend(_Range), _UFirst).out;
; 5623 :                 return {_STD move(_First), _Rewrap_iterator(_Range, _STD move(_Result))};
; 5624 :             } else {
; 5625 :                 auto _Result = _Shift_left_impl(_Ubegin(_Range), _Uend(_Range), _Pos_to_shift);
; 5626 :                 return {_RANGES begin(_Range), _Rewrap_iterator(_Range, _STD move(_Result))};
; 5627 :             }
; 5628 :         }
; 5629 : 
; 5630 :     private:
; 5631 :         template <class _It, class _Se>
; 5632 :         _NODISCARD static constexpr _It _Shift_left_impl(_It _First, _Se _Last, iter_difference_t<_It> _Pos_to_shift) {
; 5633 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 5634 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5635 :             _STL_INTERNAL_CHECK(_Pos_to_shift > 0);
; 5636 : 
; 5637 :             auto _Start_at = _First;
; 5638 :             if (_RANGES advance(_Start_at, _Pos_to_shift, _Last) != 0) {
; 5639 :                 return _First;
; 5640 :             }
; 5641 : 
; 5642 :             return _RANGES _Move_unchecked(_STD move(_Start_at), _STD move(_Last), _STD move(_First)).out;
; 5643 :         }
; 5644 :     };
; 5645 : 
; 5646 :     _EXPORT_STD inline constexpr _Shift_left_fn shift_left{_Not_quite_object::_Construct_tag{}};
; 5647 : 
; 5648 :     class _Shift_right_fn : private _Not_quite_object {
; 5649 :     public:
; 5650 :         using _Not_quite_object::_Not_quite_object;
; 5651 : 
; 5652 :         template <permutable _It, sentinel_for<_It> _Se>
; 5653 :         constexpr subrange<_It> operator()(_It _First, const _Se _Last, iter_difference_t<_It> _Pos_to_shift) const {
; 5654 :             _Adl_verify_range(_First, _Last);
; 5655 :             auto _UFirst     = _Unwrap_iter<_Se>(_First);
; 5656 :             auto _ULast      = _Unwrap_sent<_It>(_Last);
; 5657 :             const auto _Size = _Size_helper(_UFirst, _ULast);
; 5658 :             auto _Result     = _Shift_right_impl(_STD move(_UFirst), _STD move(_ULast), _Pos_to_shift, _Size);
; 5659 :             _Seek_wrapped(_First, _Result.begin());
; 5660 :             auto _Final = _First;
; 5661 :             _Seek_wrapped(_Final, _Result.end());
; 5662 :             return {_STD move(_First), _STD move(_Final)};
; 5663 :         }
; 5664 : 
; 5665 :         template <forward_range _Rng>
; 5666 :             requires permutable<iterator_t<_Rng>>
; 5667 :         constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, range_difference_t<_Rng> _Pos_to_shift) const {
; 5668 :             const auto _Size = _Size_helper(_Range);
; 5669 :             auto _Result     = _Shift_right_impl(_Ubegin(_Range), _Uend(_Range), _Pos_to_shift, _Size);
; 5670 :             auto _First      = _Rewrap_iterator(_Range, _Result.begin());
; 5671 :             auto _Final      = _Rewrap_iterator(_Range, _Result.end());
; 5672 :             return {_STD move(_First), _STD move(_Final)};
; 5673 :         }
; 5674 : 
; 5675 :     private:
; 5676 :         struct _Unsized {};
; 5677 : 
; 5678 :         template <range _Rng>
; 5679 :         _NODISCARD static constexpr auto _Size_helper(_Rng&& _Range) {
; 5680 :             if constexpr (sized_range<_Rng>) {
; 5681 :                 return _RANGES distance(_Range);
; 5682 :             } else {
; 5683 :                 return _Unsized{};
; 5684 :             }
; 5685 :         }
; 5686 : 
; 5687 :         template <class _It, sentinel_for<_It> _Se>
; 5688 :         _NODISCARD static constexpr auto _Size_helper(const _It& _First, const _Se& _Last) {
; 5689 :             if constexpr (sized_sentinel_for<_Se, _It>) {
; 5690 :                 return _Last - _First;
; 5691 :             } else {
; 5692 :                 return _Unsized{};
; 5693 :             }
; 5694 :         }
; 5695 : 
; 5696 :         template <input_iterator _It, weakly_incrementable _Out>
; 5697 :             requires indirectly_movable<_It, _Out>
; 5698 :         _NODISCARD static constexpr _Out _Move_n_helper(_It _First, iter_difference_t<_It> _Count, _Out _Result) {
; 5699 :             for (; _Count > 0; ++_First, (void) --_Count, ++_Result) {
; 5700 :                 *_Result = _RANGES iter_move(_First);
; 5701 :             }
; 5702 : 
; 5703 :             return _Result;
; 5704 :         }
; 5705 : 
; 5706 :         template <class _It, class _Se, class _SizeTy>
; 5707 :         _NODISCARD static constexpr subrange<_It> _Shift_right_impl(
; 5708 :             _It _First, _Se _Last, iter_difference_t<_It> _Pos_to_shift, const _SizeTy _Size) {
; 5709 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 5710 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5711 :             _STL_ASSERT(_Pos_to_shift >= 0, "shift count must be non-negative (N4950 [alg.shift]/5)");
; 5712 : 
; 5713 :             if (_Pos_to_shift == 0) {
; 5714 :                 return {_First, _RANGES next(_First, _Last)};
; 5715 :             }
; 5716 : 
; 5717 :             constexpr bool _Is_sized = !same_as<_SizeTy, _Unsized>;
; 5718 : 
; 5719 :             if constexpr (_Is_sized) {
; 5720 :                 if (_Pos_to_shift >= _Size) {
; 5721 :                     if constexpr (same_as<_It, _Se>) {
; 5722 :                         return {_Last, _Last};
; 5723 :                     } else if constexpr (random_access_iterator<_It>) {
; 5724 :                         _First += _Size;
; 5725 :                         return {_First, _First};
; 5726 :                     } else {
; 5727 :                         _RANGES advance(_First, _Last);
; 5728 :                         return {_First, _First};
; 5729 :                     }
; 5730 :                 }
; 5731 :             }
; 5732 : 
; 5733 :             if constexpr (_Bidi_common<_It, _Se>) {
; 5734 :                 auto _Mid = _Last;
; 5735 :                 if constexpr (_Is_sized) {
; 5736 :                     // We validated above that the length of the range is more than _Pos_to_shift
; 5737 :                     _RANGES advance(_Mid, -_Pos_to_shift);
; 5738 :                 } else {
; 5739 :                     if (_RANGES advance(_Mid, -_Pos_to_shift, _First) != 0) {
; 5740 :                         return {_Last, _Last};
; 5741 :                     }
; 5742 :                 }
; 5743 :                 return {_RANGES _Move_backward_common(_STD move(_First), _STD move(_Mid), _Last), _Last};
; 5744 :             } else if constexpr (_Is_sized && random_access_iterator<_It>) {
; 5745 :                 auto _Final = _First + _Size;
; 5746 :                 auto _Mid   = _Final - _Pos_to_shift;
; 5747 :                 return {_RANGES _Move_backward_common(_STD move(_First), _STD move(_Mid), _Final), _Final};
; 5748 :             } else {
; 5749 :                 auto _Buf = _First;
; 5750 :                 if constexpr (_Is_sized) {
; 5751 :                     _RANGES advance(_Buf, _Pos_to_shift);
; 5752 :                 } else {
; 5753 :                     if (_RANGES advance(_Buf, _Pos_to_shift, _Last) != 0) {
; 5754 :                         return {_Buf, _Buf};
; 5755 :                     }
; 5756 :                 }
; 5757 : 
; 5758 :                 if constexpr (_Is_sized) {
; 5759 :                     if (_Size < 2 * _Pos_to_shift) {
; 5760 :                         return {_Buf, _Move_n_helper(_First, _Size - _Pos_to_shift, _Buf)};
; 5761 :                     }
; 5762 :                 }
; 5763 : 
; 5764 :                 auto _Lead = _Buf;
; 5765 :                 if constexpr (_Is_sized) {
; 5766 :                     // We validated above that the length of the range is at least 2 * _Pos_to_shift
; 5767 :                     _RANGES advance(_Lead, _Pos_to_shift);
; 5768 :                 } else {
; 5769 :                     if (auto _Rem = _RANGES advance(_Lead, _Pos_to_shift, _Last); _Rem != 0) {
; 5770 :                         return {_Buf, _Move_n_helper(_First, _Pos_to_shift - _Rem, _Buf)};
; 5771 :                     }
; 5772 :                 }
; 5773 : 
; 5774 :                 auto _Trail = _Buf;
; 5775 : 
; 5776 :                 // The range is now partitioned like:
; 5777 :                 //
; 5778 :                 // | _Pos_to_shift elements |           | _Pos_to_shift elements |
; 5779 :                 // |------------------------|-----------|------------------------|------------|
; 5780 :                 // ^_First              _Buf^     _Trail^                   _Lead^       _Last^
; 5781 :                 //
; 5782 :                 // From now on, _Mid repeatedly cycles through the [_First, _Buf) window while the
; 5783 :                 // [_Trail, _Lead) window advances toward _Last.
; 5784 : 
; 5785 :                 for (;;) {
; 5786 :                     for (auto _Mid = _First; _Mid != _Buf; ++_Mid, (void) ++_Trail, ++_Lead) {
; 5787 :                         if (_Lead == _Last) {
; 5788 :                             // The leading edge of the [_Trail, _Lead) window has hit the end of
; 5789 :                             // the range, so we have only the final _Pos_to_shift elements to process.
; 5790 :                             // Their original values are lost - shifted off the end of the range -
; 5791 :                             // so we only need to fill them with new values from [_First, _Buf).
; 5792 :                             _Trail = _RANGES _Move_unchecked(_Mid, _Buf, _STD move(_Trail)).out;
; 5793 :                             _Trail = _RANGES _Move_unchecked(_First, _Mid, _STD move(_Trail)).out;
; 5794 :                             _STL_INTERNAL_CHECK(_Trail == _Lead);
; 5795 :                             return {_STD move(_Buf), _STD move(_Trail)};
; 5796 :                         }
; 5797 : 
; 5798 :                         _RANGES iter_swap(_Mid, _Trail);
; 5799 :                     }
; 5800 :                 }
; 5801 :             }
; 5802 :         }
; 5803 :     };
; 5804 : 
; 5805 :     _EXPORT_STD inline constexpr _Shift_right_fn shift_right{_Not_quite_object::_Construct_tag{}};
; 5806 : } // namespace ranges
; 5807 : #endif // _HAS_CXX23 && defined(__cpp_lib_concepts)
; 5808 : 
; 5809 : _EXPORT_STD template <class _FwdIt, class _Pr>
; 5810 : _CONSTEXPR20 _FwdIt partition(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
; 5811 :     // move elements satisfying _Pred to beginning of sequence
; 5812 :     _Adl_verify_range(_First, _Last);
; 5813 :     auto _UFirst = _Get_unwrapped(_First);
; 5814 :     auto _ULast  = _Get_unwrapped(_Last);
; 5815 :     if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
; 5816 :         for (;;) { // find any out-of-order pair
; 5817 :             for (;;) { // skip in-place elements at beginning
; 5818 :                 if (_UFirst == _ULast) {
; 5819 :                     _Seek_wrapped(_First, _UFirst);
; 5820 :                     return _First;
; 5821 :                 }
; 5822 : 
; 5823 :                 if (!_Pred(*_UFirst)) {
; 5824 :                     break;
; 5825 :                 }
; 5826 : 
; 5827 :                 ++_UFirst;
; 5828 :             }
; 5829 : 
; 5830 :             do { // skip in-place elements at end
; 5831 :                 --_ULast;
; 5832 :                 if (_UFirst == _ULast) {
; 5833 :                     _Seek_wrapped(_First, _UFirst);
; 5834 :                     return _First;
; 5835 :                 }
; 5836 :             } while (!_Pred(*_ULast));
; 5837 : 
; 5838 :             swap(*_UFirst, *_ULast); // out of place, swap and loop; intentional ADL
; 5839 :             ++_UFirst;
; 5840 :         }
; 5841 :     } else {
; 5842 :         for (;;) { // skip in-place elements at beginning
; 5843 :             if (_UFirst == _ULast) {
; 5844 :                 _Seek_wrapped(_First, _UFirst);
; 5845 :                 return _First;
; 5846 :             }
; 5847 : 
; 5848 :             if (!_Pred(*_UFirst)) {
; 5849 :                 break;
; 5850 :             }
; 5851 : 
; 5852 :             ++_UFirst;
; 5853 :         }
; 5854 : 
; 5855 :         for (auto _UNext = _UFirst; ++_UNext != _ULast;) {
; 5856 :             if (_Pred(*_UNext)) {
; 5857 :                 swap(*_UFirst, *_UNext); // out of place, swap and loop; intentional ADL
; 5858 :                 ++_UFirst;
; 5859 :             }
; 5860 :         }
; 5861 :     }
; 5862 : 
; 5863 :     _Seek_wrapped(_First, _UFirst);
; 5864 :     return _First;
; 5865 : }
; 5866 : 
; 5867 : #if _HAS_CXX17
; 5868 : _EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5869 : _FwdIt partition(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; // terminates
; 5870 : 
; 5871 : #ifdef __cpp_lib_concepts
; 5872 : namespace ranges {
; 5873 :     class _Partition_fn : private _Not_quite_object {
; 5874 :     public:
; 5875 :         using _Not_quite_object::_Not_quite_object;
; 5876 : 
; 5877 :         template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
; 5878 :             indirect_unary_predicate<projected<_It, _Pj>> _Pr>
; 5879 :         constexpr subrange<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
; 5880 :             _Adl_verify_range(_First, _Last);
; 5881 :             auto _UResult = _Partition_unchecked(_Unwrap_iter<_Se>(_STD move(_First)),
; 5882 :                 _Unwrap_sent<_It>(_STD move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 5883 :             return _Rewrap_subrange<subrange<_It>>(_First, _STD move(_UResult));
; 5884 :         }
; 5885 : 
; 5886 :         template <forward_range _Rng, class _Pj = identity,
; 5887 :             indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
; 5888 :             requires permutable<iterator_t<_Rng>>
; 5889 :         constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
; 5890 :             auto _UResult = _Partition_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
; 5891 :             return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, _STD move(_UResult));
; 5892 :         }
; 5893 : 
; 5894 :     private:
; 5895 :         template <class _It, class _Se, class _Pr, class _Pj>
; 5896 :         _NODISCARD static constexpr subrange<_It> _Partition_unchecked(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj) {
; 5897 :             _STL_INTERNAL_STATIC_ASSERT(permutable<_It>);
; 5898 :             _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
; 5899 :             _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);
; 5900 : 
; 5901 :             if constexpr (_Bidi_common<_It, _Se>) {
; 5902 :                 auto _Saved_last = _Last;
; 5903 :                 for (;; ++_First) { // find any out-of-order pair
; 5904 :                     for (;; ++_First) { // skip in-place elements at beginning
; 5905 :                         if (_First == _Last) {
; 5906 :                             return {_STD move(_First), _STD move(_Saved_last)};
; 5907 :                         }
; 5908 : 
; 5909 :                         if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 5910 :                             break;
; 5911 :                         }
; 5912 :                     }
; 5913 : 
; 5914 :                     do { // skip in-place elements at end
; 5915 :                         --_Last;
; 5916 :                         if (_First == _Last) {
; 5917 :                             return {_STD move(_First), _STD move(_Saved_last)};
; 5918 :                         }
; 5919 :                     } while (!_STD invoke(_Pred, _STD invoke(_Proj, *_Last)));
; 5920 : 
; 5921 :                     _RANGES iter_swap(_First, _Last); // out of place, swap and loop
; 5922 :                 }
; 5923 : 
; 5924 :                 return {_STD move(_First), _STD move(_Saved_last)};
; 5925 :             } else {
; 5926 :                 for (;; ++_First) { // skip in-place elements at beginning
; 5927 :                     if (_First == _Last) {
; 5928 :                         return {_First, _First};
; 5929 :                     }
; 5930 : 
; 5931 :                     if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
; 5932 :                         break;
; 5933 :                     }
; 5934 :                 }
; 5935 : 
; 5936 :                 auto _Next = _First;
; 5937 :                 while (++_Next != _Last) {
; 5938 :                     if (_STD invoke(_Pred, _STD invoke(_Proj, *_Next))) {
; 5939 :                         _RANGES iter_swap(_First, _Next); // out of place, swap and loop
; 5940 :                         ++_First;
; 5941 :                     }
; 5942 :                 }
; 5943 : 
; 5944 :                 return {_STD move(_First), _STD move(_Next)};
; 5945 :             }
; 5946 :         }
; 5947 :     };
; 5948 : 
; 5949 :     _EXPORT_STD inline constexpr _Partition_fn partition{_Not_quite_object::_Construct_tag{}};
; 5950 : } // namespace ranges
; 5951 : #endif // __cpp_lib_concepts
; 5952 : #endif // _HAS_CXX17
; 5953 : 
; 5954 : template <class _BidIt>
; 5955 : _BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
; 5956 :     const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
; 5957 :     const ptrdiff_t _Capacity) { // rotate [_First, _Last) using temp buffer
; 5958 :                                  // precondition: _Count1 == distance(_First, _Mid)
; 5959 :                                  // precondition: _Count2 == distance(_Mid, _Last)
; 5960 :     if (_Count1 == 0) {
; 5961 :         return _Last;
; 5962 :     }
; 5963 : 
; 5964 :     if (_Count2 == 0) {
; 5965 :         return _First;
; 5966 :     }
; 5967 : 
; 5968 :     if (_Count1 <= _Count2 && _Count1 <= _Capacity) { // buffer left range, then copy parts
; 5969 :         _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
; 5970 :             _Temp_ptr, _STD _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
; 5971 :         const _BidIt _New_mid = _STD _Move_unchecked(_Mid, _Last, _First);
; 5972 :         _STD _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
; 5973 :         return _New_mid; // _Backout destroys elements in temporary buffer
; 5974 :     }
; 5975 : 
; 5976 :     if (_Count2 <= _Capacity) { // buffer right range, then copy parts
; 5977 :         _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
; 5978 :             _Temp_ptr, _STD _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
; 5979 :         _Move_backward_unchecked(_First, _Mid, _Last);
; 5980 :         return _STD _Move_unchecked(_Backout._First, _Backout._Last, _First); // ditto _Backout destroys elements
; 5981 :     }
; 5982 : 
; 5983 :     // buffer too small, rotate in place
; 5984 :     return _STD rotate(_First, _Mid, _Last);
; 5985 : }
; 5986 : 
; 5987 : template <class _BidIt, class _Pr>
; 5988 : pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
; 5989 :     const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity) {
; 5990 :     // implement stable_partition of [_First, _Last] (note: closed range)
; 5991 :     // precondition: !_Pred(*_First)
; 5992 :     // precondition: _Pred(*_Last)
; 5993 :     // precondition: distance(_First, _Last) + 1 == _Count
; 5994 :     // note: _Count >= 2 and _First != _Last
; 5995 :     // returns: a pair such that first is the partition point, and second is distance(_First, partition point)
; 5996 :     using _Diff = _Iter_diff_t<_BidIt>;
; 5997 :     if (_Count - static_cast<_Diff>(1) <= _Capacity) { // - 1 since we never need to store *_Last
; 5998 :         _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr};
; 5999 :         _BidIt _Next = _First;
; 6000 :         _Backout._Emplace_back(_STD move(*_First));
; 6001 :         while (++_First != _Last) { // test each element, copying to _Temp_ptr if it's in the false range, or assigning
; 6002 :                                     // backwards if it's in the true range
; 6003 :             if (_Pred(*_First)) {
; 6004 :                 *_Next = _STD move(*_First);
; 6005 :                 ++_Next;
; 6006 :             } else {
; 6007 :                 _Backout._Emplace_back(_STD move(*_First));
; 6008 :             }
; 6009 :         }
; 6010 : 
; 6011 :         // move the last true element, *_Last, to the end of the true range
; 6012 :         *_Next = _STD move(*_Last);
; 6013 :         ++_Next;
; 6014 :         _STD _Move_unchecked(_Backout._First, _Backout._Last, _Next); // copy back the false range
; 6015 :         _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));
; 6016 :         return pair<_BidIt, _Diff>(_Next, _True_distance); // _Backout destroys elements
; 6017 :     }
; 6018 : 
; 6019 :     const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); // note: >= 1 because _Count >= 2
; 6020 :     const _BidIt _Mid       = _STD next(_First, _Mid_offset);
; 6021 : 
; 6022 :     // form [_First, _Left) true range, [_Left, _Mid) false range
; 6023 :     _BidIt _Left           = _Mid;
; 6024 :     _Diff _Left_true_count = _Mid_offset;
; 6025 :     for (;;) { // skip over the trailing false range before _Mid
; 6026 :         --_Left;
; 6027 :         if (_First == _Left) { // the entire left range is false
; 6028 :             --_Left_true_count; // to exclude *_First
; 6029 :             break;
; 6030 :         }
; 6031 : 
; 6032 :         if (_Pred(*_Left)) { // excluded the false range before _Mid, invariants reestablished, recurse
; 6033 :             const pair<_BidIt, _Diff> _Low =
; 6034 :                 _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);
; 6035 :             _Left            = _Low.first;
; 6036 :             _Left_true_count = _Low.second;
; 6037 :             break;
; 6038 :         }
; 6039 : 
; 6040 :         --_Left_true_count;
; 6041 :     }
; 6042 : 
; 6043 :     // form [_Mid, _Right) true range, [_Right, next(_Last)) false range
; 6044 :     _BidIt _Right           = _Mid;
; 6045 :     _Diff _Right_true_count = 0;
; 6046 :     for (;;) { // skip over the leading true range after and including _Mid
; 6047 :         if (_Right == _Last) { // the entire right range is true
; 6048 :             ++_Right; // to include _Last
; 6049 :             ++_Right_true_count;
; 6050 :             break;
; 6051 :         }
; 6052 : 
; 6053 :         if (!_Pred(*_Right)) { // excluded the true range after and including _Mid, invariants reestablished, recurse
; 6054 :             const _Diff _Right_count = _Count - _Mid_offset;
; 6055 :             const _Diff _Remaining   = _Right_count - _Right_true_count;
; 6056 :             const pair<_BidIt, _Diff> _High =
; 6057 :                 _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);
; 6058 :             _Right = _High.first;
; 6059 :             _Right_true_count += _High.second;
; 6060 :             break;
; 6061 :         }
; 6062 : 
; 6063 :         ++_Right;
; 6064 :         ++_Right_true_count;
; 6065 :     }
; 6066 : 
; 6067 :     // swap the [_Left, _Mid) false range with the [_Mid, _Right) true range
; 6068 :     const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
; 6069 :         static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
; 6070 :     return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));
; 6071 : }
; 6072 : 
; 6073 : template <class _BidIt, class _Pr>
; 6074 : _BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred) {
; 6075 :     // partition preserving order of equivalents
; 6076 :     for (;;) {
; 6077 :         if (_First == _Last) { // the input range is true (already partitioned)

	cmp	rdi, rdx
	jne	SHORT $LL6@stable_par
$LN54@stable_par:

; 6112 : }

	mov	rax, rdi
$LN5@stable_par:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+4208]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN55@stable_par:

; 6089 :         --_Last;

	lea	r14, QWORD PTR [rdx-8]

; 6090 :         if (_First == _Last) { // the input range is already partitioned

	cmp	rdi, r14
	je	SHORT $LN54@stable_par
$LL9@stable_par:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rax, QWORD PTR [r14]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6094 :         if (_Pred(*_Last)) { // excluded the trailing false range

	jne	SHORT $LN57@stable_par

; 6086 :     }
; 6087 : 
; 6088 :     for (;;) {
; 6089 :         --_Last;

	sub	r14, 8

; 6090 :         if (_First == _Last) { // the input range is already partitioned

	cmp	rdi, r14
	jne	SHORT $LL9@stable_par
	jmp	SHORT $LN54@stable_par
$LN57@stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rsi, r14
	sub	rsi, rdi
	sar	rsi, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6101 :     const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);

	lea	rbp, QWORD PTR [rsi+1]

; 86   :     return static_cast<ptrdiff_t>((_STD min)(static_cast<_CT>(PTRDIFF_MAX), static_cast<_CT>(_Value)));

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	cmovl	rax, rsi

; 99   :         if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { // unconditionally engage stack space

	cmp	rsi, 512				; 00000200H
	jbe	SHORT $LN67@stable_par

; 100  :             _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
; 101  :             _Capacity = static_cast<ptrdiff_t>(_Requested_size); // in bounds due to if condition
; 102  :             return;
; 103  :         }
; 104  : 
; 105  :         const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);

	mov	rsi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1562 :     if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rax, rcx
	ja	SHORT $LN34@stable_par

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	test	rax, rax
	jle	SHORT $LN34@stable_par
	npad	7
$LL35@stable_par:

; 1564 :             const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);

	lea	rcx, QWORD PTR [rsi*8]

; 1565 :             void* _Pbuf;
; 1566 : #ifdef __cpp_aligned_new
; 1567 :             if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 1568 :                 _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
; 1569 :             } else
; 1570 : #endif // __cpp_aligned_new
; 1571 :             {
; 1572 :                 _Pbuf = ::operator new(_Size, nothrow);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new

; 1573 :             }
; 1574 : 
; 1575 :             if (_Pbuf) {

	test	rax, rax
	jne	SHORT $LN58@stable_par

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	shr	rsi, 1
	jne	SHORT $LL35@stable_par
$LN34@stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	eax, eax
$LN26@stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, rax
	call	??3@YAXPEAX@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 115  :         _Capacity = _Optimistic_count;

	mov	esi, 512				; 00000200H
$LN67@stable_par:

; 6102 :     _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};

	lea	rax, QWORD PTR _Temp_buf$3[rsp+16]
$LN68@stable_par:
	mov	QWORD PTR _Temp_buf$3[rsp], rax
	mov	QWORD PTR _Temp_buf$3[rsp+8], rsi

; 6103 :     return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;

	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbp
	mov	r9, rbx
	mov	r8, r14
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
	mov	rbx, QWORD PTR [rax]

; 122  :         if (static_cast<size_t>(_Capacity) > _Optimistic_count) {

	cmp	QWORD PTR _Temp_buf$3[rsp+8], 512	; 00000200H
	jbe	SHORT $LN49@stable_par
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, QWORD PTR _Temp_buf$3[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN49@stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6111 :     return _First;

	mov	rax, rbx

; 6103 :     return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;

	jmp	$LN5@stable_par
$LN58@stable_par:

; 106  :         if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { // engage heap space

	cmp	rsi, 512				; 00000200H
	jbe	SHORT $LN26@stable_par

; 107  :             _Data     = _Raw.first;
; 108  :             _Capacity = _Raw.second;
; 109  :             return;

	jmp	SHORT $LN68@stable_par
??$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ENDP ; std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
_Temp_buf$3 = 80
__$ArrayPad$ = 4192
_First$ = 4240
_Last$ = 4248
_Pred$ = 4256
?dtor$0@?0???$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z@4HA PROC ; `std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Temp_buf$3[rdx]
	jmp	??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ ; std::_Optimistic_temporary_buffer<unsigned __int64>::~_Optimistic_temporary_buffer<unsigned __int64>
?dtor$0@?0???$stable_partition@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z@4HA ENDP ; `std::stable_partition<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEA_K@std@@YA?A_TAEAPEA_K@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEA_K@std@@YA?A_TAEAPEA_K@Z PROC	; std::_Get_unwrapped<unsigned __int64 * &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEAPEA_K@std@@YA?A_TAEAPEA_K@Z ENDP	; std::_Get_unwrapped<unsigned __int64 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Pass_fn@V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Func$ = 16
??$_Pass_fn@V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z PROC ; std::_Pass_fn<`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >, COMDAT

; 556  :     constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
; 557  :         is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
; 558  :     if constexpr (_Pass_by_value) {
; 559  :         return _Func;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 560  :     } else {
; 561  :         return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
; 562  :     }
; 563  : }

	ret	0
??$_Pass_fn@V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?A_PAEAV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ENDP ; std::_Pass_fn<`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$make_pair@AEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@std@@YA?AU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Val1$ = 16
_Val2$ = 24
??$make_pair@AEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@std@@YA?AU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::make_pair<bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movups	xmm0, XMMWORD PTR [rdx]

; 560  :     // return pair composed from arguments
; 561  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 562  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

	mov	rax, rcx

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm1

; 563  : }

	ret	0
??$make_pair@AEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@std@@YA?AU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::make_pair<bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??$make_optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@std@@YA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Value$ = 16
??$make_optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@std@@YA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@@Z PROC ; std::make_optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>, COMDAT

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [rdx]
	mov	BYTE PTR [rcx+64], 1

; 958  :     return optional<decay_t<_Ty>>{_STD forward<_Ty>(_Value)};

	mov	rax, rcx

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm1

; 959  : }

	ret	0
??$make_optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@std@@YA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@@Z ENDP ; std::make_optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YA$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YA$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z PROC ; std::forward<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YA$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z ENDP ; std::forward<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z PROC ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>, COMDAT

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [rdx]

; 249  :         : _Mybase(in_place, _STD forward<_Ty2>(_Right)) {}

	mov	rax, rcx

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	mov	BYTE PTR [rcx+64], 1
	movups	XMMWORD PTR [rcx+48], xmm1

; 249  :         : _Mybase(in_place, _STD forward<_Ty2>(_Right)) {}

	ret	0
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$0A@@?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ENDP ; std::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::optional<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z PROC	; bvh::min<float,3>, COMDAT

; 112  : Vector<Scalar, N> min(const Vector<Scalar, N>& a, const Vector<Scalar, N>& b) {

$LN26:
	sub	rsp, 40					; 00000028H

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rdx]
	mov	rax, rcx
	movsd	xmm0, QWORD PTR [r8]
	movss	xmm1, DWORD PTR [r8+4]
	minss	xmm0, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	minss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm1, DWORD PTR [r8+8]
	minss	xmm1, DWORD PTR [rdx+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+8], xmm1

; 114  : }

	add	rsp, 40					; 00000028H
	ret	0
??$min@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ENDP	; bvh::min<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z PROC ; `bvh::min<float,3>'::`2'::<lambda_1>::operator(), COMDAT

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rcx+rdx*4+12]
	minss	xmm0, DWORD PTR [rcx+rdx*4]
	ret	0
??R<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ENDP ; `bvh::min<float,3>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__b$ = 24
??0<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z PROC ; `bvh::min<float,3>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ENDP ; `bvh::min<float,3>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z PROC	; bvh::max<float,3>, COMDAT

; 118  : Vector<Scalar, N> max(const Vector<Scalar, N>& a, const Vector<Scalar, N>& b) {

$LN26:
	sub	rsp, 40					; 00000028H

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movsd	xmm3, QWORD PTR [rdx]
	mov	rax, rcx
	movsd	xmm0, QWORD PTR [r8]
	movss	xmm1, DWORD PTR [r8+4]
	maxss	xmm0, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	maxss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm1, DWORD PTR [r8+8]
	maxss	xmm1, DWORD PTR [rdx+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+8], xmm1

; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
??$max@M$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ENDP	; bvh::max<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z PROC ; `bvh::max<float,3>'::`2'::<lambda_1>::operator(), COMDAT

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rcx+rdx*4+12]
	maxss	xmm0, DWORD PTR [rcx+rdx*4]
	ret	0
??R<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ENDP ; `bvh::max<float,3>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__b$ = 24
??0<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z PROC ; `bvh::max<float,3>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ENDP ; `bvh::max<float,3>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z PROC ; std::addressof<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@YAPEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocator<bvh::TopDownBuildTask::WorkItem *><bvh::TopDownBuildTask::WorkItem>, COMDAT

; 962  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0UWorkItem@TopDownBuildTask@bvh@@@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@AEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@@Z ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocator<bvh::TopDownBuildTask::WorkItem *><bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_Destroy_in_place<bvh::TopDownBuildTask::WorkItem *>, COMDAT

; 305  :     if constexpr (is_array_v<_Ty>) {
; 306  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 307  :     } else {
; 308  :         _Obj.~_Ty();
; 309  :     }
; 310  : }

	ret	0
??$_Destroy_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_Destroy_in_place<bvh::TopDownBuildTask::WorkItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@PEAU123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@PEAU123@@Z PROC ; std::_Unfancy<bvh::TopDownBuildTask::WorkItem>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@PEAU123@@Z ENDP ; std::_Unfancy<bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@UWorkItem@TopDownBuildTask@bvh@@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@UWorkItem@TopDownBuildTask@bvh@@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::destroy<bvh::TopDownBuildTask::WorkItem>, COMDAT

; 725  : #if _HAS_CXX20
; 726  :         _STD destroy_at(_Ptr);
; 727  : #else // _HAS_CXX20
; 728  :         _Ptr->~_Uty();
; 729  : #endif // _HAS_CXX20
; 730  :     }

	ret	0
??$destroy@UWorkItem@TopDownBuildTask@bvh@@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::destroy<bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem const &>, COMDAT

; 1148 :     void _Emplace_back_internal(_Tys&&... _Vals) {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
	mov	rsi, rdx
	inc	rax
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@Emplace_ba

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN2@Emplace_ba:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	r8, QWORD PTR [rbx+16]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	add	rdx, QWORD PTR [rbx+32]

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	mov	rax, QWORD PTR [rbx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rdx, r8

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rdx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN3@Emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN3@Emplace_ba:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1163 :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 1163 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back_internal@AEBUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEBUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@YAPEAV?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
b$ = 64
??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z PROC	; bvh::operator-<float,3>, COMDAT

; 100  : Vector<Scalar, N> operator - (const Vector<Scalar, N>& a, const Vector<Scalar, N>& b) {

$LN24:
	sub	rsp, 40					; 00000028H

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm3, QWORD PTR [r8]
	mov	rax, rcx
	movsd	xmm0, QWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm0, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm1, DWORD PTR [rdx+8]
	subss	xmm1, DWORD PTR [r8+8]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+8], xmm1

; 102  : }

	add	rsp, 40					; 00000028H
	ret	0
??$?GM$02@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ENDP	; bvh::operator-<float,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z PROC ; `bvh::operator-<float,3>'::`2'::<lambda_1>::operator(), COMDAT

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm0, DWORD PTR [rcx+rdx*4]
	subss	xmm0, DWORD PTR [rcx+rdx*4+12]
	ret	0
??R<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ENDP ; `bvh::operator-<float,3>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__b$ = 24
??0<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z PROC ; `bvh::operator-<float,3>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ENDP ; `bvh::operator-<float,3>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0MAEA_K$0A@@?$pair@M_K@std@@QEAA@$$QEAMAEA_K@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0MAEA_K$0A@@?$pair@M_K@std@@QEAA@$$QEAMAEA_K@Z PROC	; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64 &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0MAEA_K$0A@@?$pair@M_K@std@@QEAA@$$QEAMAEA_K@Z ENDP	; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float,unsigned __int64 &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$make_pair@AEAM_K@std@@YA?AU?$pair@M_K@0@AEAM$$QEA_K@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Val1$ = 16
_Val2$ = 24
??$make_pair@AEAM_K@std@@YA?AU?$pair@M_K@0@AEAM$$QEA_K@Z PROC ; std::make_pair<float &,unsigned __int64>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 560  :     // return pair composed from arguments
; 561  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 562  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

	mov	rax, rcx

; 563  : }

	ret	0
??$make_pair@AEAM_K@std@@YA?AU?$pair@M_K@0@AEAM$$QEA_K@Z ENDP ; std::make_pair<float &,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$fill@PEAMM@std@@YAXQEAM0AEBM@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$fill@PEAMM@std@@YAXQEAM0AEBM@Z PROC			; std::fill<float *,float>, COMDAT

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

$LN27:
	sub	rsp, 40					; 00000028H
	xorps	xmm0, xmm0
	mov	r10, rdx

; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	movd	eax, xmm0
	sub	rdx, rcx

; 5032 : _CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {

	mov	r9, rcx

; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [r8], eax
	jne	SHORT $LN6@fill

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	and	rdx, -4
	mov	r8, rdx
	xor	edx, edx

; 5057 :         }
; 5058 :     }
; 5059 : }

	add	rsp, 40					; 00000028H

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	jmp	memset
$LN6@fill:

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	add	rdx, 3
	xor	eax, eax
	shr	rdx, 2
	cmp	r9, r10
	cmova	rdx, rax
	test	rdx, rdx
	je	SHORT $LN15@fill
	cmp	rdx, 4
	jb	SHORT $LN15@fill

; 5056 :             *_UFirst = _Val;

	movss	xmm0, DWORD PTR [r8]
	lea	rax, QWORD PTR [rcx-4]
	lea	rax, QWORD PTR [rax+rdx*4]
	cmp	r9, r8
	ja	SHORT $LN16@fill

; 5033 :     // copy _Val through [_First, _Last)
; 5034 :     _Adl_verify_range(_First, _Last);
; 5035 :     if constexpr (_Is_vb_iterator<_FwdIt, true>) {
; 5036 :         _Fill_vbool(_First, _Last, _Val);
; 5037 :     } else {
; 5038 :         auto _UFirst      = _Get_unwrapped(_First);
; 5039 :         const auto _ULast = _Get_unwrapped(_Last);
; 5040 : #if _HAS_CXX20
; 5041 :         if (!_STD is_constant_evaluated())
; 5042 : #endif // _HAS_CXX20
; 5043 :         {
; 5044 :             if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5045 :                 _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
; 5046 :                 return;
; 5047 :             } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
; 5048 :                 if (_Is_all_bits_zero(_Val)) {
; 5049 :                     _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
; 5050 :                     return;
; 5051 :                 }
; 5052 :             }
; 5053 :         }
; 5054 : 
; 5055 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r8
	jae	SHORT $LN15@fill
$LN16@fill:
	mov	QWORD PTR [rsp+32], rdi
	and	rdx, -4
	movd	eax, xmm0
	mov	rdi, r9
	cdqe
	lea	rdx, QWORD PTR [rdx*4]
	mov	rcx, rdx
	shr	rcx, 2
	rep stosd
	add	r9, rdx
	mov	rdi, QWORD PTR [rsp+32]
$LN15@fill:
	cmp	r9, r10
	je	SHORT $LN3@fill
	npad	2
$LL14@fill:

; 5056 :             *_UFirst = _Val;

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [r9], eax
	add	r9, 4
	cmp	r9, r10
	jne	SHORT $LL14@fill
$LN3@fill:

; 5057 :         }
; 5058 :     }
; 5059 : }

	add	rsp, 40					; 00000028H
	ret	0
??$fill@PEAMM@std@@YAXQEAM0AEBM@Z ENDP			; std::fill<float *,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::~_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::~_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAA@PEAUNode@?$Bvh@M@bvh@@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 16
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--, COMDAT

; 67   :         --_Myoff;

	dec	QWORD PTR [rcx+8]

; 187  :         _Mybase::operator--();
; 188  :         return *this;

	mov	rax, rcx

; 189  :     }

	ret	0
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$dead$ = 88
?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap, COMDAT

; 1545 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

$LN189:
	push	rbp
	push	rsi
	sub	rsp, 56					; 00000038H

; 1546 :         static_assert(_Minimum_map_size > 1, "The _Xlen() test should always be performed.");
; 1547 : 
; 1548 :         _Alpty _Almap(_Getal());
; 1549 :         size_type _Newsize = _Mapsize() > 0 ? _Mapsize() : 1;

	mov	rdx, QWORD PTR [rcx+16]
	mov	eax, 1
	test	rdx, rdx
	mov	rbp, rcx
	mov	r8, 576460752303423487			; 07ffffffffffffffH
	cmovne	rax, rdx
$LL2@Growmap:

; 1550 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _Minimum_map_size) {

	mov	rsi, rax
	sub	rsi, rdx
	cmp	rsi, 1
	jb	SHORT $LN4@Growmap
	cmp	rax, 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1551 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1552 :             if (max_size() / _Block_size - _Newsize < _Newsize) {

	mov	rcx, r8
	sub	rcx, rax
	cmp	rcx, rax
	jb	$LN149@Growmap

; 1554 :             }
; 1555 : 
; 1556 :             _Newsize *= 2;

	add	rax, rax

; 1557 :         }

	jmp	SHORT $LL2@Growmap
$LN3@Growmap:
	mov	QWORD PTR [rsp+48], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1560 :         size_type _Myboff = _Myoff() / _Block_size;

	mov	r12, QWORD PTR [rbp+24]
	mov	QWORD PTR [rsp+40], r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

	cmp	rax, rcx
	ja	$LN169@Growmap

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rax*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN20@Growmap

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN169@Growmap

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN133@Growmap

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	r14, QWORD PTR [rax+39]
	and	r14, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r14-8], rax

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN18@Growmap
$LN20@Growmap:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN21@Growmap

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax

; 245  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN18@Growmap
$LN21@Growmap:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

	xor	r14d, r14d
$LN18@Growmap:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1564 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

	mov	rcx, QWORD PTR [rbp+8]
	mov	rax, QWORD PTR [rbp+16]
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [r12*8]
	lea	rbx, QWORD PTR [rcx+rax*8]
	lea	rdx, QWORD PTR [rcx+r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1562 :         _Mapptr _Myptr    = _Newmap + _Myboff;

	lea	rdi, QWORD PTR [r15+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1902 :             return _Copy_memmove(_First, _Last, _Dest);

	mov	rdx, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	add	rbx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1565 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

	mov	rcx, rbx
	cmp	r12, rsi
	ja	SHORT $LN6@Growmap
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, r15
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rcx, QWORD PTR [r15+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	sub	r8, r12
	xor	edx, edx
	shl	r8, 3
	call	memset
	mov	r8, r15
	mov	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1569 :         } else { // increment not greater than offset of initial block

	jmp	SHORT $LN186@Growmap
$LN6@Growmap:

; 1570 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

	lea	rdi, QWORD PTR [rsi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1571 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

	mov	rax, QWORD PTR [rbp+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r14
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1571 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

	lea	rbx, QWORD PTR [rax+r15]
	lea	rdx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove

; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rcx, QWORD PTR [rbx+r14]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdi
$LN186@Growmap:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1575 :         if (_Map() != nullptr) {

	xor	edx, edx
	call	memset
	mov	rcx, QWORD PTR [rbp+8]
	mov	r15, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+88]
	test	rcx, rcx
	je	SHORT $LN124@Growmap
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR [rbp+16]
	shl	rdx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN136@Growmap

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN133@Growmap

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN136@Growmap:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN124@Growmap:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1581 :         _Mapsize() += _Count;

	add	QWORD PTR [rbp+16], rsi
	mov	r12, QWORD PTR [rsp+48]
	mov	QWORD PTR [rbp+8], r14
	mov	r14, QWORD PTR [rsp+40]

; 1582 :     }

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbp
	ret	0
$LN133@Growmap:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN169@Growmap:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN149@Growmap:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1553 :                 _Xlen(); // result too long

	call	?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Xlen
	int	3
$LN185@Growmap:
?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1219 :     _Container_proxy* _Myproxy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 559  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	rax, rcx
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocate, COMDAT

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocator<bvh::TopDownBuildTask::WorkItem>, COMDAT

; 958  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem>::allocator<bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@CAXXZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	rbx, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rbp, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rsi], rbp

; 2030 :         _Mylast  = _Newvec + _Newsize;

	shl	rdi, 5
	add	rdi, rbp

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	shl	rbx, 5
	add	rbx, rbp
	mov	QWORD PTR [rsi+8], rdi

; 2033 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+16], rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEAAXQEAUNode@?$Bvh@M@bvh@@_K1@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 5

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z PROC ; std::allocator<bvh::Bvh<float>::Node>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rdx, 5

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN10@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@UNode@?$Bvh@M@bvh@@@std@@QEAAPEAUNode@?$Bvh@M@bvh@@_K@Z ENDP ; std::allocator<bvh::Bvh<float>::Node>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAXPEAU?$Triangle@M$00$0A@@bvh@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAXPEAU?$Triangle@M$00$0A@@bvh@@0@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Orphan_range, COMDAT

; 2177 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAXPEAU?$Triangle@M$00$0A@@bvh@@0@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Xlength, COMDAT

; 2137 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2138 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@CAXXZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Change_array, COMDAT

; 2013 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2014 :         // orphan all iterators, discard old array, acquire new array
; 2015 :         auto& _Al         = _Getal();
; 2016 :         auto& _My_data    = _Mypair._Myval2;
; 2017 :         pointer& _Myfirst = _My_data._Myfirst;
; 2018 :         pointer& _Mylast  = _My_data._Mylast;
; 2019 :         pointer& _Myend   = _My_data._Myend;
; 2020 : 
; 2021 :         _My_data._Orphan_all();
; 2022 : 
; 2023 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	r14, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx+16]
	mov	rdx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	rax, rcx
	sar	rax, 4
	imul	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 4

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@Change_arr

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@Change_arr

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@Change_arr:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2029 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rdi

; 2030 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	shl	rax, 4
	add	rax, rdi
	mov	QWORD PTR [rbx+8], rax

; 2031 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]

; 2033 :     }

	mov	rsi, QWORD PTR [rsp+64]
	shl	rax, 4
	add	rax, rdi
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@Change_arr:
?_Change_array@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEAAXQEAU?$Triangle@M$00$0A@@bvh@@_K1@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Calculate_growth, COMDAT

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 4
	imul	r8, rax

; 1962 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1963 :         const size_type _Oldcapacity = capacity();
; 1964 :         const auto _Max              = max_size();
; 1965 : 
; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 384307168202282325			; 0555555555555555H
	mov	r9, r8
	mov	rcx, rax
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1967 :             return _Max; // geometric growth would overflow
; 1968 :         }
; 1969 : 
; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1971 : 
; 1972 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1973 :             return _Newsize; // geometric growth would be insufficient
; 1974 :         }
; 1975 : 
; 1976 :         return _Geometric; // geometric growth is sufficient
; 1977 :     }

	ret	0
?_Calculate_growth@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?max_size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::max_size, COMDAT

; 1873 :         return (_STD min)(

	mov	rax, 384307168202282325			; 0555555555555555H

; 1874 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1875 :     }

	ret	0
?max_size@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z PROC ; std::allocator<bvh::Triangle<float,1,0> >::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 384307168202282325			; 0555555555555555H
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx+rdx*2]
	shl	rcx, 4

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@_K@Z ENDP ; std::allocator<bvh::Triangle<float,1,0> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--, COMDAT

; 67   :         --_Myoff;

	dec	QWORD PTR [rcx+8]

; 68   :         return *this;

	mov	rax, rcx

; 69   :     }

	ret	0
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Xlen, COMDAT

; 1537 :     [[noreturn]] void _Xlen() const {

$LN4:
	sub	rsp, 40					; 00000028H

; 1538 :         _Xlength_error("deque<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAXXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?max_size@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size, COMDAT

; 1040 :         return (_STD min)(

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1041 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1042 :     }

	ret	0
?max_size@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z PROC ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocate, COMDAT

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN32:
	sub	rsp, 40					; 00000028H

; 70   :         if (_Count > _Max_possible) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN28@allocate

; 71   :             _Throw_bad_array_new_length(); // multiply overflow
; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*8]

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN9@allocate

; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 140  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN28@allocate

; 87   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN18@allocate

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@allocate:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 244  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN10@allocate

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H

; 87   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN10@allocate:

; 248  :     return nullptr;

	xor	eax, eax

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 975  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:

; 141  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN30@allocate:
?allocate@?$allocator@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@Z ENDP ; std::allocator<bvh::TopDownBuildTask::WorkItem *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@AEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1880 :     }

	ret	0
?capacity@?$vector@UNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<bvh::Bvh<float>::Node,std::allocator<bvh::Bvh<float>::Node> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SA_KAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SA_KAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SA_KAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal, COMDAT

; 2185 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2186 :     }

	ret	0
?_Getal@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@AEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?capacity@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ PROC ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::capacity, COMDAT

; 1878 :         auto& _My_data = _Mypair._Myval2;
; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	mov	rcx, -6148914691236517205		; aaaaaaaaaaaaaaabH
	sar	rax, 4
	imul	rax, rcx

; 1880 :     }

	ret	0
?capacity@?$vector@U?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<bvh::Triangle<float,1,0>,std::allocator<bvh::Triangle<float,1,0> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SA_KAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SA_KAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 384307168202282325			; 0555555555555555H

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SA_KAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal, COMDAT

; 1641 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1642 :     }

	ret	0
?_Getal@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SA_KAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SA_KAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size, COMDAT

; 733  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 734  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SA_KAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@UNode@?$Bvh@M@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UNode@?$Bvh@M@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::Bvh<float>::Node>,std::_Vector_val<std::_Simple_types<bvh::Bvh<float>::Node> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@V?$_Vector_val@U?$_Simple_types@U?$Triangle@M$00$0A@@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$Triangle@M$00$0A@@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::Triangle<float,1,0> >,std::_Vector_val<std::_Simple_types<bvh::Triangle<float,1,0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first, COMDAT

; 1527 :         return *this;

	mov	rax, rcx

; 1528 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@V?$_Deque_val@U?$_Deque_simple_types@UWorkItem@TopDownBuildTask@bvh@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<bvh::TopDownBuildTask::WorkItem>,std::_Deque_val<std::_Deque_simple_types<bvh::TopDownBuildTask::WorkItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@0@Z PROC ; std::exchange<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node * &>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@0@Z ENDP ; std::exchange<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEA_KAEAPEA_K@std@@YAPEA_KAEAPEA_K0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEA_KAEAPEA_K@std@@YAPEA_KAEAPEA_K0@Z PROC	; std::exchange<unsigned __int64 *,unsigned __int64 * &>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEA_KAEAPEA_K@std@@YAPEA_KAEAPEA_K0@Z ENDP	; std::exchange<unsigned __int64 *,unsigned __int64 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEA_K@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEA_K@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEA_K@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEA_K@Z PROC ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><unsigned __int64 * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEA_K@?$_Compressed_pair@U?$default_delete@$$BY0A@_K@std@@PEA_K$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEA_K@Z ENDP ; std::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1>::_Compressed_pair<std::default_delete<unsigned __int64 [0]>,unsigned __int64 *,1><unsigned __int64 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$set@MM@?$VectorSetter@$0A@M$02@bvh@@SAXAEAU?$Vector@M$02@1@MMM@Z
_TEXT	SEGMENT
v$ = 8
s$ = 16
<args_0>$ = 24
<args_1>$ = 32
??$set@MM@?$VectorSetter@$0A@M$02@bvh@@SAXAEAU?$Vector@M$02@1@MMM@Z PROC ; bvh::VectorSetter<0,float,3>::set<float,float>, COMDAT

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR [rcx+8], xmm3

; 24   :     }

	ret	0
??$set@MM@?$VectorSetter@$0A@M$02@bvh@@SAXAEAU?$Vector@M$02@1@MMM@Z ENDP ; bvh::VectorSetter<0,float,3>::set<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z PROC ; std::_Unfancy<bvh::Triangle<float,1,0> >, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@Z ENDP ; std::_Unfancy<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
$T3 = 0
__formal$dead$ = 96
_Ptr$ = 104
<_Args_0>$ = 112
<_Args_1>$ = 120
<_Args_2>$ = 128
??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN97:
	sub	rsp, 88					; 00000058H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 35   :         : p0(p0), e1(p0 - p1), e2(p2 - p0)

	movsd	xmm0, QWORD PTR [r8]
	movsd	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [r8]
	movsd	xmm3, QWORD PTR [r9]
	movaps	xmm0, xmm2
	mov	ecx, DWORD PTR [r8+8]
	subss	xmm0, xmm3
	mov	eax, DWORD PTR [r9+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movaps	XMMWORD PTR [rsp+64], xmm6
	movsd	QWORD PTR $T3[rsp], xmm2

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+12], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	movd	xmm0, eax
	mov	rax, QWORD PTR <_Args_2>$[rsp]
	movsd	QWORD PTR $T3[rsp+12], xmm3
	movaps	XMMWORD PTR [rsp+32], xmm8

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+16], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, ecx
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+20], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [rax]
	movsd	xmm3, QWORD PTR [r8]
	movaps	xmm0, xmm2
	mov	ecx, DWORD PTR [rax+8]
	subss	xmm0, xmm3
	mov	eax, DWORD PTR [r8+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movsd	QWORD PTR $T2[rsp], xmm2
	movsd	QWORD PTR $T2[rsp+12], xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+24], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movd	xmm0, eax

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+28], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, ecx
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rdx+32], xmm1

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm4, xmm1

; 166  :     });

	movsd	xmm0, QWORD PTR [rdx+12]
	movsd	xmm2, QWORD PTR [rdx+24]

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm7, xmm0
	movss	xmm1, DWORD PTR [rdx+20]
	movaps	xmm5, xmm2

; 166  :     });

	movsd	QWORD PTR $T1[rsp], xmm0

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm0, xmm1
	movss	xmm6, DWORD PTR $T1[rsp]
	shufps	xmm7, xmm7, 85				; 00000055H
	movaps	xmm8, xmm7
	shufps	xmm5, xmm5, 85				; 00000055H
	mulss	xmm0, xmm5
	mulss	xmm8, xmm4

; 166  :     });

	movsd	QWORD PTR $T1[rsp+12], xmm2

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm2, DWORD PTR $T1[rsp+12]
	subss	xmm8, xmm0
	movaps	xmm3, xmm2
	movaps	xmm0, xmm6
	mulss	xmm2, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	movaps	xmm7, XMMWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 165  :         return a[j] * b[k] - a[k] * b[j];

	mulss	xmm0, xmm4
	mulss	xmm6, xmm5
	mulss	xmm3, xmm1
	subss	xmm6, xmm2
	subss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 37   :         n = LeftHandedNormal ? cross(e1, e2) : cross(e2, e1);

	movaps	xmm0, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	movaps	xmm8, XMMWORD PTR [rsp+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 37   :         n = LeftHandedNormal ? cross(e1, e2) : cross(e2, e1);

	unpcklps xmm0, xmm3
	movsd	QWORD PTR [rdx+36], xmm0
	movss	DWORD PTR [rdx+44], xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
??$construct@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU?$Vector@M$02@4@22@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_TAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_TAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z PROC ; std::_Get_unwrapped<bvh::Triangle<float,1,0> * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_TAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z ENDP ; std::_Get_unwrapped<bvh::Triangle<float,1,0> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z PROC ; std::_Uninitialized_move<bvh::Triangle<float,1,0> *,std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rbx

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	sar	rdx, 3
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 4
	add	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAU?$Triangle@M$00$0A@@bvh@@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@0PEAU12@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@0@@Z ENDP ; std::_Uninitialized_move<bvh::Triangle<float,1,0> *,std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAU?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@PEAU?$BoundingBox@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAU?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@PEAU?$BoundingBox@M@bvh@@@Z PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><bvh::BoundingBox<float> *,std::default_delete<bvh::BoundingBox<float> [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAU?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@PEAU?$BoundingBox@M@bvh@@@Z ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><bvh::BoundingBox<float> *,std::default_delete<bvh::BoundingBox<float> [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0PEAU?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@PEAU?$Vector@M$02@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$?0PEAU?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@PEAU?$Vector@M$02@bvh@@@Z PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><bvh::Vector<float,3> *,std::default_delete<bvh::Vector<float,3> [0]>,0,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3359 :     _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

	mov	rax, rcx
	ret	0
??$?0PEAU?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@PEAU?$Vector@M$02@bvh@@@Z ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><bvh::Vector<float,3> *,std::default_delete<bvh::Vector<float,3> [0]>,0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@$0A@@?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@1@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@$0A@@?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@1@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@@Z PROC ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > ><std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >,0>, COMDAT

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r9d, r9d
	mov	QWORD PTR [rdx], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r8]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8], r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@$0A@@?$pair@V?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@V?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@2@@std@@QEAA@$$QEAV?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@1@$$QEAV?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@1@@Z ENDP ; std::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > >::pair<std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> > ><std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >,std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUNode@?$Bvh@M@bvh@@@std@@YA?A_TAEBQEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUNode@?$Bvh@M@bvh@@@std@@YA?A_TAEBQEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::_Get_unwrapped<bvh::Bvh<float>::Node * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAUNode@?$Bvh@M@bvh@@@std@@YA?A_TAEBQEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::_Get_unwrapped<bvh::Bvh<float>::Node * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z PROC ; std::_Uninitialized_move<bvh::Bvh<float>::Node *,std::allocator<bvh::Bvh<float>::Node> >, COMDAT

; 1927 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN27:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1940 :             return _Dest + (_ULast - _UFirst);

	and	rbx, -32				; ffffffffffffffe0H
	lea	rax, QWORD PTR [rdi+rbx]

; 1941 :         }
; 1942 :     }
; 1943 : 
; 1944 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1945 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1946 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1947 :     }
; 1948 : 
; 1949 :     return _Backout._Release();
; 1950 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAUNode@?$Bvh@M@bvh@@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@0PEAU123@AEAV?$allocator@UNode@?$Bvh@M@bvh@@@0@@Z ENDP ; std::_Uninitialized_move<bvh::Bvh<float>::Node *,std::allocator<bvh::Bvh<float>::Node> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rax], xmm0
	movups	XMMWORD PTR [rax+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 32			; 00000020H

; 1804 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAUNode@?$Bvh@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAUNode@?$Bvh@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1><bvh::Bvh<float>::Node * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAUNode@?$Bvh@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@UNode@?$Bvh@M@bvh@@@std@@PEAUNode@?$Bvh@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1>::_Compressed_pair<std::default_delete<bvh::Bvh<float>::Node [0]>,bvh::Bvh<float>::Node *,1><bvh::Bvh<float>::Node * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAM@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAM@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAM@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAM@Z PROC ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Compressed_pair<std::default_delete<float [0]>,float *,1><float * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAM@?$_Compressed_pair@U?$default_delete@$$BY0A@M@std@@PEAM$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAM@Z ENDP ; std::_Compressed_pair<std::default_delete<float [0]>,float *,1>::_Compressed_pair<std::default_delete<float [0]>,float *,1><float * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAI@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAI@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAI@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAI@Z PROC ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1><unsigned int * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAI@?$_Compressed_pair@U?$default_delete@$$BY0A@I@std@@PEAI$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAI@Z ENDP ; std::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1>::_Compressed_pair<std::default_delete<unsigned int [0]>,unsigned int *,1><unsigned int * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAE@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAE@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAE@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAE@Z PROC ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1><unsigned char * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAE@?$_Compressed_pair@U?$default_delete@$$BY0A@E@std@@PEAE$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAE@Z ENDP ; std::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1>::_Compressed_pair<std::default_delete<unsigned char [0]>,unsigned char *,1><unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEA_KPEA_K@std@@YAXAEBQEA_K0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEA_KPEA_K@std@@YAXAEBQEA_K0@Z PROC ; std::_Adl_verify_range<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEA_KPEA_K@std@@YAXAEBQEA_K0@Z ENDP ; std::_Adl_verify_range<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z PROC		; std::_Is_all_bits_zero<int>, COMDAT

; 5021 :     // checks if scalar type has all bits set to zero
; 5022 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 5023 :     if constexpr (is_same_v<_Ty, nullptr_t>) {
; 5024 :         return true;
; 5025 :     } else {
; 5026 :         constexpr _Ty _Zero{};
; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [rcx], 0
	sete	al

; 5028 :     }
; 5029 : }

	ret	0
??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z ENDP		; std::_Is_all_bits_zero<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Fill_zero_memset@PEA_K@std@@YAXPEA_K_K@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
??$_Fill_zero_memset@PEA_K@std@@YAXPEA_K_K@Z PROC	; std::_Fill_zero_memset<unsigned __int64 *>, COMDAT

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	lea	r8, QWORD PTR [rdx*8]
	xor	edx, edx
	jmp	memset
??$_Fill_zero_memset@PEA_K@std@@YAXPEA_K_K@Z ENDP	; std::_Fill_zero_memset<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEIAI@std@@YA$$QEAPEIAIAEAPEIAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEIAI@std@@YA$$QEAPEIAIAEAPEIAI@Z PROC	; std::move<unsigned int * __restrict &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEIAI@std@@YA$$QEAPEIAIAEAPEIAI@Z ENDP	; std::move<unsigned int * __restrict &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAPEIA_K@std@@YA$$QEAPEIA_KAEAPEIA_K@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEIA_K@std@@YA$$QEAPEIA_KAEAPEIA_K@Z PROC	; std::move<unsigned __int64 * __restrict &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAPEIA_K@std@@YA$$QEAPEIA_KAEAPEIA_K@Z ENDP	; std::move<unsigned __int64 * __restrict &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@$$QEAH2AEA_K2@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
<_Args_1>$ = 32
<_Args_2>$ = 40
<_Args_3>$ = 48
??$construct@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@$$QEAH2AEA_K2@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movsxd	rcx, DWORD PTR [r9]
	mov	rax, QWORD PTR <_Args_3>$[rsp]
	movsxd	r11, DWORD PTR [rax]
	mov	rax, QWORD PTR <_Args_2>$[rsp]
	mov	r10, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+24], r11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@$$QEAH2AEA_K2@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z PROC ; std::move<bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z ENDP ; std::move<bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z PROC ; std::forward<bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAUWorkItem@TopDownBuildTask@bvh@@AEAU123@@Z ENDP ; std::forward<bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque
;	COMDAT ??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem &>, COMDAT

; 1148 :     void _Emplace_back_internal(_Tys&&... _Vals) {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1149 :         if ((_Myoff() + _Mysize()) % _Block_size == 0 && _Mapsize() <= (_Mysize() + _Block_size) / _Block_size) {

	mov	rax, QWORD PTR [rcx+32]
	mov	rsi, rdx
	inc	rax
	mov	rbx, rcx
	cmp	QWORD PTR [rcx+16], rax
	ja	SHORT $LN2@Emplace_ba

; 1150 :             _Growmap(1);

	call	?_Growmap@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAX_K@Z ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Growmap
$LN2@Emplace_ba:

; 1151 :         }
; 1152 :         _Myoff() &= _Mapsize() * _Block_size - 1;

	mov	r8, QWORD PTR [rbx+16]
	dec	r8
	and	QWORD PTR [rbx+24], r8
	mov	rdx, QWORD PTR [rbx+24]

; 1153 :         size_type _Newoff = _Myoff() + _Mysize();

	add	rdx, QWORD PTR [rbx+32]

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	mov	rax, QWORD PTR [rbx+8]

; 563  :         return (_Off / _Block_size) & (_Mapsize - 1);

	and	rdx, r8

; 1154 :         size_type _Block  = _Getblock(_Newoff);
; 1155 :         if (_Map()[_Block] == nullptr) {

	lea	rdi, QWORD PTR [rdx*8]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN3@Emplace_ba
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1156 :             _Map()[_Block] = _Getal().allocate(_Block_size);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rdi+rcx], rax
$LN3@Emplace_ba:

; 1159 :         _Alty_traits::construct(

	mov	rax, QWORD PTR [rbx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1159 :         _Alty_traits::construct(

	mov	rcx, QWORD PTR [rdi+rax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rsi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1163 :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rcx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\deque

; 1162 :         ++_Mysize();

	inc	QWORD PTR [rbx+32]

; 1163 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Emplace_back_internal@AEAUWorkItem@TopDownBuildTask@bvh@@@?$deque@UWorkItem@TopDownBuildTask@bvh@@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@AEAAXAEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::deque<bvh::TopDownBuildTask::WorkItem,std::allocator<bvh::TopDownBuildTask::WorkItem> >::_Emplace_back_internal<bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1119 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 16
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z
_TEXT	SEGMENT
$T2 = 64
_Temp_buf$ = 80
__$ArrayPad$ = 4192
_First$ = 4240
_Last$ = 4248
_Pred$ = 4256
??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z PROC ; std::_Stable_partition_unchecked<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >, COMDAT

; 6074 : _BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred) {

$LN67:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	mov	eax, 4208				; 00001070H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 6075 :     // partition preserving order of equivalents
; 6076 :     for (;;) {
; 6077 :         if (_First == _Last) { // the input range is true (already partitioned)

	cmp	rcx, rdx
	je	SHORT $LN50@Stable_par
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rcx, QWORD PTR [r8+72]
	npad	1
$LL2@Stable_par:
	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6081 :         if (!_Pred(*_First)) { // excluded the leading true range

	je	SHORT $LN51@Stable_par

; 6082 :             break;
; 6083 :         }
; 6084 : 
; 6085 :         ++_First;

	add	rdi, 8

; 6075 :     // partition preserving order of equivalents
; 6076 :     for (;;) {
; 6077 :         if (_First == _Last) { // the input range is true (already partitioned)

	cmp	rdi, rsi
	jne	SHORT $LL2@Stable_par
$LN50@Stable_par:

; 6104 : }

	mov	rax, rdi
$LN1@Stable_par:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+4208]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN51@Stable_par:

; 6086 :     }
; 6087 : 
; 6088 :     for (;;) {
; 6089 :         --_Last;

	sub	rsi, 8

; 6090 :         if (_First == _Last) { // the input range is already partitioned

	cmp	rdi, rsi
	je	SHORT $LN50@Stable_par
$LL5@Stable_par:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rax, QWORD PTR [rsi]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6094 :         if (_Pred(*_Last)) { // excluded the trailing false range

	jne	SHORT $LN53@Stable_par

; 6086 :     }
; 6087 : 
; 6088 :     for (;;) {
; 6089 :         --_Last;

	sub	rsi, 8

; 6090 :         if (_First == _Last) { // the input range is already partitioned

	cmp	rdi, rsi
	jne	SHORT $LL5@Stable_par
	jmp	SHORT $LN50@Stable_par
$LN53@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	mov	rbp, rsi
	sub	rbp, rdi
	sar	rbp, 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6101 :     const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);

	lea	r14, QWORD PTR [rbp+1]

; 86   :     return static_cast<ptrdiff_t>((_STD min)(static_cast<_CT>(PTRDIFF_MAX), static_cast<_CT>(_Value)));

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rbp, rax
	cmovl	rax, rbp

; 99   :         if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { // unconditionally engage stack space

	cmp	rbp, 512				; 00000200H
	jbe	SHORT $LN63@Stable_par

; 100  :             _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
; 101  :             _Capacity = static_cast<ptrdiff_t>(_Requested_size); // in bounds due to if condition
; 102  :             return;
; 103  :         }
; 104  : 
; 105  :         const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);

	mov	rbp, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1562 :     if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	cmp	rax, rcx
	ja	SHORT $LN30@Stable_par

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	test	rax, rax
	jle	SHORT $LN30@Stable_par
	npad	7
$LL31@Stable_par:

; 1564 :             const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);

	lea	rcx, QWORD PTR [rbp*8]

; 1565 :             void* _Pbuf;
; 1566 : #ifdef __cpp_aligned_new
; 1567 :             if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 1568 :                 _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
; 1569 :             } else
; 1570 : #endif // __cpp_aligned_new
; 1571 :             {
; 1572 :                 _Pbuf = ::operator new(_Size, nothrow);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new

; 1573 :             }
; 1574 : 
; 1575 :             if (_Pbuf) {

	test	rax, rax
	jne	SHORT $LN54@Stable_par

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	shr	rbp, 1
	jne	SHORT $LL31@Stable_par
$LN30@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	eax, eax
$LN22@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, rax
	call	??3@YAXPEAX@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 115  :         _Capacity = _Optimistic_count;

	mov	ebp, 512				; 00000200H
$LN63@Stable_par:

; 6102 :     _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};

	lea	rax, QWORD PTR _Temp_buf$[rsp+16]
$LN64@Stable_par:
	mov	QWORD PTR _Temp_buf$[rsp], rax
	mov	QWORD PTR _Temp_buf$[rsp+8], rbp

; 6103 :     return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;

	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r14
	mov	r9, rbx
	mov	r8, rsi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
	mov	rbx, QWORD PTR [rax]

; 122  :         if (static_cast<size_t>(_Capacity) > _Optimistic_count) {

	cmp	QWORD PTR _Temp_buf$[rsp+8], 512	; 00000200H
	jbe	SHORT $LN45@Stable_par
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, QWORD PTR _Temp_buf$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN45@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6103 :     return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;

	mov	rax, rbx
	jmp	$LN1@Stable_par
$LN54@Stable_par:

; 106  :         if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { // engage heap space

	cmp	rbp, 512				; 00000200H
	jbe	SHORT $LN22@Stable_par

; 107  :             _Data     = _Raw.first;
; 108  :             _Capacity = _Raw.second;
; 109  :             return;

	jmp	SHORT $LN64@Stable_par
??$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z ENDP ; std::_Stable_partition_unchecked<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 64
_Temp_buf$ = 80
__$ArrayPad$ = 4192
_First$ = 4240
_Last$ = 4248
_Pred$ = 4256
?dtor$0@?0???$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z@4HA PROC ; `std::_Stable_partition_unchecked<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Temp_buf$[rdx]
	jmp	??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ ; std::_Optimistic_temporary_buffer<unsigned __int64>::~_Optimistic_temporary_buffer<unsigned __int64>
?dtor$0@?0???$_Stable_partition_unchecked@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YAPEA_KPEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@4@@Z@@Z@4HA ENDP ; `std::_Stable_partition_unchecked<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@PEA_KPEA_K@std@@YAXAEAPEA_K$$QEAPEA_K@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@PEA_KPEA_K@std@@YAXAEAPEA_K$$QEAPEA_K@Z PROC ; std::_Seek_wrapped<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@PEA_KPEA_K@std@@YAXAEAPEA_K$$QEAPEA_K@Z ENDP ; std::_Seek_wrapped<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAUWorkItem@TopDownBuildTask@bvh@@AEAU012@$0A@@?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@QEAA@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAUWorkItem@TopDownBuildTask@bvh@@AEAU012@$0A@@?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@QEAA@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem><bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movups	xmm0, XMMWORD PTR [rdx]

; 243  :     }

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+48], xmm1
	ret	0
??$?0AEAUWorkItem@TopDownBuildTask@bvh@@AEAU012@$0A@@?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@QEAA@AEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem><bvh::TopDownBuildTask::WorkItem &,bvh::TopDownBuildTask::WorkItem &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z PROC ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	mov	BYTE PTR [rcx+64], 1
	movups	XMMWORD PTR [rcx+48], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	ret	0
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_move_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ENDP ; std::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_move_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$min@M@std@@YAAEBMAEBM0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@M@std@@YAAEBMAEBM0@Z PROC			; std::min<float>, COMDAT

; 69   :     // return smaller of _Left and _Right
; 70   :     return _Right < _Left ? _Right : _Left;

	movss	xmm0, DWORD PTR [rcx]
	comiss	xmm0, DWORD PTR [rdx]
	cmova	rcx, rdx
	mov	rax, rcx

; 71   : }

	ret	0
??$min@M@std@@YAAEBMAEBM0@Z ENDP			; std::min<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$min@M$02@1@YA?AU01@AEBU01@0@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$min@M$02@1@YA?AU01@AEBU01@0@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::min<float,3>'::`2'::<lambda_1>,0>, COMDAT

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rdx+12]

; 54   :     }

	mov	rax, rcx

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	minss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+16]
	minss	xmm1, DWORD PTR [rdx+4]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 113  :     return Vector<Scalar, N>([=] (size_t i) { return std::min(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rdx+20]
	minss	xmm0, DWORD PTR [rdx+8]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm0

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$min@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$min@M$02@1@YA?AU01@AEBU01@0@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::min<float,3>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$max@M@std@@YAAEBMAEBM0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$max@M@std@@YAAEBMAEBM0@Z PROC			; std::max<float>, COMDAT

; 46   :     // return larger of _Left and _Right
; 47   :     return _Left < _Right ? _Right : _Left;

	movss	xmm0, DWORD PTR [rdx]
	comiss	xmm0, DWORD PTR [rcx]
	cmova	rcx, rdx
	mov	rax, rcx

; 48   : }

	ret	0
??$max@M@std@@YAAEBMAEBM0@Z ENDP			; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$max@M$02@1@YA?AU01@AEBU01@0@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$max@M$02@1@YA?AU01@AEBU01@0@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::max<float,3>'::`2'::<lambda_1>,0>, COMDAT

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rdx+12]

; 54   :     }

	mov	rax, rcx

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	maxss	xmm0, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+16]
	maxss	xmm1, DWORD PTR [rdx+4]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 119  :     return Vector<Scalar, N>([=] (size_t i) { return std::max(a[i], b[i]); });

	movss	xmm0, DWORD PTR [rdx+20]
	maxss	xmm0, DWORD PTR [rdx+8]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm0

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$max@M$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$max@M$02@1@YA?AU01@AEBU01@0@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::max<float,3>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy_at@UWorkItem@TopDownBuildTask@bvh@@@std@@YAXQEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
_Location$dead$ = 8
??$destroy_at@UWorkItem@TopDownBuildTask@bvh@@@std@@YAXQEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::destroy_at<bvh::TopDownBuildTask::WorkItem>, COMDAT

; 315  : #if _HAS_CXX20
; 316  :     if constexpr (is_array_v<_Ty>) {
; 317  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 318  :     } else
; 319  : #endif // _HAS_CXX20
; 320  :     {
; 321  :         _Location->~_Ty();
; 322  :     }
; 323  : }

	ret	0
??$destroy_at@UWorkItem@TopDownBuildTask@bvh@@@std@@YAXQEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::destroy_at<bvh::TopDownBuildTask::WorkItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEBUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEBUWorkItem@TopDownBuildTask@bvh@@AEBU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEBUWorkItem@TopDownBuildTask@bvh@@AEBU123@@Z PROC ; std::forward<bvh::TopDownBuildTask::WorkItem const &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEBUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEBUWorkItem@TopDownBuildTask@bvh@@AEBU123@@Z ENDP ; std::forward<bvh::TopDownBuildTask::WorkItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UWorkItem@TopDownBuildTask@bvh@@AEBU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEBU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UWorkItem@TopDownBuildTask@bvh@@AEBU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEBU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UWorkItem@TopDownBuildTask@bvh@@AEBU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEBU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?GM$02@1@YA?AU01@AEBU01@0@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?GM$02@1@YA?AU01@AEBU01@0@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator-<float,3>'::`2'::<lambda_1>,0>, COMDAT

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm0, DWORD PTR [rdx]

; 54   :     }

	mov	rax, rcx

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	subss	xmm0, DWORD PTR [rdx+12]
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm1, DWORD PTR [rdx+16]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movss	xmm0, DWORD PTR [rdx+8]
	subss	xmm0, DWORD PTR [rdx+20]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm0

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$?GM$02@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$?GM$02@1@YA?AU01@AEBU01@0@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::operator-<float,3>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAM_K$0A@@?$pair@M_K@std@@QEAA@AEAM$$QEA_K@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAM_K$0A@@?$pair@M_K@std@@QEAA@AEAM$$QEA_K@Z PROC	; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float &,unsigned __int64,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAM_K$0A@@?$pair@M_K@std@@QEAA@AEAM$$QEA_K@Z ENDP	; std::pair<float,unsigned __int64>::pair<float,unsigned __int64><float &,unsigned __int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Is_all_bits_zero@M@std@@YA_NAEBM@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Is_all_bits_zero@M@std@@YA_NAEBM@Z PROC		; std::_Is_all_bits_zero<float>, COMDAT

; 5020 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {

	xorps	xmm0, xmm0

; 5021 :     // checks if scalar type has all bits set to zero
; 5022 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 5023 :     if constexpr (is_same_v<_Ty, nullptr_t>) {
; 5024 :         return true;
; 5025 :     } else {
; 5026 :         constexpr _Ty _Zero{};
; 5027 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	movd	eax, xmm0
	cmp	DWORD PTR [rcx], eax
	sete	al

; 5028 :     }
; 5029 : }

	ret	0
??$_Is_all_bits_zero@M@std@@YA_NAEBM@Z ENDP		; std::_Is_all_bits_zero<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Fill_zero_memset@PEAM@std@@YAXPEAM_K@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
??$_Fill_zero_memset@PEAM@std@@YAXPEAM_K@Z PROC		; std::_Fill_zero_memset<float *>, COMDAT

; 5016 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	lea	r8, QWORD PTR [rdx*4]
	xor	edx, edx
	jmp	memset
??$_Fill_zero_memset@PEAM@std@@YAXPEAM_K@Z ENDP		; std::_Fill_zero_memset<float *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	shl	rcx, 4
	mov	rax, rcx

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z PROC ; std::uninitialized_copy<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1915 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN25:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1923 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$uninitialized_copy@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0PEAPEAU123@@Z ENDP ; std::uninitialized_copy<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_TAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_TAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_Get_unwrapped<bvh::TopDownBuildTask::WorkItem * * const &>, COMDAT

; 1156 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1157 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1158 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1159 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1160 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1161 :     } else {
; 1162 :         return static_cast<_Iter&&>(_It);
; 1163 :     }
; 1164 : }

	ret	0
??$_Get_unwrapped@AEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_TAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_Get_unwrapped<bvh::TopDownBuildTask::WorkItem * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Idl_distance@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::_Idl_distance<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1317 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1318 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1319 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1320 :     } else {
; 1321 :         return _Distance_unknown{};
; 1322 :     }
; 1323 : }

	ret	0
??$_Idl_distance@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::_Idl_distance<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@std@@YA?A_TAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@std@@YA?A_TAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@Z PROC ; std::_Get_unwrapped_n<bvh::TopDownBuildTask::WorkItem * * &,__int64>, COMDAT

; 1222 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1223 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1224 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1225 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1226 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1227 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1228 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1229 : 
; 1230 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1231 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1232 :             "integer overflow");
; 1233 :         (void) _COff;
; 1234 : 
; 1235 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1236 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1237 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1238 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1239 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1240 :     } else {
; 1241 :         // pass through iterator that doesn't participate in checking
; 1242 :         return static_cast<_Iter&&>(_It);
; 1243 :     }
; 1244 : }

	ret	0
??$_Get_unwrapped_n@AEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@std@@YA?A_TAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@_J@Z ENDP ; std::_Get_unwrapped_n<bvh::TopDownBuildTask::WorkItem * * &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z
_TEXT	SEGMENT
_UFirst$ = 48
_Count$ = 56
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<bvh::TopDownBuildTask::WorkItem * *,unsigned __int64>, COMDAT

; 2049 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

$LN6:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2050 :     // value-initialize all elements in [_UFirst, _UFirst + _Count)
; 2051 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 2052 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 2053 :         return _Zero_range(_UFirst, _UFirst + _Count);

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdi, rcx

; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	call	memset

; 2050 :     // value-initialize all elements in [_UFirst, _UFirst + _Count)
; 2051 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 2052 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 2053 :         return _Zero_range(_UFirst, _UFirst + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 2054 :     } else {
; 2055 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 2056 :         for (; 0 < _Count; --_Count) {
; 2057 :             _Backout._Emplace_back();
; 2058 :         }
; 2059 : 
; 2060 :         return _Backout._Release();
; 2061 :     }
; 2062 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n_unchecked1@PEAPEAUWorkItem@TopDownBuildTask@bvh@@_K@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@_K@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<bvh::TopDownBuildTask::WorkItem * *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z PROC ; std::_Destroy_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1094 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1095 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1096 :         for (; _First != _Last; ++_First) {
; 1097 :             _Destroy_in_place(*_First);
; 1098 :         }
; 1099 :     }
; 1100 : }

	ret	0
??$_Destroy_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z ENDP ; std::_Destroy_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0M@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<12>, COMDAT

; 65   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 66   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 67   : 
; 68   :     if constexpr (_Overflow_is_possible) {
; 69   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 70   :         if (_Count > _Max_possible) {

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx*2]
	shl	rax, 2

; 76   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0M@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ PROC	; std::_Optimistic_temporary_buffer<unsigned __int64>::~_Optimistic_temporary_buffer<unsigned __int64>, COMDAT

; 122  :         if (static_cast<size_t>(_Capacity) > _Optimistic_count) {

	cmp	QWORD PTR [rcx+8], 512			; 00000200H
	jbe	SHORT $LN5@Optimistic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, QWORD PTR [rcx]
	jmp	??3@YAXPEAX@Z				; operator delete
$LN5@Optimistic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 125  :     }

	ret	0
??1?$_Optimistic_temporary_buffer@_K@std@@QEAA@XZ ENDP	; std::_Optimistic_temporary_buffer<unsigned __int64>::~_Optimistic_temporary_buffer<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 701  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 16
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Release, COMDAT

; 1807 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1808 :         return _Last;
; 1809 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAPEAU?$Triangle@M$00$0A@@bvh@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::~_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 1797 :         _Destroy_range(_First, _Last, _Al);
; 1798 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::~_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@PEAU?$Triangle@M$00$0A@@bvh@@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@PEAU?$Triangle@M$00$0A@@bvh@@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >, COMDAT

; 1791 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAA@PEAU?$Triangle@M$00$0A@@bvh@@AEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 966  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 265  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 16
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><std::default_delete<bvh::BoundingBox<float> [0]>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3377 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> ><std::default_delete<bvh::BoundingBox<float> [0]>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><std::default_delete<bvh::Vector<float,3> [0]>,0>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3377 :         : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

	mov	rax, rcx
	ret	0
??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@$0A@@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> ><std::default_delete<bvh::Vector<float,3> [0]>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z PROC ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	mov	BYTE PTR [rcx+64], 1
	movups	XMMWORD PTR [rcx+48], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	ret	0
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Non_trivial_copy_assign@U?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@2@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ENDP ; std::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Non_trivial_copy_assign<std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >,std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEA_K@std@@YAAEAPEA_KAEAPEA_K@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_K@std@@YAAEAPEA_KAEAPEA_K@Z PROC	; std::forward<unsigned __int64 * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEA_K@std@@YAAEAPEA_KAEAPEA_K@Z ENDP	; std::forward<unsigned __int64 * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$set@M@?$VectorSetter@$00M$02@bvh@@SAXAEAU?$Vector@M$02@1@MM@Z
_TEXT	SEGMENT
v$ = 8
s$ = 16
<args_0>$ = 24
??$set@M@?$VectorSetter@$00M$02@bvh@@SAXAEAU?$Vector@M$02@1@MM@Z PROC ; bvh::VectorSetter<1,float,3>::set<float>, COMDAT

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx+4], xmm1

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);

	movss	DWORD PTR [rcx+8], xmm2

; 24   :     }

	ret	0
??$set@M@?$VectorSetter@$00M$02@bvh@@SAXAEAU?$Vector@M$02@1@MM@Z ENDP ; bvh::VectorSetter<1,float,3>::set<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
$T3 = 0
_Location$ = 96
<_Args_0>$ = 104
<_Args_1>$ = 112
<_Args_2>$ = 120
??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z PROC ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3>,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN95:
	sub	rsp, 88					; 00000058H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 35   :         : p0(p0), e1(p0 - p1), e2(p2 - p0)

	movsd	xmm0, QWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r11, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 35   :         : p0(p0), e1(p0 - p1), e2(p2 - p0)

	movsd	QWORD PTR [rcx], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	mov	r10, r9
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 35   :         : p0(p0), e1(p0 - p1), e2(p2 - p0)

	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [rdx]
	movsd	xmm3, QWORD PTR [r8]
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [r8+8]
	subss	xmm0, xmm3
	mov	r9d, DWORD PTR [rdx+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movaps	XMMWORD PTR [rsp+64], xmm6
	movsd	QWORD PTR $T3[rsp], xmm2

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+12], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	movd	xmm0, eax
	movsd	QWORD PTR $T3[rsp+12], xmm3
	movaps	XMMWORD PTR [rsp+32], xmm8

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+16], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, r9d
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+20], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [r10]
	movsd	xmm3, QWORD PTR [rdx]
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [rdx+8]
	subss	xmm0, xmm3
	mov	ecx, DWORD PTR [r10+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movsd	QWORD PTR $T2[rsp], xmm2
	movsd	QWORD PTR $T2[rsp+12], xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+24], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movd	xmm0, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+28], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, ecx
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+32], xmm1

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm4, xmm1

; 166  :     });

	movsd	xmm0, QWORD PTR [r11+12]
	movsd	xmm2, QWORD PTR [r11+24]

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm7, xmm0
	movss	xmm1, DWORD PTR [r11+20]
	movaps	xmm5, xmm2

; 166  :     });

	movsd	QWORD PTR $T1[rsp], xmm0

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm0, xmm1
	movss	xmm6, DWORD PTR $T1[rsp]
	shufps	xmm7, xmm7, 85				; 00000055H
	movaps	xmm8, xmm7
	shufps	xmm5, xmm5, 85				; 00000055H
	mulss	xmm0, xmm5
	mulss	xmm8, xmm4

; 166  :     });

	movsd	QWORD PTR $T1[rsp+12], xmm2

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm2, DWORD PTR $T1[rsp+12]
	subss	xmm8, xmm0
	movaps	xmm3, xmm2
	movaps	xmm0, xmm6
	mulss	xmm2, xmm7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	movaps	xmm7, XMMWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 165  :         return a[j] * b[k] - a[k] * b[j];

	mulss	xmm0, xmm4
	mulss	xmm6, xmm5
	mulss	xmm3, xmm1
	subss	xmm6, xmm2
	subss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 37   :         n = LeftHandedNormal ? cross(e1, e2) : cross(e2, e1);

	movaps	xmm0, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	movaps	xmm8, XMMWORD PTR [rsp+32]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 37   :         n = LeftHandedNormal ? cross(e1, e2) : cross(e2, e1);

	unpcklps xmm0, xmm3
	movsd	QWORD PTR [r11+36], xmm0
	movss	DWORD PTR [r11+44], xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
??$construct_at@U?$Triangle@M$00$0A@@bvh@@U?$Vector@M$02@2@U32@U32@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU?$Vector@M$02@2@11@Z ENDP ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Vector<float,3>,bvh::Vector<float,3>,bvh::Vector<float,3>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAU?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z PROC ; std::move<bvh::Triangle<float,1,0> &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAU?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z ENDP ; std::move<bvh::Triangle<float,1,0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z PROC ; std::_Copy_memmove<bvh::Triangle<float,1,0> *,bvh::Triangle<float,1,0> *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAU?$Triangle@M$00$0A@@bvh@@PEAU12@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@PEAU12@00@Z ENDP ; std::_Copy_memmove<bvh::Triangle<float,1,0> *,bvh::Triangle<float,1,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_PAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_PAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z PROC ; std::_To_address<bvh::Triangle<float,1,0> *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAU?$Triangle@M$00$0A@@bvh@@@std@@YA?A_PAEBQEAU?$Triangle@M$00$0A@@bvh@@@Z ENDP ; std::_To_address<bvh::Triangle<float,1,0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@U?$Triangle@M$00$0A@@bvh@@@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX$$QEAU?$Triangle@M$00$0A@@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@U?$Triangle@M$00$0A@@bvh@@@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX$$QEAU?$Triangle@M$00$0A@@bvh@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back<bvh::Triangle<float,1,0> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rax+32], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 48			; 00000030H

; 1804 :     }

	ret	0
??$_Emplace_back@U?$Triangle@M$00$0A@@bvh@@@?$_Uninitialized_backout_al@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@QEAAX$$QEAU?$Triangle@M$00$0A@@bvh@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Triangle<float,1,0> > >::_Emplace_back<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$BoundingBox@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$BoundingBox@M@bvh@@@Z PROC ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><bvh::BoundingBox<float> * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$BoundingBox@M@bvh@@@Z ENDP ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><bvh::BoundingBox<float> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0AEAPEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$Vector@M$02@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Val2_0>$ = 24
??$?0AEAPEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$Vector@M$02@bvh@@@Z PROC ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><bvh::Vector<float,3> * &>, COMDAT

; 1515 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0AEAPEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAU?$Vector@M$02@bvh@@@Z ENDP ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><bvh::Vector<float,3> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$move@AEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z PROC ; std::move<bvh::Bvh<float>::Node &>, COMDAT

; 1595 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1596 : }

	ret	0
??$move@AEAUNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z ENDP ; std::move<bvh::Bvh<float>::Node &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Unfancy@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@@Z PROC ; std::_Unfancy<bvh::Bvh<float>::Node>, COMDAT

; 37   :     return _Ptr;

	mov	rax, rcx

; 38   : }

	ret	0
??$_Unfancy@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@@Z ENDP ; std::_Unfancy<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z PROC ; std::_Copy_memmove<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAUNode@?$Bvh@M@bvh@@PEAU123@@std@@YAPEAUNode@?$Bvh@M@bvh@@PEAU123@00@Z ENDP ; std::_Copy_memmove<bvh::Bvh<float>::Node *,bvh::Bvh<float>::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAUNode@?$Bvh@M@bvh@@@std@@YA?A_PAEBQEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAUNode@?$Bvh@M@bvh@@@std@@YA?A_PAEBQEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::_To_address<bvh::Bvh<float>::Node *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAUNode@?$Bvh@M@bvh@@@std@@YA?A_PAEBQEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::_To_address<bvh::Bvh<float>::Node *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@UNode@?$Bvh@M@bvh@@@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX$$QEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UNode@?$Bvh@M@bvh@@@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX$$QEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<bvh::Bvh<float>::Node>, COMDAT

; 1802 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rax+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1803 :         ++_Last;

	add	QWORD PTR [rcx+8], 32			; 00000020H

; 1804 :     }

	ret	0
??$_Emplace_back@UNode@?$Bvh@M@bvh@@@?$_Uninitialized_backout_al@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@QEAAX$$QEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<bvh::Bvh<float>::Node> >::_Emplace_back<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNode@?$Bvh@M@bvh@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@UNode@?$Bvh@M@bvh@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node>, COMDAT

; 715  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UNode@?$Bvh@M@bvh@@$$V@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAUNode@?$Bvh@M@bvh@@@std@@YAAEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUNode@?$Bvh@M@bvh@@@std@@YAAEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z PROC ; std::forward<bvh::Bvh<float>::Node * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAUNode@?$Bvh@M@bvh@@@std@@YAAEAPEAUNode@?$Bvh@M@bvh@@AEAPEAU123@@Z ENDP ; std::forward<bvh::Bvh<float>::Node * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAM@std@@YAAEAPEAMAEAPEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAM@std@@YAAEAPEAMAEAPEAM@Z PROC		; std::forward<float * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAM@std@@YAAEAPEAMAEAPEAM@Z ENDP		; std::forward<float * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAI@std@@YAAEAPEAIAEAPEAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAI@std@@YAAEAPEAIAEAPEAI@Z PROC		; std::forward<unsigned int * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAI@std@@YAAEAPEAIAEAPEAI@Z ENDP		; std::forward<unsigned int * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAE@std@@YAAEAPEAEAEAPEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAE@std@@YAAEAPEAEAEAPEAE@Z PROC		; std::forward<unsigned char * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAE@std@@YAAEAPEAEAEAPEAE@Z ENDP		; std::forward<unsigned char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@$$QEAH1AEA_K1@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
<_Args_1>$ = 24
<_Args_2>$ = 32
<_Args_3>$ = 40
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@$$QEAH1AEA_K1@Z PROC ; std::construct_at<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	r9, QWORD PTR [r9]
	movsxd	r8, DWORD PTR [r8]
	mov	rax, QWORD PTR <_Args_3>$[rsp]
	movsxd	r10, DWORD PTR [rax]
	movsxd	rax, DWORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\top_down_builder.hpp

; 20   :             : node_index(node_index), begin(begin), end(end), depth(depth)

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	mov	QWORD PTR [rcx+24], r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 242  : }

	ret	0
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@HHAEA_KH$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@$$QEAH1AEA_K1@Z ENDP ; std::construct_at<bvh::TopDownBuildTask::WorkItem,int,int,unsigned __int64 &,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UWorkItem@TopDownBuildTask@bvh@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEAU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UWorkItem@TopDownBuildTask@bvh@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UWorkItem@TopDownBuildTask@bvh@@AEAU123@@?$_Default_allocator_traits@V?$allocator@UWorkItem@TopDownBuildTask@bvh@@@std@@@std@@SAXAEAV?$allocator@UWorkItem@TopDownBuildTask@bvh@@@1@QEAUWorkItem@TopDownBuildTask@bvh@@AEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::TopDownBuildTask::WorkItem> >::construct<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$distance@PEA_K@std@@YA_JPEA_K0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@PEA_K@std@@YA_JPEA_K0@Z PROC		; std::distance<unsigned __int64 *>, COMDAT

; 1421 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1422 :         return _Last - _First; // assume the iterator will do debug checking

	sub	rdx, rcx
	sar	rdx, 3
	mov	rax, rdx

; 1423 :     } else {
; 1424 :         _Adl_verify_range(_First, _Last);
; 1425 :         auto _UFirst             = _Get_unwrapped(_First);
; 1426 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1427 :         _Iter_diff_t<_InIt> _Off = 0;
; 1428 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1429 :             ++_Off;
; 1430 :         }
; 1431 : 
; 1432 :         return _Off;
; 1433 :     }
; 1434 : }

	ret	0
??$distance@PEA_K@std@@YA_JPEA_K0@Z ENDP		; std::distance<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 48
_Requested_size$ = 56
??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z PROC ; std::_Optimistic_temporary_buffer<unsigned __int64>::_Optimistic_temporary_buffer<unsigned __int64><__int64>, COMDAT

; 95   :     explicit _Optimistic_temporary_buffer(const _Diff _Requested_size) noexcept { // get temporary storage

$LN35:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 96   :         const auto _Attempt = _Temporary_buffer_size(_Requested_size);
; 97   :         // Since _Diff is a count of elements in a forward range, and forward iterators must denote objects in memory,
; 98   :         // it must fit in a size_t.
; 99   :         if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { // unconditionally engage stack space

	cmp	rdx, 512				; 00000200H
	ja	SHORT $LN2@Optimistic

; 100  :             _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
; 101  :             _Capacity = static_cast<ptrdiff_t>(_Requested_size); // in bounds due to if condition

	lea	rsi, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [rcx+16]

; 102  :             return;

	jmp	SHORT $LN1@Optimistic
$LN2@Optimistic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	cmovl	rax, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 105  :         const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);

	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1562 :     if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rbx, rax
	ja	SHORT $LN11@Optimistic

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	test	rbx, rbx
	jle	SHORT $LN11@Optimistic
$LL12@Optimistic:

; 1564 :             const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);

	lea	rcx, QWORD PTR [rbx*8]

; 1565 :             void* _Pbuf;
; 1566 : #ifdef __cpp_aligned_new
; 1567 :             if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 1568 :                 _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
; 1569 :             } else
; 1570 : #endif // __cpp_aligned_new
; 1571 :             {
; 1572 :                 _Pbuf = ::operator new(_Size, nothrow);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new

; 1573 :             }
; 1574 : 
; 1575 :             if (_Pbuf) {

	test	rax, rax
	jne	SHORT $LN23@Optimistic

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	shr	rbx, 1
	jne	SHORT $LL12@Optimistic
$LN11@Optimistic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	eax, eax
	lea	rsi, QWORD PTR [rdi+8]
$LN3@Optimistic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1592 :         ::operator delete(_Pbuf);

	mov	rcx, rax
	call	??3@YAXPEAX@Z				; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 114  :         _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);

	lea	rax, QWORD PTR [rdi+16]

; 115  :         _Capacity = _Optimistic_count;

	mov	ebx, 512				; 00000200H
$LN32@Optimistic:

; 116  :     }

	mov	rcx, rdi
$LN1@Optimistic:
	mov	QWORD PTR [rcx], rax
	mov	rax, rdi
	mov	QWORD PTR [rsi], rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN23@Optimistic:

; 106  :         if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { // engage heap space

	lea	rsi, QWORD PTR [rdi+8]
	cmp	rbx, 512				; 00000200H
	jbe	SHORT $LN3@Optimistic

; 107  :             _Data     = _Raw.first;
; 108  :             _Capacity = _Raw.second;
; 109  :             return;

	jmp	SHORT $LN32@Optimistic
??$?0_J@?$_Optimistic_temporary_buffer@_K@std@@QEAA@_J@Z ENDP ; std::_Optimistic_temporary_buffer<unsigned __int64>::_Optimistic_temporary_buffer<unsigned __int64><__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z
_TEXT	SEGMENT
_Capacity$GSCopy$1$ = 64
_Temp_ptr$GSCopy$1$ = 72
__$ReturnUdt$GSCopy$1$ = 80
_Low$6 = 88
_High$7 = 104
__$ArrayPad$ = 120
__$ReturnUdt$ = 192
_First$ = 200
_Last$ = 208
_Pred$ = 216
_Count$ = 224
_Temp_ptr$ = 232
_Capacity$ = 240
??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z PROC ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >, COMDAT

; 5989 :     const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity) {

$LN229:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r11, QWORD PTR _Capacity$[rsp]
	mov	r15, r8

; 5990 :     // implement stable_partition of [_First, _Last] (note: closed range)
; 5991 :     // precondition: !_Pred(*_First)
; 5992 :     // precondition: _Pred(*_Last)
; 5993 :     // precondition: distance(_First, _Last) + 1 == _Count
; 5994 :     // note: _Count >= 2 and _First != _Last
; 5995 :     // returns: a pair such that first is the partition point, and second is distance(_First, partition point)
; 5996 :     using _Diff = _Iter_diff_t<_BidIt>;
; 5997 :     if (_Count - static_cast<_Diff>(1) <= _Capacity) { // - 1 since we never need to store *_Last

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rbx, r9
	mov	r9, QWORD PTR _Temp_ptr$[rsp]
	mov	r10, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rsp], rcx
	mov	QWORD PTR _Temp_ptr$GSCopy$1$[rsp], r9
	lea	rax, QWORD PTR [r8-1]
	mov	QWORD PTR _Capacity$GSCopy$1$[rsp], r11
	cmp	rax, r11
	jg	SHORT $LN10@Stable_par
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	rax, QWORD PTR [rdx]
	lea	rdi, QWORD PTR [r9+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6001 :         while (++_First != _Last) { // test each element, copying to _Temp_ptr if it's in the false range, or assigning

	add	r10, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [r9], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5999 :         _BidIt _Next = _First;

	mov	rsi, rdx

; 6001 :         while (++_First != _Last) { // test each element, copying to _Temp_ptr if it's in the false range, or assigning

	cmp	r10, r15
	je	SHORT $LN3@Stable_par
$LL2@Stable_par:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rbx+72]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6003 :             if (_Pred(*_First)) {

	je	SHORT $LN11@Stable_par

; 6004 :                 *_Next = _STD move(*_First);

	mov	QWORD PTR [rsi], rcx

; 6005 :                 ++_Next;

	add	rsi, 8

; 6006 :             } else {

	jmp	SHORT $LN12@Stable_par
$LN11@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	QWORD PTR [rdi], rcx

; 1617 :         ++_Last;

	add	rdi, 8
$LN12@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6001 :         while (++_First != _Last) { // test each element, copying to _Temp_ptr if it's in the false range, or assigning

	add	r10, 8
	cmp	r10, r15
	jne	SHORT $LL2@Stable_par
$LN3@Stable_par:

; 6012 :         *_Next = _STD move(*_Last);

	mov	rax, QWORD PTR [r15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdi, r9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6012 :         *_Next = _STD move(*_Last);

	mov	QWORD PTR [rsi], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6013 :         ++_Next;

	add	rsi, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r9
	mov	rcx, rsi
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6015 :         _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));

	mov	rcx, QWORD PTR _Count$[rsp]

; 6016 :         return pair<_BidIt, _Diff>(_Next, _True_distance); // _Backout destroys elements

	mov	rax, r14
	sar	rdi, 3
	sub	rcx, rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [r14], rsi
	mov	QWORD PTR [r14+8], rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6016 :         return pair<_BidIt, _Diff>(_Next, _True_distance); // _Backout destroys elements

	jmp	$LN1@Stable_par
$LN10@Stable_par:
	mov	QWORD PTR [rsp+216], rbp

; 6017 :     }
; 6018 : 
; 6019 :     const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); // note: >= 1 because _Count >= 2

	mov	rax, r8
	cdq
	mov	QWORD PTR [rsp+136], r12
	sub	rax, rdx
	mov	QWORD PTR [rsp+128], r13
	sar	rax, 1
	mov	r12, rax

; 6020 :     const _BidIt _Mid       = _STD next(_First, _Mid_offset);
; 6021 : 
; 6022 :     // form [_First, _Left) true range, [_Left, _Mid) false range
; 6023 :     _BidIt _Left           = _Mid;
; 6024 :     _Diff _Left_true_count = _Mid_offset;

	mov	rbp, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 1394 :         _Where += _Off;

	lea	r13, QWORD PTR [r10+rax*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6026 :         --_Left;

	lea	rsi, QWORD PTR [r13-8]

; 6027 :         if (_First == _Left) { // the entire left range is false

	lea	rax, QWORD PTR [rbx+72]
	cmp	r10, rsi
	je	SHORT $LN157@Stable_par
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rdx, QWORD PTR [rax]
	npad	4
$LL4@Stable_par:
	mov	rcx, QWORD PTR [rsi]
	cmp	BYTE PTR [rdx+rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6032 :         if (_Pred(*_Left)) { // excluded the false range before _Mid, invariants reestablished, recurse

	jne	$LN158@Stable_par

; 6037 :             break;
; 6038 :         }
; 6039 : 
; 6040 :         --_Left_true_count;

	dec	rbp
	sub	rsi, 8
	cmp	r10, rsi
	jne	SHORT $LL4@Stable_par
$LN157@Stable_par:

; 6028 :             --_Left_true_count; // to exclude *_First

	dec	rbp
$LN5@Stable_par:

; 6041 :     }
; 6042 : 
; 6043 :     // form [_Mid, _Right) true range, [_Right, next(_Last)) false range
; 6044 :     _BidIt _Right           = _Mid;
; 6045 :     _Diff _Right_true_count = 0;

	xor	r14d, r14d
	mov	rdi, r13

; 6046 :     for (;;) { // skip over the leading true range after and including _Mid
; 6047 :         if (_Right == _Last) { // the entire right range is true

	cmp	r13, r15
	je	SHORT $LN159@Stable_par
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\sweep_sah_builder.hpp

; 215  :         auto partition_predicate = [&] (size_t i) { return marks[i] != 0; };

	mov	rcx, QWORD PTR [rax]
	npad	6
$LL7@Stable_par:
	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rcx+rax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6053 :         if (!_Pred(*_Right)) { // excluded the true range after and including _Mid, invariants reestablished, recurse

	je	$LN160@Stable_par

; 6060 :             break;
; 6061 :         }
; 6062 : 
; 6063 :         ++_Right;

	add	rdi, 8

; 6064 :         ++_Right_true_count;

	inc	r14
	cmp	rdi, r15
	jne	SHORT $LL7@Stable_par
$LN159@Stable_par:

; 6048 :             ++_Right; // to include _Last

	add	rdi, 8

; 6049 :             ++_Right_true_count;

	inc	r14
$LN8@Stable_par:

; 6065 :     }
; 6066 : 
; 6067 :     // swap the [_Left, _Mid) false range with the [_Mid, _Right) true range
; 6068 :     const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,

	sub	r12, rbp

; 5960 :     if (_Count1 == 0) {

	je	$LN113@Stable_par

; 5961 :         return _Last;
; 5962 :     }
; 5963 : 
; 5964 :     if (_Count2 == 0) {

	test	r14, r14
	je	$LN226@Stable_par

; 5965 :         return _First;
; 5966 :     }
; 5967 : 
; 5968 :     if (_Count1 <= _Count2 && _Count1 <= _Capacity) { // buffer left range, then copy parts

	mov	rax, QWORD PTR _Capacity$GSCopy$1$[rsp]
	cmp	r12, r14
	jg	$LN47@Stable_par
	cmp	r12, rax
	jg	$LN47@Stable_par
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, QWORD PTR _Temp_ptr$GSCopy$1$[rsp]
	mov	rbx, r13
	sub	rbx, rsi
	mov	rdx, rsi
	mov	r8, rbx
	call	memmove

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdi, r13

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r13
	mov	r8, rdi
	mov	rcx, rsi
	call	memmove
	mov	rdx, QWORD PTR _Temp_ptr$GSCopy$1$[rsp]

; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	add	rdi, rsi

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi
	mov	r8, rbx
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5973 :         return _New_mid; // _Backout destroys elements in temporary buffer

	jmp	$LN113@Stable_par
$LN158@Stable_par:

; 6033 :             const pair<_BidIt, _Diff> _Low =
; 6034 :                 _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);

	mov	QWORD PTR [rsp+48], r11
	lea	rcx, QWORD PTR _Low$6[rsp]
	mov	QWORD PTR [rsp+40], r9
	mov	r8, rsi
	mov	r9, rbx
	mov	QWORD PTR [rsp+32], rbp
	mov	rdx, r10
	call	??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >

; 6035 :             _Left            = _Low.first;
; 6036 :             _Left_true_count = _Low.second;

	mov	r8, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rbx+72]
	mov	r9, QWORD PTR _Temp_ptr$GSCopy$1$[rsp]
	mov	r11, QWORD PTR _Capacity$GSCopy$1$[rsp]
	mov	rsi, QWORD PTR _Low$6[rsp]
	mov	rbp, QWORD PTR _Low$6[rsp+8]
	jmp	$LN5@Stable_par
$LN160@Stable_par:

; 6054 :             const _Diff _Right_count = _Count - _Mid_offset;
; 6055 :             const _Diff _Remaining   = _Right_count - _Right_true_count;
; 6056 :             const pair<_BidIt, _Diff> _High =
; 6057 :                 _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);

	sub	r8, r14
	mov	QWORD PTR [rsp+48], r11
	sub	r8, r12
	mov	QWORD PTR [rsp+40], r9
	mov	QWORD PTR [rsp+32], r8
	lea	rcx, QWORD PTR _High$7[rsp]
	mov	r8, r15
	mov	r9, rbx
	mov	rdx, rdi
	call	??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >

; 6058 :             _Right = _High.first;
; 6059 :             _Right_true_count += _High.second;

	add	r14, QWORD PTR _High$7[rsp+8]
	mov	rdi, QWORD PTR _High$7[rsp]
	jmp	$LN8@Stable_par
$LN47@Stable_par:

; 5976 :     if (_Count2 <= _Capacity) { // buffer right range, then copy parts

	cmp	r14, rax
	jg	SHORT $LN48@Stable_par
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, QWORD PTR _Temp_ptr$GSCopy$1$[rsp]
	mov	rbx, rdi
	sub	rbx, r13
	mov	rdx, r13
	mov	r8, rbx
	call	memmove

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r13, rsi

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, rsi
	sub	rdi, r13
	mov	r8, r13
	mov	rcx, rdi
	call	memmove

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, QWORD PTR _Temp_ptr$GSCopy$1$[rsp]
	mov	r8, rbx
	mov	rcx, rsi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rdi, QWORD PTR [rbx+rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5980 :         return _STD _Move_unchecked(_Backout._First, _Backout._Last, _First); // ditto _Backout destroys elements

	jmp	SHORT $LN113@Stable_par
$LN48@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6255 :     if (_UFirst == _UMid) {

	cmp	rsi, r13
	je	SHORT $LN113@Stable_par

; 6256 :         return _Last;
; 6257 :     }
; 6258 : 
; 6259 :     if (_UMid == _ULast) {

	cmp	r13, rdi
	jne	SHORT $LN115@Stable_par
$LN226@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rdi, rsi
	jmp	SHORT $LN113@Stable_par
$LN115@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6212 :                 __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));

	mov	rdx, r13
	mov	rcx, rsi
	call	__std_reverse_trivially_swappable_8
	mov	rdx, rdi
	mov	rcx, r13
	call	__std_reverse_trivially_swappable_8
	mov	rdx, rdi
	mov	rcx, rsi
	call	__std_reverse_trivially_swappable_8

; 6267 :         _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));

	sub	rdi, r13
	sar	rdi, 3
	lea	rdi, QWORD PTR [rsi+rdi*8]
$LN113@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$1$[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6070 :     return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));

	lea	rax, QWORD PTR [r14+rbp]
	mov	r13, QWORD PTR [rsp+128]
	mov	r12, QWORD PTR [rsp+136]
	mov	rbp, QWORD PTR [rsp+216]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6070 :     return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rcx], rdi
$LN1@Stable_par:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 6071 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Stable_partition_unchecked1@PEA_KV<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@AEBUWorkItem@TopDownBuildTask@4@@Z@@std@@YA?AU?$pair@PEA_K_J@0@PEA_K0V<lambda_2>@?1??build@?$SweepSahBuildTask@U?$Bvh@M@bvh@@@bvh@@QEAA?AV?$optional@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@0@AEBUWorkItem@TopDownBuildTask@5@@Z@_JQEA_K3@Z ENDP ; std::_Stable_partition_unchecked1<unsigned __int64 *,`bvh::SweepSahBuildTask<bvh::Bvh<float> >::build'::`2'::<lambda_2> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEBU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEBU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEBU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEBU123@@Z PROC ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 242  : }

	ret	0
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEBU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEBU123@@Z ENDP ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Adl_verify_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::_Adl_verify_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1133 :     // check that [_First, _Last) forms an iterator range
; 1134 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1135 :         _Verify_range(_First, _Last);
; 1136 :     }
; 1137 : }

	ret	0
??$_Adl_verify_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::_Adl_verify_range<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z PROC ; std::_Uninitialized_copy_unchecked<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1895 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN21:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1912 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_unchecked@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@QEAPEAU123@0@Z ENDP ; std::_Uninitialized_copy_unchecked<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Seek_wrapped@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@$$QEAPEAPEAU123@@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@$$QEAPEAPEAU123@@Z PROC ; std::_Seek_wrapped<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1256 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1257 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1258 :     } else {
; 1259 :         _It = _STD forward<_UIter>(_UIt);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1260 :     }
; 1261 : }

	ret	0
??$_Seek_wrapped@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAXAEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@$$QEAPEAPEAU123@@Z ENDP ; std::_Seek_wrapped<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z PROC ; std::_Zero_range<bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 2017 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2018 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 2019 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 2020 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 2021 :     return _Last;

	mov	rax, rbx

; 2022 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@0@Z ENDP ; std::_Zero_range<bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_To_address@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_To_address<bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 4395 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4396 :     return _STD to_address(_Val);

	mov	rax, QWORD PTR [rcx]

; 4397 : }

	ret	0
??$_To_address@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA?A_PAEBQEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_To_address<bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Return_temporary_buffer@_K@std@@YAXQEA_K@Z
_TEXT	SEGMENT
_Pbuf$ = 8
??$_Return_temporary_buffer@_K@std@@YAXQEA_K@Z PROC	; std::_Return_temporary_buffer<unsigned __int64>, COMDAT

; 1586 : #ifdef __cpp_aligned_new
; 1587 :     if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 1588 :         ::operator delete(_Pbuf, align_val_t{alignof(_Ty)});
; 1589 :     } else
; 1590 : #endif // __cpp_aligned_new
; 1591 :     {
; 1592 :         ::operator delete(_Pbuf);

	jmp	??3@YAXPEAX@Z				; operator delete
??$_Return_temporary_buffer@_K@std@@YAXQEA_K@Z ENDP	; std::_Return_temporary_buffer<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ PROC ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Release, COMDAT

; 1621 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1622 :         return _Last;
; 1623 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAPEAPEAUWorkItem@TopDownBuildTask@bvh@@XZ ENDP ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::~_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1610 :         _Destroy_range(_First, _Last);
; 1611 :     }

	ret	0
??1?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::~_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAA@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout@PEA_K@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout@PEA_K@std@@QEAA@XZ PROC	; std::_Uninitialized_backout<unsigned __int64 *>::~_Uninitialized_backout<unsigned __int64 *>, COMDAT

; 1610 :         _Destroy_range(_First, _Last);
; 1611 :     }

	ret	0
??1?$_Uninitialized_backout@PEA_K@std@@QEAA@XZ ENDP	; std::_Uninitialized_backout<unsigned __int64 *>::~_Uninitialized_backout<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K@Z PROC ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>, COMDAT

; 1602 :     constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K@Z ENDP ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?release@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAPEAU?$Vector@M$02@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAPEAU?$Vector@M$02@bvh@@XZ PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3455 :     }

	ret	0
?release@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAPEAU?$Vector@M$02@bvh@@XZ ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ PROC ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get_deleter, COMDAT

; 3434 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3435 :     }

	ret	0
?get_deleter@?$unique_ptr@$$BY0A@U?$Vector@M$02@bvh@@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@2@XZ ENDP ; std::unique_ptr<bvh::Vector<float,3> [0],std::default_delete<bvh::Vector<float,3> [0]> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?release@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAPEAU?$BoundingBox@M@bvh@@XZ
_TEXT	SEGMENT
this$ = 8
?release@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAPEAU?$BoundingBox@M@bvh@@XZ PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::release, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx]

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory

; 3455 :     }

	ret	0
?release@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAPEAU?$BoundingBox@M@bvh@@XZ ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory
;	COMDAT ?get_deleter@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_deleter@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ PROC ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get_deleter, COMDAT

; 3434 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3435 :     }

	ret	0
?get_deleter@?$unique_ptr@$$BY0A@U?$BoundingBox@M@bvh@@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@QEAAAEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@2@XZ ENDP ; std::unique_ptr<bvh::BoundingBox<float> [0],std::default_delete<bvh::BoundingBox<float> [0]> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp
;	COMDAT ??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 0
$T3 = 0
this$ = 96
p0$ = 104
p1$ = 112
p2$ = 120
??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z PROC ; bvh::Triangle<float,1,0>::Triangle<float,1,0>, COMDAT

; 36   :     {

$LN93:
	sub	rsp, 88					; 00000058H

; 35   :         : p0(p0), e1(p0 - p1), e2(p2 - p0)

	movsd	xmm0, QWORD PTR [rdx]

; 36   :     {

	mov	r11, rcx
	movsd	QWORD PTR [rcx], xmm0
	mov	r10, r9
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [rdx]
	movsd	xmm3, QWORD PTR [r8]
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [r8+8]
	subss	xmm0, xmm3
	mov	r9d, DWORD PTR [rdx+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movaps	XMMWORD PTR [rsp+64], xmm6
	movsd	QWORD PTR $T3[rsp], xmm2

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+12], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	movd	xmm0, eax
	movsd	QWORD PTR $T3[rsp+12], xmm3
	movaps	XMMWORD PTR [rsp+32], xmm8

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+16], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, r9d
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+20], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movsd	xmm2, QWORD PTR [r10]
	movsd	xmm3, QWORD PTR [rdx]
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [rdx+8]
	subss	xmm0, xmm3
	mov	ecx, DWORD PTR [r10+8]
	movaps	xmm1, xmm2
	shufps	xmm1, xmm1, 85				; 00000055H
	movsd	QWORD PTR $T2[rsp], xmm2
	movsd	QWORD PTR $T2[rsp+12], xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+24], xmm0

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movaps	xmm0, xmm3
	shufps	xmm0, xmm0, 85				; 00000055H
	subss	xmm1, xmm0
	movd	xmm0, eax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 38   :     }

	mov	rax, r11
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+28], xmm1

; 101  :     return Vector<Scalar, N>([=] (size_t i) { return a[i] - b[i]; });

	movd	xmm1, ecx
	subss	xmm1, xmm0

; 53   :             values[i] = f(i);

	movss	DWORD PTR [r11+32], xmm1

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm4, xmm1

; 166  :     });

	movsd	xmm0, QWORD PTR [r11+12]
	movsd	xmm2, QWORD PTR [r11+24]

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm7, xmm0
	movss	xmm1, DWORD PTR [r11+20]
	movaps	xmm5, xmm2

; 166  :     });

	movsd	QWORD PTR $T1[rsp], xmm0

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm0, xmm1
	movss	xmm6, DWORD PTR $T1[rsp]
	shufps	xmm7, xmm7, 85				; 00000055H
	movaps	xmm8, xmm7
	shufps	xmm5, xmm5, 85				; 00000055H
	mulss	xmm0, xmm5
	mulss	xmm8, xmm4

; 166  :     });

	movsd	QWORD PTR $T1[rsp+12], xmm2

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm2, DWORD PTR $T1[rsp+12]
	subss	xmm8, xmm0
	movaps	xmm3, xmm2
	movaps	xmm0, xmm6
	mulss	xmm2, xmm7
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 38   :     }

	movaps	xmm7, XMMWORD PTR [rsp+48]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp

; 165  :         return a[j] * b[k] - a[k] * b[j];

	mulss	xmm0, xmm4
	mulss	xmm6, xmm5
	mulss	xmm3, xmm1
	subss	xmm6, xmm2
	subss	xmm3, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\triangle.hpp

; 37   :         n = LeftHandedNormal ? cross(e1, e2) : cross(e2, e1);

	movaps	xmm0, xmm8

; 38   :     }

	movaps	xmm8, XMMWORD PTR [rsp+32]
	unpcklps xmm0, xmm3
	movsd	QWORD PTR [r11+36], xmm0
	movss	DWORD PTR [r11+44], xmm6
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
??0?$Triangle@M$00$0A@@bvh@@QEAA@AEBU?$Vector@M$02@1@00@Z ENDP ; bvh::Triangle<float,1,0>::Triangle<float,1,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp
;	COMDAT ??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$dead$ = 16
__param1$ = 24
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z PROC ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [r8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	mov	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	mov	BYTE PTR [rcx+64], 1
	movups	XMMWORD PTR [rcx+48], xmm1
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\BVHBuilder.cpp

	ret	0
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_construct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ENDP ; std::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >::_Optional_construct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> ><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<bvh::BoundingBox<float> [0]> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<bvh::BoundingBox<float> [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@1@$$QEAPEAU?$BoundingBox@M@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@1@$$QEAPEAU?$BoundingBox@M@bvh@@@Z PROC ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@std@@PEAU?$BoundingBox@M@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$BoundingBox@M@bvh@@@1@$$QEAPEAU?$BoundingBox@M@bvh@@@Z ENDP ; std::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1>::_Compressed_pair<std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *,1><std::default_delete<bvh::BoundingBox<float> [0]>,bvh::BoundingBox<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@0@AEAU10@@Z PROC ; std::forward<std::default_delete<bvh::Vector<float,3> [0]> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@@std@@YA$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@0@AEAU10@@Z ENDP ; std::forward<std::default_delete<bvh::Vector<float,3> [0]> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@1@$$QEAPEAU?$Vector@M$02@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@1@$$QEAPEAU?$Vector@M$02@bvh@@@Z PROC ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *>, COMDAT

; 1520 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??$?0U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@@?$_Compressed_pair@U?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@std@@PEAU?$Vector@M$02@bvh@@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$default_delete@$$BY0A@U?$Vector@M$02@bvh@@@1@$$QEAPEAU?$Vector@M$02@bvh@@@Z ENDP ; std::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1>::_Compressed_pair<std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *,1><std::default_delete<bvh::Vector<float,3> [0]>,bvh::Vector<float,3> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$set@$$V@?$VectorSetter@$01M$02@bvh@@SAXAEAU?$Vector@M$02@1@M@Z
_TEXT	SEGMENT
v$ = 8
s$ = 16
??$set@$$V@?$VectorSetter@$01M$02@bvh@@SAXAEAU?$Vector@M$02@1@M@Z PROC ; bvh::VectorSetter<2,float,3>::set<>, COMDAT

; 22   :         v[I] = s;

	movss	DWORD PTR [rcx+8], xmm1

; 23   :         VectorSetter<I + 1, Scalar, N>::set(v, args...);
; 24   :     }

	ret	0
??$set@$$V@?$VectorSetter@$01M$02@bvh@@SAXAEAU?$Vector@M$02@1@M@Z ENDP ; bvh::VectorSetter<2,float,3>::set<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@@Z PROC ; std::to_address<bvh::Triangle<float,1,0> >, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@U?$Triangle@M$00$0A@@bvh@@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@@Z ENDP ; std::to_address<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@U?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z PROC ; std::forward<bvh::Triangle<float,1,0> >, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@U?$Triangle@M$00$0A@@bvh@@@std@@YA$$QEAU?$Triangle@M$00$0A@@bvh@@AEAU12@@Z ENDP ; std::forward<bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@U?$Triangle@M$00$0A@@bvh@@U12@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$Triangle@M$00$0A@@bvh@@U12@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@U?$Triangle@M$00$0A@@bvh@@U12@@?$_Default_allocator_traits@V?$allocator@U?$Triangle@M$00$0A@@bvh@@@std@@@std@@SAXAEAV?$allocator@U?$Triangle@M$00$0A@@bvh@@@1@QEAU?$Triangle@M$00$0A@@bvh@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Triangle<float,1,0> > >::construct<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$BoundingBox@M@bvh@@@std@@YAAEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$BoundingBox@M@bvh@@@std@@YAAEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z PROC ; std::forward<bvh::BoundingBox<float> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$BoundingBox@M@bvh@@@std@@YAAEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z ENDP ; std::forward<bvh::BoundingBox<float> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$Vector@M$02@bvh@@@std@@YAAEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$Vector@M$02@bvh@@@std@@YAAEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z PROC ; std::forward<bvh::Vector<float,3> * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAU?$Vector@M$02@bvh@@@std@@YAAEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z ENDP ; std::forward<bvh::Vector<float,3> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z PROC ; std::to_address<bvh::Bvh<float>::Node>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@UNode@?$Bvh@M@bvh@@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z ENDP ; std::to_address<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@UNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z PROC ; std::forward<bvh::Bvh<float>::Node>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@UNode@?$Bvh@M@bvh@@@std@@YA$$QEAUNode@?$Bvh@M@bvh@@AEAU123@@Z ENDP ; std::forward<bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$construct@UNode@?$Bvh@M@bvh@@U123@@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@$$QEAU345@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UNode@?$Bvh@M@bvh@@U123@@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@$$QEAU345@@Z PROC ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 721  :     }

	ret	0
??$construct@UNode@?$Bvh@M@bvh@@U123@@?$_Default_allocator_traits@V?$allocator@UNode@?$Bvh@M@bvh@@@std@@@std@@SAXAEAV?$allocator@UNode@?$Bvh@M@bvh@@@1@QEAUNode@?$Bvh@M@bvh@@$$QEAU345@@Z ENDP ; std::_Default_allocator_traits<std::allocator<bvh::Bvh<float>::Node> >::construct<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNode@?$Bvh@M@bvh@@$$V$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
??$construct_at@UNode@?$Bvh@M@bvh@@$$V$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z PROC ; std::construct_at<bvh::Bvh<float>::Node,0>, COMDAT

; 240  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

	xorps	xmm0, xmm0

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0

; 242  : }

	ret	0
??$construct_at@UNode@?$Bvh@M@bvh@@$$V$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@@Z ENDP ; std::construct_at<bvh::Bvh<float>::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEAU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEAU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEAU123@@Z PROC ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 242  : }

	ret	0
??$construct_at@UWorkItem@TopDownBuildTask@bvh@@AEAU123@$0A@@std@@YAPEAUWorkItem@TopDownBuildTask@bvh@@QEAU123@AEAU123@@Z ENDP ; std::construct_at<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Temporary_buffer_size@_J@std@@YA_J_J@Z
_TEXT	SEGMENT
_Value$ = 8
??$_Temporary_buffer_size@_J@std@@YA_J_J@Z PROC		; std::_Temporary_buffer_size<__int64>, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rcx, rax
	cmovl	rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 87   : }

	ret	0
??$_Temporary_buffer_size@_J@std@@YA_J_J@Z ENDP		; std::_Temporary_buffer_size<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Count$ = 56
??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z PROC ; std::_Get_temporary_buffer<unsigned __int64>, COMDAT

; 1561 : pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {

$LN23:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1562 :     if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	mov	rbx, rdx
	mov	rdi, rcx
	cmp	rdx, rax
	ja	SHORT $LN3@Get_tempor

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	test	rdx, rdx
	jle	SHORT $LN3@Get_tempor
	npad	12
$LL4@Get_tempor:

; 1564 :             const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);

	lea	rcx, QWORD PTR [rbx*8]

; 1565 :             void* _Pbuf;
; 1566 : #ifdef __cpp_aligned_new
; 1567 :             if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 1568 :                 _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
; 1569 :             } else
; 1570 : #endif // __cpp_aligned_new
; 1571 :             {
; 1572 :                 _Pbuf = ::operator new(_Size, nothrow);

	lea	rdx, OFFSET FLAT:?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
	call	??2@YAPEAX_KAEBUnothrow_t@std@@@Z	; operator new

; 1573 :             }
; 1574 : 
; 1575 :             if (_Pbuf) {

	test	rax, rax
	jne	SHORT $LN13@Get_tempor

; 1563 :         for (; 0 < _Count; _Count /= 2) {

	shr	rbx, 1
	jne	SHORT $LL4@Get_tempor
$LN3@Get_tempor:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	xor	eax, eax
	mov	QWORD PTR [rdi+8], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1582 : }

	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN13@Get_tempor:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR [rdi+8], rbx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1582 : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Get_temporary_buffer@_K@std@@YA?AU?$pair@PEA_K_J@0@_J@Z ENDP ; std::_Get_temporary_buffer<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@_K@?$_Uninitialized_backout@PEA_K@std@@QEAAX$$QEA_K@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@_K@?$_Uninitialized_backout@PEA_K@std@@QEAAX$$QEA_K@Z PROC ; std::_Uninitialized_backout<unsigned __int64 *>::_Emplace_back<unsigned __int64>, COMDAT

; 1615 :         // construct a new element at *_Last and increment
; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1617 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1618 :     }

	ret	0
??$_Emplace_back@_K@?$_Uninitialized_backout@PEA_K@std@@QEAAX$$QEA_K@Z ENDP ; std::_Uninitialized_backout<unsigned __int64 *>::_Emplace_back<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z PROC ; std::_Move_unchecked<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 4886 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4887 :     // move [_First, _Last) to [_Dest, ...)
; 4888 :     // note: _Move_unchecked has callers other than the move family
; 4889 :     if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4890 : #if _HAS_CXX20
; 4891 :         if (!_STD is_constant_evaluated())
; 4892 : #endif // _HAS_CXX20
; 4893 :         {
; 4894 :             return _Copy_memmove(_First, _Last, _Dest);
; 4895 :         }
; 4896 :     }
; 4897 : 
; 4898 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4899 :         *_Dest = _STD move(*_First);
; 4900 :     }
; 4901 : 
; 4902 :     return _Dest;
; 4903 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ENDP ; std::_Move_unchecked<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEAPEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEAPEA_KAEA_J@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEAPEA_KAEA_J@Z PROC ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * &,__int64 &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEAPEA_KAEA_J@Z ENDP ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * &,__int64 &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$next@PEA_K@std@@YAPEA_KPEA_K_J@Z
_TEXT	SEGMENT
_First$ = 8
_Off$ = 16
??$next@PEA_K@std@@YAPEA_KPEA_K_J@Z PROC		; std::next<unsigned __int64 *>, COMDAT

; 1394 :         _Where += _Off;

	lea	rax, QWORD PTR [rcx+rdx*8]

; 1443 :     static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");
; 1444 : 
; 1445 :     _STD advance(_First, _Off);
; 1446 :     return _First;
; 1447 : }

	ret	0
??$next@PEA_K@std@@YAPEA_KPEA_K_J@Z ENDP		; std::next<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm
;	COMDAT ??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z
_TEXT	SEGMENT
_First$ = 80
_Mid$ = 88
_Last$ = 96
_Count1$ = 104
_Count2$ = 112
_Temp_ptr$ = 120
_Capacity$ = 128
??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z PROC ; std::_Buffered_rotate_unchecked<unsigned __int64 *>, COMDAT

; 5957 :     const ptrdiff_t _Capacity) { // rotate [_First, _Last) using temp buffer

$LN151:
	push	rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H
	mov	r15, QWORD PTR _Temp_ptr$[rsp]
	mov	rsi, r8
	mov	rbp, rdx
	mov	r14, rcx

; 5958 :                                  // precondition: _Count1 == distance(_First, _Mid)
; 5959 :                                  // precondition: _Count2 == distance(_Mid, _Last)
; 5960 :     if (_Count1 == 0) {

	test	r9, r9
	jne	SHORT $LN2@Buffered_r

; 5961 :         return _Last;

	mov	rax, r8

; 5985 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN2@Buffered_r:

; 5962 :     }
; 5963 : 
; 5964 :     if (_Count2 == 0) {

	mov	rax, QWORD PTR _Count2$[rsp]
	test	rax, rax
	jne	SHORT $LN3@Buffered_r

; 5965 :         return _First;

	mov	rax, r14

; 5985 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN3@Buffered_r:

; 5966 :     }
; 5967 : 
; 5968 :     if (_Count1 <= _Count2 && _Count1 <= _Capacity) { // buffer left range, then copy parts

	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rsp+104], rbx
	cmp	r9, rax
	jg	SHORT $LN4@Buffered_r
	cmp	r9, rcx
	jg	SHORT $LN4@Buffered_r
	mov	QWORD PTR [rsp+32], rdi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r14
	mov	rdi, rbp
	mov	rcx, r15
	sub	rdi, r14
	mov	r8, rdi
	call	memmove

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rsi, rbp

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbp
	mov	r8, rsi
	mov	rcx, r14
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rbx, QWORD PTR [r14+rsi]

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	mov	rdx, r15
	call	memmove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5973 :         return _New_mid; // _Backout destroys elements in temporary buffer

	mov	rdi, QWORD PTR [rsp+32]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+104]

; 5985 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN4@Buffered_r:

; 5974 :     }
; 5975 : 
; 5976 :     if (_Count2 <= _Capacity) { // buffer right range, then copy parts

	cmp	rax, rcx
	jg	SHORT $LN5@Buffered_r
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, rsi

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r15
	sub	rbx, rbp
	mov	r8, rbx
	call	memmove

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbp, r14

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	rdx, r14
	sub	rsi, rbp
	mov	r8, rbp
	mov	rcx, rsi
	call	memmove

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rdx, r15
	mov	rcx, r14
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [r14+rbx]
	mov	rbx, QWORD PTR [rsp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5985 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN5@Buffered_r:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 6255 :     if (_UFirst == _UMid) {

	cmp	r14, rbp
	je	SHORT $LN70@Buffered_r

; 6256 :         return _Last;
; 6257 :     }
; 6258 : 
; 6259 :     if (_UMid == _ULast) {

	cmp	rbp, rsi
	jne	SHORT $LN72@Buffered_r

; 6260 :         return _First;

	mov	rsi, r14
	jmp	SHORT $LN70@Buffered_r
$LN72@Buffered_r:

; 6212 :                 __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));

	mov	rcx, r14
	call	__std_reverse_trivially_swappable_8
	mov	rdx, rsi
	mov	rcx, rbp
	call	__std_reverse_trivially_swappable_8
	mov	rdx, rsi
	mov	rcx, r14
	call	__std_reverse_trivially_swappable_8

; 6267 :         _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));

	sub	rsi, rbp
	sar	rsi, 3
	lea	rsi, QWORD PTR [r14+rsi*8]
$LN70@Buffered_r:
	mov	rbx, QWORD PTR [rsp+104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\algorithm

; 5984 :     return _STD rotate(_First, _Mid, _Last);

	mov	rax, rsi

; 5985 : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
??$_Buffered_rotate_unchecked@PEA_K@std@@YAPEA_KQEA_K00_J101@Z ENDP ; std::_Buffered_rotate_unchecked<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0AEBQEA_K_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEBQEA_K$$QEA_J@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEBQEA_K_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEBQEA_K$$QEA_J@Z PROC ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * const &,__int64,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0AEBQEA_K_J$0A@@?$pair@PEA_K_J@std@@QEAA@AEBQEA_K$$QEA_J@Z ENDP ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 * const &,__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z PROC ; std::_Copy_memmove<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@PEAPEAU123@00@Z ENDP ; std::_Copy_memmove<bvh::TopDownBuildTask::WorkItem * *,bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Emplace_back@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z PROC ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Emplace_back<bvh::TopDownBuildTask::WorkItem * &>, COMDAT

; 1615 :         // construct a new element at *_Last and increment
; 1616 :         _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 1617 :         ++_Last;

	add	QWORD PTR [rcx+8], 8

; 1618 :     }

	ret	0
??$_Emplace_back@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@?$_Uninitialized_backout@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@QEAAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@@Z ENDP ; std::_Uninitialized_backout<bvh::TopDownBuildTask::WorkItem * *>::_Emplace_back<bvh::TopDownBuildTask::WorkItem * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAPEAU123@@Z PROC ; std::forward<bvh::TopDownBuildTask::WorkItem * *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YA$$QEAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAPEAU123@@Z ENDP ; std::forward<bvh::TopDownBuildTask::WorkItem * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$to_address@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z
_TEXT	SEGMENT
_Val$ = 8
??$to_address@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z PROC ; std::to_address<bvh::TopDownBuildTask::WorkItem *>, COMDAT

; 328  :     static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
; 329  :     return _Val;

	mov	rax, rcx

; 330  : }

	ret	0
??$to_address@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@@Z ENDP ; std::to_address<bvh::TopDownBuildTask::WorkItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Destroy_range@PEA_KPEA_K@std@@YAXPEA_KQEA_K@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Destroy_range@PEA_KPEA_K@std@@YAXPEA_KQEA_K@Z PROC	; std::_Destroy_range<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 1094 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1095 :     if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 1096 :         for (; _First != _Last; ++_First) {
; 1097 :             _Destroy_in_place(*_First);
; 1098 :         }
; 1099 :     }
; 1100 : }

	ret	0
??$_Destroy_range@PEA_KPEA_K@std@@YAXPEA_KQEA_K@Z ENDP	; std::_Destroy_range<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$Vector@M$02@bvh@@$$T@std@@YAPEAU?$Vector@M$02@bvh@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$Vector@M$02@bvh@@$$T@std@@YAPEAU?$Vector@M$02@bvh@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<bvh::Vector<float,3> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$Vector@M$02@bvh@@$$T@std@@YAPEAU?$Vector@M$02@bvh@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<bvh::Vector<float,3> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$exchange@PEAU?$BoundingBox@M@bvh@@$$T@std@@YAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$BoundingBox@M@bvh@@$$T@std@@YAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<bvh::BoundingBox<float> *,std::nullptr_t>, COMDAT

; 753  :     // assign _New_val to _Val, return previous _Val
; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 755  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 756  :     return _Old_val;
; 757  : }

	ret	0
??$exchange@PEAU?$BoundingBox@M@bvh@@$$T@std@@YAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<bvh::BoundingBox<float> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z
_TEXT	SEGMENT
$T1 = 0
__$ReturnUdt$ = 80
a$ = 88
b$ = 96
??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z PROC	; bvh::cross<float>, COMDAT

; 161  : Vector3<Scalar> cross(const Vector3<Scalar>& a, const Vector3<Scalar>& b) {

$LN28:
	sub	rsp, 72					; 00000048H

; 166  :     });

	movsd	xmm0, QWORD PTR [rdx]

; 162  :     return Vector3<Scalar>([=] (size_t i) {

	mov	rax, rcx

; 166  :     });

	movsd	xmm2, QWORD PTR [r8]
	movaps	XMMWORD PTR [rsp+48], xmm6

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm6, xmm2

; 166  :     });

	movsd	QWORD PTR $T1[rsp], xmm0

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm4, DWORD PTR $T1[rsp]
	movaps	XMMWORD PTR [rsp+32], xmm7
	movaps	xmm7, xmm0
	shufps	xmm7, xmm7, 85				; 00000055H
	shufps	xmm6, xmm6, 85				; 00000055H
	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR [r8+8]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rdx+8]

; 166  :     });

	movsd	QWORD PTR $T1[rsp+12], xmm2

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm3, DWORD PTR $T1[rsp+12]
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [r8+8]
	mulss	xmm4, xmm6

; 167  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm1

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [rdx+8]
	mulss	xmm3, xmm7

; 167  : }

	movaps	xmm7, XMMWORD PTR [rsp+32]

; 165  :         return a[j] * b[k] - a[k] * b[j];

	subss	xmm1, xmm0
	subss	xmm4, xmm3

; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+4], xmm1
	movss	DWORD PTR [rcx+8], xmm4

; 167  : }

	add	rsp, 72					; 00000048H
	ret	0
??$cross@M@bvh@@YA?AU?$Vector@M$02@0@AEBU10@0@Z ENDP	; bvh::cross<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??R<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??R<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z PROC ; `bvh::cross<float>'::`2'::<lambda_1>::operator(), COMDAT

; 163  :         size_t j = (i + 1) % 3;

	lea	r10, QWORD PTR [rdx+1]
	mov	r9, rdx
	mov	r11, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mov	rax, r11
	mul	r10

; 164  :         size_t k = (i + 2) % 3;

	mov	rax, r11
	shr	rdx, 1
	lea	r8, QWORD PTR [rdx+rdx*2]
	sub	r10, r8
	lea	r8, QWORD PTR [r9+2]
	mul	r8

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm1, DWORD PTR [rcx+r10*4+12]
	shr	rdx, 1
	lea	rax, QWORD PTR [rdx+rdx*2]
	sub	r8, rax
	movss	xmm0, DWORD PTR [rcx+r8*4+12]
	mulss	xmm0, DWORD PTR [rcx+r10*4]
	mulss	xmm1, DWORD PTR [rcx+r8*4]
	subss	xmm0, xmm1

; 166  :     });

	ret	0
??R<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEBA@_K@Z ENDP ; `bvh::cross<float>'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??0<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z
_TEXT	SEGMENT
this$ = 8
__a$ = 16
__b$ = 24
??0<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z PROC ; `bvh::cross<float>'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 162  :     return Vector3<Scalar>([=] (size_t i) {
; 163  :         size_t j = (i + 1) % 3;
; 164  :         size_t k = (i + 2) % 3;
; 165  :         return a[j] * b[k] - a[k] * b[j];
; 166  :     });

	mov	eax, DWORD PTR [rdx+8]
	movsd	xmm0, QWORD PTR [rdx]
	movsd	QWORD PTR [rcx], xmm0
	movsd	xmm0, QWORD PTR [r8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [r8+8]
	movsd	QWORD PTR [rcx+12], xmm0
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	ret	0
??0<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@QEAA@00@Z ENDP ; `bvh::cross<float>'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ?set@?$VectorSetter@$02M$02@bvh@@SAXAEAU?$Vector@M$02@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?set@?$VectorSetter@$02M$02@bvh@@SAXAEAU?$Vector@M$02@2@@Z PROC ; bvh::VectorSetter<3,float,3>::set, COMDAT

; 29   :     bvh_always_inline static void set(Vector<Scalar, N>&) {}

	ret	0
?set@?$VectorSetter@$02M$02@bvh@@SAXAEAU?$Vector@M$02@2@@Z ENDP ; bvh::VectorSetter<3,float,3>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K0@Z
_TEXT	SEGMENT
this$ = 8
_First_$ = 16
_Last_$ = 24
??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K0@Z PROC ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>, COMDAT

; 1604 :     constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$_Uninitialized_backout@PEA_K@std@@QEAA@PEA_K0@Z ENDP ; std::_Uninitialized_backout<unsigned __int64 *>::_Uninitialized_backout<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\optional
;	COMDAT ??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
<_Args_0>$ = 24
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z PROC ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >, COMDAT

; 83   :         : _Value(_STD forward<_Types>(_Args)...), _Has_value{true} {} // initialize contained value with _Args...

	movups	xmm0, XMMWORD PTR [r8]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	mov	BYTE PTR [rcx+64], 1
	movups	XMMWORD PTR [rcx+48], xmm1
	ret	0
??$?0U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@@?$_Optional_destruct_base@U?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@std@@$00@std@@QEAA@Uin_place_t@1@$$QEAU?$pair@UWorkItem@TopDownBuildTask@bvh@@U123@@1@@Z ENDP ; std::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1>::_Optional_destruct_base<std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem>,1><std::pair<bvh::TopDownBuildTask::WorkItem,bvh::TopDownBuildTask::WorkItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$BoundingBox@M@bvh@@@std@@YA$$QEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$BoundingBox@M@bvh@@@std@@YA$$QEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z PROC ; std::forward<bvh::BoundingBox<float> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$BoundingBox@M@bvh@@@std@@YA$$QEAPEAU?$BoundingBox@M@bvh@@AEAPEAU12@@Z ENDP ; std::forward<bvh::BoundingBox<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@PEAU?$Vector@M$02@bvh@@@std@@YA$$QEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU?$Vector@M$02@bvh@@@std@@YA$$QEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z PROC ; std::forward<bvh::Vector<float,3> *>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@PEAU?$Vector@M$02@bvh@@@std@@YA$$QEAPEAU?$Vector@M$02@bvh@@AEAPEAU12@@Z ENDP ; std::forward<bvh::Vector<float,3> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@U?$Triangle@M$00$0A@@bvh@@U12@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU12@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@U?$Triangle@M$00$0A@@bvh@@U12@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU12@@Z PROC ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0>,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0

; 242  : }

	ret	0
??$construct_at@U?$Triangle@M$00$0A@@bvh@@U12@$0A@@std@@YAPEAU?$Triangle@M$00$0A@@bvh@@QEAU12@$$QEAU12@@Z ENDP ; std::construct_at<bvh::Triangle<float,1,0>,bvh::Triangle<float,1,0>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@UNode@?$Bvh@M@bvh@@U123@$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@$$QEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@UNode@?$Bvh@M@bvh@@U123@$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@$$QEAU123@@Z PROC ; std::construct_at<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 242  : }

	ret	0
??$construct_at@UNode@?$Bvh@M@bvh@@U123@$0A@@std@@YAPEAUNode@?$Bvh@M@bvh@@QEAU123@$$QEAU123@@Z ENDP ; std::construct_at<bvh::Bvh<float>::Node,bvh::Bvh<float>::Node,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$min@_J@std@@YAAEB_JAEB_J0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_J@std@@YAAEB_JAEB_J0@Z PROC			; std::min<__int64>, COMDAT

; 69   :     // return smaller of _Left and _Right
; 70   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovl	rcx, rdx
	mov	rax, rcx

; 71   : }

	ret	0
??$min@_J@std@@YAAEB_JAEB_J0@Z ENDP			; std::min<__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0PEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEAPEA_KAEA_J@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0PEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEAPEA_KAEA_J@Z PROC ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 *,__int64 &,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0PEA_KAEA_J$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEAPEA_KAEA_J@Z ENDP ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><unsigned __int64 *,__int64 &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
;	COMDAT ??$?0$$TH$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEA$$T$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0$$TH$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEA$$T$$QEAH@Z PROC ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><std::nullptr_t,int,0>, COMDAT

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	movsxd	rax, DWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 243  :     }

	mov	rax, rcx
	ret	0
??$?0$$TH$0A@@?$pair@PEA_K_J@std@@QEAA@$$QEA$$T$$QEAH@Z ENDP ; std::pair<unsigned __int64 *,__int64>::pair<unsigned __int64 *,__int64><std::nullptr_t,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEA_J@std@@YAAEA_JAEA_J@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEA_J@std@@YAAEA_JAEA_J@Z PROC		; std::forward<__int64 &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEA_J@std@@YAAEA_JAEA_J@Z ENDP		; std::forward<__int64 &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$advance@PEA_K_J@std@@YAXAEAPEA_K_J@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
??$advance@PEA_K_J@std@@YAXAEAPEA_K_J@Z PROC		; std::advance<unsigned __int64 *,__int64>, COMDAT

; 1393 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1394 :         _Where += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 1395 :     } else {
; 1396 :         if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
; 1397 :             _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
; 1398 :         }
; 1399 : 
; 1400 :         decltype(auto) _UWhere      = _Get_unwrapped_n(_STD move(_Where), _Off);
; 1401 :         constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(_STD move(_Where), _Off))>;
; 1402 : 
; 1403 :         if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
; 1404 :             for (; _Off < 0; ++_Off) {
; 1405 :                 --_UWhere;
; 1406 :             }
; 1407 :         }
; 1408 : 
; 1409 :         for (; 0 < _Off; --_Off) {
; 1410 :             ++_UWhere;
; 1411 :         }
; 1412 : 
; 1413 :         if constexpr (_Need_rewrap) {
; 1414 :             _Seek_wrapped(_Where, _STD move(_UWhere));
; 1415 :         }
; 1416 :     }
; 1417 : }

	ret	0
??$advance@PEA_K_J@std@@YAXAEAPEA_K_J@Z ENDP		; std::advance<unsigned __int64 *,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z PROC ; std::_Uninitialized_move_unchecked<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 1627 : _CONSTEXPR20 _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

$LN21:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1643 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_KQEA_K0@Z ENDP ; std::_Uninitialized_move_unchecked<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move_backward_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z PROC ; std::_Move_backward_unchecked<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx

; 4928 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Move_backward_unchecked@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ENDP ; std::_Move_backward_unchecked<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z
_TEXT	SEGMENT
_First$ = 64
_Mid$ = 72
_Last$ = 80
??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z PROC		; std::rotate<unsigned __int64 *>, COMDAT

; 6246 : _CONSTEXPR20 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {

$LN45:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 6247 :     // exchange the ranges [_First, _Mid) and [_Mid, _Last)
; 6248 :     // that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
; 6249 :     // returns the iterator pointing at *_First's new home
; 6250 :     _Adl_verify_range(_First, _Mid);
; 6251 :     _Adl_verify_range(_Mid, _Last);
; 6252 :     auto _UFirst      = _Get_unwrapped(_First);
; 6253 :     auto _UMid        = _Get_unwrapped(_Mid);
; 6254 :     const auto _ULast = _Get_unwrapped(_Last);
; 6255 :     if (_UFirst == _UMid) {

	cmp	rcx, rdx
	jne	SHORT $LN2@rotate

; 6256 :         return _Last;

	mov	rax, rbx

; 6268 :     } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
; 6269 :         _STD reverse(_UFirst, _UMid);
; 6270 :         _STD reverse(_UMid, _ULast);
; 6271 :         auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
; 6272 :         _STD reverse(_Tmp.first, _Tmp.second);
; 6273 :         _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
; 6274 :     } else {
; 6275 :         auto _UNext = _UMid;
; 6276 :         do { // rotate the first cycle
; 6277 :             swap(*_UFirst, *_UNext); // intentional ADL
; 6278 :             ++_UFirst;
; 6279 :             ++_UNext;
; 6280 :             if (_UFirst == _UMid) {
; 6281 :                 _UMid = _UNext;
; 6282 :             }
; 6283 :         } while (_UNext != _ULast);
; 6284 :         _Seek_wrapped(_First, _UFirst);
; 6285 :         while (_UMid != _ULast) { // rotate subsequent cycles
; 6286 :             _UNext = _UMid;
; 6287 :             do {
; 6288 :                 swap(*_UFirst, *_UNext); // intentional ADL
; 6289 :                 ++_UFirst;
; 6290 :                 ++_UNext;
; 6291 :                 if (_UFirst == _UMid) {
; 6292 :                     _UMid = _UNext;
; 6293 :                 }
; 6294 :             } while (_UNext != _ULast);
; 6295 :         }
; 6296 :     }
; 6297 : 
; 6298 :     return _First;
; 6299 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@rotate:

; 6257 :     }
; 6258 : 
; 6259 :     if (_UMid == _ULast) {

	cmp	rsi, rbx
	jne	SHORT $LN3@rotate

; 6260 :         return _First;

	mov	rax, rdi

; 6268 :     } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
; 6269 :         _STD reverse(_UFirst, _UMid);
; 6270 :         _STD reverse(_UMid, _ULast);
; 6271 :         auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
; 6272 :         _STD reverse(_Tmp.first, _Tmp.second);
; 6273 :         _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
; 6274 :     } else {
; 6275 :         auto _UNext = _UMid;
; 6276 :         do { // rotate the first cycle
; 6277 :             swap(*_UFirst, *_UNext); // intentional ADL
; 6278 :             ++_UFirst;
; 6279 :             ++_UNext;
; 6280 :             if (_UFirst == _UMid) {
; 6281 :                 _UMid = _UNext;
; 6282 :             }
; 6283 :         } while (_UNext != _ULast);
; 6284 :         _Seek_wrapped(_First, _UFirst);
; 6285 :         while (_UMid != _ULast) { // rotate subsequent cycles
; 6286 :             _UNext = _UMid;
; 6287 :             do {
; 6288 :                 swap(*_UFirst, *_UNext); // intentional ADL
; 6289 :                 ++_UFirst;
; 6290 :                 ++_UNext;
; 6291 :                 if (_UFirst == _UMid) {
; 6292 :                     _UMid = _UNext;
; 6293 :                 }
; 6294 :             } while (_UNext != _ULast);
; 6295 :         }
; 6296 :     }
; 6297 : 
; 6298 :     return _First;
; 6299 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN3@rotate:

; 6212 :                 __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));

	call	__std_reverse_trivially_swappable_8
	mov	rdx, rbx
	mov	rcx, rsi
	call	__std_reverse_trivially_swappable_8
	mov	rdx, rbx
	mov	rcx, rdi
	call	__std_reverse_trivially_swappable_8

; 6261 :     }
; 6262 : 
; 6263 :     if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
; 6264 :         _STD reverse(_UFirst, _UMid);
; 6265 :         _STD reverse(_UMid, _ULast);
; 6266 :         _STD reverse(_UFirst, _ULast);
; 6267 :         _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));

	sub	rbx, rsi
	sar	rbx, 3
	lea	rax, QWORD PTR [rdi+rbx*8]

; 6268 :     } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
; 6269 :         _STD reverse(_UFirst, _UMid);
; 6270 :         _STD reverse(_UMid, _ULast);
; 6271 :         auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
; 6272 :         _STD reverse(_Tmp.first, _Tmp.second);
; 6273 :         _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
; 6274 :     } else {
; 6275 :         auto _UNext = _UMid;
; 6276 :         do { // rotate the first cycle
; 6277 :             swap(*_UFirst, *_UNext); // intentional ADL
; 6278 :             ++_UFirst;
; 6279 :             ++_UNext;
; 6280 :             if (_UFirst == _UMid) {
; 6281 :                 _UMid = _UNext;
; 6282 :             }
; 6283 :         } while (_UNext != _ULast);
; 6284 :         _Seek_wrapped(_First, _UFirst);
; 6285 :         while (_UMid != _ULast) { // rotate subsequent cycles
; 6286 :             _UNext = _UMid;
; 6287 :             do {
; 6288 :                 swap(*_UFirst, *_UNext); // intentional ADL
; 6289 :                 ++_UFirst;
; 6290 :                 ++_UNext;
; 6291 :                 if (_UFirst == _UMid) {
; 6292 :                     _UMid = _UNext;
; 6293 :                 }
; 6294 :             } while (_UNext != _ULast);
; 6295 :         }
; 6296 :     }
; 6297 : 
; 6298 :     return _First;
; 6299 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$rotate@PEA_K@std@@YAPEA_KPEA_K00@Z ENDP		; std::rotate<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z PROC ; std::forward<bvh::TopDownBuildTask::WorkItem * &>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@AEAPEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAAEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z ENDP ; std::forward<bvh::TopDownBuildTask::WorkItem * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Construct_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z PROC ; std::_Construct_in_place<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &>, COMDAT

; 248  : #if _HAS_CXX20
; 249  :     if (_STD is_constant_evaluated()) {
; 250  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 251  :     } else
; 252  : #endif // _HAS_CXX20
; 253  :     {
; 254  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 255  :     }
; 256  : }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	ret	0
??$_Construct_in_place@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@std@@YAXAEAPEAUWorkItem@TopDownBuildTask@bvh@@0@Z ENDP ; std::_Construct_in_place<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\bvh\vector.hpp
;	COMDAT ??$?0V<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$cross@M@1@YA?AU01@AEBU01@0@Z@@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
??$?0V<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$cross@M@1@YA?AU01@AEBU01@0@Z@@Z PROC ; bvh::Vector<float,3>::Vector<float,3><`bvh::cross<float>'::`2'::<lambda_1>,0>, COMDAT

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm2, DWORD PTR [rdx+8]

; 54   :     }

	mov	rax, rcx

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movss	xmm1, DWORD PTR [rdx+4]
	movaps	xmm0, xmm2
	mulss	xmm1, DWORD PTR [rdx+20]
	mulss	xmm0, DWORD PTR [rdx+16]
	movss	xmm3, DWORD PTR [rdx+12]
	movss	xmm4, DWORD PTR [rdx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [rdx+20]
	mulss	xmm4, DWORD PTR [rdx+16]

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx], xmm1

; 165  :         return a[j] * b[k] - a[k] * b[j];

	movaps	xmm1, xmm3
	mulss	xmm3, DWORD PTR [rdx+4]
	mulss	xmm1, xmm2
	subss	xmm4, xmm3
	subss	xmm1, xmm0

; 52   :         for (size_t i = 0; i < N; ++i)
; 53   :             values[i] = f(i);

	movss	DWORD PTR [rcx+8], xmm4
	movss	DWORD PTR [rcx+4], xmm1

; 54   :     }

	ret	0
??$?0V<lambda_1>@?1???$cross@M@bvh@@YA?AU?$Vector@M$02@1@AEBU21@0@Z@$0A@@?$Vector@M$02@bvh@@QEAA@V<lambda_1>@?1???$cross@M@1@YA?AU01@AEBU01@0@Z@@Z ENDP ; bvh::Vector<float,3>::Vector<float,3><`bvh::cross<float>'::`2'::<lambda_1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout@PEA_K@std@@QEAAPEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout@PEA_K@std@@QEAAPEA_KXZ PROC ; std::_Uninitialized_backout<unsigned __int64 *>::_Release, COMDAT

; 1621 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1622 :         return _Last;
; 1623 :     }

	ret	0
?_Release@?$_Uninitialized_backout@PEA_K@std@@QEAAPEA_KXZ ENDP ; std::_Uninitialized_backout<unsigned __int64 *>::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$forward@$$T@std@@YA$$QEA$$TAEA$$T@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@$$T@std@@YA$$QEA$$TAEA$$T@Z PROC		; std::forward<std::nullptr_t>, COMDAT

; 1584 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1585 : }

	ret	0
??$forward@$$T@std@@YA$$QEA$$TAEA$$T@Z ENDP		; std::forward<std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_backward_memmove@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z PROC ; std::_Copy_backward_memmove<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 4834 :     // implement copy_backward-like function as memmove
; 4835 :     auto _FirstPtr              = _To_address(_First);
; 4836 :     auto _LastPtr               = _To_address(_Last);
; 4837 :     auto _DestPtr               = _To_address(_Dest);
; 4838 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4839 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4840 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4841 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rdx, rcx
	mov	rax, r8

; 4842 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	sub	rax, rdx
	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rax
	jmp	memmove
??$_Copy_backward_memmove@PEA_KPEA_K@std@@YAPEA_KPEA_K00@Z ENDP ; std::_Copy_backward_memmove<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$reverse@PEA_K@std@@YAXQEA_K0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$reverse@PEA_K@std@@YAXQEA_K0@Z PROC			; std::reverse<unsigned __int64 *>, COMDAT

; 6191 :     _Adl_verify_range(_First, _Last);
; 6192 :     auto _UFirst = _Get_unwrapped(_First);
; 6193 :     auto _ULast  = _Get_unwrapped(_Last);
; 6194 : #if _USE_STD_VECTOR_ALGORITHMS
; 6195 :     using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
; 6196 :     constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
; 6197 :         _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
; 6198 :     constexpr size_t _Nx                = sizeof(_Elem);
; 6199 : 
; 6200 :     if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
; 6201 : #if _HAS_CXX20
; 6202 :         if (!_STD is_constant_evaluated())
; 6203 : #endif // _HAS_CXX20
; 6204 :         {
; 6205 :             if constexpr (_Nx == 1) {
; 6206 :                 __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
; 6207 :             } else if constexpr (_Nx == 2) {
; 6208 :                 __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
; 6209 :             } else if constexpr (_Nx == 4) {
; 6210 :                 __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
; 6211 :             } else {
; 6212 :                 __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));

	jmp	__std_reverse_trivially_swappable_8
??$reverse@PEA_K@std@@YAXQEA_K0@Z ENDP			; std::reverse<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
;	COMDAT ??$addressof@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z PROC ; std::addressof<bvh::TopDownBuildTask::WorkItem *>, COMDAT

; 1607 :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 1608 : }

	ret	0
??$addressof@PEAUWorkItem@TopDownBuildTask@bvh@@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@@Z ENDP ; std::addressof<bvh::TopDownBuildTask::WorkItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$construct_at@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@$0A@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@AEAPEAU123@@Z
_TEXT	SEGMENT
_Location$ = 8
<_Args_0>$ = 16
??$construct_at@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@$0A@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@AEAPEAU123@@Z PROC ; std::construct_at<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &,0>, COMDAT

; 241  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx

; 242  : }

	ret	0
??$construct_at@PEAUWorkItem@TopDownBuildTask@bvh@@AEAPEAU123@$0A@@std@@YAPEAPEAUWorkItem@TopDownBuildTask@bvh@@QEAPEAU123@AEAPEAU123@@Z ENDP ; std::construct_at<bvh::TopDownBuildTask::WorkItem *,bvh::TopDownBuildTask::WorkItem * &,0>
_TEXT	ENDS
END
