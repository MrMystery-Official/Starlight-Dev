; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_R2UIAINBNodeDefault@@8			; UIAINBNodeDefault::`RTTI Base Class Array'
PUBLIC	??_R4UIAINBNodeDefault@@6B@			; UIAINBNodeDefault::`RTTI Complete Object Locator'
PUBLIC	??_R3UIAINBNodeDefault@@8			; UIAINBNodeDefault::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVUIAINBNodeDefault@@@8			; UIAINBNodeDefault `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@UIAINBNodeDefault@@8		; UIAINBNodeDefault::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7UIAINBNodeDefault@@6B@			; UIAINBNodeDefault::`vftable'
;	COMDAT ??_7UIAINBNodeDefault@@6B@
CONST	SEGMENT
??_7UIAINBNodeDefault@@6B@ DQ FLAT:??_R4UIAINBNodeDefault@@6B@ ; UIAINBNodeDefault::`vftable'
	DQ	FLAT:?Render@UIAINBNodeDefault@@UEAAXXZ
	DQ	FLAT:?RebuildNode@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?UpdateVisuals@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?PostProcessLinkedNodeInfo@UIAINBNodeBase@@UEAAXAEAUPin@1@AEAULinkedNodeInfo@AINBFile@@@Z
	DQ	FLAT:?PostProcessNode@UIAINBNodeBase@@UEAAXXZ
	DQ	FLAT:?GetNodeType@UIAINBNodeBase@@UEAA?AW4NodeType@1@XZ
	DQ	FLAT:?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
	DQ	FLAT:?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
	DQ	FLAT:?GetHeaderColor@UIAINBNodeDefault@@UEAA?AUImColor@@XZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@UIAINBNodeDefault@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UIAINBNodeDefault@@8 DD imagerel ??_R0?AVUIAINBNodeDefault@@@8 ; UIAINBNodeDefault::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3UIAINBNodeDefault@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUIAINBNodeDefault@@@8
data$rs	SEGMENT
??_R0?AVUIAINBNodeDefault@@@8 DQ FLAT:??_7type_info@@6B@ ; UIAINBNodeDefault `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVUIAINBNodeDefault@@', 00H
data$rs	ENDS
;	COMDAT ??_R3UIAINBNodeDefault@@8
rdata$r	SEGMENT
??_R3UIAINBNodeDefault@@8 DD 00H			; UIAINBNodeDefault::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2UIAINBNodeDefault@@8
rdata$r	ENDS
;	COMDAT ??_R4UIAINBNodeDefault@@6B@
rdata$r	SEGMENT
??_R4UIAINBNodeDefault@@6B@ DD 01H			; UIAINBNodeDefault::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVUIAINBNodeDefault@@@8
	DD	imagerel ??_R3UIAINBNodeDefault@@8
	DD	imagerel ??_R4UIAINBNodeDefault@@6B@
rdata$r	ENDS
;	COMDAT ??_R2UIAINBNodeDefault@@8
rdata$r	SEGMENT
??_R2UIAINBNodeDefault@@8 DD imagerel ??_R1A@?0A@EA@UIAINBNodeDefault@@8 ; UIAINBNodeDefault::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@UIAINBNodeBase@@8
	ORG $+3
PUBLIC	??$__std_find_trivial@IG@@YAPEAIPEAI0G@Z	; __std_find_trivial<unsigned int,unsigned short>
PUBLIC	??$_Could_compare_equal_to_value_type@PEAIG@std@@YA_NAEBG@Z ; std::_Could_compare_equal_to_value_type<unsigned int *,unsigned short>
PUBLIC	??$_Find_unchecked@PEAIG@std@@YAPEAIPEAIQEAIAEBG@Z ; std::_Find_unchecked<unsigned int *,unsigned short>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,unsigned short>
PUBLIC	?GetHeaderColor@UIAINBNodeDefault@@UEAA?AUImColor@@XZ ; UIAINBNodeDefault::GetHeaderColor
PUBLIC	?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ; UIAINBNodeDefault::RenderLinks
PUBLIC	?Render@UIAINBNodeDefault@@UEAAXXZ		; UIAINBNodeDefault::Render
PUBLIC	?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ ; UIAINBNodeDefault::GenerateNodeShapeInfo
PUBLIC	??0ImColor@@QEAA@XZ				; ImColor::ImColor
PUBLIC	??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeDefault::UIAINBNodeDefault
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z DD imagerel $LN20
	DD	imagerel $LN20+42
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD imagerel $LN160
	DD	imagerel $LN160+920
	DD	imagerel $unwind$?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Render@UIAINBNodeDefault@@UEAAXXZ DD imagerel $LN1530
	DD	imagerel $LN1530+5160
	DD	imagerel $unwind$?Render@UIAINBNodeDefault@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA+41
	DD	imagerel $unwind$?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ DD imagerel $LN1353
	DD	imagerel $LN1353+3508
	DD	imagerel $unwind$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD imagerel $LN50
	DD	imagerel $LN50+296
	DD	imagerel $unwind$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 04H
	DB	'>'
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 02H
	DB	0cH
	DD	imagerel ??1UIAINBNodeBase@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
	DD	imagerel $ip2state$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z DD 081911H
	DD	0b6419H
	DD	0a5419H
	DD	093419H
	DD	070155219H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ DB 01cH
	DB	0eeH
	DB	00H
	DB	089H, 07H
	DB	02H
	DB	'=', 03H
	DB	00H
	DB	0bcH
	DB	04H
	DB	'0'
	DB	06H
	DB	0b6H
	DB	08H
	DB	081H, 0cH
	DB	00H
	DB	'%', 08H
	DB	0cH
	DB	'.'
	DB	0eH
	DB	0b4H
	DB	010H
	DB	'Y', 0fH
	DB	0cH
	DB	0cH
	DB	00H
	DB	0cH
	DB	04H
	DB	0cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ DB 010H
	DB	0eH
	DD	imagerel ?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	02H
	DB	0ceH
	DD	imagerel ?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e1H
	DB	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
	DD	imagerel $ip2state$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ DD 01b4d11H
	DD	017c84dH
	DD	018b845H
	DD	019a83dH
	DD	01a9838H
	DD	01b8833H
	DD	01c782eH
	DD	01d682aH
	DD	0457426H
	DD	0446426H
	DD	0433426H
	DD	03c0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Render@UIAINBNodeDefault@@UEAAXXZ DB '>'
	DB	'-', 02H
	DB	00H
	DB	01dH, 06H
	DB	02H
	DB	'('
	DB	00H
	DB	0b9H, 07H
	DB	04H
	DB	','
	DB	00H
	DB	0b6H
	DB	06H
	DB	'0'
	DB	08H
	DB	'<'
	DB	0aH
	DB	'}', 02H
	DB	08H
	DB	09dH, 02H
	DB	00H
	DB	'm', 0cH
	DB	0cH
	DB	01cH
	DB	00H
	DB	0aaH
	DB	0eH
	DB	'0'
	DB	010H
	DB	'<'
	DB	012H
	DB	01dH, 07H
	DB	00H
	DB	0f1H, 02H
	DB	014H
	DB	'.'
	DB	00H
	DB	09cH
	DB	016H
	DB	'0'
	DB	018H
	DB	0c0H
	DB	01aH
	DB	0b9H, 02H
	DB	018H
	DB	'i', 04H
	DB	00H
	DB	0f1H, 02H
	DB	018H
	DB	'A', 03H
	DB	00H
	DB	089H, 03H
	DB	02H
	DB	'e', 04H
	DB	00H
	DB	0b5H, 04H
	DB	06H
	DB	0cH
	DB	00H
	DB	018H
	DB	016H
	DB	0cH
	DB	0eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Render@UIAINBNodeDefault@@UEAAXXZ DB 01aH
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	046H
	DD	imagerel ?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	0dH
	DB	02H
	DD	imagerel ?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	09dH
	DB	03H
	DD	imagerel ?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	036H
	DD	imagerel ?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA
	DB	02aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?Render@UIAINBNodeDefault@@UEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Render@UIAINBNodeDefault@@UEAAXXZ
	DD	imagerel $ip2state$?Render@UIAINBNodeDefault@@UEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Render@UIAINBNodeDefault@@UEAAXXZ DD 01d6619H
	DD	01ad855H
	DD	01bc84dH
	DD	01cb845H
	DD	01da83dH
	DD	01e9838H
	DD	01f8833H
	DD	020782eH
	DD	021682aH
	DD	04d7426H
	DD	04c6426H
	DD	04b3426H
	DD	0440126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?Render@UIAINBNodeDefault@@UEAAXXZ
	DD	0192H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z DD 0c2c01H
	DD	0a682cH
	DD	0170118H
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
;	COMDAT ??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z
_TEXT	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z PROC ; UIAINBNodeDefault::UIAINBNodeDefault, COMDAT

; 5    : {

$LN50:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx
	mov	rdi, rcx

; 4    :     : UIAINBNodeBase(&Node, EditorId, HeaderBackground, EnableFlow)

	call	??0UIAINBNodeBase@@QEAA@PEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ; UIAINBNodeBase::UIAINBNodeBase
	npad	1

; 5    : {

	lea	rax, OFFSET FLAT:??_7UIAINBNodeDefault@@6B@
	mov	QWORD PTR [rdi], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	xor	eax, eax
	mov	QWORD PTR [rdi+272], rax
	mov	QWORD PTR [rdi+280], rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 6    :     GenerateNodeShapeInfo();

	mov	rcx, rdi
	call	?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ ; UIAINBNodeDefault::GenerateNodeShapeInfo

; 7    :     if (Node.Name.find(".module") != std::string::npos) {

	add	rsi, 32					; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4357 :         return static_cast<size_type>(_Traits_find<_Traits>(

	mov	rax, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN15@UIAINBNode

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN15@UIAINBNode:

; 577  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	cmp	rax, 7
	jb	SHORT $LN2@UIAINBNode

; 578  :         // xpos cannot exist, report failure
; 579  :         // N4950 [string.view.find]/3 says:
; 580  :         // 1. _Start_at <= xpos
; 581  :         // 2. xpos + _Needle_size <= _Hay_size;
; 582  :         // therefore:
; 583  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 584  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 585  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 586  :         return static_cast<size_t>(-1);
; 587  :     }
; 588  : 
; 589  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 590  :         return _Start_at;
; 591  :     }
; 592  : 
; 593  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	lea	rbp, QWORD PTR [rax+rsi]

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rbp-6]
	sub	r8, rsi

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 46					; 0000002eH
	mov	rcx, rsi
	call	memchr
	mov	rbx, rax

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	je	SHORT $LN2@UIAINBNode
	npad	1
$LL22@UIAINBNode:

; 381  :         return __builtin_memcmp(_First1, _First2, _Count);

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07MPGOMNN@?4module@
	mov	rcx, rbx
	call	memcmp

; 600  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	test	eax, eax
	je	SHORT $LN43@UIAINBNode

; 594  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	inc	rbx

; 595  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	lea	r8, QWORD PTR [rbp-6]
	sub	r8, rbx

; 421  :             return __builtin_char_memchr(_First, _Ch, _Count);

	mov	edx, 46					; 0000002eH
	mov	rcx, rbx
	call	memchr
	mov	rbx, rax

; 596  :         if (!_Match_try) { // didn't find first character; report failure

	test	rax, rax
	jne	SHORT $LL22@UIAINBNode
$LN2@UIAINBNode:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 10   :         mHeaderColor = ImColor(70, 100, 130);

	mov	DWORD PTR [rdi+272], 1049398413		; 3e8c8c8dH
	mov	DWORD PTR [rdi+276], 1053345994		; 3ec8c8caH
	mov	DWORD PTR [rdi+280], 1057129091		; 3f028283H
$LN47@UIAINBNode:

; 11   :     }
; 12   : }

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rdi+284], xmm0
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN43@UIAINBNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 601  :             return static_cast<size_t>(_Match_try - _Haystack);

	sub	rbx, rsi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 7    :     if (Node.Name.find(".module") != std::string::npos) {

	cmp	rbx, -1
	je	SHORT $LN2@UIAINBNode

; 8    :         mHeaderColor = ImColor(90, 130, 90);

	mov	DWORD PTR [rdi+272], 1052030133		; 3eb4b4b5H
	mov	DWORD PTR [rdi+276], 1057129091		; 3f028283H
	mov	DWORD PTR [rdi+280], 1052030133		; 3eb4b4b5H

; 9    :     } else {

	jmp	SHORT $LN47@UIAINBNode
	int	3
??0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z ENDP ; UIAINBNodeDefault::UIAINBNodeDefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 64
Node$ = 72
EditorId$ = 80
HeaderBackground$ = 88
EnableFlow$dead$ = 96
?dtor$0@?0???0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA PROC ; `UIAINBNodeDefault::UIAINBNodeDefault'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1UIAINBNodeBase@@QEAA@XZ
?dtor$0@?0???0UIAINBNodeDefault@@QEAA@AEAUNode@AINBFile@@IAEAUTexture@TextureMgr@@AEA_N@Z@4HA ENDP ; `UIAINBNodeDefault::UIAINBNodeDefault'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
;	COMDAT ??0ImColor@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImColor@@QEAA@XZ PROC				; ImColor::ImColor, COMDAT

; 282  :     constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 2585 :     constexpr ImColor()                                             { }

	mov	rax, rcx
	ret	0
??0ImColor@@QEAA@XZ ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
;	COMDAT ?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ
_TEXT	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ PROC	; UIAINBNodeDefault::GenerateNodeShapeInfo, COMDAT

; 15   : {

$LN1353:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-264]
	sub	rsp, 480				; 000001e0H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$1$[rbp-256], rcx
	xor	r14d, r14d
	mov	DWORD PTR $T4[rsp], r14d

; 16   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 32 + ImGui::GetStyle().ItemSpacing.x;

	mov	rdx, QWORD PTR [rcx+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 15   : {

	mov	ebx, r14d
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	bts	ebx, 12
	lea	rcx, QWORD PTR $T17[rbp-256]
	test	ax, ax
	jne	SHORT $LN1059@GenerateNo

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1344@GenerateNo
$LN1059@GenerateNo:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1344@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	DWORD PTR $T4[rsp], ebx
	mov	rdi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

	lea	rax, QWORD PTR $T17[rbp-256]
	mov	rdx, QWORD PTR $T17[rbp-256]
	mov	r8, QWORD PTR $T17[rbp-232]
	cmp	r8, 16
	cmovae	rax, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	movss	xmm9, DWORD PTR __real@bf800000
	movss	xmm10, DWORD PTR __real@7f7fffff
	movss	xmm11, DWORD PTR __real@3f7fff58
	xorps	xmm7, xmm7
	test	rax, rax
	jne	SHORT $LN1041@GenerateNo
	xorps	xmm0, xmm0

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN1038@GenerateNo
$LN1041@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rdi+15696]
	lea	rdx, QWORD PTR text_size$9[rbp-256]
	mov	rcx, QWORD PTR [rdi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$9[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	r8, QWORD PTR $T17[rbp-232]
	mov	rdx, QWORD PTR $T17[rbp-256]
$LN1038@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 16   :     mNodeShapeInfo.FrameWidth = 8 * 2 + ImGui::CalcTextSize(mNode->GetName().c_str()).x + 32 + ImGui::GetStyle().ItemSpacing.x;

	movss	xmm8, DWORD PTR __real@41800000
	addss	xmm0, xmm8
	movss	xmm12, DWORD PTR __real@42000000
	addss	xmm0, xmm12
	addss	xmm0, DWORD PTR [rdi+14628]
	movss	DWORD PTR [rsi+20], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	r8, 16
	jb	SHORT $LN1067@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1067@GenerateNo:

; 4841 :         _My_data._Mysize = 0;

	movdqa	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	movdqu	XMMWORD PTR $T17[rbp-240], xmm0

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T17[rbp-256], r14b
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 18   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
$LN1350@GenerateNo:

; 19   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	lea	r9, OFFSET FLAT:__ImageBase
	mov	r11, -1
	lea	r10d, QWORD PTR [r11+23]
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	mov	rcx, QWORD PTR [rsi+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv6748[rbp-256], rdx
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 19   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+rdx*8]
	mov	r12, QWORD PTR [rax+rdx*8+8]
	cmp	r15, r12
	je	$LN1327@GenerateNo
	npad	4
$LL7@GenerateNo:

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN16@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T8[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T8[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T8[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+32]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+56], 16
	jb	SHORT $LN1005@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN1005@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1108@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN1011@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T8[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1027@GenerateNo
$LN1011@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1022@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN1021@GenerateNo
$LN1022@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN1021@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T8[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T8[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T8[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1027@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T8[rsp]
	or	ebx, 1
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1345@GenerateNo
$LN16@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN880@GenerateNo
	mov	ecx, DWORD PTR $LN1335@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN874@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T6[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T6[rsp+16], 3

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T6[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T6[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T6[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T6[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	SHORT $LN1346@GenerateNo
$LN875@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04PCGIEMCI@Bool@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	SHORT $LN1347@GenerateNo
$LN876@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05KKPNNHNB@Float@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	SHORT $LN1347@GenerateNo
$LN877@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 6
	lea	rdx, OFFSET FLAT:??_C@_06ENNEIMBA@String@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	SHORT $LN1347@GenerateNo
$LN878@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05PJCBICIO@Vec3f@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1347@GenerateNo
$LN879@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@EALHFGP@UserDefined@
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1347@GenerateNo
$LN880@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
$LN1347@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T6[rsp], xmm0
	mov	QWORD PTR $T6[rsp+16], r14
	mov	QWORD PTR $T6[rsp+24], r14
	lea	rcx, QWORD PTR $T6[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN1346@GenerateNo:
	bts	ebx, 11
	lea	rdi, QWORD PTR $T6[rsp]
	or	ebx, 2
$LN1345@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1110@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN698@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN698@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T19[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 9
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T19[rbp-256]
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	ebx, 10
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T12[rbp-240]
	mov	rdx, QWORD PTR $T12[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN636@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T12[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T12[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T12[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T12[rbp-256]
	jmp	SHORT $LN635@GenerateNo
$LN636@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T12[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN635@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T11[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T11[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T11[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T11[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T11[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	bts	ebx, 8
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T11[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T11[rbp-256]
	mov	rdx, QWORD PTR $T11[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN716@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN713@GenerateNo
$LN716@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$15[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$15[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$15[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T11[rbp-232]
	mov	rcx, QWORD PTR $T11[rbp-256]
$LN713@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN738@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN750@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN747@GenerateNo
$LN750@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN738@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T11[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T11[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T12[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN767@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T12[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN779@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN776@GenerateNo
$LN779@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN767@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T12[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T12[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T19[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN796@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T19[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN808@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN805@GenerateNo
$LN808@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN796@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 2
	je	SHORT $LN854@GenerateNo
	and	ebx, -3
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T6[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN854@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T6[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN866@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN863@GenerateNo
$LN866@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN854@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 21   :             Width += ImGui::CalcTextSize((Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 1
	je	SHORT $LN825@GenerateNo
	and	ebx, -2
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T8[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN825@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN837@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN834@GenerateNo
$LN837@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN825@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 22   :             Width += ImGui::GetStyle().ItemSpacing.x + 32;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]

; 23   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, rsi
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 22   :             Width += ImGui::GetStyle().ItemSpacing.x + 32;

	movaps	xmm2, xmm1
	addss	xmm2, xmm12
	addss	xmm2, xmm6

; 23   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm2

; 24   :             if (i == (int)AINBFile::ValueType::Vec3f) {

	cmp	r13b, 4
	jne	SHORT $LN14@GenerateNo

; 25   :                 Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm0, xmm1
$LN14@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 27   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 19   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL7@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1327@GenerateNo:

; 30   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) { 

	mov	rax, QWORD PTR [rsi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rax+200]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 30   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) { 

	mov	r15, QWORD PTR [rcx+rdx*8]
	mov	r12, QWORD PTR [rcx+rdx*8+8]
	cmp	r15, r12
	je	$LN1341@GenerateNo
$LL10@GenerateNo:

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	cmp	r13b, 5
	jne	$LN18@GenerateNo
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T7[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T7[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T7[rbp-232], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [r15+56]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r14, QWORD PTR [r15+40]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+64], 16
	jb	SHORT $LN594@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN594@GenerateNo:

; 2620 :         if (_Count > max_size()) {

	cmp	rsi, r8
	ja	$LN1112@GenerateNo

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	rsi, 16
	jae	SHORT $LN600@GenerateNo

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR $T7[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN616@GenerateNo
$LN600@GenerateNo:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15
	cmp	rdi, r8

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN611@GenerateNo

; 4716 :             return _Max;

	mov	rdi, r8
	jmp	SHORT $LN610@GenerateNo
$LN611@GenerateNo:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rdi, 22
	cmovb	rdi, r10
$LN610@GenerateNo:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	cmovb	rdx, r11
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T7[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T7[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T7[rbp-232], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r14
	mov	rcx, rax
	call	memcpy
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
$LN616@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	lea	rdi, QWORD PTR $T7[rsp]
	or	ebx, 4
	mov	rsi, QWORD PTR this$GSCopy$1$[rbp-256]
	xor	r14d, r14d
	jmp	$LN1348@GenerateNo
$LN18@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 210  :     switch (ValueType) {

	movzx	eax, r13b
	cmp	eax, 5
	ja	$LN261@GenerateNo
	mov	ecx, DWORD PTR $LN1334@GenerateNo[r9+rax*4]
	add	rcx, r9
	jmp	rcx
$LN255@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 3

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_03DBLNGNIM@Int@
	mov	WORD PTR $T5[rsp], ax
	movzx	eax, BYTE PTR ??_C@_03DBLNGNIM@Int@+2
	mov	BYTE PTR $T5[rsp+2], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+3], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 212  :         return "Int";

	jmp	$LN1349@GenerateNo
$LN256@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 4

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	DWORD PTR $T5[rsp], 1819242306		; 6c6f6f42H

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+4], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 214  :         return "Bool";

	jmp	$LN1349@GenerateNo
$LN257@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05KKPNNHNB@Float@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05KKPNNHNB@Float@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 216  :         return "Float";

	jmp	$LN1349@GenerateNo
$LN258@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 6

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_06ENNEIMBA@String@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_06ENNEIMBA@String@+4
	mov	WORD PTR $T5[rsp+4], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+6], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 218  :         return "String";

	jmp	$LN1349@GenerateNo
$LN259@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 5

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR ??_C@_05PJCBICIO@Vec3f@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, BYTE PTR ??_C@_05PJCBICIO@Vec3f@+4
	mov	BYTE PTR $T5[rsp+4], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+5], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 220  :         return "Vec3f";

	jmp	SHORT $LN1349@GenerateNo
$LN260@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 11

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movsd	xmm0, QWORD PTR ??_C@_0M@EALHFGP@UserDefined@
	movsd	QWORD PTR $T5[rsp], xmm0
	movzx	eax, WORD PTR ??_C@_0M@EALHFGP@UserDefined@+8
	mov	WORD PTR $T5[rsp+8], ax
	movzx	eax, BYTE PTR ??_C@_0M@EALHFGP@UserDefined@+10
	mov	BYTE PTR $T5[rsp+10], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+11], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeBase.cpp

; 222  :         return "UserDefined";

	jmp	SHORT $LN1349@GenerateNo
$LN261@GenerateNo:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T5[rsp], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T5[rsp+16], 7

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR ??_C@_07NBCGADJA@Unknown@
	mov	DWORD PTR $T5[rsp], eax
	movzx	eax, WORD PTR ??_C@_07NBCGADJA@Unknown@+4
	mov	WORD PTR $T5[rsp+4], ax
	movzx	eax, BYTE PTR ??_C@_07NBCGADJA@Unknown@+6
	mov	BYTE PTR $T5[rsp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T5[rsp+7], 0
$LN1349@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	mov	QWORD PTR $T5[rsp+24], 15
	bts	ebx, 7
	lea	rdi, QWORD PTR $T5[rsp]
	or	ebx, 8
$LN1348@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T4[rsp], ebx
	mov	rcx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, r8
	sub	rax, rcx
	cmp	rax, 2
	jb	$LN1120@GenerateNo

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN244@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN244@GenerateNo:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rax, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rcx
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 64					; 00000040H
	mov	DWORD PTR $T4[rsp], ebx

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rdi
	lea	r8, QWORD PTR $T18[rbp-256]
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	or	ebx, 32					; 00000020H
	mov	DWORD PTR $T4[rsp], ebx

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T14[rbp-240]
	mov	rdx, QWORD PTR $T14[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 1
	jb	SHORT $LN178@GenerateNo

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T14[rbp-240], rax

; 2226 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T14[rbp-256]

; 2227 :         if (_Large_string_engaged()) {

	cmp	rdx, 16
	cmovae	rax, QWORD PTR $T14[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	WORD PTR [rax+rcx], 41			; 00000029H

; 3277 :             return *this;

	lea	rax, QWORD PTR $T14[rbp-256]
	jmp	SHORT $LN177@GenerateNo
$LN178@GenerateNo:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	lea	rcx, QWORD PTR $T14[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN177@GenerateNo:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T13[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T13[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T13[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T13[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T13[rbp-240], xmm1

; 4998 :     return _STD move(_Left.append(_Right));

	mov	QWORD PTR [rax+16], r14
	mov	QWORD PTR [rax+24], 15
	mov	BYTE PTR [rax], 0
	or	ebx, 16
	mov	DWORD PTR $T4[rsp], ebx

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR $T13[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR $T13[rbp-256]
	mov	rdx, QWORD PTR $T13[rbp-232]
	cmp	rdx, 16
	cmovae	r8, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	r8, r8
	jne	SHORT $LN152@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm6, xmm7
	jmp	SHORT $LN149@GenerateNo
$LN152@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], r8
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rax+15696]
	lea	rdx, QWORD PTR text_size$16[rbp-256]
	mov	rcx, QWORD PTR [rax+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$16[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm6, eax
	cvtdq2ps xmm6, xmm6
	movss	DWORD PTR text_size$16[rbp-256], xmm6

; 5428 : 
; 5429 :     return text_size;

	mov	rdx, QWORD PTR $T13[rbp-232]
	mov	rcx, QWORD PTR $T13[rbp-256]
$LN149@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	addss	xmm6, xmm8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	cmp	rdx, 16
	jb	SHORT $LN103@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN112@GenerateNo
$LN115@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN103@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T13[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T13[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T14[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN73@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T14[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN82@GenerateNo
$LN85@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T14[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T14[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T14[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN132@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN144@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN141@GenerateNo
$LN144@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN132@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 8
	je	SHORT $LN566@GenerateNo
	and	ebx, -9
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T5[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN566@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T5[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN578@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN575@GenerateNo
$LN578@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN566@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 32   :             Width += ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x;

	test	bl, 4
	je	SHORT $LN537@GenerateNo
	and	ebx, -5
	mov	DWORD PTR $T4[rsp], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T7[rbp-232]
	cmp	rdx, 16

; 4832 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN537@GenerateNo

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T7[rsp]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN549@GenerateNo

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN546@GenerateNo
$LN549@GenerateNo:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN537@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 33   :             Width += 2 * ImGui::GetStyle().ItemSpacing.x + 32;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm1, DWORD PTR [rax+14628]
	addss	xmm1, xmm1
	addss	xmm1, xmm12
	addss	xmm1, xmm6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movss	xmm0, DWORD PTR [rsi+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 34   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 30   :         for (AINBFile::OutputEntry& Output : mNode->OutputParameters[i]) { 

	add	r15, 72					; 00000048H
	cmp	r15, r12
	mov	r8, 9223372036854775807			; 7fffffffffffffffH
	lea	r9, OFFSET FLAT:__ImageBase
	mov	r10d, 22
	lea	r11, QWORD PTR [r10-23]
	jne	$LL10@GenerateNo
	mov	rdx, QWORD PTR tv6748[rbp-256]
$LN1341@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rax+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 37   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rcx+rdx*8+8]
	mov	rdi, QWORD PTR [rcx+rdx*8]
	cmp	rdi, r14
	je	$LN2@GenerateNo
	xor	r15d, r15d
	npad	2
$LL13@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN44@GenerateNo

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN44@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5408 :     ImGuiContext& g = *GImGui;

	mov	rsi, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN51@GenerateNo

; 5419 :         return ImVec2(0.0f, font_size);

	movaps	xmm1, xmm7
	jmp	SHORT $LN48@GenerateNo
$LN51@GenerateNo:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r15
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm9
	movaps	xmm3, xmm10
	movss	xmm2, DWORD PTR [rsi+15696]
	lea	rdx, QWORD PTR text_size$10[rbp-256]
	mov	rcx, QWORD PTR [rsi+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$10[rbp-256]
	addss	xmm0, xmm11
	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR text_size$10[rbp-256], xmm1
$LN48@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 41   :             Width += GetParamValueWidth(i);

	movzx	edx, r13b
	mov	rcx, QWORD PTR this$GSCopy$1$[rbp-256]
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth

; 38   :             float Width = 8 * 2;
; 39   :             Width += ImGui::CalcTextSize(Immediate.Name.c_str()).x;

	addss	xmm1, xmm8

; 40   :             Width += ImGui::GetStyle().ItemSpacing.x;

	addss	xmm1, DWORD PTR [rsi+14628]

; 41   :             Width += GetParamValueWidth(i);

	addss	xmm0, xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\cmath

; 140  :     return _CSTD fmaxf(_Xx, _Yx);

	movaps	xmm1, xmm0
	mov	rsi, rcx
	movss	xmm0, DWORD PTR [rcx+20]
	call	QWORD PTR __imp_fmaxf
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 42   :             mNodeShapeInfo.FrameWidth = std::fmax(mNodeShapeInfo.FrameWidth, Width);

	movss	DWORD PTR [rsi+20], xmm0

; 37   :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	rdi, 200				; 000000c8H
	cmp	rdi, r14
	jne	$LL13@GenerateNo
$LN2@GenerateNo:

; 18   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r13b
	cmp	r13b, 6
	jae	SHORT $LN1331@GenerateNo
	xor	r14d, r14d
	jmp	$LN1350@GenerateNo
$LN747@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN776@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN805@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN863@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN834@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN112@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN82@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN141@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN575@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN546@GenerateNo:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1331@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 45   : }

	lea	r11, QWORD PTR [rsp+480]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1120@GenerateNo:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1108@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1110@GenerateNo:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1112@GenerateNo:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1343@GenerateNo:
	npad	3
$LN1335@GenerateNo:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 45   : }

	DD	$LN874@GenerateNo
	DD	$LN875@GenerateNo
	DD	$LN876@GenerateNo
	DD	$LN877@GenerateNo
	DD	$LN878@GenerateNo
	DD	$LN879@GenerateNo
$LN1334@GenerateNo:
	DD	$LN255@GenerateNo
	DD	$LN256@GenerateNo
	DD	$LN257@GenerateNo
	DD	$LN258@GenerateNo
	DD	$LN259@GenerateNo
	DD	$LN260@GenerateNo
?GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ ENDP	; UIAINBNodeDefault::GenerateNodeShapeInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN22@dtor$1
	and	DWORD PTR $T4[rbp], -2
	lea	rcx, QWORD PTR $T8[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN22@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN24@dtor$2
	and	DWORD PTR $T4[rbp], -3
	lea	rcx, QWORD PTR $T6[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN24@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$3
	lea	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$4
	lea	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN31@dtor$6
	and	DWORD PTR $T4[rbp], -5
	lea	rcx, QWORD PTR $T7[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN31@dtor$6:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$7
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T4[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN33@dtor$7
	and	DWORD PTR $T4[rbp], -9
	lea	rcx, QWORD PTR $T5[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN33@dtor$7:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$7@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$8
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 64
$T5 = 72
$T6 = 72
$T7 = 104
$T8 = 104
this$GSCopy$1$ = 136
text_size$9 = 144
text_size$10 = 144
$T11 = 152
$T12 = 184
$T13 = 216
$T14 = 248
text_size$15 = 280
text_size$16 = 288
tv6748 = 296
$T17 = 304
$T18 = 336
$T19 = 336
this$ = 528
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA PROC ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$9
	lea	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??GenerateNodeShapeInfo@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP ; `UIAINBNodeDefault::GenerateNodeShapeInfo'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
;	COMDAT ?Render@UIAINBNodeDefault@@UEAAXXZ
_TEXT	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?Render@UIAINBNodeDefault@@UEAAXXZ PROC			; UIAINBNodeDefault::Render, COMDAT

; 48   : {

$LN1530:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-328]
	sub	rsp, 544				; 00000220H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	xor	r15d, r15d
	mov	edi, r15d
	mov	DWORD PTR $T9[rsp], r15d

; 49   :     uint32_t CurrentId = mEditorId;

	mov	esi, DWORD PTR [rcx+16]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 283  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

	movaps	xmm0, XMMWORD PTR __xmm@41000000410000004100000041000000
	movups	XMMWORD PTR $T29[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 52   :     ed::PushStyleVar(ed::StyleVar_NodePadding, ImVec4(8, 8, 8, 8));

	lea	rdx, QWORD PTR $T29[rbp-256]
	call	?PushStyleVar@NodeEditor@ax@@YAXW4StyleVar@12@AEBUImVec4@@@Z ; ax::NodeEditor::PushStyleVar

; 53   :     ed::BeginNode(CurrentId++);

	mov	edx, esi
	inc	esi
	mov	DWORD PTR CurrentId$1$[rsp], esi
	mov	ebx, esi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 148  :     s_Editor->GetNodeBuilder().Begin(id);

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?Begin@NodeBuilder@Detail@NodeEditor@ax@@QEAAXUNodeId@34@@Z ; ax::NodeEditor::Detail::NodeBuilder::Begin
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 57   :     if (mEnableFlow) {

	mov	rax, QWORD PTR [r14+256]
	movss	xmm11, DWORD PTR __real@41000000
	lea	r12, QWORD PTR [r15-1]
	movss	xmm12, DWORD PTR __real@437f0000
	cmp	BYTE PTR [rax], r15b
	je	$LN25@Render

; 58   :         float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 59   :         ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 60   :         ImRect HeaderRect = DrawPin(CurrentId++, mFlowLinked, Alpha * 255, UIAINBNodeBase::PinType::Flow, ed::PinKind::Input, mNode->GetName());

	lea	rdx, QWORD PTR $T36[rbp-256]
	mov	rcx, QWORD PTR [r14+8]
	call	?GetName@Node@AINBFile@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; AINBFile::Node::GetName
	mov	r8d, esi
	inc	esi
	mov	DWORD PTR CurrentId$1$[rsp], esi
	mulss	xmm6, xmm12
	cvttss2si rcx, xmm6
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r15d
	mov	DWORD PTR [rsp+40], 6
	mov	DWORD PTR [rsp+32], ecx
	movzx	r9d, BYTE PTR [r14+264]
	lea	rdx, QWORD PTR HeaderRect$28[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin

; 61   :         ImGui::PopStyleVar();

	lea	ecx, QWORD PTR [r15+1]
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 62   :         mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = UIAINBNodeBase::PinType::Flow, .Node = mNode } });

	lea	rcx, QWORD PTR [r14+120]
	mov	DWORD PTR $T16[rsp], r15d
	mov	DWORD PTR $T16[rsp+4], 6
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR $T16[rsp+8], rax
	mov	QWORD PTR $T16[rsp+16], r15
	mov	DWORD PTR $T16[rsp+24], r12d
	mov	WORD PTR $T16[rsp+28], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T35[rbp-256], ebx
	movups	xmm0, XMMWORD PTR $T16[rsp]
	movups	XMMWORD PTR $T35[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T16[rsp+16]
	movups	XMMWORD PTR $T35[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T35[rbp-256]
	lea	rdx, QWORD PTR $T39[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 64   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm0, DWORD PTR HeaderRect$28[rbp-252]
	subss	xmm0, DWORD PTR __real@41600000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 64   :         mNodeShapeInfo.HeaderMin = ImVec2(HeaderRect.GetTL().x - 32 - ImGui::GetStyle().ItemSpacing.x - 1, HeaderRect.GetTL().y - 14);

	movss	xmm1, DWORD PTR HeaderRect$28[rbp-256]
	subss	xmm1, DWORD PTR __real@42000000
	subss	xmm1, DWORD PTR [rax+14628]
	subss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [r14+24], xmm1
	movss	DWORD PTR [r14+28], xmm0

; 65   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 2, HeaderRect.GetBR().y + 12);

	movss	xmm2, DWORD PTR HeaderRect$28[rbp-244]
	addss	xmm2, DWORD PTR __real@41400000
	addss	xmm1, DWORD PTR [r14+20]
	addss	xmm1, DWORD PTR __real@40000000

; 66   :     } else {

	jmp	$LN1521@Render
$LN25@Render:

; 67   :         ImGui::Text(mNode->GetName().c_str());

	mov	rdx, QWORD PTR [r14+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\AINB.cpp

; 2908 : 	if (this->Type == (uint16_t)AINBFile::NodeTypes::UserDefined)

	movzx	eax, WORD PTR [rdx]
	lea	rcx, QWORD PTR $T26[rbp-256]
	test	ax, ax
	jne	SHORT $LN1258@Render

; 2909 : 		return this->Name;

	add	rdx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN1522@Render
$LN1258@Render:

; 2910 : 
; 2911 : 	return AINBFile::NodeTypeToString((AINBFile::NodeTypes)this->Type);

	movzx	edx, ax
	call	?NodeTypeToString@AINBFile@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4NodeTypes@1@@Z ; AINBFile::NodeTypeToString
$LN1522@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 67   :         ImGui::Text(mNode->GetName().c_str());

	mov	edi, 32768				; 00008000H
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T26[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T26[rbp-232], 16
	cmovae	rcx, QWORD PTR $T26[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 67   :         ImGui::Text(mNode->GetName().c_str());

	call	?Text@ImGui@@YAXPEBDZZ			; ImGui::Text
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T26[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm0, DWORD PTR [rax+18632]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 68   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm0, DWORD PTR __real@41100000
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5637 :     return g.LastItemData.Rect.Min;

	movss	xmm1, DWORD PTR [rax+18628]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 68   :         mNodeShapeInfo.HeaderMin = ImVec2(ImGui::GetItemRectMin().x - 1 - ImGui::GetStyle().ItemSpacing.x, ImGui::GetItemRectMin().y - 9);

	subss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR [rax+14628]
	movss	DWORD PTR [r14+24], xmm1
	movss	DWORD PTR [r14+28], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5643 :     return g.LastItemData.Rect.Max;

	movss	xmm2, DWORD PTR [rax+18640]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 69   :         mNodeShapeInfo.HeaderMax = ImVec2(mNodeShapeInfo.HeaderMin.x + mNodeShapeInfo.FrameWidth + 10, ImGui::GetItemRectMax().y + 8);

	addss	xmm2, xmm11
	addss	xmm1, DWORD PTR [r14+20]
	addss	xmm1, DWORD PTR __real@41200000
$LN1521@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	r11d, 32				; 00000020H
	mov	rsi, r14
	mov	QWORD PTR $T30[rbp-256], r11
	mov	QWORD PTR $T41[rbp-256], r14
	mov	rax, r14
	movss	DWORD PTR [r14+r11], xmm1
	movss	DWORD PTR [rax+36], xmm2
	xorps	xmm10, xmm10
	mov	DWORD PTR $T19[rbp-256], 0
	mov	DWORD PTR $T19[rbp-252], 1090519040	; 41000000H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 72   :     ImGui::Dummy(ImVec2(0, 8));

	lea	rcx, QWORD PTR $T19[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy

; 73   : 
; 74   :     bool AddedHeader = false;

	xor	bl, bl
	mov	BYTE PTR AddedHeader$1$[rsp], bl

; 75   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r13b, r13b
	movss	xmm13, DWORD PTR __real@bf800000
	npad	15
$LL4@Render:

; 76   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	rcx, QWORD PTR [r14+8]
	movzx	eax, r13b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r12, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv8215[rbp-256], r12
	mov	rax, QWORD PTR [rcx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 76   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	mov	r15, QWORD PTR [rax+r12*8]
	mov	rax, QWORD PTR [rax+r12*8+8]
	mov	QWORD PTR <end>$L0$1$[rbp-256], rax
	cmp	r15, rax
	je	$LN2@Render
	mov	r14d, DWORD PTR CurrentId$1$[rsp]
	dec	r14d
	mov	DWORD PTR tv7700[rsp], r14d
	lea	rsi, QWORD PTR [r15+160]
$LL7@Render:

; 77   :             if (!AddedHeader) {

	test	bl, bl
	jne	SHORT $LN27@Render

; 78   :                 mNodeShapeInfo.HeaderMax.x += 8;

	mov	rax, QWORD PTR $T41[rbp-256]
	movss	xmm0, DWORD PTR [rax+r11]
	addss	xmm0, xmm11
	movss	DWORD PTR [rax+r11], xmm0

; 79   :                 AddedHeader = true;

	mov	BYTE PTR AddedHeader$1$[rsp], 1
$LN27@Render:

; 80   :             }
; 81   : 
; 82   :             // Input param (-> Name [Value])
; 83   :             float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 84   :             ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 85   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	cmp	r13b, 5
	jne	$LN43@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T15[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T15[rsp+16], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T15[rsp+24], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi-112]

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	r12, QWORD PTR [rsi-128]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-104], 16
	jb	SHORT $LN1163@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r12]
$LN1163@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1312@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN1169@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T15[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T15[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1185@Render
$LN1169@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1180@Render

; 4716 :             return _Max;

	mov	rbx, rax
	jmp	SHORT $LN1179@Render
$LN1180@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN1179@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T15[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T15[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T15[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
$LN1185@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 85   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	lea	rbx, QWORD PTR $T15[rsp]
	or	edi, 1
	mov	r14d, DWORD PTR tv7700[rsp]
	mov	r12, QWORD PTR tv8215[rbp-256]
	jmp	SHORT $LN1523@Render
$LN43@Render:
	movzx	r8d, r13b
	lea	rdx, QWORD PTR $T34[rbp-256]
	call	?GetValueTypeName@UIAINBNodeBase@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; UIAINBNodeBase::GetValueTypeName
	mov	rbx, rax
	or	edi, 2
$LN1523@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T9[rsp], edi
	mov	rax, QWORD PTR [rsi-144]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	sub	rcx, rax
	cmp	rcx, 2
	jb	$LN1313@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-136], 16
	jb	SHORT $LN1128@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN1128@Render:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rcx, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR $T49[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 14
	mov	DWORD PTR $T9[rsp], edi

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rbx
	lea	r8, QWORD PTR $T49[rbp-256]
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 13
	mov	DWORD PTR $T9[rsp], edi

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	lea	rcx, QWORD PTR $T25[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T22[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r10d, r10d
	mov	QWORD PTR $T22[rbp-240], r10

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T22[rbp-232], r10

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T22[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T22[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r10

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], r10b

; 4998 :     return _STD move(_Left.append(_Right));

	bts	edi, 12
	mov	DWORD PTR $T9[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 85   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	movzx	edx, r13b
	call	?ValueTypeToPinType@UIAINBNodeBase@@QEAA?AW4PinType@1@E@Z ; UIAINBNodeBase::ValueTypeToPinType
	mov	ebx, eax
	mulss	xmm6, xmm12
	cvttss2si rdx, xmm6
	cmp	WORD PTR [rsi-96], r10w
	jge	SHORT $LN1496@Render
	mov	rcx, QWORD PTR [rsi]
	cmp	QWORD PTR [rsi-8], rcx
	jne	SHORT $LN1496@Render
	xor	r9d, r9d
	jmp	SHORT $LN46@Render
$LN1496@Render:
	mov	r9b, 1
$LN46@Render:
	mov	eax, DWORD PTR CurrentId$1$[rsp]
	mov	r8d, eax
	inc	eax
	mov	DWORD PTR CurrentId$1$[rsp], eax
	inc	r14d
	mov	DWORD PTR tv7700[rsp], r14d
	lea	rax, QWORD PTR $T22[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r10d
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], edx
	lea	rdx, QWORD PTR $T43[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T25[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1059@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T25[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1059@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T25[rbp-240], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T25[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T25[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T49[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1051@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T49[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN1051@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 85   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	dil, 2
	je	SHORT $LN1148@Render
	and	edi, -3
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T34[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
	npad	1
$LN1148@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 85   :             DrawPin(CurrentId++, Input.NodeIndex >= 0 || !Input.Sources.empty(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Input, Input.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Input.Class : GetValueTypeName(i)) + ")");

	test	dil, 1
	je	SHORT $LN1145@Render
	and	edi, -2
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR $T15[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1145@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 86   :             ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	mov	rax, QWORD PTR [rax+72]
	lea	rcx, QWORD PTR [rax+r12*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 87   :             mInputParameters[i].push_back(CurrentId - 1);

	mov	DWORD PTR $T17[rsp], r14d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN1108@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], r14d

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN1107@Render
$LN1108@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T17[rsp]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN1107@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 88   :             mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Input, .Type = ValueTypeToPinType(i), .Node = mNode, .ObjectPtr = &Input } });

	mov	rax, QWORD PTR this$GSCopy$1$[rsp]
	lea	rcx, QWORD PTR [rax+120]
	mov	DWORD PTR $T14[rsp], 0
	mov	DWORD PTR $T14[rsp+4], ebx
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR $T14[rsp+8], rax
	mov	QWORD PTR $T14[rsp+16], r15
	mov	rax, -1
	mov	DWORD PTR $T14[rsp+24], eax
	mov	WORD PTR $T14[rsp+28], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	DWORD PTR $T33[rbp-256], r14d
	movups	xmm0, XMMWORD PTR $T14[rsp]
	movups	XMMWORD PTR $T33[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T14[rsp+16]
	movups	XMMWORD PTR $T33[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T33[rbp-256]
	lea	rdx, QWORD PTR $T45[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 89   :             ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm10
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 90   :             if (Input.NodeIndex == -1 && Input.Sources.empty()) { // Input param is not linked to any output param, so the value has to be set directly

	cmp	WORD PTR [rsi-96], -1
	jne	$LN1495@Render
	mov	rax, QWORD PTR [rsi]
	cmp	QWORD PTR [rsi-8], rax
	jne	$LN1495@Render
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T40[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T40[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T40[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi-144]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r12, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi-136], 16
	jb	SHORT $LN1205@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r12, QWORD PTR [r15]
$LN1205@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1314@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T40[rbp-232], 15
	cmp	r14, 16
	jae	SHORT $LN1211@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T40[rbp-240], r14

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r12]
	movups	XMMWORD PTR $T40[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN1219@Render
$LN1211@Render:

; 2648 :         }
; 2649 : 
; 2650 :         _My_data._Myres               = _BUF_SIZE - 1;
; 2651 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, r14
	lea	rcx, QWORD PTR $T40[rbp-256]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	rbx, rax

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rax
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T40[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T40[rbp-240], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T40[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r12
	mov	rcx, rax
	call	memcpy
$LN1219@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 91   :                 DrawParameterValue(static_cast<AINBFile::ValueType>(i), Input.Name, CurrentId, (void*)&Input.Value);

	lea	rax, QWORD PTR [rsi-56]
	movzx	edx, r13b
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR CurrentId$1$[rsp]
	lea	r8, QWORD PTR $T40[rbp-256]
	mov	rcx, QWORD PTR this$GSCopy$1$[rsp]
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 92   :             } else {

	mov	r14d, DWORD PTR tv7700[rsp]
	mov	r12, QWORD PTR tv8215[rbp-256]
	jmp	SHORT $LN5@Render
$LN1495@Render:

; 93   :                 if (i == (int)AINBFile::ValueType::UserDefined) {

	cmp	r13b, 5
	jne	SHORT $LN30@Render

; 94   :                     ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine

; 95   :                 }

	jmp	SHORT $LN5@Render
$LN30@Render:

; 98   :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	movzx	edx, r13b
	mov	rcx, QWORD PTR this$GSCopy$1$[rsp]
	call	?GetParamValueWidth@UIAINBNodeBase@@QEAAME@Z ; UIAINBNodeBase::GetParamValueWidth
	movss	DWORD PTR $T38[rbp-256], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	DWORD PTR $T38[rbp-252], 0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 98   :                     ImGui::Dummy(ImVec2(GetParamValueWidth(i), 0));

	lea	rcx, QWORD PTR $T38[rbp-256]
	call	?Dummy@ImGui@@YAXAEBUImVec2@@@Z		; ImGui::Dummy
$LN5@Render:

; 76   :         for (AINBFile::InputEntry& Input : mNode->InputParameters[i]) {

	add	r15, 240				; 000000f0H
	add	rsi, 240				; 000000f0H
	cmp	r15, QWORD PTR <end>$L0$1$[rbp-256]
	movzx	ebx, BYTE PTR AddedHeader$1$[rsp]
	mov	r11, QWORD PTR $T30[rbp-256]
	jne	$LL7@Render
	mov	r14, QWORD PTR this$GSCopy$1$[rsp]
$LN2@Render:

; 75   :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r13b
	cmp	r13b, 6
	jb	$LL4@Render

; 99   :                 }
; 100  :             }
; 101  :         }
; 102  :     }
; 103  : 
; 104  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r12b, r12b
	mov	rdx, -8198552921648689607		; 8e38e38e38e38e39H
	movss	xmm8, DWORD PTR __real@7f7fffff
	movss	xmm9, DWORD PTR __real@3f7fff58
	movss	xmm7, DWORD PTR __real@41900000
	xor	esi, esi
$LL10@Render:

; 105  :         for (uint16_t j = 0; j < mNode->OutputParameters[i].size(); j++) {

	mov	WORD PTR j$1$[rsp], si
	mov	r8, QWORD PTR [r14+8]
	movzx	eax, r12b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	r13, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [r8+200]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+r13*8+8]
	sub	rcx, QWORD PTR [rax+r13*8]
	sar	rcx, 3
	imul	rcx, rdx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 105  :         for (uint16_t j = 0; j < mNode->OutputParameters[i].size(); j++) {

	test	rcx, rcx
	je	$LN8@Render
	mov	rdx, rsi
	mov	eax, DWORD PTR CurrentId$1$[rsp]
	dec	eax
	mov	DWORD PTR tv7692[rsp], eax
$LL13@Render:

; 106  :             if (!AddedHeader) {

	test	bl, bl
	jne	SHORT $LN32@Render

; 107  :                 mNodeShapeInfo.HeaderMax.x += 8;

	movss	xmm0, DWORD PTR [r14+r11]
	addss	xmm0, xmm11
	movss	DWORD PTR [r14+r11], xmm0

; 108  :                 AddedHeader = true;

	mov	BYTE PTR AddedHeader$1$[rsp], 1
$LN32@Render:

; 109  :             }
; 110  : 
; 111  :             AINBFile::OutputEntry& Output = mNode->OutputParameters[i][j];

	mov	rax, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rax+200]
	lea	rcx, QWORD PTR [rdx+rdx*8]
	mov	rax, QWORD PTR [rax+r13*8]
	lea	r15, QWORD PTR [rax+rcx*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10264:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]

; 10265:     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	movss	xmm6, DWORD PTR [rcx+312]
	subss	xmm6, DWORD PTR [rcx+80]
	addss	xmm6, DWORD PTR [rcx+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 113  :             ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (18 + ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm6, DWORD PTR [r14+20]
	cmp	r12b, 5
	jne	$LN47@Render
	lea	rsi, QWORD PTR [r15+40]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T21[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	eax, eax
	mov	QWORD PTR $T21[rbp-240], rax

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T21[rbp-232], rax

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN962@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN962@Render:

; 2620 :         if (_Count > max_size()) {

	mov	r9, 9223372036854775807			; 7fffffffffffffffH
	cmp	r14, r9
	ja	$LN1317@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN968@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T21[rbp-240], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T21[rbp-232], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T21[rbp-256], xmm0

; 2647 :             return;

	jmp	SHORT $LN984@Render
$LN968@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, r9

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN979@Render

; 4716 :             return _Max;

	mov	rbx, r9
	jmp	SHORT $LN978@Render
$LN979@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	r10d, 22
	cmovb	rbx, r10
$LN978@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T21[rbp-256], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T21[rbp-240], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T21[rbp-232], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN984@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 113  :             ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (18 + ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	lea	rbx, QWORD PTR $T21[rbp-256]
	or	edi, 4
	jmp	SHORT $LN1524@Render
$LN47@Render:
	movzx	r8d, r12b
	lea	rdx, QWORD PTR $T13[rsp]
	call	?GetValueTypeName@UIAINBNodeBase@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; UIAINBNodeBase::GetValueTypeName
	mov	rbx, rax
	or	edi, 8
$LN1524@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T9[rsp], edi
	mov	rdx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rdx
	cmp	rax, 2
	jb	$LN1318@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN927@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN927@Render:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	lea	rsi, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rdx
	lea	rcx, QWORD PTR $T48[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 11
	mov	DWORD PTR $T9[rsp], edi

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rbx
	lea	r8, QWORD PTR $T48[rbp-256]
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 10
	mov	DWORD PTR $T9[rsp], edi

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	lea	rcx, QWORD PTR $T24[rbp-256]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T27[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	xor	r14d, r14d
	mov	QWORD PTR $T27[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T27[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T27[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T27[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r14

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], r14b

; 4998 :     return _STD move(_Left.append(_Right));

	bts	edi, 9
	mov	DWORD PTR $T9[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 3085 :     return GImGui->Style;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T27[rbp-256]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR $T27[rbp-232], 16
	cmovae	rax, QWORD PTR $T27[rbp-256]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5418 :     if (text == text_display_end)

	test	rax, rax
	jne	SHORT $LN858@Render
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 270  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movaps	xmm0, xmm10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 5419 :         return ImVec2(0.0f, font_size);

	jmp	SHORT $LN855@Render
$LN858@Render:

; 5420 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r14
	mov	QWORD PTR [rsp+40], rax
	movss	DWORD PTR [rsp+32], xmm13
	movaps	xmm3, xmm8
	movss	xmm2, DWORD PTR [rbx+15696]
	lea	rdx, QWORD PTR text_size$37[rbp-256]
	mov	rcx, QWORD PTR [rbx+15688]
	call	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA

; 5421 : 
; 5422 :     // Round
; 5423 :     // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
; 5424 :     // FIXME: Investigate using ceilf or e.g.
; 5425 :     // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
; 5426 :     // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
; 5427 :     text_size.x = IM_FLOOR(text_size.x + 0.99999f);

	movss	xmm0, DWORD PTR text_size$37[rbp-256]
	addss	xmm0, xmm9
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR text_size$37[rbp-256], xmm0
$LN855@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 113  :             ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (18 + ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	addss	xmm0, xmm7
	addss	xmm0, xmm7
	addss	xmm0, DWORD PTR [rbx+14628]
	subss	xmm6, xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_internal.h

; 3023 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	rax, QWORD PTR [rbx+16408]
	mov	BYTE PTR [rax+237], 1
	mov	rax, QWORD PTR [rbx+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10285:     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm0, DWORD PTR [rax+80]
	subss	xmm0, DWORD PTR [rax+184]
	addss	xmm0, xmm6
	movss	DWORD PTR [rax+312], xmm0

; 10286:     //window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
; 10287:     window->DC.IsSetPos = true;

	mov	BYTE PTR [rax+377], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T27[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN835@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T27[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN835@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T27[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T27[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T27[rbp-256], r14b

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T24[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN827@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T24[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN827@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T24[rbp-240], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T24[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T24[rbp-256], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T48[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN819@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T48[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1
$LN819@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 113  :             ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (18 + ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	test	dil, 8
	je	SHORT $LN1036@Render
	and	edi, -9
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T13[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN1035@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T13[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1035@Render:

; 4841 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T13[rsp+16], r14

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T13[rsp+24], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T13[rsp], 0
$LN1036@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 113  :             ImGui::SetCursorPosX(ImGui::GetCursorPosX() + mNodeShapeInfo.FrameWidth - (18 + ImGui::CalcTextSize((Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")").c_str()).x + 18 + ImGui::GetStyle().ItemSpacing.x));

	test	dil, 4
	je	SHORT $LN1043@Render
	and	edi, -5
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T21[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN1043@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T21[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN1043@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 114  :             float Alpha = ImGui::GetStyle().Alpha;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	movss	xmm6, DWORD PTR [rax+14552]

; 115  :             ImGui::PushStyleVar(ImGuiStyleVar_Alpha, Alpha);

	movaps	xmm1, xmm6
	xor	ecx, ecx
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	cmp	r12b, 5
	jne	$LN49@Render
	lea	rsi, QWORD PTR [r15+40]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T12[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T12[rsp+16], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T12[rsp+24], r14

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r14, QWORD PTR [rsi+16]

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rsi+24], 16
	jb	SHORT $LN1002@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN1002@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r14, rax
	ja	$LN1319@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	cmp	r14, 16
	jae	SHORT $LN1008@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rsp+16], r14

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T12[rsp+24], 15

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [rsi]
	movups	XMMWORD PTR $T12[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN1024@Render
$LN1008@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rbx, r14
	or	rbx, 15
	cmp	rbx, rax

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN1019@Render

; 4716 :             return _Max;

	mov	rbx, rax
	jmp	SHORT $LN1018@Render
$LN1019@Render:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

	cmp	rbx, 22
	mov	eax, 22
	cmovb	rbx, rax
$LN1018@Render:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rbx
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T12[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T12[rsp+16], r14

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T12[rsp+24], rbx

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [r14+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, rsi
	mov	rcx, rax
	call	memcpy
$LN1024@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	lea	rbx, QWORD PTR $T12[rsp]
	or	edi, 16
	xor	r14d, r14d
	lea	rsi, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI@
	jmp	SHORT $LN1525@Render
$LN49@Render:
	movzx	r8d, r12b
	lea	rdx, QWORD PTR $T47[rbp-256]
	call	?GetValueTypeName@UIAINBNodeBase@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@E@Z ; UIAINBNodeBase::GetValueTypeName
	mov	rbx, rax
	or	edi, 32					; 00000020H
$LN1525@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

	mov	DWORD PTR $T9[rsp], edi
	mov	rdx, QWORD PTR [r15+16]

; 4939 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	sub	rax, rdx
	cmp	rax, 2
	jb	$LN1320@Render

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r9, r15

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [r15+24], 16
	jb	SHORT $LN849@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [r15]
$LN849@Render:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

	mov	QWORD PTR [rsp+48], 2
	mov	QWORD PTR [rsp+40], rsi
	mov	QWORD PTR [rsp+32], rdx
	lea	rcx, QWORD PTR $T32[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEBD_K23@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 8
	mov	DWORD PTR $T9[rsp], edi

; 4980 :     return {_String_constructor_concat_tag{}, _Left, _Right};

	mov	r9, rbx
	lea	r8, QWORD PTR $T32[rbp-256]
	lea	rcx, QWORD PTR $T20[rbp-256]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	bts	edi, 7
	mov	DWORD PTR $T9[rsp], edi

; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR $T20[rbp-240]
	mov	r8, QWORD PTR $T20[rbp-232]
	mov	rax, r8
	sub	rax, rdx

; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	lea	rcx, QWORD PTR $T20[rbp-256]
	cmp	rax, 1
	jb	SHORT $LN755@Render

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR $T20[rbp-240], rax

; 2227 :         if (_Large_string_engaged()) {

	cmp	r8, 16
	cmovae	rcx, QWORD PTR $T20[rbp-256]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	movzx	eax, WORD PTR ??_C@_01PKGAHCOL@?$CJ@
	mov	BYTE PTR [rcx+rdx], al

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 3277 :             return *this;

	lea	rax, QWORD PTR $T20[rbp-256]
	jmp	SHORT $LN754@Render
$LN755@Render:

; 3278 :         }
; 3279 : 
; 3280 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 1
	lea	r9, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ@
	mov	edx, 1
	call	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV34@QEBD_K@Z@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEBD0@Z@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned __int64>
$LN754@Render:
	xorps	xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR $T23[rbp-256], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T23[rbp-240], r14

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T23[rbp-232], r14

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T23[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T23[rbp-240], xmm1

; 4821 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], r14

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0

; 4998 :     return _STD move(_Left.append(_Right));

	or	edi, 64					; 00000040H
	mov	DWORD PTR $T9[rsp], edi
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	movzx	edx, r12b
	call	?ValueTypeToPinType@UIAINBNodeBase@@QEAA?AW4PinType@1@E@Z ; UIAINBNodeBase::ValueTypeToPinType
	mov	ebx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	r14, QWORD PTR this$GSCopy$1$[rsp]
	mov	rcx, QWORD PTR [r14+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility

; 124  :         return const_cast<_Ty*>(

	movzx	esi, WORD PTR j$1$[rsp]
	mov	r8d, esi
	mov	rdx, QWORD PTR [rcx+r13*8+8]
	mov	rcx, QWORD PTR [rcx+r13*8]
	call	__std_find_trivial_4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r14+96]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	cmp	rax, QWORD PTR [rcx+r13*8+8]
	setne	r9b
	mov	eax, DWORD PTR CurrentId$1$[rsp]
	mov	r8d, eax
	inc	eax
	mov	DWORD PTR CurrentId$1$[rsp], eax
	inc	DWORD PTR tv7692[rsp]
	mulss	xmm6, xmm12
	cvttss2si rax, xmm6
	lea	rcx, QWORD PTR $T23[rbp-256]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], 1
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], eax
	lea	rdx, QWORD PTR $T44[rbp-256]
	call	?DrawPin@UIAINBNodeBase@@QEAA?AUImRect@@I_NIW4PinType@1@W4PinKind@NodeEditor@ax@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; UIAINBNodeBase::DrawPin
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T20[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN645@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T20[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN657@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN654@Render
$LN657@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN645@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T20[rbp-240], rax

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T20[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T20[rbp-256], al

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T32[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN691@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T32[rbp-256]
	mov	rax, rcx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN703@Render

; 157  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 158  : 
; 159  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN700@Render
$LN703@Render:

; 265  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN691@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	test	dil, 32					; 00000020H
	je	SHORT $LN940@Render
	and	edi, -33				; ffffffffffffffdfH
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T47[rbp-232]
	cmp	r8, 16
	jb	SHORT $LN939@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T47[rbp-256]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN939@Render:

; 4841 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T47[rbp-240], rax

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T47[rbp-232], 15

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T47[rbp-256], al
$LN940@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 116  :             DrawPin(CurrentId++, std::find(mLinkedOutputParams[i].begin(), mLinkedOutputParams[i].end(), j) != mLinkedOutputParams[i].end(), Alpha * 255, ValueTypeToPinType(i), ed::PinKind::Output, Output.Name + " (" + (i == (int)AINBFile::ValueType::UserDefined ? Output.Class : GetValueTypeName(i)) + ")");

	test	dil, 16
	je	SHORT $LN947@Render
	and	edi, -17
	mov	DWORD PTR $T9[rsp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

	mov	r8, QWORD PTR $T12[rsp+24]
	cmp	r8, 16
	jb	SHORT $LN947@Render

; 4833 :             _ASAN_STRING_REMOVE(*this);
; 4834 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 4835 :             auto& _Al          = _Getal();
; 4836 :             _Destroy_in_place(_My_data._Bx._Ptr);
; 4837 :             _My_data._Activate_SSO_buffer();
; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	r8
	mov	rdx, QWORD PTR $T12[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN947@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 117  :             ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r14+48]
	lea	rcx, QWORD PTR [rax+r13*8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 118  :             mOutputParameters[i].push_back(CurrentId - 1);

	mov	eax, DWORD PTR tv7692[rsp]
	mov	DWORD PTR $T18[rbp-256], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN673@Render

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [rdx], eax

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN672@Render
$LN673@Render:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T18[rbp-256]
	call	??$_Emplace_reallocate@I@?$vector@IV?$allocator@I@std@@@std@@AEAAPEAIQEAI$$QEAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Emplace_reallocate<unsigned int>
$LN672@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 119  :             mPins.insert({ CurrentId - 1, Pin { .Kind = ed::PinKind::Output, .Type = ValueTypeToPinType(i), .Node = mNode, .ObjectPtr = &Output, .ParameterIndex = j } });

	lea	rcx, QWORD PTR [r14+120]
	mov	DWORD PTR $T11[rsp], 1
	mov	DWORD PTR $T11[rsp+4], ebx
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR $T11[rsp+8], rax
	mov	QWORD PTR $T11[rsp+16], r15
	mov	DWORD PTR $T11[rsp+24], esi
	mov	WORD PTR $T11[rsp+28], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	eax, DWORD PTR tv7692[rsp]
	mov	DWORD PTR $T31[rbp-256], eax
	movups	xmm0, XMMWORD PTR $T11[rsp]
	movups	XMMWORD PTR $T31[rbp-248], xmm0
	movups	xmm1, XMMWORD PTR $T11[rsp+16]
	movups	XMMWORD PTR $T31[rbp-232], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T31[rbp-256]
	lea	rdx, QWORD PTR $T42[rbp-256]
	call	??$emplace@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IUPin@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIUPin@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIUPin@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Pin,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Pin> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 105  :         for (uint16_t j = 0; j < mNode->OutputParameters[i].size(); j++) {

	movzx	r9d, WORD PTR j$1$[rsp]
	inc	r9w
	mov	WORD PTR j$1$[rsp], r9w
	mov	r8, QWORD PTR [r14+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r8+200]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+r13*8+8]
	sub	rcx, QWORD PTR [rax+r13*8]
	sar	rcx, 3
	mov	rax, -8198552921648689607		; 8e38e38e38e38e39H
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 105  :         for (uint16_t j = 0; j < mNode->OutputParameters[i].size(); j++) {

	movzx	edx, r9w
	cmp	rdx, rcx
	movzx	ebx, BYTE PTR AddedHeader$1$[rsp]
	mov	r11, QWORD PTR $T30[rbp-256]
	jb	$LL13@Render
	xor	esi, esi
	mov	rdx, rax
$LN8@Render:

; 99   :                 }
; 100  :             }
; 101  :         }
; 102  :     }
; 103  : 
; 104  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r12b
	cmp	r12b, 6
	jae	SHORT $LN1502@Render
	movzx	ebx, BYTE PTR AddedHeader$1$[rsp]
	mov	r11, QWORD PTR $T30[rbp-256]
	jmp	$LL10@Render
$LN654@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN700@Render:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN1502@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.cpp

; 10258:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16408]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2539 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	movss	xmm7, DWORD PTR [rcx+316]
	subss	xmm7, DWORD PTR [rcx+84]
	movss	xmm6, DWORD PTR [rcx+312]
	subss	xmm6, DWORD PTR [rcx+80]

; 2538 : static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

	addss	xmm7, DWORD PTR [rcx+188]
	addss	xmm6, DWORD PTR [rcx+184]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 124  :     bool HasImmediate = false;

	mov	BYTE PTR HasImmediate$1$[rsp], 0

; 125  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	dl, dl
	mov	r9, QWORD PTR [r8+152]
	npad	3
$LL16@Render:

; 126  :         if (!mNode->ImmediateParameters[i].empty()) {

	movzx	eax, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 126  :         if (!mNode->ImmediateParameters[i].empty()) {

	mov	rax, QWORD PTR [r9+rcx*8+8]
	cmp	QWORD PTR [r9+rcx*8], rax
	jne	SHORT $LN1321@Render

; 125  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	dl
	cmp	dl, 6
	jb	SHORT $LL16@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2620 :         if (_Count > max_size()) {

	jmp	SHORT $LN34@Render
$LN1321@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 127  :             HasImmediate = true;

	mov	BYTE PTR HasImmediate$1$[rsp], 1

; 128  :             break;
; 129  :         }
; 130  :     }
; 131  : 
; 132  :     if (HasImmediate)
; 133  :         ImGui::NewLine();

	call	?NewLine@ImGui@@YAXXZ			; ImGui::NewLine
$LN34@Render:

; 134  : 
; 135  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r8b, r8b
	mov	BYTE PTR i$1$[rsp], r8b
	lea	r15, OFFSET FLAT:__ImageBase
$LL19@Render:

; 136  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	rdx, QWORD PTR [r14+8]
	movzx	eax, r8b
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdx+152]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 136  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	mov	r14, QWORD PTR [rax+rcx*8]
	mov	r13, QWORD PTR [rax+rcx*8+8]
	mov	rdi, QWORD PTR this$GSCopy$1$[rsp]
	cmp	r14, r13
	je	$LN17@Render
	lea	rbx, QWORD PTR [r14+64]
	movzx	r12d, r8b
$LL22@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	rcx, r14

; 2236 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rbx-40], 16
	jb	SHORT $LN1498@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r14]
$LN1498@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui_widgets.cpp

; 256  :     TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	call	?TextEx@ImGui@@YAXPEBD0H@Z		; ImGui::TextEx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 139  :             ImGui::SameLine();

	movaps	xmm1, xmm13
	movaps	xmm0, xmm10
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 803  :         return static_cast<size_t>(_Which);

	movsx	rdx, BYTE PTR [rbx]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 141  :             bool ValueTypeMismatch = Immediate.ValueType != Immediate.Value.index();

	movsxd	rax, DWORD PTR [rbx+8]

; 142  :             if (ValueTypeMismatch) {

	cmp	rax, rdx
	je	$LN191@Render

; 143  :                 switch (i) {

	mov	ecx, r12d
	test	r12d, r12d
	je	$LN36@Render
	sub	ecx, 1
	je	$LN38@Render
	sub	ecx, 1
	je	$LN37@Render
	sub	ecx, 1
	je	SHORT $LN39@Render
	cmp	ecx, 1
	jne	$LN191@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 4
	jne	SHORT $LN193@Render

; 1032 :             auto& _Target = _STD _Variant_raw_get<_TargetIdx>(_Storage());
; 1033 :             _Target       = static_cast<_Ty&&>(_Obj);

	movaps	xmm0, xmm10
	unpcklps xmm0, xmm10
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm10

; 1034 :         } else {

	jmp	$LN191@Render
$LN193@Render:

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1512@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN213@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN231@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 391  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	movaps	xmm0, xmm10
	unpcklps xmm0, xmm10
	movsd	QWORD PTR [rbx-32], xmm0
	movss	DWORD PTR [rbx-24], xmm10

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 4
	jmp	$LN191@Render
$LN39@Render:

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 3
	jne	SHORT $LN281@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3395 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rcx, QWORD PTR [rbx-32]
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1034 :         } else {

	jmp	$LN191@Render
$LN281@Render:
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	movups	XMMWORD PTR _Temp$46[rbp-256], xmm0

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR _Temp$46[rbp-240], rsi

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Temp$46[rbp-232], 15

; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR _Temp$46[rbp-256], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1511@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN346@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN364@Render:

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR _Temp$46[rbp-256]
	movups	XMMWORD PTR [rbx-32], xmm0
	movups	xmm1, XMMWORD PTR _Temp$46[rbp-240]
	movups	XMMWORD PTR [rbx-16], xmm1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 3
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 155  :                     break;

	jmp	SHORT $LN191@Render
$LN37@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 2
	je	SHORT $LN1526@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1510@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN572@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN590@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 431  :         : _Head(static_cast<_Types&&>(_Args)...) {} // initialize _Head with _Args...

	mov	DWORD PTR [rbx-32], esi

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 2
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 149  :                     break;

	jmp	SHORT $LN191@Render
$LN38@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	cmp	dl, 1
	je	SHORT $LN1527@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1509@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN518@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN536@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 1
$LN1527@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 152  :                     break;

	mov	rcx, -32				; ffffffffffffffe0H
	mov	rax, rbx
	mov	BYTE PTR [rbx+rcx], 0
	jmp	SHORT $LN191@Render
$LN36@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 1031 :         if (index() == _TargetIdx) {

	test	dl, dl
	je	SHORT $LN1526@Render

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

	mov	eax, DWORD PTR $LN1508@Render[r15+rdx*4+4]
	add	rax, r15
	jmp	rax
$LN159@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3119 :         _Tidy_deallocate();

	lea	rcx, QWORD PTR [rbx-32]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN177@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 808  :         _Which = static_cast<_Index_t>(_Idx);

	mov	BYTE PTR [rbx], 0
$LN1526@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	mov	DWORD PTR [rbx-32], esi
$LN191@Render:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR $T10[rsp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

	mov	QWORD PTR $T10[rsp+16], rsi

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

	mov	QWORD PTR $T10[rsp+24], rsi

; 2492 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rbx-48]

; 2235 :         const value_type* _Result = _Bx._Buf;

	mov	r15, r14

; 2244 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx-40], 16

; 2236 :         if (_Large_string_engaged()) {

	jb	SHORT $LN1497@Render

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [r14]
$LN1497@Render:

; 2620 :         if (_Count > max_size()) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rax
	ja	$LN1323@Render

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

	mov	QWORD PTR $T10[rsp+24], 15
	cmp	rsi, 16
	jae	SHORT $LN99@Render

; 2629 :             _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rsp+16], rsi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	movups	xmm0, XMMWORD PTR [r15]
	movups	XMMWORD PTR $T10[rsp], xmm0

; 2647 :             return;

	jmp	SHORT $LN115@Render
$LN99@Render:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdi, rsi
	or	rdi, 15

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	cmp	rdi, rax
	jbe	SHORT $LN110@Render

; 4716 :             return _Max;

	mov	rdi, rax
	jmp	SHORT $LN109@Render
$LN110@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

	cmp	rdi, 22
	mov	eax, 22
	cmovb	rdi, rax
$LN109@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rdx, rdi
	add	rdx, 1
	mov	rax, -1
	cmovb	rdx, rax
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	QWORD PTR $T10[rsp], rax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

	mov	QWORD PTR $T10[rsp+16], rsi

; 2658 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR $T10[rsp+24], rdi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	lea	r8, QWORD PTR [rsi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
	mov	rdi, QWORD PTR this$GSCopy$1$[rsp]
$LN115@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 162  :             DrawParameterValue(static_cast<AINBFile::ValueType>(i), Immediate.Name, CurrentId, (void*)&Immediate.Value);

	lea	rax, QWORD PTR [rbx-32]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR CurrentId$1$[rsp]
	lea	r8, QWORD PTR $T10[rsp]
	mov	edx, r12d
	mov	rcx, rdi
	call	?DrawParameterValue@UIAINBNodeBase@@QEAAXW4ValueType@AINBFile@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPEAX@Z ; UIAINBNodeBase::DrawParameterValue

; 136  :         for (AINBFile::ImmediateParameter& Immediate : mNode->ImmediateParameters[i]) {

	add	r14, 200				; 000000c8H
	add	rbx, 200				; 000000c8H
	cmp	r14, r13
	mov	esi, 0
	lea	r15, OFFSET FLAT:__ImageBase
	jne	$LL22@Render
	movzx	r8d, BYTE PTR i$1$[rsp]
$LN17@Render:

; 134  : 
; 135  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r8b
	mov	BYTE PTR i$1$[rsp], r8b
	cmp	r8b, 6
	jae	SHORT $LN1504@Render
	mov	r14, QWORD PTR this$GSCopy$1$[rsp]
	xor	esi, esi
	jmp	$LL19@Render
$LN226@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\variant

; 657  :         _STL_STAMP(16, _STL_VISIT_STAMP);

$LN359@Render:
$LN585@Render:
$LN531@Render:
$LN172@Render:
$LN1504@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui_node_editor\imgui_node_editor_api.cpp

; 193  :     s_Editor->GetNodeBuilder().End();

	mov	rcx, QWORD PTR ?s_Editor@@3PEAUEditorContext@Detail@NodeEditor@ax@@EA
	add	rcx, 1032				; 00000408H
	call	?End@NodeBuilder@Detail@NodeEditor@ax@@QEAAXXZ ; ax::NodeEditor::Detail::NodeBuilder::End
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 167  :     ed::PopStyleVar();

	call	?PopStyleVar@NodeEditor@ax@@YAXH@Z	; ax::NodeEditor::PopStyleVar

; 168  : 
; 169  :     DrawNodeHeader();

	mov	rcx, rdi
	call	?DrawNodeHeader@UIAINBNodeBase@@QEAAXXZ	; UIAINBNodeBase::DrawNodeHeader

; 170  :     if(HasImmediate)

	cmp	BYTE PTR HasImmediate$1$[rsp], 0
	je	SHORT $LN41@Render

; 171  :         DrawImmediateSeperator(CursorPos);

	movaps	xmm0, xmm6
	unpcklps xmm0, xmm7
	movq	rdx, xmm0
	mov	rcx, rdi
	call	?DrawImmediateSeperator@UIAINBNodeBase@@QEAAXUImVec2@@@Z ; UIAINBNodeBase::DrawImmediateSeperator
$LN41@Render:

; 172  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+544]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1323@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1312@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1314@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1313@Render:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1317@Render:

; 2621 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1319@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1320@Render:

; 4941 :         _Xlen_string();

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN1318@Render:
	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	int	3
$LN1520@Render:
	npad	1
$LN1512@Render:
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 172  : }

	DD	$LN231@Render
	DD	$LN231@Render
	DD	$LN231@Render
	DD	$LN231@Render
	DD	$LN213@Render
	DD	$LN231@Render
$LN1511@Render:
	DD	$LN364@Render
	DD	$LN364@Render
	DD	$LN364@Render
	DD	$LN364@Render
	DD	$LN346@Render
	DD	$LN364@Render
$LN1510@Render:
	DD	$LN590@Render
	DD	$LN590@Render
	DD	$LN590@Render
	DD	$LN590@Render
	DD	$LN572@Render
	DD	$LN590@Render
$LN1509@Render:
	DD	$LN536@Render
	DD	$LN536@Render
	DD	$LN536@Render
	DD	$LN536@Render
	DD	$LN518@Render
	DD	$LN536@Render
$LN1508@Render:
	DD	$LN177@Render
	DD	$LN177@Render
	DD	$LN177@Render
	DD	$LN177@Render
	DD	$LN159@Render
	DD	$LN177@Render
?Render@UIAINBNodeDefault@@UEAAXXZ ENDP			; UIAINBNodeDefault::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$1@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$1
	lea	rcx, QWORD PTR $T26[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN54@dtor$2
	and	DWORD PTR $T9[rbp], -2
	lea	rcx, QWORD PTR $T15[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN54@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN56@dtor$3
	and	DWORD PTR $T9[rbp], -3
	lea	rcx, QWORD PTR $T34[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN56@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$4@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$4
	lea	rcx, QWORD PTR $T49[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$5@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$5
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$8
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN64@dtor$8
	and	DWORD PTR $T9[rbp], -5
	lea	rcx, QWORD PTR $T21[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN64@dtor$8:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$8@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN66@dtor$9
	and	DWORD PTR $T9[rbp], -9
	lea	rcx, QWORD PTR $T13[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN66@dtor$9:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$10@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$10
	lea	rcx, QWORD PTR $T48[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$11@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$11
	lea	rcx, QWORD PTR $T24[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN73@dtor$13
	and	DWORD PTR $T9[rbp], -17
	lea	rcx, QWORD PTR $T12[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN73@dtor$13:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$14
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T9[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN75@dtor$14
	and	DWORD PTR $T9[rbp], -33			; ffffffffffffffdfH
	lea	rcx, QWORD PTR $T47[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN75@dtor$14:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$14@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$15@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$15
	lea	rcx, QWORD PTR $T32[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 64
AddedHeader$1$ = 64
$T9 = 68
CurrentId$1$ = 72
tv7700 = 76
tv7692 = 76
$T10 = 80
$T11 = 80
$T12 = 80
$T13 = 80
$T14 = 80
$T15 = 80
$T16 = 80
j$1$ = 112
HasImmediate$1$ = 112
$T17 = 112
this$GSCopy$1$ = 120
tv8215 = 128
$T18 = 128
$T19 = 128
$T20 = 136
$T21 = 136
$T22 = 136
$T23 = 168
$T24 = 168
$T25 = 168
$T26 = 168
<end>$L0$1$ = 200
$T27 = 200
HeaderRect$28 = 200
$T29 = 200
$T30 = 232
$T31 = 240
$T32 = 240
$T33 = 240
$T34 = 240
$T35 = 240
$T36 = 240
text_size$37 = 280
$T38 = 280
$T39 = 280
$T40 = 296
$T41 = 328
$T42 = 336
$T43 = 336
$T44 = 352
$T45 = 352
_Temp$46 = 368
$T47 = 368
$T48 = 368
$T49 = 368
__$ArrayPad$ = 400
this$ = 592
?dtor$16@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA PROC	; `UIAINBNodeDefault::Render'::`1'::dtor$16
	lea	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Render@UIAINBNodeDefault@@UEAAXXZ@4HA ENDP	; `UIAINBNodeDefault::Render'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
;	COMDAT ?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 72
$T6 = 88
$T7 = 104
$T8 = 120
$T9 = 136
i$1$ = 256
this$ = 256
Nodes$ = 264
j$1$ = 272
tv1209 = 280
?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z PROC ; UIAINBNodeDefault::RenderLinks, COMDAT

; 175  : {

$LN160:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 184				; 000000b8H

; 176  :     uint32_t CurrentLinkId = mEditorId + 500; //Link start at +500

	mov	ebp, DWORD PTR [rcx+16]

; 177  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	xor	r8b, r8b
	add	ebp, 500				; 000001f4H
	movaps	XMMWORD PTR [rsp+160], xmm6
	movss	xmm6, DWORD PTR __real@3f800000
	xor	r12d, r12d
	mov	esi, r12d
	mov	QWORD PTR tv1209[rsp], r12
	mov	r14d, r12d
	mov	BYTE PTR i$1$[rsp], r8b
	mov	r11, rdx
	mov	r13, rcx
	mov	r10, -1229782938247303441		; eeeeeeeeeeeeeeefH
	npad	3
$LL4@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 178  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	movzx	r9d, r12w
	mov	WORD PTR j$1$[rsp], r12w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdx+176]

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	sar	rcx, 4
	imul	rcx, r10
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 178  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	test	rcx, rcx
	je	$LN2@RenderLink
	lea	r10, QWORD PTR [r13+184]
	mov	r15, r12
	npad	4
$LL7@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdx+176]
	imul	rdi, r15, 240				; 000000f0H
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 179  :             AINBFile::InputEntry& Input = mNode->InputParameters[i][j];

	mov	ebx, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	add	rdi, QWORD PTR [rax+r14]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 180  :             if (Input.NodeIndex >= 0) { //Single link

	movzx	ecx, WORD PTR [rdi+64]
	test	cx, cx
	js	$LN15@RenderLink

; 182  :                 mLinks.insert({ CurrentLinkId++, Link { .ObjectPtr = &Input, .Type = LinkType::Parameter, .NodeIndex = (uint16_t)Input.NodeIndex, .ParameterIndex = (uint16_t)Input.ParameterIndex } });

	mov	eax, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T4[rsp+20], cx
	mov	DWORD PTR $T4[rsp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T4[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rdi+66]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, r10
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T4[rsp+22], ax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 182  :                 mLinks.insert({ CurrentLinkId++, Link { .ObjectPtr = &Input, .Type = LinkType::Parameter, .NodeIndex = (uint16_t)Input.NodeIndex, .ParameterIndex = (uint16_t)Input.ParameterIndex } });

	inc	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	QWORD PTR $T4[rsp+8], rdi
	mov	DWORD PTR $T4[rsp+16], r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi+224]
	mov	rcx, -1085102592571150095		; f0f0f0f0f0f0f0f1H
	sub	rax, QWORD PTR [rdi+216]
	sar	rax, 3
	imul	rax, rcx
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 184  :                 if (Input.Function.Instructions.size() > 0)

	test	rax, rax
	je	$LN14@RenderLink

; 185  :                 {
; 186  :                     AINBFile::ValueType DataType;
; 187  :                     switch (Input.Function.InputDataType)

	movzx	ecx, WORD PTR [rdi+210]
	sub	ecx, 2
	je	SHORT $LN16@RenderLink
	sub	ecx, 1
	je	SHORT $LN18@RenderLink
	sub	ecx, 1
	je	SHORT $LN17@RenderLink
	sub	ecx, 1
	je	SHORT $LN19@RenderLink
	cmp	ecx, 1
	je	SHORT $LN20@RenderLink

; 204  :                     default:
; 205  :                         DataType = (AINBFile::ValueType)i;

	mov	r9, rsi
	jmp	SHORT $LN8@RenderLink
$LN20@RenderLink:

; 201  :                     case EXB::Type::Vec3f:
; 202  :                         DataType = AINBFile::ValueType::Vec3f;

	mov	r9d, 4

; 203  :                         break;

	jmp	SHORT $LN8@RenderLink
$LN19@RenderLink:

; 198  :                     case EXB::Type::String:
; 199  :                         DataType = AINBFile::ValueType::String;

	mov	r9d, 3

; 200  :                         break;

	jmp	SHORT $LN8@RenderLink
$LN17@RenderLink:

; 191  :                         break;
; 192  :                     case EXB::Type::F32:
; 193  :                         DataType = AINBFile::ValueType::Float;

	mov	r9d, 2

; 194  :                         break;

	jmp	SHORT $LN8@RenderLink
$LN18@RenderLink:

; 195  :                     case EXB::Type::S32:
; 196  :                         DataType = AINBFile::ValueType::Int;

	mov	r9, r12

; 197  :                         break;

	jmp	SHORT $LN8@RenderLink
$LN16@RenderLink:

; 188  :                     {
; 189  :                     case EXB::Type::Bool:
; 190  :                         DataType = AINBFile::ValueType::Bool;

	mov	r9d, 1
$LN8@RenderLink:

; 208  :                     ed::Link(CurrentLinkId -1, Nodes[Input.NodeIndex]->mOutputParameters[(int)DataType][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	movzx	r8d, BYTE PTR i$1$[rsp]
	lea	rdx, QWORD PTR $T6[rsp]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	lea	rdx, QWORD PTR [r9+r9*2]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 208  :                     ed::Link(CurrentLinkId -1, Nodes[Input.NodeIndex]->mOutputParameters[(int)DataType][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rax, QWORD PTR [r13+72]
	mov	rcx, QWORD PTR [rax+r14]
	mov	rax, QWORD PTR Nodes$[rsp]
	mov	r8d, DWORD PTR [rcx+r15*4]
	mov	rax, QWORD PTR [rax]
	movsx	rcx, WORD PTR [rdi+64]
	mov	rax, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+rdx*8]

; 209  :                 }

	jmp	SHORT $LN157@RenderLink
$LN14@RenderLink:

; 212  :                     ed::Link(CurrentLinkId - 1, Nodes[Input.NodeIndex]->mOutputParameters[i][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	movzx	r8d, BYTE PTR i$1$[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 212  :                     ed::Link(CurrentLinkId - 1, Nodes[Input.NodeIndex]->mOutputParameters[i][Input.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rax, QWORD PTR [r13+72]
	mov	rcx, QWORD PTR [rax+r14]
	mov	rax, QWORD PTR Nodes$[rsp]
	mov	r8d, DWORD PTR [rcx+r15*4]
	mov	rax, QWORD PTR [rax]
	movsx	rcx, WORD PTR [rdi+64]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rax+r14]
$LN157@RenderLink:

; 215  :             for (AINBFile::MultiEntry& Entry : Input.Sources) { // Multi link

	movsx	rcx, WORD PTR [rdi+66]
	lea	r9, QWORD PTR $T3[rsp]
	movss	DWORD PTR [rsp+32], xmm6
	movups	XMMWORD PTR $T3[rsp], xmm0
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	rcx, rbx
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
	mov	r11, QWORD PTR Nodes$[rsp]
	movzx	r9d, WORD PTR j$1$[rsp]
	movzx	r8d, BYTE PTR i$1$[rsp]
$LN15@RenderLink:
	mov	r12, QWORD PTR [rdi+160]
	mov	rsi, QWORD PTR [rdi+152]
	cmp	rsi, r12
	je	$LN5@RenderLink
	npad	9
$LL12@RenderLink:

; 216  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	lea	rdx, QWORD PTR $T8[rsp]
	mov	ebx, ebp
	call	?GetValueTypeColor@UIAINBNodeBase@@QEAA?AUImColor@@E@Z ; UIAINBNodeBase::GetValueTypeColor
	lea	r9, QWORD PTR $T2[rsp]
	movss	DWORD PTR [rsp+32], xmm6
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	xmm0, XMMWORD PTR [rax]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 216  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rax, QWORD PTR [r13+72]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\imgui\imgui.h

; 2591 :     inline operator ImVec4() const                                  { return Value; }

	movups	XMMWORD PTR $T2[rsp], xmm0
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 216  :                 ed::Link(CurrentLinkId++, Nodes[Entry.NodeIndex]->mOutputParameters[i][Entry.ParameterIndex], mInputParameters[i][j], GetValueTypeColor(i));

	mov	rcx, QWORD PTR [r14+rax]
	mov	rax, QWORD PTR [r11]
	mov	r8d, DWORD PTR [rcx+r15*4]
	movzx	ecx, WORD PTR [rsi]
	mov	rcx, QWORD PTR [rax+rcx*8]
	mov	rax, QWORD PTR [rcx+48]
	movzx	ecx, WORD PTR [rsi+2]
	mov	rax, QWORD PTR [rax+r14]
	mov	edx, DWORD PTR [rax+rcx*4]
	mov	ecx, ebp
	inc	ebp
	call	?Link@NodeEditor@ax@@YA_NULinkId@12@UPinId@12@1AEBUImVec4@@M@Z ; ax::NodeEditor::Link
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rsi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	r8, QWORD PTR $T1[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T1[rsp+20], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rdx, QWORD PTR $T9[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	movzx	eax, WORD PTR [rsi+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	lea	rcx, QWORD PTR [r13+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 242  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

	mov	WORD PTR $T1[rsp+22], ax
	mov	DWORD PTR $T1[rsp], ebx
	mov	QWORD PTR $T1[rsp+8], rdi
	mov	DWORD PTR $T1[rsp+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xhash

; 938  :         return emplace(_STD move(_Val));

	call	??$emplace@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@?$_Hash@V?$_Umap_traits@IULink@UIAINBNodeBase@@V?$_Uhash_compare@IU?$hash@I@std@@U?$equal_to@I@2@@std@@V?$allocator@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@4@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBIULink@UIAINBNodeBase@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@$$CBIULink@UIAINBNodeBase@@@1@@Z ; std::_Hash<std::_Umap_traits<unsigned int,UIAINBNodeBase::Link,std::_Uhash_compare<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,UIAINBNodeBase::Link> >,0> >::emplace<std::pair<unsigned int const ,UIAINBNodeBase::Link> >
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 215  :             for (AINBFile::MultiEntry& Entry : Input.Sources) { // Multi link

	movzx	r8d, BYTE PTR i$1$[rsp]
	add	rsi, 96					; 00000060H
	mov	r11, QWORD PTR Nodes$[rsp]
	cmp	rsi, r12
	jne	$LL12@RenderLink
	movzx	r9d, WORD PTR j$1$[rsp]
$LN5@RenderLink:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rdx, QWORD PTR [r13+8]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 178  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	lea	r10, QWORD PTR [r13+184]
	movzx	r8d, BYTE PTR i$1$[rsp]
	inc	r9w
	mov	r11, QWORD PTR Nodes$[rsp]
	mov	r12d, 0
	mov	rsi, QWORD PTR tv1209[rsp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rdx+176]
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 178  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	movzx	r15d, r9w
	mov	WORD PTR j$1$[rsp], r9w
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [r14+rax+8]
	sub	rcx, QWORD PTR [r14+rax]
	mov	rax, -1229782938247303441		; eeeeeeeeeeeeeeefH
	sar	rcx, 4
	imul	rcx, rax
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp

; 178  :         for (uint16_t j = 0; j < mNode->InputParameters[i].size(); j++) {

	cmp	r15, rcx
	jb	$LL7@RenderLink
	mov	r10, rax
$LN2@RenderLink:

; 177  :     for (uint8_t i = 0; i < AINBFile::ValueTypeCount; i++) {

	inc	r8b
	inc	rsi
	add	r14, 24
	mov	BYTE PTR i$1$[rsp], r8b
	mov	QWORD PTR tv1209[rsp], rsi
	cmp	r8b, 6
	jb	$LL4@RenderLink

; 217  :                 mLinks.insert({ CurrentLinkId - 1, Link { .ObjectPtr = &Input, .Type = LinkType::Parameter, .NodeIndex = Entry.NodeIndex, .ParameterIndex = Entry.ParameterIndex } });
; 218  :             }
; 219  :         }
; 220  :     }
; 221  : }

	movaps	xmm6, XMMWORD PTR [rsp+160]
	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?RenderLinks@UIAINBNodeDefault@@UEAAXAEAV?$vector@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@V?$allocator@V?$unique_ptr@VUIAINBNodeBase@@U?$default_delete@VUIAINBNodeBase@@@std@@@std@@@2@@std@@@Z ENDP ; UIAINBNodeDefault::RenderLinks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File H:\Paul\switchemulator\Zelda TotK\MapEditorV4\OldVersion\MapEditor\UIAINBNodeDefault.cpp
;	COMDAT ?GetHeaderColor@UIAINBNodeDefault@@UEAA?AUImColor@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?GetHeaderColor@UIAINBNodeDefault@@UEAA?AUImColor@@XZ PROC ; UIAINBNodeDefault::GetHeaderColor, COMDAT

; 225  :     return mHeaderColor;

	movups	xmm0, XMMWORD PTR [rcx+272]
	mov	rax, rdx
	movups	XMMWORD PTR [rdx], xmm0

; 226  : }

	ret	0
?GetHeaderColor@UIAINBNodeDefault@@UEAA?AUImColor@@XZ ENDP ; UIAINBNodeDefault::GetHeaderColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Val$ = 72
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,unsigned short>, COMDAT

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10, r8
	mov	r11, rdx

; 124  :         return const_cast<_Ty*>(

	movzx	r8d, WORD PTR [r9]

; 5846 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	mov	rbx, rcx

; 124  :         return const_cast<_Ty*>(

	mov	rdx, r10
	mov	rcx, r11
	call	__std_find_trivial_4

; 5847 :     _Adl_verify_range(_First, _Last);
; 5848 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5849 :         return _Find_vbool(_First, _Last, _Val);
; 5850 :     } else {
; 5851 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5852 :         return _First;

	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 5853 :     }
; 5854 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@G@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@0@V10@V10@AEBG@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Find_unchecked@PEAIG@std@@YAPEAIPEAIQEAIAEBG@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find_unchecked@PEAIG@std@@YAPEAIPEAIQEAIAEBG@Z PROC	; std::_Find_unchecked<unsigned int *,unsigned short>, COMDAT

; 124  :         return const_cast<_Ty*>(

	movzx	r8d, WORD PTR [r8]
	jmp	__std_find_trivial_4
??$_Find_unchecked@PEAIG@std@@YAPEAIPEAIQEAIAEBG@Z ENDP	; std::_Find_unchecked<unsigned int *,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PEAIG@std@@YA_NAEBG@Z
_TEXT	SEGMENT
_Val$dead$ = 8
??$_Could_compare_equal_to_value_type@PEAIG@std@@YA_NAEBG@Z PROC ; std::_Could_compare_equal_to_value_type<unsigned int *,unsigned short>, COMDAT

; 5747 :     // check whether _Val is within the limits of _Elem
; 5748 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5749 : 
; 5750 :     if constexpr (disjunction_v<
; 5751 : #ifdef __cpp_lib_byte
; 5752 :                       is_same<_Ty, byte>,
; 5753 : #endif // __cpp_lib_byte
; 5754 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5755 :         return true;
; 5756 :     } else {
; 5757 :         using _Elem = _Iter_value_t<_InIt>;
; 5758 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5759 : 
; 5760 :         if constexpr (is_same_v<_Elem, bool>) {
; 5761 :             return _Val == true || _Val == false;
; 5762 :         } else if constexpr (is_signed_v<_Elem>) {
; 5763 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5764 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5765 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5766 : 
; 5767 :             if constexpr (is_signed_v<_Ty>) {
; 5768 :                 // signed _Elem, signed _Ty
; 5769 :                 return _Min <= _Val && _Val <= _Max;
; 5770 :             } else {
; 5771 :                 // signed _Elem, unsigned _Ty
; 5772 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5773 :                     // negative values of _Elem can compare equal to values of _Ty
; 5774 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5775 :                 } else {
; 5776 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5777 :                     return _Val <= _Max;
; 5778 :                 }
; 5779 :             }
; 5780 :         } else {
; 5781 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5782 : 
; 5783 :             if constexpr (is_unsigned_v<_Ty>) {
; 5784 :                 // unsigned _Elem, unsigned _Ty
; 5785 :                 return _Val <= _Max;

	mov	al, 1

; 5786 :             } else {
; 5787 :                 // unsigned _Elem, signed _Ty
; 5788 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5789 :                     // negative values of _Ty can compare equal to values of _Elem
; 5790 :                     return _Val <= _Max;
; 5791 :                 } else {
; 5792 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5793 :                     return 0 <= _Val && _Val <= _Max;
; 5794 :                 }
; 5795 :             }
; 5796 :         }
; 5797 :     }
; 5798 : }

	ret	0
??$_Could_compare_equal_to_value_type@PEAIG@std@@YA_NAEBG@Z ENDP ; std::_Could_compare_equal_to_value_type<unsigned int *,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$__std_find_trivial@IG@@YAPEAIPEAI0G@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$__std_find_trivial@IG@@YAPEAIPEAI0G@Z PROC		; __std_find_trivial<unsigned int,unsigned short>, COMDAT

; 115  :     if constexpr (_STD is_pointer_v<_TVal> || _STD is_null_pointer_v<_TVal>) {
; 116  :         return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 117  :     } else if constexpr (sizeof(_Ty) == 1) {
; 118  :         return const_cast<_Ty*>(
; 119  :             static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 120  :     } else if constexpr (sizeof(_Ty) == 2) {
; 121  :         return const_cast<_Ty*>(
; 122  :             static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 123  :     } else if constexpr (sizeof(_Ty) == 4) {
; 124  :         return const_cast<_Ty*>(

	movzx	r8d, r8w
	jmp	__std_find_trivial_4
??$__std_find_trivial@IG@@YAPEAIPEAI0G@Z ENDP		; __std_find_trivial<unsigned int,unsigned short>
_TEXT	ENDS
END
